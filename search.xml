<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Http状态码及含义</title>
    <url>/wiki/Http%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<blockquote>
<p>http状态码由3个十进制数字组成。第一个数字表示状态码的分类，后面的两位表示该分类下不同的状态。<br>分为5个大类。</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>1**    信息。服务器收到请求，请继续执行请求</li>
<li>2**    成功。请求被成功接收并处理</li>
<li>3**    重定向。需要进一步操作来完成请求</li>
<li>4**    客户端错误。无法完成请求，或请求包含语法错误</li>
<li>5**    服务器错误。服务器在处理请求的过程中发成错误</li>
</ul>
<h2 id="各个状态说明"><a href="#各个状态说明" class="headerlink" title="各个状态说明"></a>各个状态说明</h2><ul>
<li>100： 继续请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分。</li>
<li>101： 切换协议请求者已要求服务器切换协议，服务器已确认并准备切换。</li>
<li>200： 成功服务器已成功处理了请求。</li>
<li>201： 已创建请求成功并且服务器创建了新的资源。</li>
<li>202： 已接受服务器已接受请求，但尚未处理。</li>
<li>203： 非授权信息服务器已成功处理了请求，但返回的信息可能来自另一来源。</li>
<li>204： 无内容服务器成功处理了请求，但没有返回任何内容。</li>
<li>205： 重置内容服务器成功处理了请求，内容被重置。</li>
<li>206： 部分内容服务器成功处理了部分请求。</li>
<li>300： 多种选择针对请求，服务器可执行多种操作。</li>
<li>301： 永久移动请求的网页已永久移动到新位置，即永久重定向。</li>
<li>302： 临时移动请求的网页暂时跳转到其他页面，即暂时重定向。</li>
<li>303： 查看其他位置如果原来的请求是 POST，重定向目标文档应该通过 GET 提取。</li>
<li>304： 未修改此次请求返回的网页未修改，继续使用上次的资源。</li>
<li>305： 使用代理请求者应该使用代理访问该网页。</li>
<li>307： 临时重定向请求的资源临时从其他位置响应。</li>
<li>400： 错误请求服务器无法解析该请求。</li>
<li>401： 未授权请求没有进行身份验证或验证未通过。</li>
<li>403： 禁止访问服务器拒绝此请求。</li>
<li>404： 未找到服务器找不到请求的网页。</li>
<li>405： 方法禁用服务器禁用了请求中指定的方法。</li>
<li>406： 不接受无法使用请求的内容响应请求的网页。</li>
<li>407： 需要代理授权请求者需要使用代理授权。</li>
<li>408： 请求超时服务器请求超时。</li>
<li>409： 冲突服务器在完成请求时发生冲突。</li>
<li>410： 已删除请求的资源已永久删除。</li>
<li>411： 需要有效长度服务器不接受不含有效内容长度标头字段的请求。</li>
<li>412： 未满足前提条件服务器未满足请求者在请求中设置的其中一个前提条件。</li>
<li>413： 请求实体过大请求实体过大，超出服务器的处理能力。</li>
<li>414： 请求 URI 过长请求网址过长，服务器无法处理。</li>
<li>415： 不支持类型请求的格式不受请求页面的支持。</li>
<li>416： 请求范围不符页面无法提供请求的范围。</li>
<li>417： 未满足期望值服务器未满足期望请求标头字段的要求。</li>
<li>500： 服务器内部错误服务器遇到错误，无法完成请求。</li>
<li>501： 未实现服务器不具备完成请求的功能。</li>
<li>502： 错误网关服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li>503： 服务不可用服务器目前无法使用。</li>
<li>504： 网关超时服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li>
<li>505： HTTP 版本不支持服务器不支持请求中所用的 HTTP 协议版本。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-Xms,Xmx和Xss</title>
    <url>/wiki/JVM-Xms-Xmx%E5%92%8CXss/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730163232526.png" alt="image-20210730163232526" style="zoom:47%;" />

<h1 id="性能调优参数Xms，Xmx，Xss的含义"><a href="#性能调优参数Xms，Xmx，Xss的含义" class="headerlink" title="性能调优参数Xms，Xmx，Xss的含义"></a>性能调优参数Xms，Xmx，Xss的含义</h1><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>规定了每个线程虚拟机栈及堆栈的大小，一般情况下，256k是足够的，此配置将会影响此进程中并发线程数的大小。</p>
<h3 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h3><p>表示初始化JAVA堆的大小及该进程刚创建出来的时候，他的专属JAVA堆的大小，一旦对象容量超过了JAVA堆的初始容量，JAVA堆将会自动扩容到-Xmx大小。</p>
<h3 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h3><p>表示java堆可以扩展到的最大值，在很多情况下，通常将-Xms和-Xmx设置成一样的，因为当堆不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性。</p>
<h3 id="堆内存分配："><a href="#堆内存分配：" class="headerlink" title="堆内存分配："></a>堆内存分配：</h3><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/a1439775520/article/details/97787160">类似-Xms、-Xmn这些参数的含义：</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1671253445384660292&wfr=spider&for=pc">JVM三大性能调优参数Xms，Xmx，Xss的含义，你又知道多少呢</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jmap</title>
    <url>/wiki/JVM-jmap/</url>
    <content><![CDATA[<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<h2 id="jmap-heap-pid"><a href="#jmap-heap-pid" class="headerlink" title="jmap -heap pid"></a>jmap -heap pid</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Attaching to process ID <span class="number">7183</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.242</span>-b08</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">4</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2051014656</span> (<span class="number">1956.</span>0MB)</span><br><span class="line">   NewSize                  = <span class="number">42991616</span> (<span class="number">41.</span>0MB)</span><br><span class="line">   MaxNewSize               = <span class="number">683671552</span> (<span class="number">652.</span>0MB)</span><br><span class="line">   OldSize                  = <span class="number">87031808</span> (<span class="number">83.</span>0MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">233308160</span> (<span class="number">222.</span>5MB)</span><br><span class="line">   used     = <span class="number">161611280</span> (<span class="number">154.</span>12452697753906MB)</span><br><span class="line">   free     = <span class="number">71696880</span> (<span class="number">68.</span>37547302246094MB)</span><br><span class="line">   <span class="number">69.26945032698384</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   used     = <span class="number">899896</span> (<span class="number">0.</span>8582077026367188MB)</span><br><span class="line">   free     = <span class="number">672968</span> (<span class="number">0.</span>6417922973632812MB)</span><br><span class="line">   <span class="number">57.213846842447914</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">223346688</span> (<span class="number">213.</span>0MB)</span><br><span class="line">   used     = <span class="number">115841432</span> (<span class="number">110.</span>4749984741211MB)</span><br><span class="line">   free     = <span class="number">107505256</span> (<span class="number">102.</span>5250015258789MB)</span><br><span class="line">   <span class="number">51.866196466723515</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">41772</span> interned Strings occupying <span class="number">4324472</span> bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/a4ad53179df3">jvm 性能调优工具之 jmap</a><br><a href="https://pandora.blog.csdn.net/article/details/108705081">JVM调试工具-jmap</a><br><a href="https://blog.csdn.net/lengyue309/article/details/80590119">通过jstack与jmap分析一次线上故障</a>                 
  </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jstack</title>
    <url>/wiki/JVM-jstack/</url>
    <content><![CDATA[<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><h2 id="jstack-功能"><a href="#jstack-功能" class="headerlink" title="jstack 功能"></a>jstack 功能</h2><p>主要分为两个功能：</p>
<p>a．  针对活着的进程做本地的或远程的线程dump；</p>
<p>b．  针对core文件做线程dump。</p>
<p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<h2 id="jstack-操作方式"><a href="#jstack-操作方式" class="headerlink" title="jstack 操作方式"></a>jstack 操作方式</h2><blockquote>
<p>jps -l | grep keyword -&gt; pid<br>jstack pid</p>
</blockquote>
<p>jstack结果如下；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;lettuce-nioEventLoop-4-1&quot; #639 daemon prio=5 os_prio=0 tid=0x00007ff27025d800 nid=0x258f runnable [0x00007ff262af7000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">	- locked &lt;0x000000008988d6a8&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">	- locked &lt;0x000000008988d770&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">	- locked &lt;0x000000008988d600&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)</span><br><span class="line">	at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:68)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:803)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:457)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/weixin_30013175/article/details/113901522">https://blog.csdn.net/weixin_30013175/article/details/113901522</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jstat</title>
    <url>/wiki/JVM-jstat/</url>
    <content><![CDATA[<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>jstat是一个简单的实用工具，在JDK中存在，用于提供与JVM性能相关的统计信息，例如垃圾收集，编译活动。 jstat的主要优势在于，它可以在运行JVM且无需任何先决条件的情况下动态捕获这些指标。 这是什么意思？ 例如，如果要捕获与垃圾回收相关的统计信息，则需要在启动JVM之前传递以下参数：</p>
<blockquote>
<p> -Xlog:gc*:file={file-path} </p>
</blockquote>
<p>此参数将启用GC日志并将其打印在指定的文件路径中。 假设您尚未传递此参数，那么将不会生成与GC相关的统计信息。 这是jstat可以派上用场的地方。 您可以动态地连接到JVM并捕获GC，编译相关的统计信息如下所示。</p>
<h2 id="jstat操作"><a href="#jstat操作" class="headerlink" title="jstat操作"></a>jstat操作</h2><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat -gc -t 11656 10000 30 </span><br></pre></td></tr></table></figure>
<p>-gc ：将显示与垃圾收集相关的统计信息</p>
<p>自JVM启动以来的-t时间戳将被打印</p>
<p>11656：目标JVM进程ID</p>
<p>10000：每10,000毫秒（即10秒）将打印一次统计信息。</p>
<p>30 ：将打印30次迭代的统计信息。 因此，以上选项将导致JVM打印指标300秒（即10秒x 30次迭代）。</p>
<p>（请注意，除了-gc之外，您还可以传递其他各种选项来生成不同的数据集。有关不同选项的更多详细信息，请参见此处 。）<br>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">        34486.1 1536.0 1536.0  0.0   878.8  226816.0 132809.2  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br><span class="line">        34496.3 1536.0 1536.0  0.0   878.8  226816.0 138030.9  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br><span class="line">        34506.3 1536.0 1536.0  0.0   878.8  226816.0 195648.1  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br></pre></td></tr></table></figure>

<h3 id="字段解读"><a href="#字段解读" class="headerlink" title="字段解读"></a>字段解读</h3><p>S0C –幸存者0区域的容量，以KB为单位</p>
<p>S1C –幸存者1区域的容量，以KB为单位</p>
<p>S0U –幸存者0区域使用的空间以KB为单位</p>
<p>S1U –幸存者1区域以KB为单位使用空间</p>
<p>EC –伊甸园地区容量（KB）</p>
<p>欧盟–伊甸园地区的已利用空间（以KB为单位）</p>
<p>OC –旧区域容量（KB）</p>
<p>OU –旧区域的已利用空间，以KB为单位</p>
<p>MC –元空间区域容量，以KB为单位</p>
<p>MU –元空间区域使用的空间以KB为单位</p>
<p>CCSC –压缩类空间区域的容量，以KB为单位</p>
<p>CCSU –压缩类空间区域以KB为单位使用空间</p>
<p>YGC –迄今为止发生的年轻GC事件的数量</p>
<p>YGCT –到目前为止，年轻GC花费的时间</p>
<p>FGC –迄今为止已发生的完全GC事件的数量</p>
<p>FGCT –到目前为止已花费的完整GC时间</p>
<p>GCT –到目前为止所花费的GC时间总量（基本上是YGCT + FGCT）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dnc8371/article/details/107255359">jstat分析_jstat –分析</a> </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-strace</title>
    <url>/wiki/JVM-strace/</url>
    <content><![CDATA[<h1 id="strace-命令查看操作系统日志"><a href="#strace-命令查看操作系统日志" class="headerlink" title="strace 命令查看操作系统日志"></a>strace 命令查看操作系统日志</h1><p><code>strace -ff -o out java ***.class</code></p>
<p>-ff : 跟踪进程下所有线程用到的系统命令<br>-o : 将跟踪的操作系统日志输出</p>
<blockquote>
<p>下面查看JDK1.8下，BIO模式都有哪些系统命令的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.io.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 2:55 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SockerIo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        Socket client = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = client.getInputStream();</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        <span class="comment">// 读阻塞</span></span><br><span class="line">        System.err.println(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务端</p>
</blockquote>
<p>1、<code>javac SockerIo.java</code> 得到SockerIo.class<br>然后，使用strace启动java程序👇：<br>2、<code>strace -ff -0 out java SockerIo</code><br>得到如下日志：<br><img src="https://oscimg.oschina.net/oscnet/up-924f13a6df8c2ce97e13019329008fb4a84.png"></p>
<blockquote>
<p>客户端使用nc连接9090端口，然后请求数据</p>
</blockquote>
<p><code>nc 127.0.0.1 9090</code>  发送如下数据</p>
<img src="https://oscimg.oschina.net/oscnet/up-4b7b364f021786bd9bdf4f40135da3b4a8d.png">

<blockquote>
<p>strace查看日志</p>
</blockquote>
<p>查看主线程日志：<br><img src="https://oscimg.oschina.net/oscnet/up-291f9a1018a2d288b88a5c2e43666d5d47e.png"><br>如上图，👆文件最大的是主线程日志：</p>
<img src="https://oscimg.oschina.net/oscnet/up-c306b9f94e3d0a3582b049d3c4769b4f5ec.png">

<p>根据上面👆strace命令跟踪的日志可以看到，JDK1.8下的BIO的多路复用器是使用的「poll」</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-内存结构</title>
    <url>/wiki/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>作为程序员，最常接触到Java虚拟机的部分应该是内存结构这一部分了，同样这一部分的内容很多，面试也是最常被问到的。虽然JDK已经发布了16版本，但是国内大部分企业都还在使用JDK8。 今天学习一下虚拟机的运行时数据区的组成和各个组件的功能。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730144621195.png" alt="image-20210730144621195" style="zoom:50%;" />

<p>JDK8官方网站文档链接 – 》 <a href="https://docs.oracle.com/javase/8/docs/index.html">JDK</a></p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些数据区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户的启动和结束而建立和销毁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730141548126.png" alt="image-20210730141548126"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register），它是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的模型概念中，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<blockquote>
<p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。</p>
</blockquote>
<p>由于Java虚拟机的多线程是通过线程轮流切换处理器执行时间的方式实现的，在任何一个确定的时刻，一个处理器的一个核只会执行一条线程中的指令，因此，<font color=red>为了线程切换后能够恢复到正确的执行位置，每一条线程都需要拥有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储</font>，这类内存区域称为“线程私有”的内存，即如上图所示，每一个线程都会拥有自己的一块内存区域。</p>
<p>程序计数器在执行本地方法时（例如调用C语言代码）计数器值为空，其他时候则是指向正在执行的虚拟机字节码指令的地址。</p>
<p>程序计数器是在Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域，因为Java程序计数器它所需要存储的内容仅仅就是下一个需要待执行的命令的地址，其所需内存是创建时即可只晓的，不需要后期进行扩容等其他的操作。</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stacks），<font color=red>Java虚拟机栈也是线程私有的,它的生命周期与线程相同</font>。Java每个方法在执行的同时都会创建一个栈帧用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至方法执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>虚拟机栈中局部变量表部分与Java对象内存分配关系密切，局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，该类型可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他于此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>局部变量表中，64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用一个。<code>局部变量表所需的内存空间在编译期间完成分配</code>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；<br>如果虚拟机栈可以动态拓展，如果拓展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈作用类似，它们之间的区别是虚拟机栈为虚拟机执行Java方法，而本地方法栈则为虚拟机执行Native方法服务。有些虚拟机会将本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会抛出StackOverflowErro和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap），对于大多数的应用来说，Java堆是虚拟机所管理的最大的一块内存。<code>Java堆是被所有的线程所共享的，在虚拟机启动时创建</code>。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存的（Java虚拟机规范中描述为所有的对象实例和数组都要在堆上分配内存）。</p>
<p><strong>Java堆是垃圾收集器管理的主要区域</strong>，因此很多时候也被称为GC堆。从内存回收的角度来看，由于现在收集器基本都是采用分代算法收集器，所以Java堆中还可以细分为：新生代和老年代；再细致一点可以分为Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>根据Java虚拟机规范，<em><strong>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可</strong></em>，在实现时既可以是固定大小的，也可以是可拓展的，当前主流的虚拟机都是按照可拓展来实现的。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出OutOfMemoryError异常。</p>
<p>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )<strong>、</strong>老年代 ( Old )<strong>。</strong>新生代 ( Young )</strong> 又被划分为三个区域：<strong>Eden</strong>、**From Survivor(S0)<strong>、</strong>To Survivor(S1)**。如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730150932873.png" alt="image-20210730150932873" style="zoom: 30%;" />

<p>这样划分的目的是为了使JVM能够更好的管理内存中的对象，包括内存的分配以及回收。  而新生代按eden和两个survivor的分法，是为了</p>
<ul>
<li>有效空间增大，eden+1个survivor；</li>
<li>有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其挪到老年代中，即只需扫描其中一个survivor。如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放。</li>
<li>两个Survivor区可解决内存碎片化</li>
</ul>
<h3 id="堆栈相关参数"><a href="#堆栈相关参数" class="headerlink" title="堆栈相关参数"></a>堆栈相关参数</h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小，单位m、g</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小，即JVM栈的大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值</td>
</tr>
<tr>
<td>-XX:NewSzie(-Xns)</td>
<td>年轻代内存初始大小,可以缩写-Xns</td>
</tr>
<tr>
<td>-XX:MaxNewSize(-Xmx)</td>
<td>年轻代内存最大允许大小，可以缩写-Xmx</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio</td>
<td>GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio</td>
<td>预估堆内存是堆大小动态调控的重要选项之一。堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值)。前者会根据使用情况动态调大或缩小，以提高GC回收的效率，默认70%</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄，设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshold</td>
<td>可以设定老年代阀值的初始值</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note：</strong> 每次GC 后会调整堆的大小，为了<strong>防止动态调整带来的性能损耗</strong>，一般设置-<strong>Xms、-Xmx 相等</strong>。</p>
</blockquote>
<p>新生代的三个设置参数：-Xmn，-XX:NewSize，-XX:NewRatio的优先级：<br> （1）.最高优先级：  -XX:NewSize=1024m和-XX:MaxNewSize=1024m<br> （2）.次高优先级：  -Xmn1024m  （默认等效效果是：-XX:NewSize==-XX:MaxNewSize==1024m）<br> （3）.最低优先级：-XX:NewRatio=2<br> 推荐使用的是-Xmn参数，原因是这个参数很简洁，相当于一次性设定NewSize和MaxNewSIze，而且两者相等。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与Java堆一样，是线程共享的，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。<code>类加载的信息和数据就放在方法区。</code></p>
<p>Java虚拟机规范堆方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的内存回收成绩比较令人难以满意，尤其时类型卸载，条件相当苛刻，但是这个区域的内存回收也是必要的。</p>
<p>根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了类的版本、字段、方法、接口等描述信息以外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量池放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范所定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。</p>
<p>直接内存虽然不会受到Java堆大小的限制，但是受到本机总内存大小以及处理器寻址空间的限制，如果忽略了直接内存，当各个区域内存总和大于服务器内存时，将会导致动态拓展时出现OutOfMemoryError异常。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5</a></p>
<p><a href="https://blog.csdn.net/qq_21122519/article/details/94408118">https://blog.csdn.net/qq_21122519/article/details/94408118</a></p>
<p><a href="https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1">https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-垃圾回收机制</title>
    <url>/wiki/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>垃圾回收总体思路：</strong></p>
<p>1、什么是垃圾回收，为什么需要垃圾回收；</p>
<p>2、回收的到底是什么？由谁来回收谁？</p>
<p>3、回收的判断标准是什么</p>
<p>4、什么时候回收，回收的种类和流程是怎样的</p>
<p>5、在哪些地方进行回收</p>
<hr>
<h1 id="1-什么是垃圾回收"><a href="#1-什么是垃圾回收" class="headerlink" title="1. 什么是垃圾回收"></a>1. 什么是垃圾回收</h1><p>任何语言在运行过程中都会创建对象，也就意味着需要在内存中为这些对象在内存中分配空间，在这些对象失去使用的意义的时候，需要释放掉这些内容，保证内存能够提供给新的对象使用。<strong>对于对象内存的释放就是垃圾回收机制，也叫做gc</strong>。</p>
<p>对于java开发者来说gc是一个双刃剑，一方面，java程序员在开发程序的时候不需要像开发C++那样手动分配对象的内存，还要在合适的时机手动释放，一定程度地降低了java程序员的开发难度。另一方面，虚拟机可以帮助程序开发人员管理内存，如果程序员不了解虚拟机垃圾回收的原理，很容易引起OOM，造成服务的崩溃和系统的宕机；</p>
<h1 id="2、对象如何判活"><a href="#2、对象如何判活" class="headerlink" title="2、对象如何判活"></a>2、对象如何判活</h1><p>对象存活表示的是当前对象是否还在被使用，没有被使用的对象我们可以称其为已经“死亡”，如果对象依然在被使用，我们称其为“存活”状态，对象是否被使用则是通过对象的引用进行判断的。而垃圾回收机制就是负责将已经死亡的对象进行清理。</p>
<p><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生</strong>，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作。<code>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的</code>，因此这几个区域的内存分配和回收都具备确定性，在这几个区域不需要过多的考虑回收的问题，当方法结束或者线程结束的时候，内存自然就跟着回收了。</p>
<p>Java堆则和上述三种区域不同，Java中一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，而**只有当<code>Java程序运行时我们才能知道哪些对象会被创建**</code>，所以堆中的内存分配和回收都是<code>动态</code>进行的，因此垃圾收集器所关注的也是这部分的内存。</p>
<p>垃圾回收器在对堆进行回收前，第一件事情就是要判断堆中的对象哪些是依旧在使用的，哪些已经不可能再被使用了。这里的判断主要有两种方式，第一种是引用计数算法，第二种是可达性分析算法。</p>
<h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p>引用计数算法给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的。这种算法实现简单，判定效率也很高，<font color=red>但是它难以解决对象之间循环引用的问题</font>，例如对象A和对象B相互引用了对方，而A和B都没有在被使用了，但这两个对象却也不会被垃圾回收器回收。</p>
<h2 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h2><p>主流的判断方法则是使用可达性分析算法来判断对象是否存活。这个算法需要选择一些对象作为“GC Roots”，每次都通过这些roots节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots不存在引用链的时候，则证明这个对象是不可用的。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730201240815.png" alt="image-20210730201240815" style="zoom:50%;" />

<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<p>1、虚拟机栈中引用的对象<br>2、方法区中类静态属性引用的对象<br>3、方法区中常量引用的对象<br>4、本地方法栈中JNI（即Native方法）引用的对象</p>
<p>可达性分析算法中根据GC Roots找引用链，存在两个主要的问题。</p>
<p>一个是可作为GC Roots的节点主要在全局性的引用（例如常量或者类静态属性）于上下文(例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，将会消耗很多的时间。</p>
<p>还有一个问题是GC停顿，可达性分析必须确保在整个的分析过程中，执行系统就像被冻结在某个时间节点，整个分析过程中对象的引用关系不能发生变化，这样才能保证分析结果的准确性，因此在进行GC时，需要停顿所有的Java线程。（Stop The World）</p>
<h2 id="3-3-对象两次标记判活"><a href="#3-3-对象两次标记判活" class="headerlink" title="3.3 对象两次标记判活"></a>3.3 对象两次标记判活</h2><p>即使在可达性分析算法中不可达的对象，也并非是”非死不可“的，这时候它们暂时处于”缓刑“阶段，<em><strong>要宣告一个对象死亡，至少要经历两次标记过程</strong></em>：</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法(当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行“)。</p>
<p>如果一个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里的执行是指由虚拟机去触发这个方法，但并不一定会等待该方法执行完毕（为了避免finalize方法中出现类似死循环都操作，导致内存无法被回收，同时导致F-Queue队列中的其他对象一直处于等待状态）。</p>
<p>当执行完finalze()方法后，GC将会对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()方法中又重新获得了引用，对象将会被移出对列并且继续存活，如果对象依旧存在于队列中并且被进行第二次标记，对象将被GC回收。</p>
<p>需要注意的是任何一个对象的finalize()方法只会执行一次，如果第一次通过finalize()方法救活了对象，那么第二次相同的方法就会失效。同时由于finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此应当尽量避免使用finalize()方法。</p>
<h1 id="3-对象引用分类"><a href="#3-对象引用分类" class="headerlink" title="3. 对象引用分类"></a>3. 对象引用分类</h1><p>JDK1.2以前，Java中引用的定义很传统，如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义下的对象只存在两种状态，被引用和未被引用状态。但有些对象我们希望当内存存够的时候能够保留这些对象，当内存不足的时候则能够对这些对象进行清理，这一类对象则无法使用这种传统的定义来表示。</p>
<p>JDK1.2之后，Java对引用进行了扩充，将引用分为<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>四种，这四种引用的强度依次逐渐减弱。</p>
<h2 id="3-1-强引用"><a href="#3-1-强引用" class="headerlink" title="3.1 强引用"></a>3.1 强引用</h2><p>就是指在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。即使内存不足时，垃圾回收器也不会回收强引用的对象，而是会直接抛出<code>OutOfMemoryError</code>异常。如果想让强引用对象被回收，可以手动设置obj = null;来实现。</p>
<h2 id="3-2-软引用"><a href="#3-2-软引用" class="headerlink" title="3.2 软引用"></a>3.2 软引用</h2><p>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在内存足够的时候，是不会回收软引用的对象的，而在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果软引用回收后依然内存不足，则会抛出OutOfMemoryError异常。在JDK1.2之后，提供了SoftReference类来实现软引用。<code>软引用可以用来实现缓存技术。</code></p>
<h2 id="3-3-弱引用"><a href="#3-3-弱引用" class="headerlink" title="3.3 弱引用"></a>3.3 弱引用</h2><p>弱引用和软引用一样用来描述非必须的对象，但是它的强度比软引用更弱一些，被<code>弱引用关联的对象只能生存到下一次垃圾收集发生之前</code>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了<code>WeakReference</code>类来实现弱引用。</p>
<h2 id="3-4-虚引用"><a href="#3-4-虚引用" class="headerlink" title="3.4 虚引用"></a>3.4 虚引用</h2><p>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p>
<h1 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4.垃圾回收算法"></a>4.垃圾回收算法</h1><p><em>垃圾收集算法的目的是在已经明确了哪些内存块需要回收以后，如何高效的回收这些内存空间。</em></p>
<h2 id="4-1-标记清除算法"><a href="#4-1-标记清除算法" class="headerlink" title="4.1 标记清除算法"></a>4.1 标记清除算法</h2><p><strong>标记-清除算法</strong>采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203128783.png" alt="image-20210730203128783" style="zoom:50%;" />

<p>标记清除算法主要有两个不足之处：一个是效率问题，标记和清除两个过程的效率都不高；另一个问题是空间问题，标记清除之后会造成内存空间中存在大量的内存碎片，空间碎片太多时，当要分配一片大内存空间时可能会找不到合适的连续内存空间进行分配，从而触发另一次垃圾收集动作。</p>
<h2 id="4-2-标记复制算法"><a href="#4-2-标记复制算法" class="headerlink" title="4.2 标记复制算法"></a>4.2 标记复制算法</h2><p>该算法的提出是为了克服<strong>句柄的开销</strong>和<strong>解决堆碎片</strong>的垃圾回收。建立在存活对象少，垃圾对象多的前提下。此算法<code>每次只处理正在使用中的对象</code>，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现碎片问题。但缺点也是很明显，就是需要两倍内存空间。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203413207.png" alt="image-20210730203413207" style="zoom:50%;" />

<p>它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<p>现在的商业虚拟机都会<code>采用这种算法来回收新生代</code>，根据统计新生代中98%的对象都是“朝夕生死”的，因此对于新生代的回收不用按照1:1的比例来进行内存划分，可以将内存划分为一块Eden区域和两块Survivor空间，每次使用时都选择Eden区域和一块Survivor区域进行内存分配。<em><strong>当回收时，将Eden区域和Survivor区域中还存活的对象全部移动到另一块Survivor区域，然后清理掉Eden区域和刚刚使用的Survivor区域。</strong></em></p>
<p><em><strong>HotSpot虚拟机中Eden和Survivor的比例是1:8</strong></em>，<em><strong>即每次都有90%的内存空间在进行使用，只有10%的内存空间被浪费了。</strong></em>当然，如果每次内存都有98%被回收，那么每次被移动到另一块Survivor区域的内存只有2%，这样是没有任何问题的，但是如果移动到另一块Survivor区域的内存超过了10%，就需要依赖其他的内存（这里指老年代）进行分配担保了（将多出的对象分配到老年代）。</p>
<h2 id="4-3-标记整理算法"><a href="#4-3-标记整理算法" class="headerlink" title="4.3 标记整理算法"></a>4.3 标记整理算法</h2><p> 此算法是结合了“标记-清除”和“复制算法”两个算法的优点。避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203709050.png" alt="image-20210730203709050" style="zoom:50%;" />

<p>标记-整理算法的标记过程和标记-清除算法的标记过程一致，但是在标记完以后，标记-整理算法会将所有存活的对象都移动到一端，然后再进行清除。<strong>这种算法适用于老年代</strong>，因为老年代的对象存活率都会比较高，如果像之前一样进行复制移动，将会产生大量的复制操作导致效率变低，同时每次都会存活下大量对象导致需要很多的内存空间来进行分配担保。</p>
<h2 id="4-4-分代收集算法"><a href="#4-4-分代收集算法" class="headerlink" title="4.4 分代收集算法"></a>4.4 分代收集算法</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731141452995.png" alt="image-20210731141452995" style="zoom:50%;" />

<p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法根据对象存活周期的不同将内存划分为几块，一般是把Java堆划分位新生代和老年代。新生代中每次都会有大批对象死去，只有少量对象存活，因此可以选用复制算法。</p>
<p>老年代每次都会有大量对象存活，因此选择标记-清理或者标记-整理算法来进行。</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-深入理解Java虚拟机</title>
    <url>/wiki/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h2><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730150029336.png" alt="image-20210730150029336"></p>
<h2 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h2><ul>
<li><a href="https://geekibli.github.io/wiki/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">Java内存结构</a> </li>
<li><a href="https://geekibli.github.io/wiki/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/">Java对象创建</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></li>
<li><a href="https://geekibli.github.io/wiki/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">类加载机制</a></li>
<li><a href="https://geekibli.github.io/wiki/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">垃圾回收机制</a></li>
<li><a href="https://geekibli.github.io/wiki/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">垃圾收集器</a></li>
<li>虚拟机调优</li>
</ul>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://blog.csdn.net/qq_21122519/article/details/94408118">JAVA虚拟机概述</a><br><a href="http://c.biancheng.net/view/3677.html">Java虚拟机（JVM）工作原理</a><br><a href="https://juejin.cn/post/6844903892774289421">推荐收藏系列：一文理解JVM虚拟机（内存、垃圾回收、性能优化）解决面试中遇到问题</a><br><a href="https://juejin.cn/post/6981790758290358302">Java虚拟机内存管理和性能调优</a><br><a href="https://juejin.cn/post/6844903494063751175">重读 JVM</a><br><a href="https://juejin.cn/post/6986594521752535053">【2021最新版】JVM面试题总结（87道题含答案解析）</a><br><a href="https://www.pdai.tech/md/java/jvm/java-jvm-classload.html">JVM 基础 - Java 类加载机制</a><br><a href="https://juejin.cn/post/6981643053396131853">JVM知识点整理</a><br><a href="https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1">https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-对象创建</title>
    <url>/wiki/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-对象创建方式"><a href="#1-对象创建方式" class="headerlink" title="1.对象创建方式"></a>1.对象创建方式</h2><p>Java中有一下几种方式创建对象：</p>
<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>实质</strong></th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键</td>
<td>调用无参或有参构造器函数创建</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用无参或有参构造器函数创建，且需要是publi的构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用有参和私有private构造器函数创建，实用性更广</td>
</tr>
<tr>
<td>使用Clone方法</td>
<td>不调用任何参构造器函数，且对象需要实现Cloneable接口并实现其定义的clone方法，且默认为浅复制</td>
</tr>
<tr>
<td>第三方库Objenesis</td>
<td>利用了asm字节码技术，动态生成Constructor对象</td>
</tr>
</tbody></table>
<h2 id="2、对象创建过程"><a href="#2、对象创建过程" class="headerlink" title="2、对象创建过程"></a>2、对象创建过程</h2><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730153219366.png" alt="image-20210730153219366"></p>
<h3 id="2-1-类的加载"><a href="#2-1-类的加载" class="headerlink" title="2.1 类的加载"></a>2.1 类的加载</h3><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="2-2-分配内存"><a href="#2-2-分配内存" class="headerlink" title="2.2 分配内存"></a>2.2 分配内存</h3><p>类的加载检查通过后，接下来是为新生对象分配内存。但类加载完成后所需的内存大小就已经完全确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配内存有两种方式：</p>
<ul>
<li><strong>指针碰撞（Bump the Pointer）</strong>：假设java堆中内存是绝对规整的，所有用过得内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪到一段与对象大小相等的距离</li>
<li><strong>空闲列表（Free List）</strong>：如果java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li>
</ul>
<p>选择哪种分配方式由java堆是否完整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理（标记-整理）功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>还有一个问题需要考虑，在虚拟机中对象频繁的创建（即使是修改一个指针所指的位置），在并发情况下会带来线程安全的问题。作为虚拟机来说，必须保证线程安全，所有虚拟机采用两种方式保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试</strong>：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</li>
<li><strong>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</strong>：为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB的内存已用尽时，在采用上述的CAS进行内存分配</li>
</ul>
<h3 id="2-3-初始化零值"><a href="#2-3-初始化零值" class="headerlink" title="2.3 初始化零值"></a>2.3 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，<code>程序能访问到这些字段的数据类型所对应的零值</code>。</p>
<h3 id="2-4-设置对象头"><a href="#2-4-设置对象头" class="headerlink" title="2.4 设置对象头"></a>2.4 设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p>
<h3 id="2-5-执行Init方法"><a href="#2-5-执行Init方法" class="headerlink" title="2.5 执行Init方法"></a>2.5 执行Init方法</h3><p>在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看，对象创建才刚开始， <code>&lt;init&gt;</code> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏ <code>&lt;init&gt;</code>⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。</p>
<h2 id="3-对象在内存布局"><a href="#3-对象在内存布局" class="headerlink" title="3.对象在内存布局"></a>3.对象在内存布局</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730160335842.png" alt="image-20210730160335842" style="zoom:33%;" />



<p><code>对象头(Header)</code>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<h2 id="4-对象访问"><a href="#4-对象访问" class="headerlink" title="4. 对象访问"></a>4. 对象访问</h2><p>建⽴对象就是为了使⽤对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问⽅式有虚拟机实现⽽定，⽬前主流的访问⽅式有使⽤句柄和直接指针两种：</p>
<h3 id="4-1-句柄访问"><a href="#4-1-句柄访问" class="headerlink" title="4.1 句柄访问"></a>4.1 句柄访问</h3><p> 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730160814175.png" alt="image-20210730160814175" style="zoom:50%;" />

<h3 id="4-2-直接指针"><a href="#4-2-直接指针" class="headerlink" title="4 .2 直接指针"></a>4 .2 直接指针</h3><p> 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730161006154.png" alt="image-20210730161006154" style="zoom:50%;" />

<p>这两种对象访问⽅式各有优势。使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。</p>
<h2 id="5、对象内存分配"><a href="#5、对象内存分配" class="headerlink" title="5、对象内存分配"></a>5、对象内存分配</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730164126810.png" alt="image-20210730164126810" style="zoom:50%;" />

<p>Java内存体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：<strong>给对象分配内存</strong>和<strong>回收分配给对象的内存</strong>。</p>
<p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区域，如果启动了本地线程分配缓冲，将按线程优先分配在TLAB上。<code>少数情况下也可能直接分配在老年代中</code>。具体的分配规则取决于垃圾收集器的类型以及虚拟机中参数的配置。但是有几条最普遍的内存分配规则如下：</p>
<h3 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a>5.1 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区进行分配。当Eden区没有足够内存进行分配时，虚拟机将会发起一次Minor GC。</p>
<h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h3><p>所谓大对象，是指需要大量连续存储空间的Java对象，最典型的大对象就是那种很长的字符串或者数组。大对象对虚拟机分配来说是一个坏消息，经常出现大对象会导致虚拟机需要经常调用GC来为这些大对象整理出足够的连续空间。</p>
<h3 id="5-3长期存活的对象将进入老年代"><a href="#5-3长期存活的对象将进入老年代" class="headerlink" title="5.3长期存活的对象将进入老年代"></a>5.3长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代。为了做到这一点，虚拟机给每一个对象定义了一个对象年龄计数器。如果对象在Eden出生并且经过了第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1。对象在Survivor区域中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）对象将会被晋身到老年代中。</p>
<h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h3><p>为了能够更好的适应不同程序的内存状况，虚拟机并不是每次都要等到对象的年龄到达阈值才将对象移动到老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等待年龄增长。</p>
<h3 id="5-6-空间分配担保"><a href="#5-6-空间分配担保" class="headerlink" title="5.6 空间分配担保"></a>5.6 空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代中最大可用的连续空间是否大于新生代所有对象空间综合，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次GC是有风险的；如果小于，或者设置不允许，那这时将改为进行一次Full GC。</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载机制</title>
    <url>/wiki/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="1-类加载机制具体流程"><a href="#1-类加载机制具体流程" class="headerlink" title="1. 类加载机制具体流程"></a>1. 类加载机制具体流程</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730171153387.png" alt="image-20210730171153387" style="zoom:67%;" />

<p>Java 的类加载过程可以分为 5 个阶段：载入、验证、准备、解析和初始化。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。</p>
<h3 id="1-1-Loading（载入）"><a href="#1-1-Loading（载入）" class="headerlink" title="1.1 Loading（载入）"></a>1.1 Loading（载入）</h3><blockquote>
<p> JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象。</p>
</blockquote>
<ol>
<li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li>
</ol>
<p><strong>数组类的特殊性</strong>：<code>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的</code>。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p>
<ol>
<li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li>
<li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li>
<li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li>
</ol>
<p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p>
<h3 id="1-2-Verification（验证）"><a href="#1-2-Verification（验证）" class="headerlink" title="1.2 Verification（验证）"></a>1.2 Verification（验证）</h3><p>JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。</p>
<h5 id="1-2-1-文件格式验证"><a href="#1-2-1-文件格式验证" class="headerlink" title="1.2.1 文件格式验证"></a>1.2.1 文件格式验证</h5><ol>
<li>是否以魔数 0xCAFEBABE 开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li>
<li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li>
<li>……</li>
</ol>
<p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p>
<h5 id="1-2-2-元数据验证"><a href="#1-2-2-元数据验证" class="headerlink" title="1.2.2 元数据验证"></a>1.2.2 元数据验证</h5><ol>
<li>这个类是否有父类（除 java.lang.Object 之外）</li>
<li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li>
</ol>
<p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<h5 id="1-2-3-字节码验证"><a href="#1-2-3-字节码验证" class="headerlink" title="1.2.3 字节码验证"></a>1.2.3 字节码验证</h5><ol>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li>
<li>……</li>
</ol>
<p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<h5 id="1-2-4-符号引用验证"><a href="#1-2-4-符号引用验证" class="headerlink" title="1.2.4 符号引用验证"></a>1.2.4 符号引用验证</h5><ol>
<li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li>
<li>……</li>
</ol>
<p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p>
<h3 id="1-3-Preparation（准备）"><a href="#1-3-Preparation（准备）" class="headerlink" title="1.3 Preparation（准备）"></a>1.3 Preparation（准备）</h3><h5 id="1-3-1-设置默认值"><a href="#1-3-1-设置默认值" class="headerlink" title="1.3.1 设置默认值"></a>1.3.1 设置默认值</h5><p>JVM 会在该阶段对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p>
<p>也就是说，假如有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String chenmo = <span class="string">&quot;沉默&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String wanger = <span class="string">&quot;王二&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String cmower = <span class="string">&quot;沉默王二&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 null。</p>
<p>需要注意的是，static final 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 null。</p>
<h5 id="1-3-2-各种类型默认值"><a href="#1-3-2-各种类型默认值" class="headerlink" title="1.3.2 各种类型默认值"></a>1.3.2 各种类型默认值</h5><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730170747559.png" alt="image-20210730170747559" style="zoom:33%;" />

<h3 id="1-4-Resolution（解析）"><a href="#1-4-Resolution（解析）" class="headerlink" title="1.4 Resolution（解析）"></a>1.4 Resolution（解析）</h3><p>该阶段将常量池中的符号引用转化为直接引用。</p>
<p><code>**符号引用**</code> : 以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。</p>
<p><code>**直接引用**</code> : 直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</p>
<p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。</p>
<p>直接引用通过对符号引用进行解析，找到引用的实际内存地址。</p>
<h3 id="1-5-Initialization（初始化）"><a href="#1-5-Initialization（初始化）" class="headerlink" title="1.5 Initialization（初始化）"></a>1.5 Initialization（初始化）</h3><p>该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。</p>
<p>oh，no，上面这段话说得很抽象，不好理解，对不对，我来举个例子。</p>
<p><code>String cmower = new String(&quot;沉默王二&quot;);</code><br>上面这段代码使用了 new 关键字来实例化一个字符串对象，那么这时候，就会调用 String 类的构造方法对 cmower 进行实例化。</p>
<h2 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2. 双亲委派机制"></a>2. 双亲委派机制</h2><p>聊完类加载过程，就不得不聊聊类加载器。</p>
<h3 id="2-1-什么是类加载"><a href="#2-1-什么是类加载" class="headerlink" title="2.1 什么是类加载"></a>2.1 什么是类加载</h3><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730171408574.png" alt="image-20210730171408574" style="zoom:50%;" />

<p>一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试<br>ClassNotFoundException 和 NoClassDefFoundError 等异常。</p>
<p><em><strong>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 Class 对象不 equals）。</strong></em></p>
<p>站在程序员的角度来看，Java 类加载器可以分为三种。</p>
<p>1）<strong>启动类加载器</strong>（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。</p>
<p>2）<strong>扩展类加载器</strong>（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件。</p>
<p>3）<strong>应用类加载器</strong>（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。</p>
<p>来来来，通过一段简单的代码了解下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Test.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(loader.toString());</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 类名.class.getClassLoader() 可以获取到此引用；然后通过 loader.getParent() 可以获取类加载器的上层类加载器。</p>
<p>这段代码的输出结果如下：</p>
<p>sun.misc.Launcher$AppClassLoader@73d16e93<br>sun.misc.Launcher$ExtClassLoader@15db9742<br>第一行输出为 Test 的类加载器，即应用类加载器，它是 sun.misc.Launcher$AppClassLoader 类的实例；第二行输出为扩展类加载器，是 sun.misc.Launcher$ExtClassLoader 类的实例。那启动类加载器呢？</p>
<p>按理说，扩展类加载器的上层类加载器是启动类加载器，但在我这个版本的 JDK 中， 扩展类加载器的 getParent() 返回 null。所以没有输出。</p>
<h3 id="2-2-双亲委派的意义"><a href="#2-2-双亲委派的意义" class="headerlink" title="2.2 双亲委派的意义"></a>2.2 双亲委派的意义</h3><p>使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种层次模型，可以避免类的重复加载，也可以避免核心类被不同的类加载器加载到内存中造成冲突和混乱，从而保证了Java核心库的安全。</p>
<h2 id="3-类加载的应用"><a href="#3-类加载的应用" class="headerlink" title="3. 类加载的应用"></a>3. 类加载的应用</h2><p><a href="https://juejin.cn/post/6931972267609948167">https://juejin.cn/post/6931972267609948167</a></p>
<ul>
<li>类加载</li>
<li>热部署</li>
<li>加密保护</li>
<li>依赖冲突</li>
</ul>
<h2 id="4-双亲委派如何破坏"><a href="#4-双亲委派如何破坏" class="headerlink" title="4. 双亲委派如何破坏"></a>4. 双亲委派如何破坏</h2><p>线程上下文加载器</p>
<p><a href="https://enfangzhong.github.io/2019/12/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">https://enfangzhong.github.io/2019/12/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></p>
<p><a href="https://www.cnblogs.com/joemsu/p/9310226.html#_caption_2">https://www.cnblogs.com/joemsu/p/9310226.html#_caption_2</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-自定义类加载器</title>
    <url>/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p>为什么要自定义加载器</p>
<p>原因：<br>1、存放在自定义路径上的类，需要通过自定义类加载器去加载。【注意：AppClassLoader加载classpath下的类】<br>2、类不一定从文件中加载，也可能从网络中的流中加载，这就需要自定义加载器去实现加密解密。<br>3、可以定义类的实现机制，实现类的热部署,<br>如OSGi中的bundle模块就是通过实现自己的ClassLoader实现的，<br>如tomcat实现的自定义类加载模型。</p>
<p>如何实现自定义加载器</p>
<blockquote>
<p>实现自定义类加载有以下两步：<br>1、继承ClassLoader<br>2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。<br>注意：如果要打破双亲委派机制，需要重写loadClass方法。<br>如下：是一个自定义 的类加载器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span>  <span class="keyword">extends</span>  <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 data= loadByte(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/admin/test/&quot;</span>+name);</span><br><span class="line">            FileInputStream fi = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> len = fi.available();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fi.read(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>下面是要加载的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类编译后的class 文件放置在/Users/admin/test/下,然后执行如下代码去加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;Demo.class&quot;</span>);</span><br><span class="line">        Object o=clazz.newInstance();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">输出:hello</span><br></pre></td></tr></table></figure>

<p>能不能自己写一个java.lang.String</p>
<p>1、代码书写后可以编译不会报错<br>2、在另一个类中加载java.lang.String，通过反射调用自己写的String类里的方法，得到结果NoSuchMethod，说明加载的还是原来的String，因为通过双亲委派机制，会把java.lang.String一直提交给启动类加载器去加载，通过他加载，加载到的永远是/lib下面的java.lang.String<br>3、在这个自己写的类中写上main方法<br>public static void main(String[] args)<br>执行main方法报错，因为这个String并不是系统的java.lang.String，所以JVM找不到main方法的签名</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_28605513/article/details/85014451">JVM:如何实现一个自定义类加载器？</a><br>原文链接：<a href="https://blog.csdn.net/qq_28605513/article/details/85014451">https://blog.csdn.net/qq_28605513/article/details/85014451</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-CAS原理和底层实现</title>
    <url>/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="CAS原理和底层实现"><a href="#CAS原理和底层实现" class="headerlink" title="CAS原理和底层实现"></a>CAS原理和底层实现</h1><img src="https://oscimg.oschina.net/oscnet/up-0ed0dcb929342035287eb09818f33416baa.png" width=550 height=400>

<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是（compare and swap） 的缩写，它能在不加锁的情况下，在多线程的环境下，保证多线程一致性的改动某一值；</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题是一个线程在CAS比较值和原来是否相等的过程中，别的线程修改过这个值，但是又改回去了，倒置当前线程比较的时候，发现是相等的，但是，中间是被修改过的；  </p>
<p>添加版本号，比较值的时候同时比较版本号</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger:"></a>AtomicInteger:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe:"></a>Unsafe:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>运用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h3 id="jdk8u-atomic-linux-x86-inline-hpp-93行"><a href="#jdk8u-atomic-linux-x86-inline-hpp-93行" class="headerlink" title="jdk8u: atomic_linux_x86.inline.hpp 93行"></a>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></h3><p>is_MP = Multi Processor  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">&quot;cmp $0, &quot;</span> #mp <span class="meta-string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="最终实现："><a href="#最终实现：" class="headerlink" title="最终实现："></a>最终实现：</h3><p>底层对应一个汇编指令「lock comxchg」，但是comxchg这条指令不是原子性的，他不能保证在比较的时候，别的线程会不会改变值；而保证线程安全的则是lock这条指令，lock这条指令在执行后面执行的时候锁定一个「北桥信号」，而不是采用纵线锁的方式；</p>
<h2 id="CAS在JDK中的实现"><a href="#CAS在JDK中的实现" class="headerlink" title="CAS在JDK中的实现"></a>CAS在JDK中的实现</h2><p>1、AtomitInteger<br>2、ConcurrentHashMap</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-FutureTask原理</title>
    <url>/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><h3 id="Future方法介绍"><a href="#Future方法介绍" class="headerlink" title="Future方法介绍"></a>Future方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务 可中断的方式取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断任务是否处于取消状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断异步任务是否执行完成      ==这里使用轮训的方式监听==</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到有结果返回；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到设置的时间，有结果返回，没有结果则抛出异常；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单示范Callable-amp-Future"><a href="#简单示范Callable-amp-Future" class="headerlink" title="简单示范Callable&amp;Future"></a>简单示范Callable&amp;Future</h3><p>（1）向线程池中提交任务的submit方法不是阻塞方法，而Future.get方法是一个阻塞方法<br>（2）submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果，所以一般需要使用future.isDone先判断任务是否全部执行完成，完成后再使用future.get得到结果。（也可以用get (long timeout, TimeUnit unit)方法可以设置超时时间，防止无限时间的等待）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;start call method...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main method start....&quot;</span>);</span><br><span class="line">        FutureTest futureTest = <span class="keyword">new</span> FutureTest();</span><br><span class="line">        Future1Test future1Test = <span class="keyword">new</span> Future1Test();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(future1Test);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;future not done !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(futureTest);</span><br><span class="line">        <span class="comment">// submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果</span></span><br><span class="line">        <span class="comment">// 这里先提交了future1Test，休眠了4s, futureTest休眠了3s，但是等我们get到结果的时候，是消耗的4s时间的；</span></span><br><span class="line">        System.err.println(<span class="string">&quot;cost time: &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">        System.err.println(<span class="string">&quot;future: &quot;</span> + future.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;future1: &quot;</span> + future1.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;main method end....&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main method start....</span><br><span class="line">future not done !</span><br><span class="line"><span class="comment">// 说明了第一 get()方法是阻塞，第二线程池任务都执行完成之后，按提交任务顺序get结果返回值</span></span><br><span class="line">cost time: <span class="number">4</span></span><br><span class="line">start call method...</span><br><span class="line">future: future <span class="number">2</span> test</span><br><span class="line">future1: <span class="number">1111</span></span><br><span class="line">main method end....</span><br></pre></td></tr></table></figure>

<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul>
<li>线程池执行任务有两种方式execute和submit，execute是不带返回值的，submit是有返回值的;</li>
<li>main方法中可以不使用线程池，可以直接创建线程，调用start方法就可以，切记只有在演示代码的时候后。手动直接创建线程的方式还是不要用，因为一旦请求变多，则会创建无数的线程，线程数大于CPU核数，进而导致CPU频繁切换上下分进行调度，性能严重下降。</li>
<li>而且线程的数据是存放在内存中的，会占用大量的内存，增加垃圾回收的压力。严重的会发生OOM;</li>
<li>异常main方法中我们使用的是Future<String> future接收异步任务执行的放回结果，但实际上Future其实是一个interface，并不能接收返回结果的，那实际我们调用future.get()是，是实例了一个FutureTask对象来接受的；</li>
</ul>
<h3 id="FutureTask讲解"><a href="#FutureTask讲解" class="headerlink" title="FutureTask讲解"></a>FutureTask讲解</h3><p>下面主要针对Future的实现类FutureTask的几个重要方法展开</p>
<h4 id="FutureTask继承关系"><a href="#FutureTask继承关系" class="headerlink" title="FutureTask继承关系"></a>FutureTask继承关系</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 下面是RunnableFuture接口的继承关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>FutureTask 重要的成员变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="comment">//任务执行结果或者任务异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="comment">//执行任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="comment">//等待节点，关联等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//state字段的内存偏移量     这个在线程池执行任务的时候进行状态判断的时候会用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="comment">//runner字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line"><span class="comment">//waiters字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义任务的生命周期</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NORMAL:指的是任务能够正常执行状态  </li>
<li>EXCEPTIONAL：表示任务执行异常  </li>
<li>CANCELLED：取消状态，之后的状态都表示任务取消或终端  </li>
</ul>
<p>下面看一下FutureTask中几个重要的方法</p>
<h4 id="执行结果-report方法"><a href="#执行结果-report方法" class="headerlink" title="执行结果 | report方法"></a>执行结果 | report方法</h4><blockquote>
<p>Returns result or throws exception for completed task.<br>主要是上报异步任务执行的结果或返回任务执行发生的异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>判断逻辑就是根据参数，也是是任务状态，根据不同的状态处理相应的逻辑。比如NORNAL状态，表示任务正常执行，直接返回结果就可以。如果状态大于CANCELLED，说明任务被取消或终端，会抛出CancellationException()；如果不是异常状态，则抛出ExecutionException；</p>
<h4 id="任务执行-run"><a href="#任务执行-run" class="headerlink" title="任务执行 |   run()"></a>任务执行 |   run()</h4><blockquote>
<p>执行异步任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果状态 state 不是 NEW，或者设置 runner 值失败</span></span><br><span class="line">     <span class="comment">// 表示有别的线程在此之前调用 run 方法，并成功设置了 runner 值</span></span><br><span class="line">     <span class="comment">// 保证了只有一个线程可以运行 try 代码块中的代码。</span></span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">             !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//以上state值变更的由CAS操作保证原子性</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="comment">//只有c不为null且状态state为NEW的情况</span></span><br><span class="line">         <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="keyword">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//调用callable的call方法，并获得返回结果</span></span><br><span class="line">                 result = c.call();</span><br><span class="line">                 <span class="comment">//运行成功</span></span><br><span class="line">                 ran = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="keyword">null</span>;</span><br><span class="line">                 ran = <span class="keyword">false</span>;</span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 <span class="comment">//设置结果</span></span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">         <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">         runner = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">         <span class="comment">// leaked interrupts</span></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">             handlePossibleCancellationInterrupt(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑就是调用Callable的call方法，==result=c.call();== 并且对任务执行的结果或异常信息进行处理；</p>
<h4 id="获取结果-get-throws-InterruptedException-ExecutionException"><a href="#获取结果-get-throws-InterruptedException-ExecutionException" class="headerlink" title="获取结果 | get() throws InterruptedException, ExecutionException"></a>获取结果 | get() throws InterruptedException, ExecutionException</h4><blockquote>
<p>获取异步任务执行的结果或异常信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法执行两个操作：  </p>
<ul>
<li>判断任务的状态,如果没有执行完成，调用awaitDone方法</li>
<li>任务完成，调用我们上面说的report方法，返回任务执行结果</li>
</ul>
<h4 id="任务阻塞-awaitDone-boolean-timed-long-nanos"><a href="#任务阻塞-awaitDone-boolean-timed-long-nanos" class="headerlink" title="任务阻塞 | awaitDone(boolean timed, long nanos)"></a>任务阻塞 | awaitDone(boolean timed, long nanos)</h4><blockquote>
<p>等到任务执行完成 也是get方法阻塞特性的关键所在</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// CPU轮转</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果线程中断了，将线程移除等待队列，抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 如果任务状态大于完成，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务完成，但是返回值outcome还没有设置，可以先让出线程执行权，让其他线程执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">// 下面是任务还没有执行完成的状态，将线程添加到等待队列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="comment">// 判断get方法是否设置了超时时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 如果超出设置的时间，线程移除等到队列</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有设置超时时间，线程直接阻塞，直到任务完成</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>主要执行步骤：</p>
<ul>
<li>判断线程是否被中断，如果被中断了，就从等待的线程栈中移除该等待节点，然后抛出中断异常 </li>
<li>读取state,判断任务是否已经完成，如果已经完成或者任务已经取消，此时调用get方法的线程不会阻塞，会直接获取到结果或者拿到异常信息；  </li>
<li>如果s == COMPLETING，说明任务已经结束，但是结果还没有保存到outcome中，==此时线程让出执行权，给其他线程先执行；==   </li>
<li>如果任务没有执行完成，则需要创建等待节点，等待插入到阻塞队列  </li>
<li>判断queued，这里是将c中创建节点q加入队列头。使用Unsafe的CAS方法，对waiters进行赋值，waiters也是一个WaitNode节点，相当于队列头，或者理解为队列的头指针。通过WaitNode可以遍历整个阻塞队列  </li>
<li>然后判断超时时间，时间是在调用get方法的时候传输进来的，如果有超时时间，则设置超时时间，如果超出时间，则将线程移除等待队列；如果没有设置时间，则直接阻塞线程；  </li>
</ul>
<h4 id="取消任务-cancel-boolean-mayInterruptIfRunning"><a href="#取消任务-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="取消任务 |  cancel(boolean mayInterruptIfRunning)"></a>取消任务 |  cancel(boolean mayInterruptIfRunning)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Param</span> mayInterruptIfRunning 是否中断</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在状态还为NEW的时候，根据参数中的是否允许传递，</span></span><br><span class="line"><span class="comment">     * 将状态流转到INTERRUPTING或者CANCELLED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 必须将栈顶CAS为null，否则重读栈顶并重试。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历并唤醒栈中节点对应的线程。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将next域置为null，这样对GC友好。</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; </span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * done方法是暴露给子类的一个钩子方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个方法在ExecutorCompletionService.QueueingFuture中的override实现是把结果加到阻塞队列里。</span></span><br><span class="line"><span class="comment">     * CompletionService谁用谁知道，奥秘全在这。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * callable置为null主要为了减少内存开销,</span></span><br><span class="line"><span class="comment">     * 更多可以了解JVM memory footprint相关资料。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    callable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Callable-amp-Future使用场景"><a href="#Callable-amp-Future使用场景" class="headerlink" title="Callable&amp;Future使用场景"></a>Callable&amp;Future使用场景</h3><ul>
<li>异步任务需要拿到返回值</li>
<li>多线程并发调用，顺序组装返回值，一些并发框架中会看到相应体现</li>
<li>还有一些分布式任务调度的场景，远程调用需要回填执行结果</li>
<li>还有很多通信框架中都有体现</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p>(1) <a href="https://blog.csdn.net/qq_34562093/article/details/90209520">future.get方法阻塞问题的解决，实现按照任务完成的先后顺序获取任务的结果</a><br>(2) <a href="https://blog.csdn.net/luofenghan/article/details/78596950#%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java多线程引发的性能问题以及调优策略</a><br>(3) <a href="https://www.jianshu.com/p/55221d045f39">可取消的异步任务——FutureTask用法及解析</a><br>(4) <a href="https://www.cnblogs.com/micrari/p/7374513.html">FutureTask源码解读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO</title>
    <url>/wiki/Java-NIO/</url>
    <content><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><blockquote>
<p>Java NIO 对于Java BIO的优化</p>
</blockquote>
<h2 id="Java-非阻塞IO"><a href="#Java-非阻塞IO" class="headerlink" title="Java 非阻塞IO"></a>Java 非阻塞IO</h2><blockquote>
<p>及时不使用线程池，也可以处理多个客户端请求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ServerSocketChannel ss = ServerSocketChannel.open();</span><br><span class="line">    ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">    ss.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        SocketChannel client = ss.accept();</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;client is null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">            System.err.println(<span class="string">&quot;client port &quot;</span> + port);</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 串型话</span></span><br><span class="line">        <span class="comment">// 真实场景下 每一个client一个独自的buffer</span></span><br><span class="line">        <span class="keyword">for</span> (SocketChannel c : clients) &#123;</span><br><span class="line">            <span class="comment">// -1 出现空轮训 </span></span><br><span class="line">            <span class="keyword">int</span> num = c.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">                byteBuffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                System.err.println(c.socket().getPort() + <span class="string">&quot; :   &quot;</span> + b);</span><br><span class="line">                <span class="comment">// 清空 循环下一次client在使用</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上可以实现，一个线程可以处理多个客户端链接，服务端非阻塞接收，接收之后，读取数据也是非阻塞的；</p>
</blockquote>
<blockquote>
<p>NIO的非阻塞是操作系统内部实现的，底层调用了linux内核的accept函数</p>
</blockquote>
<blockquote>
<p>d Java的NIO有什么弊端</p>
</blockquote>
<ul>
<li>服务端还是会进行空转</li>
<li>不管有没有客户端连接建立，服务端都要不断执行accept方法</li>
<li>不管客户端连接有没有传输数据，都会执行一遍read操作</li>
</ul>
<blockquote>
<p>资源浪费问题</p>
</blockquote>
<p>还是会存在C10k的问题</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--buffer</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-buffer/</url>
    <content><![CDATA[<h1 id="Buffer-读写"><a href="#Buffer-读写" class="headerlink" title="Buffer 读写"></a>Buffer 读写</h1><h2 id="NIO之Buffer"><a href="#NIO之Buffer" class="headerlink" title="NIO之Buffer"></a>NIO之Buffer</h2><p>Buffer作为NIO三大核心组件之一，本质上是一块可以写入数据，以及从中读取数据的内存，实际上也是一个byte[]数据,只是在NIO中被封装成了NIO Buffer对象<br>并提供了一组方法来访问这个内存块。</p>
<h3 id="下面是一个简单的Demo"><a href="#下面是一个简单的Demo" class="headerlink" title="下面是一个简单的Demo"></a>下面是一个简单的Demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一个text.txt文件，生成一个新的text1.txt文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNioDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">        FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">// 声明缓冲区大小为1024字节</span></span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 从通道中读取数据</span></span><br><span class="line">        inChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">// 读模式切换为写模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//把缓冲区的数据写到通道</span></span><br><span class="line">        outChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 数据写完之后清空全部缓冲区</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="comment">//关闭文件流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; 执行结果：生成/Users/gaolei/Desktop/text1.txt文件  </span><br><span class="line"></span><br><span class="line">**Buffer进行数据读写操作的一般步骤**  </span><br><span class="line"><span class="number">1</span>、写入数据到Buffer  </span><br><span class="line"><span class="number">2</span>、调用flip()方法  </span><br><span class="line"><span class="number">3</span>、从Buffer中读取数据  </span><br><span class="line"><span class="number">4</span>、调用clear()方法或者compact()方法  </span><br><span class="line"></span><br><span class="line">&gt; clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### Buffer三个核心的属性  </span><br><span class="line">- capacity 容量 与buffer处在什么模式无关</span><br><span class="line">- position 游标位置 指向下一个存放/读取数据的位置 范围（<span class="number">0</span> ～ capacity–<span class="number">1</span>）</span><br><span class="line">- limit </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 读写操作中Buffer三大属性的变化</span><br><span class="line">初始状态  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;    </span><br><span class="line">第一次读取数据  </span><br><span class="line">position处于起始位置，limit和capacity都处于结尾  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-41b47d9e54d58c7b39caf9e514fc9b5261f.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">第二次读取数据  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-07f3d1aa1f886b592b386cd4d846810911d.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">当写数据的时候，需要调用flip方法： </span><br><span class="line">当将Buffer从写模式切换到读模式，position会被重置为<span class="number">0.</span> 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。  </span><br><span class="line">当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）     </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-b9323701bbb34a6c12f61d5ac2652ab7eeb.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">Clear方法  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JAVA NIO下的Buffer分类</span><br><span class="line">- ByteBuffer</span><br><span class="line">- MappedByteBuffer</span><br><span class="line">- CharBuffer</span><br><span class="line">- DoubleBuffer</span><br><span class="line">- FloatBuffer</span><br><span class="line">- IntBuffer</span><br><span class="line">- LongBuffer</span><br><span class="line">- ShortBuffer</span><br><span class="line">&gt; Java基本类型除了布尔类型，都有其对应的Buffer </span><br><span class="line"></span><br><span class="line">### ByteBuffer使用</span><br><span class="line">&gt; 下面以ByteBuffer为例子看一下Buffer如何使用</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 创建一个byteBuffer，设置容量为1024字节</span></span><br><span class="line">ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>1、如下代码，其实调用了new HeapByteBuffer(capacity, capacity)来创建一个buffer  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>2、创建了buffer之后要往里面写数据，除了上面从channel中读取数据之外，还可以调用put方法,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>3、如果写将buffer中的数据写出去，必须先调用flap方法</p>
<blockquote>
<p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
</blockquote>
<p>4、将数据写到通道中 inChannel.write(buf);</p>
<p>5、数据写出到通道之后，要将缓存清空，一般调用clear方法<br><strong>clear方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//position将被设回0</span></span><br><span class="line">       position = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//limit被设置成 capacity的值</span></span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。<br><strong>compact方法</strong><br>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//compact()方法将所有未读的数据拷贝到Buffer起始处。</span></span><br><span class="line">        System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">        <span class="comment">//position设到最后一个未读元素正后面</span></span><br><span class="line">        position(remaining());</span><br><span class="line">        <span class="comment">//limit属性设置成capacity</span></span><br><span class="line">        limit(capacity());</span><br><span class="line">        discardMark();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">现在Buffer准备好写数据了，但是不会覆盖未读的数据 </span><br></pre></td></tr></table></figure>
<h3 id="零拷贝原理"><a href="#零拷贝原理" class="headerlink" title="零拷贝原理"></a>零拷贝原理</h3><p>– 零拷贝，第一次接触零拷贝是在kafka的数据存储部分–<br>IO流程：<br><img src="https://oscimg.oschina.net/oscnet/up-f5a9accbd021cfe41414ca72391b3889049.png"  height="230" width="395"><br>内存映射缓冲区<br><img src="https://oscimg.oschina.net/oscnet/up-a7a80d3426d1497bcaa69f30789718db0ee.png"  height="230" width="395"><br>比普通IO操作文件快很多，甚至比channel还要快很多。<br>因为避免了很多系统调用（System.read System.write）。减少了内核缓冲区的数据拷贝到用户缓冲区。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      FileChannel in = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">      FileChannel out = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>), StandardOpenOption.READ, StandardOpenOption.CREATE, StandardOpenOption.WRITE);</span><br><span class="line">      MappedByteBuffer inBuffer = in.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, in.size());</span><br><span class="line">      MappedByteBuffer outBuffer = out.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, in.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inBuffer.limit()];</span><br><span class="line">      inBuffer.get(bytes);</span><br><span class="line">      outBuffer.put(bytes);</span><br><span class="line">      in.close();</span><br><span class="line">      out.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-ec7269566091c2f389749849ad734972de6.png"><br>普通的网络IO拷贝流程<br>1、首先系统从磁盘上拷贝文件到内核空间缓冲区<br>2、然后在内核空间拷贝数据到用户空间<br>3、第三次，用户缓冲区再将数据拷贝到内核部分的socket缓冲<br>4、内核在将存储在socket缓冲区的数据拷贝并发送到网卡缓冲区<br>以上一个常规的网络IO经历了4次数据拷贝；  </p>
<p>设置缓冲区的意义在于提升性能，当用户空间仅仅需要一小部分数据的时候，操作系统会在磁盘上读取一块数据方法内核缓冲区，这个叫做局部性原理。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6209218a39ae427544247f1b3937b4043cc.png"><br>零拷贝减去了内核空间数据到用户空间数据的拷贝，从而提升IO性能。假设读取的文件很大，操作系统需要读取磁盘大量数据到内核空间，<br>这时候内核缓冲区的作用是很难体现的。因为如果用户空间需要少量数据的时候是可以直接在内核空间获取的（局部性原理）。正式因为有了零拷贝，<br>操作系统在磁盘读取数据之后，可以直接发送到网卡缓冲区，从而大大提升IO性能。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--channel</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-channel/</url>
    <content><![CDATA[<h1 id="NIO核心组件-Channel"><a href="#NIO核心组件-Channel" class="headerlink" title="NIO核心组件 - Channel"></a>NIO核心组件 - Channel</h1><h2 id="SocketChannel-和-ServerSocketChannel"><a href="#SocketChannel-和-ServerSocketChannel" class="headerlink" title="SocketChannel 和 ServerSocketChannel"></a>SocketChannel 和 ServerSocketChannel</h2><p>学习此部分可以对比Socket和ServerSocket</p>
<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketServer01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocketChannel 支持阻塞/非阻塞</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 设置成非阻塞。默认阻塞true</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 循环监听客户端连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有客户端连接，则返回一个socketChannel实例，否则socketChannel=null</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                <span class="comment">// 代码执行到此处，说明有客户端链接</span></span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 读取客户端发送的数据，并输出</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.err.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                    <span class="comment">// 将数据在写会客户端</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    socketChannel.write(buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//验证客户端 socketChannel设置成false时，从服务端read数据的操作变成非阻塞的</span></span><br><span class="line">                    <span class="comment">//ByteBuffer buffer = ByteBuffer.allocate(1024);</span></span><br><span class="line">                    <span class="comment">//buffer.put(&quot;this is server!&quot;);</span></span><br><span class="line">                    <span class="comment">//buffer.flip();</span></span><br><span class="line">                    <span class="comment">//socketChannel.write(buffer);</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    System.err.println(<span class="string">&quot;no client&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 默认阻塞IO true</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// finishConnect的主要作用就是确认通道连接已建立，方便后续IO操作（读写）不会因连接没建立而导致NotYetConnectedException异常。</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel.isConnectionPending()) &#123;</span><br><span class="line">                <span class="comment">// finishConnect一直阻塞到connect建立完成</span></span><br><span class="line">                socketChannel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            </span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">int</span> r = socketChannel.read(byteBuffer); <span class="comment">// 非阻塞方法 byteBuffer的数据还是上面put的</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;get msg:&#123;&#125;&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server no back&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--selector</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-selector/</url>
    <content><![CDATA[<h1 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>1、select选择器会告诉客户端哪些连接有数据要读取，但是读取的操作还是用户自己触发的，这种叫做「同步」</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 4:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMultiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.err.println(<span class="string">&quot;server started ....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// selector.select() 调用系统内核的select</span></span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 从多路复用器中选择有效的key</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        acceptHandle(key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        readHandle(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel client = ssc.accept();</span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class="line">        System.err.println(<span class="string">&quot;client arrived &quot;</span> + client.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            read = client.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务端读到的数据，再写一遍给到客户端</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// client 发生错误 或者断开 read == -1</span></span><br><span class="line">                <span class="comment">// 导致空转 最终CPU达到100%</span></span><br><span class="line">                client.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的写法是一个selector既担任boss又担任worker </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-join方法原理解析</title>
    <url>/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">join重载方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> join()</span><br><span class="line"><span class="number">2</span> join(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line"><span class="number">3</span> join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br></pre></td></tr></table></figure>
<h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//        t.join();</span></span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上将t.join();注释掉，执行的一种可能结果如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">main thread end... </span><br><span class="line">join thread demo</span><br><span class="line"></span><br><span class="line">还有可能是这种结果：</span><br><span class="line">main thread start... </span><br><span class="line">join thread demo</span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure>
<p>但是把注释去掉，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的demo,效果是显而易见的。当main线程去调用t.join()是，会将自己当前线程阻塞，等到t线程执行完成到达完结状态，main线程才可以继续执行。  </p>
<p>我们看一下join()设置超时时间的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程睡眠4s</span></span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">null</span>;</span><br><span class="line">        System.err.println(strings.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 但是主线程join的超时时间是1s</span></span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br><span class="line">Exception in thread <span class="string">&quot;ibli joinTest ...&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at com.ibli.threadTest.api.JoinDemo.run(JoinDemo.java:<span class="number">14</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的执行结果可以看到，子线程设置了4s的超时时间，但是主线程在1秒超时后，并没有等待子线程执行完毕，就被唤醒执行后续操作了；这样的预期是否符合你的预期呢？<br>下面我们按照join的源码去分析吧！</p>
</blockquote>
<h3 id="join方法原理"><a href="#join方法原理" class="headerlink" title="join方法原理"></a>join方法原理</h3><p>下面是join的原理图</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5386b2aaabd43cab4b0f042e0270118~tplv-k3u1fbpfcp-zoom-1.image?imageView2/2/w/480/h/480/q/85/interlace/1" width = "400" height = "500" div align=right />




<blockquote>
<p>join()源码</p>
</blockquote>
<p>首先会调用join(0)方法，其实是join的重载方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是join的核心实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先校验参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果join方法没有参数，则相当于直接调用wait方法</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面是isAlive方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法，作用是判断当前的线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。</p>
<ul>
<li><p>这里有一个点要注意，join为什么阻塞的是主线程，而不是子线程呢？  </p>
</li>
<li><p>不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p>
</li>
<li><p>其实join()方法的核心在于wait(),在主线程中调用t.join()相当于在main方法中添加 new JoinDemo().wait();是一样的效果；在这里只不过是wait方法写在了子线程的方法中。  </p>
</li>
<li><p>再次重申一遍，join方法的作用是在主线程阻塞，等在子线程执行完之后，由子线程唤醒主线程，再继续执行主线程调用t.join()方法之后的逻辑。</p>
</li>
</ul>
<blockquote>
<p>那么主线程是在什么情况下知道要继续执行呢？就是上面说的，主线程其实是由join的子线程在执行完成之后调用的notifyAll()方法，来唤醒等待的线程。怎么证明呢？</p>
</blockquote>
<p>其实大家可以去翻看JVM的源码实现，Thread.cpp文件中，有一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">  <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">  <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中调用ensure_join方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">  <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">&quot;java thread object must exist&quot;</span>);</span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">  <span class="comment">// to complete once we&#x27;ve done the notify_all below</span></span><br><span class="line">  <span class="comment">//这里是清除native线程，这个操作会导致isAlive()方法返回false</span></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  <span class="comment">// 在这里唤醒等待的线程</span></span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JVM的代码中，线程执行结束的最终调用了lock.notify_all(thread)方法来唤醒所有处于等到的线程</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>比如我们使用Callable执行异步任务，需要在主线程处理任务的返回值时，可以调用join方法；</li>
<li>还有一些场景希望线程之间顺序执行的；</li>
</ul>
<h2 id="join-方法与sleep-的比较"><a href="#join-方法与sleep-的比较" class="headerlink" title="join()方法与sleep()的比较"></a>join()方法与sleep()的比较</h2><p>我们先说一下sleep方法：</p>
<ul>
<li>让当前线程休眠指定时间。</li>
<li>休眠时间的准确性依赖于系统时钟和CPU调度机制。</li>
<li>不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进- 入到当前同步块或者同步方法中的。</li>
<li>可通过调用interrupt()方法来唤醒休眠线程。</li>
<li>sleep是静态方法，可以在任何地方调用</li>
</ul>
<p>相比与sleep方法<br>sleep是静态方法，而且sleep的线程不是放锁资源，而join方法是对象方法，并且在等待的过程中会释放掉对象锁；</p>
<blockquote>
<p>关于join方法会释放对象锁，那到底是释放的那个对象的锁呢，可以参照 <a href="https://www.cnblogs.com/lwmp/p/11805440.html">关于join() 是否会释放锁的一些思考</a> </p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.iteye.com/blog/uule-1101994">1、Java多线程中join方法的理解</a><br><a href="https://blog.csdn.net/weichi7549/article/details/108449618">2、Thread.join的作用和原理</a><br><a href="https://www.jianshu.com/p/fc51be7e5bc0">3、Thread.join的作用和原理</a></p>
</blockquote>
<blockquote>
<p>d <p align="middle">山脚太拥挤 我们更高处见。</p></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-synchronized关键字剖析</title>
    <url>/wiki/Java-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>之前写过一篇关于synchronized关键字的文章，是当时听马士兵老师的公开课时记录的一些关键笔记📒 <a href="https://geekibli.github.io/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">链接🔗</a></p>
<p>下面我们还是要学习和总结一下synchronized</p>
<h2 id="synchronized-特性"><a href="#synchronized-特性" class="headerlink" title="synchronized 特性"></a>synchronized 特性</h2><ul>
<li>有序性<br><code>as-if-serial</code></li>
</ul>
<p>不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的，还有就是有数据依赖的也是不能重排序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure>
<p>这两段是怎么都不能重排序的，b的值依赖a的值，a如果不先赋值，那就为空了。</p>
<ul>
<li>可见性<br>主要依靠Java内存模型实现</li>
<li>原子性<br>通过汇编指令控制</li>
<li>可重入<br>synchronized锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了</li>
<li>不可中断<br>不可中断就是指，一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断。<br>值得一提的是，Lock的tryLock方法是可以被中断的。</li>
</ul>
<h2 id="了解对象头"><a href="#了解对象头" class="headerlink" title="了解对象头"></a>了解对象头</h2><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>在64位的虚拟机中：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729145750638.png" alt="image-20210729145750638"></p>
<p><strong>32位虚拟机中：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729145831606.png" alt="image-20210729145831606"></p>
<p><strong>可以参见之前的文章</strong>  👉  <a href="https://geekibli.github.io/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/">Java对象头</a></p>
<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><p>之前的文章已经在 <code>Java代码</code>、<code>字节码</code>、<code>JVM级别</code>和<code>汇编指令</code>四个级别介绍了synchronzied的实现。<br>JDK对synchronzied不断的优化，大家熟悉的锁升级过程，其实就是在源码里面，调用了不同的实现去获取获取锁，失败就调用更高级的实现，最后升级完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729144552761.png" alt="image-20210729144552761"></p>
<p>升级方向：【 无锁 】 -&gt; 【 偏向锁 】-&gt; 【 轻量级锁 】-&gt; 【 重量级锁 】</p>
<p>Tip：<font color=red>切记这个升级过程是不可逆的</font>；</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>对象头是由 Mark Word 和 Class pointer 组成，锁争夺也就是对象头指向的Monitor对象的争夺，一旦有线程持有了这个对象，标志位修改为1，就进入偏向模式，同时会把这个线程的ID记录在对象的Mark Word中。</p>
<p>这个过程是采用了<code>CAS</code>乐观锁操作的，每次同一线程进入，虚拟机就不进行任何同步的操作了，对标志位+1就好了，不同线程过来，CAS会失败，也就意味着获取锁失败。</p>
<p>偏向锁在1.6之后是默认开启的，1.5中是关闭的，需要手动开启参数是xx:-UseBiasedLocking=false。</p>
<p>初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。</p>
<p>当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。<code>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</code></p>
<p>偏向锁是指当一段同步代码<strong>一直被同一个线程所访问</strong>时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。<code>轻量级锁的获取及释放依赖多次 CAS 原子指令</code>，而<code>偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令</code>即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，<code>线程是不会主动释放偏向锁的。</code></p>
<p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果<code>线程不处于活动状态</code>，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p>
<p><strong>偏向锁关闭，或者多个线程竞争偏向锁怎么办呢？</strong></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>还是跟Mark Work 相关，如果这个对象是无锁的，jvm就会在当前线程的栈帧中建立一个叫<code>锁记录（Lock Record）</code>的空间，用来存储锁对象的Mark Word 拷贝，然后把Lock Record中的owner指向当前对象。</p>
<p>JVM接下来会利用CAS尝试把对象原本的Mark Word 更新会Lock Record的指针，成功就说明加锁成功，改变锁标志位，执行相关同步操作。</p>
<p>如果失败了，就会判断当前对象的Mark Word是否指向了当前线程的栈帧，是则表示当前的线程已经持有了这个对象的锁，否则说明被其他线程持有了，继续锁升级，修改锁的状态，之后等待的线程也阻塞。</p>
<p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
<p>轻量级锁的获取主要由两种情况：<br>① 当关闭偏向锁功能时；<br>② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</p>
<p>一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。这里要明确一下什么是锁竞争：</p>
<blockquote>
<p>如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p>
</blockquote>
<img src='https://img-blog.csdnimg.cn/20200606123648335.png' width=600 height=650>

<p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p>
<p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>我不是在上面提到了Linux系统的用户态和内核态的切换很耗资源，其实就是线程的等待唤起过程，那怎么才能减少这种消耗呢？</p>
<p>自旋，过来的现在就不断自旋，防止线程被挂起，一旦可以获取资源，就直接尝试成功，直到超出阈值，自旋锁的默认大小是10次，-XX：PreBlockSpin可以修改。</p>
<p>自旋都失败了，那就升级为重量级的锁，像1.5的一样，等待唤起咯。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729151704773.png" alt="image-20210729151704773" style="zoom:33%;" />

<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待之前成功获得过的锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，因此允许自旋等待持续相对更长的时间。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那么以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p><strong>自适应自旋解决的是“锁竞争时间不确定”的问题</strong>。JVM很难感知确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p>
<p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p>
<p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资</p>
<p>大家在看ObjectMonitor源码的时候，会发现Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，对应的线程就是park()和upark()。<br>这个操作涉及用户态和内核态的转换了，这种切换是很耗资源的，所以知道为啥有自旋锁这样的操作了吧，按道理类似死循环的操作更费资源才是对吧？其实不是，大家了解一下就知道了。</p>
<blockquote>
<p>那用户态和内核态又是啥呢？</p>
</blockquote>
<img src='https://oscimg.oschina.net/oscnet/up-3d168748d90e18da228ce8f55a9cc4a6cc4.png' width=300 height=300>

<p>Linux系统的体系结构分为用户空间（应用程序的活动空间）和内核。我们所有的程序都在用户空间运行，进入用户运行状态也就是（用户态），但是很多操作可能涉及内核运行，比如涉及到I/O，我们就会进入内核运行状态（内核态）。</p>
<p>这个过程是很复杂的，也涉及很多值的传递，我简单概括下流程：</p>
<ul>
<li>用户态把一些数据放到寄存器，或者创建对应的堆栈，表明需要操作系统提供的服务。</li>
<li>用户态执行系统调用（系统调用是操作系统的最小功能单位）。</li>
<li>CPU切换到内核态，跳到对应的内存指定的位置执行指令。</li>
<li>系统调用处理器去读取我们先前放到内存的数据参数，执行程序的请求。</li>
<li>调用完成，操作系统重置CPU为用户态返回结果，并执行下个指令。</li>
</ul>
<p>所以大家一直说，1.6之前是重量级锁，没错，但是他重量的本质，是ObjectMonitor调用的过程，以及Linux内核的复杂运行机制决定的，大量的系统资源消耗，所以效率才低。<br>还有两种情况也会发生内核态和用户态的切换：异常事件和外围设备的中断 大家也可以了解下。</p>
<blockquote>
<p>普通的IO读写也会涉及到用户态和内核的切换，但是为了提升IO 的性能，操作系统可以通过 <code>零拷贝</code> 来实现，Redis和Kafka,还有netty的底层IO模型都存在零拷贝。</p>
</blockquote>
<h3 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h3><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729150936860.png" alt="image-20210729150936860"></p>
<h2 id="synchronized和Lock对比"><a href="#synchronized和Lock对比" class="headerlink" title="synchronized和Lock对比"></a>synchronized和Lock对比</h2><p>我们先看看他们的区别：</p>
<ul>
<li>synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API。</li>
<li>synchronized会自动释放锁，而Lock必须手动释放锁。</li>
<li>synchronized是不可中断的，Lock可以中断也可以不中断。</li>
<li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li>
<li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
<li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li>
</ul>
<p>两者一个是JDK层面的一个是JVM层面的，我觉得最大的区别其实在，我们是否需要丰富的api，还有一个我们的场景。</p>
<blockquote>
<p><strong>比如我现在是滴滴，我早上有打车高峰，我代码使用了大量的synchronized，有什么问题？锁升级过程是不可逆的，过了高峰我们还是重量级的锁，那效率是不是大打折扣了？这个时候你用Lock是不是很好？</strong></p>
</blockquote>
<h2 id="synchronized使用注意事项"><a href="#synchronized使用注意事项" class="headerlink" title="synchronized使用注意事项"></a>synchronized使用注意事项</h2><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。</p>
<blockquote>
<p> <strong>使用Synchronized有哪些要注意的？</strong></p>
</blockquote>
<ul>
<li>锁对象不能为空，因为锁的信息都保存在对象头里</li>
<li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li>
<li>避免死锁</li>
<li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li>
</ul>
<blockquote>
<p><strong>synchronized是公平锁吗？</strong></p>
</blockquote>
<p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，不过这种抢占的方式可以预防饥饿。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/bakari/p/5520860.html">Linux探秘之用户态与内核态</a></p>
<p><a href="https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ">傻瓜三歪让我教他「零拷贝」</a></p>
<p><a href="https://www.jianshu.com/p/8c255b942535">偏向锁、轻量级锁、重量级锁、自旋锁、自适应自旋锁</a></p>
<p><a href="https://www.cnblogs.com/mingyueyy/p/13054296.html">关于 锁的四种状态与锁升级过程 图文详解</a></p>
<p><a href="https://mp.weixin.qq.com/s/2ka1cDTRyjsAGk_-ii4ngw">死磕Synchronized底层实现</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-synchronzied底层原理</title>
    <url>/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="synchronzied底层原理"><a href="#synchronzied底层原理" class="headerlink" title="synchronzied底层原理"></a>synchronzied底层原理</h1><h2 id="synchronzied四个层级实现"><a href="#synchronzied四个层级实现" class="headerlink" title="synchronzied四个层级实现"></a>synchronzied四个层级实现</h2><ul>
<li>Java代码 通过添加synchronzied给对象或者方法或者代码块</li>
<li>字节码层级通过一组 MONITORENTER/MONITOREXIT指令</li>
<li>JVM层级：锁升级过程</li>
<li>汇编执行通过 lock comxchg指令保证原子操作</li>
</ul>
<p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db <span class="string">&quot;Hello&quot;</span>, <span class="number">0xA</span></span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, <span class="number">1</span> ;文件描述符<span class="number">1</span> std_out</span><br><span class="line">    mov eax, <span class="number">4</span> ;write函数系统调用号 <span class="number">4</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">    mov ebx, <span class="number">0</span></span><br><span class="line">    mov eax, <span class="number">1</span> ;exit函数系统调用号</span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure>

<p>优化后的synchronized如下👇：</p>
<h2 id="Java层级"><a href="#Java层级" class="headerlink" title="Java层级"></a>Java层级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Object object = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">          System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">    <span class="comment">// parameter  args</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L2 L3 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 13 L4</span></span><br><span class="line"><span class="function">    NEW java/lang/Object</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/lang/Object.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L5</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">16</span> L6</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    DUP</span><br><span class="line">    ASTORE <span class="number">2</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">17</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">18</span> L7</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L8</span><br><span class="line">   L2</span><br><span class="line">   FRAME FULL [[Ljava/lang/String; java/lang/Object java/lang/Object] [java/lang/Throwable]</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">    ALOAD <span class="number">3</span></span><br><span class="line">    ATHROW</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">19</span> L8</span><br><span class="line">   FRAME CHOP <span class="number">1</span></span><br><span class="line">    RETURN</span><br><span class="line">   L9</span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L4 L9 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE object Ljava/lang/Object; L5 L9 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要通过MONITORENTER 和 MONITOREXIT 两个字节码指令控制加锁过程</p>
</blockquote>
<h2 id="JVM层级"><a href="#JVM层级" class="headerlink" title="JVM层级"></a>JVM层级</h2><p>通过锁升级过程实现加锁；<br>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁 自适应锁）-&gt; 重量级锁<br>锁升级过程可以查看 <a href="doc:rjG4EIhi">锁升级过程</a>  复制理解</p>
<h2 id="汇编指令级别"><a href="#汇编指令级别" class="headerlink" title="汇编指令级别"></a>汇编指令级别</h2><p>linux操作系统安装hsdis插件，查看java代码的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    static volatile int i = 0;</span><br><span class="line">    </span><br><span class="line">    public static void n() &#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void m() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    publics static void main(String[] args) &#123;</span><br><span class="line">        for(int j=0; j&lt;1000_000; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</span><br></pre></td></tr></table></figure>
<ul>
<li>C1 Compile Level 1 (一级优化)</li>
<li>C2 Compile Level 2 (二级优化)</li>
</ul>
<blockquote>
<p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-为什么禁止把SimpleDateFormat定义成static变量?</title>
    <url>/wiki/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E6%88%90static%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文参照 《Java技术灵魂15问》</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在日常开发中，我们经常会用到时间，我们有很多办法在 Java 代码中获取时 间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工 具，把时间显示成我们需要的格式。</p>
<p>最常用的方法就是使用 SimpleDateFormat 类。这是一个看上去功能比较简单 的类，但是，一旦使用不当也有可能导致很大的问题。<br>在 Java 开发手册中，有如下明确规定:</p>
<img src="https://oscimg.oschina.net/oscnet/up-8b016ecefbdfc6ea675aaf7f2a0511bbc6a.png">

<p>那么，本文就围绕 SimpleDateFormat 的用法、原理等来深入分析下如何以正 确的姿势使用它。</p>
<p>SimpleDateFormat 是 Java 提供的一个格式化和解析日期的工具类。它允许进 行格式化(日期 -&gt; 文本)、解析(文本 -&gt; 日期)和规范化。SimpleDateFormat 使 得可以选择任何用户定义的日期 - 时间格式的模式。</p>
<p>在 Java 中，可以使用 SimpleDateFormat 的 format 方法，将一个 Date 类型 转化成 String 类型，并且可以指定输出格式。</p>
<h2 id="SimpleDateFormat-用法"><a href="#SimpleDateFormat-用法" class="headerlink" title="SimpleDateFormat 用法"></a>SimpleDateFormat 用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Date转String</span></span><br><span class="line">Date data = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String dataStr = sdf.format(data);</span><br><span class="line">System.out.println(dataStr);</span><br></pre></td></tr></table></figure>

<p>以上代码，转换的结果是:2018-11-25 13:00:00，日期和时间格式由”日期 和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就 行了。</p>
<p>在 Java 中，可以使用 SimpleDateFormat 的 parse 方法，将一个 String 类型 转化成 Date 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String转Data </span></span><br><span class="line">System.out.println(sdf.parse(dataStr));</span><br></pre></td></tr></table></figure>


<h2 id="日期和时间模式表达方法"><a href="#日期和时间模式表达方法" class="headerlink" title="日期和时间模式表达方法"></a>日期和时间模式表达方法</h2><p>在使用 SimpleDateFormat 的时候，需要通过字母来描述时间元素，并组装成 想要的日期和时间模式。常用的时间元素和字母的对应表如下:</p>
<img src='https://oscimg.oschina.net/oscnet/up-80bd4dd81e9c6fb2f0fe9c3b5eae1cef2b8.png'>

<p>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表 示方法。</p>
<img src="https://oscimg.oschina.net/oscnet/up-0c95fadb15ae4ca6aedb2e8cb68ce7ec50b.png">


<h2 id="输出不同时区的时间"><a href="#输出不同时区的时间" class="headerlink" title="输出不同时区的时间"></a>输出不同时区的时间</h2><p>时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置(时 角)决定时间，这就使得不同经度的地方的时间有所不同(地方时)。1863 年，首次 使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p>
<p>世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日 出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p>
<p>现今全球共分为 24 个时区。由于实用上常常 1 个国家，或 1 个省份同时跨着 2 个或更多时区，为了照顾到行政上的方便，常将 1 个国家或 1 个省份划在一起。所以 时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差 不多跨 5 个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间 为准。</p>
<p>由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一 样，所以，在 Java 中想要获取时间的时候，要重点关注一下时区问题。<br>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获取中国的当前 时间的原因。</p>
<p>那么，如何在 Java 代码中获取不同时区的时间呢? SimpleDateFormat 可以 实现这个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>)); </span><br><span class="line">System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br></pre></td></tr></table></figure>

<p>以上代码，转换的结果是:2018-11-24 21:00:00 。既中国的时间是 11 月 25 日的 13 点，而美国洛杉矶时间比中国北京时间慢了 16 个小时(这还和冬夏令时有关 系，就不详细展开了)。</p>
<p>如果你感兴趣，你还可以尝试打印一下美国纽约时间(America/New_York)。 纽约时间是 2018-11-25 00:00:00。纽约时间比中国北京时间早了 13 个小时。</p>
<p>当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍 SimpleDate-Format，其他方法暂不介绍了。</p>
<h2 id="SimpleDateFormat-线程安全性"><a href="#SimpleDateFormat-线程安全性" class="headerlink" title="SimpleDateFormat 线程安全性"></a>SimpleDateFormat 线程安全性</h2><p>由于 SimpleDateFormat 比较常用，而且在一般情况下，一个应用中的时间显 示模式都是一样的，所以很多人愿意使用如下方式定义 SimpleDateFormat:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            simpleDateFormat.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">            System.out.println(simpleDateFormat.format(Calendar.getInstance().</span><br><span class="line">                    getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ 这种定义方式，存在很大的安全隐患。</p>
<p>我们来看一段代码，以下代码使用线程池来执行时间输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个全局的SimpleDateFormat</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用ThreadFactoryBuilder定义一个线程池</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">                ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个线程安全的 HashSet</span></span><br><span class="line">            Set&lt;String&gt; dates = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取当前时间</span></span><br><span class="line">                Calendar calendar = Calendar.getInstance();</span><br><span class="line">                <span class="keyword">int</span> finalI = i;</span><br><span class="line">                pool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 时间增加</span></span><br><span class="line">                    calendar.add(Calendar.DATE, finalI);</span><br><span class="line">        <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                    String dateString = simpleDateFormat.format(calendar.</span><br><span class="line">                            getTime());</span><br><span class="line">                    <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                    dates.add(dateString); </span><br><span class="line">                    <span class="comment">//countDown countDownLatch.countDown();</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞，直到 countDown 数量为 0 countDownLatch.await();</span></span><br><span class="line">        <span class="comment">// 输出去重后的时间个数 System.out.println(dates.size());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>以上代码，其实比较简单，很容易理解。就是循环一百次，每次循环的时候都在 当前时间基础上增加一个天数(这个天数随着循环次数而变化)，然后把所有日期放入 一个线程安全的、带有去重功能的 Set 中，然后输出 Set 中元素个数。</p>
<p>正常情况下，以上代码输出结果应该是 100。但是实际执行结果是一个小于 100 的数字。</p>
<p>原因就是因为 SimpleDateFormat 作为一个非线程安全的类，被当做了共享变 量在多个线程中进行使用，这就出现了线程安全问题。</p>
<h2 id="线程不安全原因"><a href="#线程不安全原因" class="headerlink" title="线程不安全原因"></a>线程不安全原因</h2><p>通过以上代码，我们发现了在并发场景中使用 SimpleDateFormat 会有线程安 全问题。其实，JDK 文档中已经明确表明了 SimpleDateFormat 不应该用在多线程 场景中:</p>
<blockquote>
<p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</blockquote>
<p>那么接下来分析下为什么会出现这种问题，SimpleDateFormat 底层到底是怎 么实现的?<br>我们跟一下 SimpleDateFormat 类中 format 方法的实现其实就能发现端倪。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from Format after creating a FieldDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="params"><span class="function">                                FieldDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Convert input date to time field list</span></span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = compiledPattern[i] &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> count = compiledPattern[i++] &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">255</span>) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                toAppendTo.append((<span class="keyword">char</span>)count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_CHARS:</span><br><span class="line">                toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">                i += count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SimpleDateFormat 中的 format 方法在执行过程中，会使用一个成员变量 calendar 来保存时间。这其实就是问题的关键。</p>
<p>由于我们在声明 SimpleDateFormat 的时候，使用的是 static 定义的。那么 这 个 SimpleDateFormat就是一个共享变量， 随 之，SimpleDateFormat 中 的 calendar 也就可以被多个线程访问到。</p>
<p>假设线程 1 刚刚执行完 calendar.setTime 把时间设置成 2018-11-11，还 没等执行完，线程 2 又执行了 calendar.setTime 把时间改成了 2018-12-12。 这时候线程 1 继续往下执行，拿到的 calendar.getTime 得到的时间就是线程 2 改 过之后的。</p>
<p>除了 format 方法以外，SimpleDateFormat 的 parse 方法也有同样的问题。 所以，不要把 SimpleDateFormat 作为一个共享变量使用。</p>
<h2 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="headerlink" title="如何解决线程安全问题"></a>如何解决线程安全问题</h2><ul>
<li>使用局部变量<br> 不要使用static</li>
<li>加同步锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// 获取当前时间</span></span><br><span class="line">           Calendar calendar = Calendar.getInstance();</span><br><span class="line">           <span class="keyword">int</span> finalI = i;</span><br><span class="line">           pool.execute(() -&gt; &#123;</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                   <span class="comment">// 时间增加</span></span><br><span class="line">                   calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                   <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                   String dateString = simpleDateFormat.format(calendar.getTime()); <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                   dates.add(dateString);</span><br><span class="line">                   <span class="comment">//countDown</span></span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以 只对 simpleDateFormat.format 这一行加锁，这样效率更高一些。</p>
<ul>
<li>使用 ThreadLocal<br> 第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以 得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 使用ThreadLocal定义一个全局的SimpleDateFormat */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 用法</span></span><br><span class="line">       String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure>

<p>用 ThreadLocal 来实现其实是有点类似于缓存的思路，每个线程都有一个独享 的对象，避免了频繁创建对象，也避免了多线程的竞争。</p>
<p>当然，以上代码也有改进空间，就是，其实 SimpleDateFormat 的创建过程可 以改为延迟加载。这里就不详细介绍了。</p>
<h2 id="使用-DateTimeFormatter"><a href="#使用-DateTimeFormatter" class="headerlink" title="使用 DateTimeFormatter"></a>使用 DateTimeFormatter</h2><p>如果是 Java8 应用，可以使用 DateTimeFormatter 代替 SimpleDateFormat， 这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析日期</span></span><br><span class="line">String dateStr = <span class="string">&quot;2016年10月25日&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">LocalDate date = LocalDate.parse(dateStr, formatter);</span><br><span class="line"><span class="comment">// 日期转换为字符串</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 hh:mm a&quot;</span>);</span><br><span class="line">String nowStr = now.format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本 文 介 绍 了 SimpleDateFormat 的 用 法，SimpleDateFormat 主 要 可 以 在 String 和 Date 之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场 景中 SimpleDateFormat 是不能保证线程安全的，需要开发者自己来保证其安全性。</p>
<p>主要的几个手段有改为局部变量、使用 synchronized 加锁、使用 Threadlocal 为每一个线程单独创建一个等。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-传统的BIO</title>
    <url>/wiki/Java-%E4%BC%A0%E7%BB%9F%E7%9A%84BIO/</url>
    <content><![CDATA[<h1 id="传统的BIO"><a href="#传统的BIO" class="headerlink" title="传统的BIO"></a>传统的BIO</h1><h2 id="Socket-和-ServerSocket"><a href="#Socket-和-ServerSocket" class="headerlink" title="Socket 和 ServerSocket"></a>Socket 和 ServerSocket</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">       <span class="comment">// 阻塞</span></span><br><span class="line">       Socket client = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">       InputStream inputStream = client.getInputStream();</span><br><span class="line"></span><br><span class="line">       BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">       <span class="comment">// 读阻塞</span></span><br><span class="line">       System.err.println(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>new ServerSocket(9090);</p>
</blockquote>
<p>这个java程序创建new ServerSocket(9090);会调用操作系统内核，也就是系统调用，<br>比如linux操作系统，应用进程也就是我们的java进程，会调用linux的内核方法，创建一个socket，在linux系统中就是一个文件描述符fd，最终对得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket() = XXfd</span><br><span class="line">bind(XXfd,9090)</span><br><span class="line">listen(XXfd)</span><br></pre></td></tr></table></figure>

<p><img src="https://sjwx.easydoc.xyz/47754217/files/kn1ecf3d.png" alt="image.png"></p>
<ul>
<li>socket 的read方法 ，读取客户端发送的数据，如果没有，则一直阻塞</li>
<li>serverSocket的accept方法，等待客户端的链接，如果没有链接，则一直阻塞等待</li>
<li>serverSocket 一次只能处理一个客户端请求</li>
</ul>
<h2 id="BIO程序有哪些弊端？"><a href="#BIO程序有哪些弊端？" class="headerlink" title="BIO程序有哪些弊端？"></a>BIO程序有哪些弊端？</h2><ul>
<li>服务端一次处理一个请求，并发非常低</li>
<li>没有客户端请求，服务端一直阻塞，占用资源</li>
</ul>
<h2 id="如果在bio的基础上，利用多线程处理客户端请求？"><a href="#如果在bio的基础上，利用多线程处理客户端请求？" class="headerlink" title="如果在bio的基础上，利用多线程处理客户端请求？"></a>如果在bio的基础上，利用多线程处理客户端请求？</h2><blockquote>
<p>d C10K问题 </p>
</blockquote>
<p><font color=red>来一个链接，服务端创建一个线程</font> ，去处理请求，服务端继续监听客户端，是不是可以增加并发？<br>有什么问题？</p>
<ul>
<li>线程消耗内存资源</li>
</ul>
<p>如果一下子过来10万个请求呢？<br>服务器要创建10万个线程，内存就崩了。</p>
<p>如果搞一个线程池呢？ 并发度最大为最大线程数？ 并发度已经定死了？</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-锁升级过程</title>
    <url>/wiki/Java-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><h2 id="使用JOL查看加锁之后的对象信息"><a href="#使用JOL查看加锁之后的对象信息" class="headerlink" title="使用JOL查看加锁之后的对象信息"></a>使用JOL查看加锁之后的对象信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           f0 b8 d0 <span class="number">0f</span> (<span class="number">11110000</span> <span class="number">10111000</span> <span class="number">11010000</span> <span class="number">00001111</span>) (<span class="number">265337072</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">70</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">01110000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">28672</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>


<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><blockquote>
<p>锁升级过程： new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-2f555289640d34755ca4288ab080906554b.png" width=750 height=450> 

<p><strong>自旋锁什么时候升级为重量级锁？</strong></p>
<p>超过自选次数仍没有获得锁</p>
<p><strong>为什么有自旋锁还需要重量级锁？</strong></p>
<blockquote>
<p>自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗<br>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p>
</blockquote>
<p><strong>偏向锁是否一定比自旋锁效率高？</strong></p>
<blockquote>
<p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁<br>JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开</p>
</blockquote>
<h3 id="synchronized优化的过程和markword息息相关"><a href="#synchronized优化的过程和markword息息相关" class="headerlink" title="synchronized优化的过程和markword息息相关"></a>synchronized优化的过程和markword息息相关</h3><p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p>
<ol>
<li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p>
</li>
<li><p>o.hashCode()<br>001 + hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>little endian big endian </p>
<p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p>
</li>
<li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure></li>
<li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p>
</li>
<li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p>
</li>
<li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p>
</li>
<li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
</li>
</ol>
<p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)<br>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p>
<p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p>
<blockquote>
<p><strong>轻量级锁重量级锁的hashCode存在与什么地方？</strong><br>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
</blockquote>
<p>关于epoch: (不重要)</p>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<p>没错，我就是厕所所长</p>
<p>加锁，指的是锁定对象</p>
<h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><blockquote>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
</blockquote>
<p>现代版本进行了优化</p>
<blockquote>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
</blockquote>
<p>1、偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>2、有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>3、自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>4、自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>5、偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-锁消除和锁膨胀</title>
    <url>/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/</url>
    <content><![CDATA[<h1 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h1><h2 id="锁消除-（lock-eliminate）"><a href="#锁消除-（lock-eliminate）" class="headerlink" title="锁消除 （lock eliminate）"></a>锁消除 （lock eliminate）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h2 id="锁粗化-（lock-coarsening）"><a href="#锁粗化-（lock-coarsening）" class="headerlink" title="锁粗化 （lock coarsening）"></a>锁粗化 （lock coarsening）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p><a href="https://www.zhihu.com/question/63859501">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM?"></a>什么是JMM?</h2><p>Java Memory Model简称JMM, 是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。(可能在术语上与Java运行时内存分布有歧义，后者指堆、方法区、线程栈等内存区域)。</p>
<p> <strong>JMM规范的内容</strong>  </p>
<ul>
<li>所有变量存储在主内存  </li>
<li>主内存是虚拟机内存的一部分</li>
<li>每条线程有自己的工作内存</li>
<li>线程的工作内存保存变量的主内存副本</li>
<li>线程对变量的操作必须在工作内存中进行</li>
<li>不同线程之间无法直接访问对方工作内存中的变量</li>
<li>线程间变量值的传递均需要通过主内存来完成</li>
</ul>
<p>JMM并不是一个客观存在的东西，它实际是为了<strong>规范Java虚拟机制定到一套标准</strong>。那为什么需要这套标准呢？ </p>
<p>其实我们都知道JVM是运行在操作系统之上的。而目前的操作系统都是基于冯诺伊曼设置的计算机系统体系来的。CPU是计算机中用来执行控制和计算的核心组件。</p>
<p>所有的计算任务全部在CPU中完成，但是我们的所有变量的数据全部存储在主内存中。CPU在执行计算时，需要去主内存加载数据，CPU执行运算的速度极快，这就设计一个CPU执行速度和数据加载速度不一致的问题。   </p>
<img src= "https://user-gold-cdn.xitu.io/2018/2/7/1616dcd4cfc4f98c?imageView2/0/w/1280/h/960/ignore-error/1" width = "300" height = "400" align=center />

<p> 在操作系统级别解决这个问题的办法是引入了CPU缓存。每个CPU都有自己私有的L1缓存和L2缓存，当执行计算时，会优先去CPU自己的缓存中寻找数据，没有的话才会重新加载内存数据。这种方式一定程度上解决了CPU计算和数据加载不一致的问题。    </p>
<p><strong>但是也会引入一个新的问题，就是数据一致性问题。</strong>  </p>
<h2 id="缓存一致性与MESI协议"><a href="#缓存一致性与MESI协议" class="headerlink" title="缓存一致性与MESI协议"></a>缓存一致性与MESI协议</h2><blockquote>
<p>首先看一下什么是MESI协议</p>
</blockquote>
<p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），<br>用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p>
<ul>
<li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li>
<li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li>
<li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li>
<li>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729160558598.png" alt="image-20210729160558598" style="zoom:40%;" />      

<p>如何解决缓存一致性问题呢？</p>
<p>如上图所示，共享变量是存储在主内存Memory中，在CPU计算时，每一个CPU都有改变量的独立拷贝，每个CPU可以去读取甚至修改共享变量的值，但是为了保证数据的一致性，一个CPU modify了变量的值，需要通知其他的CPU这个变量的最新值是什么。那么可以怎么做呢。</p>
<p>1、在初始状态，每个CPU还没有加载共享变量，所有每一个CPU的缓存行的状态都是invalid；  </p>
<p>2、当CPU0去使用这个共享变量的时候，首先去自己的缓存中查找，肯定是缓存不命中的，也就是cache miss,这个时候去主内存Memory中去加载，当共享变量的值加载到CPU0的缓存后，CPU缓存行状态变成shared,  也就是共享状态；  </p>
<p>3、如果这个时候有其他的CPU也读取了共享变量的值，它们的cache line 的状态同样也是shared共享状态；此时一个CPU如果修改共享变量的值，而没有通知其他的CPU,就会造成缓存一致性问题；</p>
<p>4、当CPU0尝试去修改共享变量的值时，它会发出一个read invalidate命令，同时CPU0的缓存行状态设置为exclusive(独占),同时将其他加载了这个共享变量的cacheline的状态设置为invalid。通俗一点就是CPU0独占的这个变量的缓存行，其他的CPU缓存的共享变量都失效了； </p>
<p>5、CPU0接下来修改共享变量的值，它会将cacheline的状态修改为modified,其实也是独占共享变量的cacheline，<br>只不过是此时缓存行的数据和主内存Memory的数据不一致的，而exclusive虽然也是独占状态，但是共享变量的值是一样的，modified的值需要write back到Memory中去的，而exclusive是不需要的； </p>
<p>6、在cacheline没有替换出CPU0的cache之前，当有其他CPU来读取共享变量，此时肯定是cache miss ,因为CPU0的modify操作已经将它的缓存失效了。如果CPU0的状态是modified状态，它必须响应其他CPU的读操作，会告知其他CPU主内存的数据是dirty data。所以其他的CPU的状态可能会变成shared。如果CPU0还没有write back操作，其他的CPU状态还是invalid状态。</p>
<h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>正如上面所描述的，在CPU0进行共享变量的修改，会同步修改其他CPU的cacheline状态为invalid，这个操作是和共享变量的写操作同步进行的，因此共享变量的写操作的性能是非常差的。在修改其他的CPU cacheline状态时，CPU0其实是处于阻塞状态的。所以为了优化这个问题，提出了Store Buffer的解决方案。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729161714758.png" alt="image-20210729161714758" style="zoom:33%;" />

<p>这样的话，写操作不必等到cacheline被加载，而是直接写到store buffer中，然后去执行后续的操作。由于是store buffer相当于是异步处理，在这里可能会出现因为并发执行导致的执行执行交叉问题，具体解决方法是依赖于内存屏障。  </p>
<p>具体可以参考这篇文章：<a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html">Linux内核同步机制之（三）：memory barrier</a>  </p>
<h3 id="Invalidate-Queue"><a href="#Invalidate-Queue" class="headerlink" title="Invalidate Queue"></a>Invalidate Queue</h3><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。为了解决上面两个问题，引进了失效队列（invalidate queue）。</p>
<p>处理失效的工作如下：</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729161824400.png" alt="image-20210729161824400" style="zoom:33%;" />


<ul>
<li>收到失效消息时，放到失效队列中去。</li>
<li>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。</li>
<li>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</li>
</ul>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens- before原则"></a>happens- before原则</h2><blockquote>
<p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：    </p>
</blockquote>
<p>1、单线程每个操作，happen-before于该线程中任意后续操作；<br>2、volatile写happen-before与后续对这个变量的读；<br>3、synchronized解锁happen-before后续对这个锁的加锁；<br>4、final变量的写happen-before于final域对象的读，happen-before后续对final变量的读；<br>5、传递性规则，A先于B，B先于C，那么A一定先于C发生；  </p>
<blockquote>
<p><a href="https://www.processon.com/view/5c8b0978e4b0c996d363dcbc?fromnew=1">https://www.processon.com/view/5c8b0978e4b0c996d363dcbc?fromnew=1</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <url>/wiki/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<h2 id="ThreadLocalMap结构"><a href="#ThreadLocalMap结构" class="headerlink" title="ThreadLocalMap结构"></a>ThreadLocalMap结构</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b45487065b90?imageView2/0/w/1280/h/960/ignore-error/1'>




<h2 id="ThreadLocal-set流程"><a href="#ThreadLocal-set流程" class="headerlink" title="ThreadLocal set流程"></a>ThreadLocal set流程</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b454879fe57d?imageView2/0/w/1280/h/960/ignore-error/1'>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://juejin.cn/post/6854573219916021767">Java面试必问：ThreadLocal终极篇 </a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/wiki/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><blockquote>
<p>反向探知，在程序运行是动态的获取类的相关属性<br>这种动态获取类的内容以及动态调用对象的方法和获取属性的机制，叫做java反射机制；</p>
</blockquote>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><blockquote>
<p>优点<br>增加了程序的灵活性，避免的固有逻辑写死到程序中<br>代码简介，提高程序的复用性</p>
</blockquote>
<blockquote>
<p>缺点<br>相比于直接调用，反射有比较大的性能消耗<br>内部暴露和安全隐患  （因为反射可以操作private成员变量和调用private成员方法）</p>
</blockquote>
<h3 id="反射的基本操作"><a href="#反射的基本操作" class="headerlink" title="反射的基本操作"></a>反射的基本操作</h3><h4 id="获取类对象的4种方式"><a href="#获取类对象的4种方式" class="headerlink" title="获取类对象的4种方式"></a>获取类对象的4种方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用forName方法得到一个对象，这也是最容易想到的方式</span><br><span class="line">Class&lt;?&gt; object = Class.forName(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">// 通过实例对象调用getClass方法</span><br><span class="line">Teacher teacher = new Teacher();</span><br><span class="line">Class&lt;?&gt; objectT = teacher.getClass();</span><br><span class="line"></span><br><span class="line">// 通过类加载器的方式</span><br><span class="line">Class&lt;?&gt; loader = ClassLoader.getSystemClassLoader().loadClass(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">//通过一个类.class</span><br><span class="line">Class&lt;?&gt; tt = Teacher.class;</span><br></pre></td></tr></table></figure>

<h4 id="基本信息操作"><a href="#基本信息操作" class="headerlink" title="基本信息操作"></a>基本信息操作</h4><table>
<thead>
<tr>
<th align="center">类修饰符</th>
<th align="center">PUBLIC</th>
<th align="center">PRIVATE</th>
<th align="center">PROTECTED</th>
<th align="center">STATIC</th>
<th align="center">FINAL</th>
<th align="center">SYNCHRONIZED</th>
<th align="center">VOLATILE</th>
<th align="center">TRANSIENT</th>
<th align="center">NATIVE</th>
<th align="center">INTERFACE</th>
<th align="center">ABSTRACT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">modifiers</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">128</td>
<td align="center">256</td>
<td align="center">512</td>
<td align="center">1024</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类的修饰符 具体的值可以参考JDK API文档中的定义 返回值是int类型  public：1</span><br><span class="line">System.err.println(tt.getModifiers());</span><br><span class="line">// 包名</span><br><span class="line">System.err.println(tt.getPackage());</span><br><span class="line">// 类的名称</span><br><span class="line">System.err.println(tt.getName());</span><br><span class="line">// 父类</span><br><span class="line">System.err.println(tt.getSuperclass());</span><br><span class="line">// 类加载器</span><br><span class="line">System.err.println(tt.getClassLoader());</span><br><span class="line">// 简称</span><br><span class="line">System.err.println(tt.getSimpleName());</span><br><span class="line">// 类实现的所有的接口</span><br><span class="line">System.err.println(tt.getInterfaces().length);</span><br><span class="line">// 所有的注解类型</span><br><span class="line">System.err.println(tt.getAnnotations().length);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">package com.ibli.javaBase.reflection</span><br><span class="line">com.ibli.javaBase.reflection.Teacher</span><br><span class="line">class java.lang.Object</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Teacher</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h4 id="查看类的变量"><a href="#查看类的变量" class="headerlink" title="查看类的变量"></a>查看类的变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// User extend Person(aa,bb)</span><br><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 能够拿到类的所有的变量</span><br><span class="line">Field[] fields = obj.getDeclaredFields();</span><br><span class="line">for (Field field : fields)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;    &quot;);</span><br><span class="line"></span><br><span class="line">// 只能够拿到类的public的变量</span><br><span class="line">Field[] fields1 = obj.getFields();</span><br><span class="line">for (Field field : fields1)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;     &quot;);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 age</span><br><span class="line">2 name</span><br><span class="line">1 sex</span><br><span class="line">10 height</span><br><span class="line">    </span><br><span class="line">1 sex</span><br><span class="line">1 aa</span><br><span class="line">1 bb</span><br></pre></td></tr></table></figure>
<p>结论：  </p>
<ul>
<li>getDeclaredFields<br>（1）getDeclaredFields能够获取本类的所有成员变量，无论是public还是private;<br>（2）但是不能获取父类的任何属性；<br>（3）可以获取static类型的属性；</li>
<li>getFields<br>（1）只能够获取本类的public属性；<br>（2）能够获取父类的public属性；<br>（3）可以获取static类型的属性；  </li>
</ul>
<h4 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置Person中的变量aa</span><br><span class="line">Field aaField = obj.getField(&quot;aa&quot;);</span><br><span class="line">aaField.setInt(user,111);</span><br><span class="line">System.err.println(user.getAa());</span><br><span class="line"></span><br><span class="line">// 设置User私有成员变量</span><br><span class="line">Field ageField = obj.getDeclaredField(&quot;age&quot;);</span><br><span class="line">// 设置访问权限</span><br><span class="line">ageField.setAccessible(true);</span><br><span class="line">ageField.set(user,333);</span><br><span class="line">System.err.println(user.getAge());</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111</span><br><span class="line">333</span><br></pre></td></tr></table></figure>


<h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line"></span><br><span class="line">// 可以获取父类的方法</span><br><span class="line">Method[] methods = obj.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; -----  &quot;);</span><br><span class="line"></span><br><span class="line">// 获取本类中的所有方法</span><br><span class="line">Method[] methods1 = obj.getDeclaredMethods();</span><br><span class="line">for (Method method : methods1) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; 。。。。。。 &quot;);</span><br><span class="line">// 执行结果就不展示了</span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li>getDeclaredMethods<br>（1）可以获取本类中的所有方法；<br>（2）可以获取本类的静态方法</li>
<li>getMethods<br>（1）可以获取本类中的所有==公有==方法；<br>（2）可以获取父类中的所有==公有==方法；<br>（3）可以获取本类和父类的公有静态方法；</li>
</ul>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 访问私有方法</span><br><span class="line">Method sleep = obj.getDeclaredMethod(&quot;sleep&quot;);</span><br><span class="line">sleep.setAccessible(true);</span><br><span class="line">sleep.invoke(user);</span><br><span class="line"></span><br><span class="line">// 如果是静态方法，invoke第一个参数传null即可</span><br><span class="line">Method say = obj.getDeclaredMethod(&quot;say&quot;,String.class);</span><br><span class="line">say.setAccessible(true);</span><br><span class="line">say.invoke(null,&quot;hello java&quot;);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Im sleeping!</span><br><span class="line">say hello java</span><br></pre></td></tr></table></figure>


<h4 id="构造器的使用"><a href="#构造器的使用" class="headerlink" title="构造器的使用"></a>构造器的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">// 查询共有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors = obj.getConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors)&#123;</span><br><span class="line">    System.out.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以获取私有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors1 = obj.getDeclaredConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors1)&#123;</span><br><span class="line">    System.err.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line"></span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">2   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>getConstructors<br>（1）获得本类所有的公有构造器  </li>
<li>getDeclaredConstructors<br>（1）获得本类所有的构造器（public&amp;private）  </li>
</ul>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用newInstance创建对象 调用无参构造器</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 获取构造器来实例化对象</span><br><span class="line">Constructor&lt;User&gt; constructor = obj.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">User temp = constructor.newInstance(22, &quot;java&quot;);</span><br><span class="line">System.err.println(temp.getAge() + &quot; &quot; + temp.getName());</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>22 java</p>
</blockquote>
<h3 id="反射性能为什么差"><a href="#反射性能为什么差" class="headerlink" title="反射性能为什么差"></a>反射性能为什么差</h3><blockquote>
<p>可以从两方面考虑，第一个是反射生成Class对象时性能差，第二是通过反射调用对象方式是的性能差；</p>
</blockquote>
<p>（1） 调用forName 本地方法<br>（2）每次newInstance 都会进行一次安全检查<br>（3）在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p>
<p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的Object数组   </li>
<li>基本类型的自动装箱、拆箱  (参考资料2)</li>
<li>还有最重要的方法内联。</li>
</ul>
<blockquote>
<p>参考资料<br>(1)<a href="https://blog.csdn.net/xqlovetyj/article/details/82798864">反射为什么慢</a><br>(2)<a href="https://blog.csdn.net/Admin_Jhon/article/details/52873468?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf">关于装箱拆箱为什么会影响效率</a><br>(3)<a href="https://zhuanlan.zhihu.com/p/55630861">jvm之方法内联优化</a></p>
</blockquote>
<h3 id="反射使用的场景"><a href="#反射使用的场景" class="headerlink" title="反射使用的场景"></a>反射使用的场景</h3><ul>
<li>JDBC封装    </li>
<li>Spring IOC</li>
<li>jdbcTemplate</li>
<li>Mybatis使用大量反射</li>
</ul>
<h3 id="使用反射注意点"><a href="#使用反射注意点" class="headerlink" title="使用反射注意点"></a>使用反射注意点</h3><ul>
<li>在获取Field,method,construtor的时候，应尽量避免是用getDelcaredXXX(),应该传进参数获取指定的字段，方法和构造器；</li>
<li>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的</li>
</ul>
<blockquote>
<p align="middle"> ---------------------   前途浩浩荡荡 万事尽可期待。-----------------------  </p>
</blockquote>
<h3 id="反射在IOC中的应用"><a href="#反射在IOC中的应用" class="headerlink" title="反射在IOC中的应用"></a>反射在IOC中的应用</h3>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象头</title>
    <url>/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><h2 id="JOL查看对象头信息"><a href="#JOL查看对象头信息" class="headerlink" title="JOL查看对象头信息"></a>JOL查看对象头信息</h2><p>在项目中引入以下依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>写一个main方法，创建一个Object，然后打印对象信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>由此可知，new Object()在内存中占16个字节，组成部分8字节的markword+4字节的class point+4字节的对齐；</p>
<h2 id="Java对象在内存中的布局"><a href="#Java对象在内存中的布局" class="headerlink" title="Java对象在内存中的布局"></a>Java对象在内存中的布局</h2><image src="https://oscimg.oschina.net/oscnet/up-056ef14e62f5dfde1a5af579dabeb6e4c2a.png" width=250 height=420>

<ul>
<li>markword<blockquote>
<p>存储sync锁标志，分代年龄等一些关键信息 8字节</p>
</blockquote>
</li>
<li>class pointer<blockquote>
<p>指向当前对象所属类类型 4字节</p>
</blockquote>
</li>
</ul>
<p><strong>查看java命令默认带的参数命令：</strong> java -XX:+PrintCommandLineFlags -version </p>
<blockquote>
<p>-XX:InitialHeapSize=134217728<br>-XX:MaxHeapSize=2147483648<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers 压缩类指针 4字节<br>-XX:+UseCompressedOops 普通对象指针压缩 4字节<br>-XX:+UseParallelGC</p>
</blockquote>
<ul>
<li>instance data<blockquote>
<p>寸尺当前对象的实例数据</p>
</blockquote>
</li>
<li>padding<blockquote>
<p>对齐填充，当对象所占字节数不能被8整除之后，进行填充对齐。 目前的操作系统基本上都是64位的；</p>
</blockquote>
</li>
</ul>
<h2 id="顺丰面试题，new-Object-在内存中占多少个字节"><a href="#顺丰面试题，new-Object-在内存中占多少个字节" class="headerlink" title="顺丰面试题，new Object()在内存中占多少个字节"></a>顺丰面试题，new Object()在内存中占多少个字节</h2><p>1、如果创建的是空对象，没有实例数据</p>
<ul>
<li>默认开启了class pointer指针压缩<blockquote>
<p>8字节markword + 4字节class pointer + 4字节 padding</p>
</blockquote>
</li>
<li>如果关闭了类指针压缩<blockquote>
<p>8字节markword + 8字节class pointer</p>
</blockquote>
</li>
</ul>
<p>2、如果创建的对象有实力数据，如下对象：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person（int age , String name）</span><br></pre></td></tr></table></figure></p>
<ul>
<li>默认开启了class pointer指针压缩<blockquote>
<p>8字节markword + 4字节class pointer + 4字节int + 4字节String + 4字节padding对齐</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-多线程的发展和意义</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<h1 id="线程基础概念"><a href="#线程基础概念" class="headerlink" title="线程基础概念"></a>线程基础概念</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是CPU执行任务的基本单位，一个进程中包含一个或者多个线程，一个进程内的多个线程共享进程的资源，每一个线程有自己的独立内存，是线程不共享的。</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><ul>
<li>并行<br> 同一时刻，横向有多少个线程可以运行</li>
<li>并发<br> 系统和服务器同一时刻能够承受的并发线程</li>
</ul>
<h2 id="线程的特征"><a href="#线程的特征" class="headerlink" title="线程的特征"></a>线程的特征</h2><ul>
<li>异步（不需要等待）<br> 比如说注册之后发送验证码，验证码的过程可以异步去做不需要客户去在注册接口等待这个时间；</li>
<li>并行（CPU核数）   </li>
</ul>
<h2 id="Java中线程的使用"><a href="#Java中线程的使用" class="headerlink" title="Java中线程的使用"></a>Java中线程的使用</h2><ul>
<li>继承Thread</li>
<li>实现Runnalbe</li>
<li>实现Callable/Future</li>
</ul>
<h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="title">extend</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">      b = a + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行start方法，其实是调用JVM相关的指令， thread.cpp</p>
<blockquote>
<p>java thread.start() -&gt; cpp thread.start() -&gt; os指令:create.thread    start.thread<br>操作系统层面会创建线程，线程创建之后，线程可以启动，（线程启动之后并不一定马上执行）这些线程统一有CPU调度算法来处理；决定那个线程分配给那个执行CPU；<br>CPU执行线程任务的时候，会调用run方法 -&gt; cpp run方法  -&gt; java  thread.run()</p>
</blockquote>
<img src='https://oscimg.oschina.net/oscnet/up-9147a0440e839bc9946fc87147e97b7c793.png' whith=600 height=380>

<p>⚠️ CompletableFuture 异步回调通知，基于Future的优化 </p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程创建，当线程中的指令执行完成之后，run（）结束 线程销毁<br>其他线程状态</p>
<ul>
<li>等待状态 （sleep join wait）</li>
<li>锁阻塞状态 （blocked 竞争锁失败 park）</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-dc87c94066283689df31680050c67edd7b1.png" width=500 height=450>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStatusDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;time waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStatusDemo.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ThreadStatusDemo.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BlockDemo.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>查看线程状态</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<h2 id="线程如何停止"><a href="#线程如何停止" class="headerlink" title="线程如何停止"></a>线程如何停止</h2><p>interrupt() 停止线程<br>主动停止方式 -&gt; run方法执行结束<br>被动停止方式</p>
<p>一般中断线程是在无法控制线程的情况下，比如线程wait ， 线程sleep ， 线程while(true)<br><code>Thread.currnetThread().isInterrupted()</code></p>
<blockquote>
<p>stop方法停止线程 禁止使用 相当于kill线程 不友好</p>
</blockquote>
<p>interrupt 功能</p>
<ul>
<li>唤醒阻塞状态的线程</li>
<li>修改中断标志，false -&gt; true</li>
</ul>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-深入理解volatile</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/</url>
    <content><![CDATA[<h1 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h1><p>正确理解volatile</p>
<blockquote>
<p>多级cache结构 -&gt; 缓存一致性协议（MESI）-&gt; store buffer和invalidate queue -&gt; 内存屏障</p>
</blockquote>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>volatile的可见性依赖于Java内存模型。 可以参见之前的文章  👉 <a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></p>
<p><code>Java内存模型(JavaMemoryModel)</code>描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。</p>
<p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
<p><code>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量</code>。</p>
<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729170756502.png" alt="image-20210729170756502" style="zoom:35%;" />

<p>volatile实现可见性</p>
<p>每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写会了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。</p>
<p>volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。</p>
<p>至于其他线程是如何更新缓存行中的数据以及其他线程的缓存行是如何失效的，可以参见之前的文章。 <a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></p>
<h3 id="嗅探机制"><a href="#嗅探机制" class="headerlink" title="嗅探机制"></a>嗅探机制</h3><p>在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。</p>
<p>由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而<strong>嗅探是实现缓存一致性的常见机制</strong>。</p>
<p><strong>嗅探机制工作原理</strong>：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。</p>
<p>注意：</p>
<blockquote>
<p>基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。</p>
</blockquote>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p><strong>什么是指令重排序</strong>?</p>
<p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p>
<p>【源代码】 -&gt; 【编译器优化重排序】-&gt; 【指令集并行重排序】-&gt; 【内存系统重排序】-&gt; 【最终执行指令序列】</p>
<p>一般重排序可以分为如下三种：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li>
</ul>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。</p>
<p>为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p>
<table>
<thead>
<tr>
<th align="center"><strong>内存屏障</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">StoreStore 屏障</td>
<td align="left">禁止上面的普通写和下面的 volatile 写重排序。</td>
</tr>
<tr>
<td align="center">StoreLoad 屏障</td>
<td align="left">防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td>
</tr>
<tr>
<td align="center">LoadLoad 屏障</td>
<td align="left">禁止下面所有的普通读操作和上面的 volatile 读重排序。</td>
</tr>
<tr>
<td align="center">LoadStore 屏障</td>
<td align="left">禁止下面所有的普通写操作和上面的 volatile 读重排序。</td>
</tr>
</tbody></table>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>
<p><strong>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</strong></p>
<h3 id="volatile在DCL的应用"><a href="#volatile在DCL的应用" class="headerlink" title="volatile在DCL的应用"></a>volatile在DCL的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>
<h3 id="一次性安全发布"><a href="#一次性安全发布" class="headerlink" title="一次性安全发布"></a>一次性安全发布</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>theFlooble</code> 引用不是 volatile 类型，<code>doWork()</code> 中的代码在解除对 <code>theFlooble</code> 的引用时，将会得到一个不完全构造的 <code>Flooble</code>。</p>
<p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>
<h2 id="无法保证原子性"><a href="#无法保证原子性" class="headerlink" title="无法保证原子性"></a>无法保证原子性</h2><p>所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p>
<p>在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 volatile 修饰的变量是<strong>线程不安全的</strong>。</p>
<p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 AtomicInteger）。</p>
<p>这里特别说一下，对任意单个使用 volatile 修饰的变量的读 / 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p>
<h1 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h1><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p>
<p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制。</p>
<p>volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</p>
<p>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</p>
<p>2、volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供<strong>原子性和互斥性</strong>。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</p>
<p>3、volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p>
<p>4、volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</p>
<p>5、volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</p>
<p>6、volatile可以使得long和double的赋值是原子的。</p>
<p>7、volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</p>
<hr>
<p><strong>参考资料</strong></p>
<p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时</a></p>
<p><a href="https://juejin.cn/post/6844903520760496141">面试官最爱的volatile关键字</a></p>
<p><a href="https://juejin.cn/post/6844903959107207175">一文吃透Volatile，征服面试官</a></p>
<p><a href="https://www.cnblogs.com/lidl/archive/2012/06/25/2561431.html">java语言的线程安全volatile用法</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Blocking Queue</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BBlocking-Queue/</url>
    <content><![CDATA[<h1 id="Blocking-Queue"><a href="#Blocking-Queue" class="headerlink" title="Blocking Queue"></a>Blocking Queue</h1><p>A blocking queue is a queue that blocks when you try to dequeue from it and the queue is empty, or if you try to enqueue items to it and the queue is already full. A thread trying to dequeue from an empty queue is blocked until some other thread inserts an item into the queue. A thread trying to enqueue an item in a full queue is blocked until some other thread makes space in the queue, either by dequeuing one or more items or clearing the queue completely.</p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210804131939043.png" alt="image-20210804131939043" style="zoom:50%;" />

<p>阻塞队列两大特性：</p>
<ul>
<li>当队列满时，如果<strong>生产者线程</strong>向队列 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出</li>
<li>当队列为空时，如果<strong>消费者线程</strong> 从队列里面 take 元素，队列会阻塞消费者线程，直到队列不为空</li>
</ul>
<p>阻塞队列最常使用在生产者和消费者模型中，生产者生产数据，将数据存放在队列中，消费者消费数据，在队列中取出数据。</p>
<p>阻塞队列在不可用时，下面是各种处理操作的结果：👇</p>
<table>
<thead>
<tr>
<th align="center">方法/处理方式</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">一直阻塞</th>
<th align="center">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入方法</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e, time,unit)</td>
</tr>
<tr>
<td align="center">移除方法</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查方法</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table>
<h3 id="add-抛出异常IllegalStateException"><a href="#add-抛出异常IllegalStateException" class="headerlink" title="add 抛出异常IllegalStateException"></a>add 抛出异常IllegalStateException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        queue.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;queue size -&gt; &quot;</span> + queue.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常信息：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Queue full</span><br><span class="line">	at java.util.AbstractQueue.add(AbstractQueue.java:<span class="number">98</span>)</span><br><span class="line">	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:<span class="number">312</span>)</span><br><span class="line">	at com.ibli.note.ArrayBlockingQueueDemo.main(ArrayBlockingQueueDemo.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<h3 id="element抛出异常NoSuchElementException"><a href="#element抛出异常NoSuchElementException" class="headerlink" title="element抛出异常NoSuchElementException"></a>element抛出异常NoSuchElementException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;queue size -&gt; &quot;</span> + queue.size());</span><br><span class="line">        queue.element();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常信息：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue size -&gt; <span class="number">0</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.NoSuchElementException</span><br><span class="line">	at java.util.AbstractQueue.element(AbstractQueue.java:<span class="number">136</span>)</span><br><span class="line">	at com.ibli.note.ArrayBlockingQueueDemo.main(ArrayBlockingQueueDemo.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>底层由数组实现的有界的阻塞队列，它的容量在创建的时候就已经确认了，并且不能修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，ArrayBlockingQueue是不保证线程公平访问队列的，这里所谓的公平与否是指，阻塞的线程能否按照阻塞的先后顺序访问队列，先阻塞先访问，后阻塞后访问。</p>
<p>思考为什么默认情况下是非公平的方式访问呢？ 🤔</p>
<blockquote>
<p>这个是为了增加系统资源利用率，在不保证公平的情况下，多线程之间之间执行的效率要比公平模式下高的多。</p>
</blockquote>
<h3 id="ArrayBlovkingQueue-put方法"><a href="#ArrayBlovkingQueue-put方法" class="headerlink" title="ArrayBlovkingQueue#put方法"></a>ArrayBlovkingQueue#put方法</h3><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210804140652447.png" alt="image-20210804140652447"></p>
<p>下面是put方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  	<span class="comment">// 加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">          	<span class="comment">// 队列满了之后，阻塞</span></span><br><span class="line">            notFull.await();</span><br><span class="line">      	<span class="comment">// 向队列中添加元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">// 执行完最后释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是添加数据的方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">  	<span class="comment">// 数据添加完之后，唤醒等待队列中的线程到同步队列</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‼️唤醒的线程能够抢到锁是不确定的，signal会添加节点到同步队列中等待获取锁。这个可以看一下Condition那篇文章。</p>
<p>ArrayBlockingQueue更多详细细节以及原理跳转链接<a href="https://www.jianshu.com/p/a636b3d83911">https://www.jianshu.com/p/a636b3d83911</a></p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性，与ArrayBlockingQueue相比起来具有更高的吞吐量，为了防止LinkedBlockingQueue容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE;</p>
<blockquote>
<p>Executors.newFixedThreadPool 阿里巴巴禁止使用Executors来创建线程池</p>
</blockquote>
<p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p>
<h3 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认大小为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue-put方法"><a href="#LinkedBlockingQueue-put方法" class="headerlink" title="LinkedBlockingQueue#put方法"></a>LinkedBlockingQueue#put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取锁中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满，如果已满阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node放入队列中</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 再次判断队列是否有可用空间，如果有唤醒下一个线程进行添加操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一条数据，唤醒消费线程进行消费</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>队列已满，阻塞等待。</li>
<li>队列未满，创建一个node节点放入队列中，如果放完以后队列还有剩余空间，继续唤醒下一个添加线程进行添加。如果放之前队列中没有元素，放完以后要唤醒消费线程进行消费。</li>
</ul>
<h3 id="ArrayBlockingQueue与LinkedBlockingQueue的比较"><a href="#ArrayBlockingQueue与LinkedBlockingQueue的比较" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue的比较"></a>ArrayBlockingQueue与LinkedBlockingQueue的比较</h3><p><strong>相同点</strong>：ArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；</p>
<p><strong>不同点</strong>：</p>
<p>1、ArrayBlockingQueue底层是采用的数组进行实现，而LinkedBlockingQueue则是采用链表数据结构；</p>
<p>2、ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率</p>
<p>更多LinkedBlockingQueue的实现细节参见<a href="https://blog.csdn.net/tonywu1992/article/details/83419448">https://blog.csdn.net/tonywu1992/article/details/83419448</a></p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个支持优先级的<strong>无界阻塞</strong>队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用优先级队列需要注意的点：</p>
<p>1、队列中不允许出现null值，也不允许出现不能排序的元素。</p>
<p>2、队列容量是没有上限的，但是如果插入的元素超过负载，有可能会引起OutOfMemory异常。</p>
<blockquote>
<p>当我们使用无界队列是都应该注意的点，不能在队列中无限存放数据</p>
</blockquote>
<p>3、PriorityBlockingQueue由于是无界的，所以put方法是非阻塞的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block  请自行对照上面表格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以给定初始容量，这个容量会按照一定的算法自动扩充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Default array capacity.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里默认的容量是 11，由于也是基于数组。</p>
<p>4、<code>内部只有一个Lock，所以生产消费者不能同时作业</code></p>
<p>详情可以参照<a href="https://www.cnblogs.com/wyq1995/p/12289462.html">https://www.cnblogs.com/wyq1995/p/12289462.html</a></p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue顾名思义，具有延时作用的队列。</p>
<p>记得第一次接触延时队列的时候是在看分布式任务调度时看到底层有关延时队列的实现。</p>
<p>DelayQueue 也是一个无界阻塞队列，使用时要注意OOM。</p>
<p><code>只有delay时间小于0的元素才能够被取出。</code></p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>创建一个类，实现Delayed方法，重写getDelay方法和compareTo方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayData</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> second;</span><br><span class="line">    <span class="keyword">private</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayData</span><span class="params">(<span class="keyword">long</span> second, String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        System.err.println(second + <span class="string">&quot; &quot;</span> + l);</span><br><span class="line">        <span class="keyword">this</span>.second = second + l;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diffTime = second - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diffTime,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        DelayData tmp = (DelayData) o;</span><br><span class="line">        <span class="keyword">long</span> result =  second - tmp.getSecond() ;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DelayData&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;second=&quot;</span> + second +</span><br><span class="line">                <span class="string">&quot;, val=&#x27;&quot;</span> + val + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后创建两个线程模拟生产者和消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DelayQueue&lt;DelayData&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;DelayData&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            delayQueue.put(<span class="keyword">new</span> DelayData(<span class="number">5000</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">            delayQueue.put(<span class="keyword">new</span> DelayData(<span class="number">10000</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">            delayQueue.put(<span class="keyword">new</span> DelayData(<span class="number">15000</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.err.println(<span class="string">&quot;执行一次循环  队列长度&quot;</span> + delayQueue.size());</span><br><span class="line">                    DelayData poll = delayQueue.take();</span><br><span class="line">                    <span class="keyword">if</span> (poll != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        System.err.println(poll.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (delayQueue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p><strong>SynchronousQueue</strong>实际上它不是一个真正的队列，因为它不会维护队列中元素的存储空间，与其他队列不同的是，它维护一组线程，这些线程在等待把元素加入或移除队列。适用于生产者少消费者多的情况。</p>
<p>SynchronousQueue是生产者直接把数据给消费者（消费者直接从生产者这里拿数据）。换句话说，<strong>每一个插入操作必须等待一个线程对应的移除操作</strong>。SynchronousQueue又有两种模式：</p>
<p>1、公平模式</p>
<p>　　采用公平锁，并配合一个FIFO队列（Queue）来管理多余的生产者和消费者</p>
<p>2、非公平模式</p>
<p>　　采用非公平锁，并配合一个LIFO栈（Stack）来管理多余的生产者和消费者，这也是SynchronousQueue默认的模式</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transferer 是一个内部类用于在生产者和消费者之间传递数据</p>
<h3 id="实现生产者消费者"><a href="#实现生产者消费者" class="headerlink" title="实现生产者消费者"></a>实现生产者消费者</h3><p>下面模拟一个生产者生产数据，两个消费者消费数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">                    queue.put(l);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产者生产数据 :&quot;</span> + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费数据 ： &quot;</span> + queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费数据 ： &quot;</span> + queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0 生产者生产数据 :1628055947404</span><br><span class="line">Thread-1消费者消费数据 ： 1628055947404</span><br><span class="line">Thread-0 生产者生产数据 :1628055947506</span><br><span class="line">Thread-2消费者消费数据 ： 1628055947506</span><br><span class="line">Thread-0 生产者生产数据 :1628055947608</span><br><span class="line">Thread-2消费者消费数据 ： 1628055947608</span><br><span class="line">Thread-0 生产者生产数据 :1628055947713</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue详细实现细节参见<a href="https://blog.csdn.net/yanyan19880509/article/details/52562039">https://blog.csdn.net/yanyan19880509/article/details/52562039</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html</a></p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/index.html">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<p><a href="https://www.baeldung.com/java-blocking-queue">https://www.baeldung.com/java-blocking-queue</a></p>
<p><a href="https://blog.csdn.net/tonywu1992/article/details/83419448">https://blog.csdn.net/tonywu1992/article/details/83419448</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Condition机制底层</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/</url>
    <content><![CDATA[<h1 id="Lock框架中的Condition机制"><a href="#Lock框架中的Condition机制" class="headerlink" title="Lock框架中的Condition机制"></a>Lock框架中的Condition机制</h1><p>还是看一下之前ReentrantLock中调用condition方法的流程图 👇</p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210803140956785.png" alt="image-20210803140956785" style="zoom:40%;" />



<p>任何一个java对象都天然继承于Object类，在线程间实现通信的往往会应用到Object的几个方法，比如wait(),wait(long timeout),wait(long timeout, int nanos)与notify(),notifyAll()几个方法实现等待/通知机制，同样的， 在java Lock体系下依然会有同样的方法实现等待/通知机制。</p>
<p>从整体上来看<strong>Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。两者除了在使用方式上不同外，在<strong>功能特性</strong>上还是有很多的不同：</p>
<ol>
<li>Condition能够支持不响应中断，而通过使用Object方式不支持；</li>
<li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；</li>
<li>Condition能够支持超时时间的设置，而Object不支持</li>
</ol>
<h2 id="1-Condition接口提供的方法"><a href="#1-Condition接口提供的方法" class="headerlink" title="1. Condition接口提供的方法"></a>1. Condition接口提供的方法</h2><h3 id="1-1-await方法"><a href="#1-1-await方法" class="headerlink" title="1.1 await方法"></a>1.1 await方法</h3><p><strong>void await() throws InterruptedException</strong></p>
<p>当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</p>
<p><strong>long awaitNanos(long nanosTimeout)</strong></p>
<p>当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</p>
<p><strong>boolean await(long time, TimeUnit unit)throws InterruptedException</strong></p>
<p>同第二种，支持自定义时间单位</p>
<p><strong>boolean awaitUntil(Date deadline) throws InterruptedException</strong></p>
<p>当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong></p>
<h3 id="1-2-signal方法"><a href="#1-2-signal方法" class="headerlink" title="1.2 signal方法"></a>1.2 signal方法</h3><p><strong>void signal()</strong></p>
<p>唤醒一个等待在condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</p>
<p><strong>void signalAll()</strong></p>
<p>与1的区别在于能够唤醒所有等待在condition上的线程。</p>
<h2 id="2-Condition在ReentrantLock中的使用"><a href="#2-Condition在ReentrantLock中的使用" class="headerlink" title="2. Condition在ReentrantLock中的使用"></a>2. Condition在ReentrantLock中的使用</h2><p>下面先通过一个例子看一下Condition的使用 👇</p>
<p>1、大致流程就是线程1先获取lock之后，执行线程1的方法，然后调用condition.await();方法阻塞当前线程；同时加入Condition等待队列</p>
<p>2、线程1释放lock之后，线程2而已经在同步队列中了，线程2获取lock执行权，执行condition.signal()方法唤醒线程1</p>
<p>3、线程1被唤醒之后，node节点重新添加到同步队列中，等待获取执行权限，在线程2调用了unlock()方法之后，线程1重新获取到lock之后，执行后续流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;enter thread 1 &quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;thread 1 invoke await&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.err.println(<span class="string">&quot;thread 1 invoked signal&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="string">&quot;exit thread 1 &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;enter thread 2 &quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;thread 2 invoke signal&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.err.println(<span class="string">&quot;exit thread 2 &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果可以猜想一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enter thread <span class="number">1</span> </span><br><span class="line">thread <span class="number">1</span> invoke await</span><br><span class="line">enter thread <span class="number">2</span> </span><br><span class="line">thread <span class="number">2</span> invoke signal</span><br><span class="line">exit thread <span class="number">2</span> </span><br><span class="line">thread <span class="number">1</span> invoked signal</span><br><span class="line">exit thread <span class="number">1</span> </span><br></pre></td></tr></table></figure>



<h2 id="3-Condition等待-通知实现原理"><a href="#3-Condition等待-通知实现原理" class="headerlink" title="3. Condition等待/通知实现原理"></a>3. Condition等待/通知实现原理</h2><p>要想能够深入的掌握condition还是应该知道它的实现原理，现在我们一起来看看condiiton的源码。创建一个condition对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会new出一个<strong>ConditionObject</strong>对象，该类是AQS的一个内部类，和Node类一样，非常重要。</p>
<p>condition是要和lock配合使用的也就是condition和Lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。</p>
<p>我们知道在锁机制的实现上，AQS内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到<strong>同步队列</strong>，同样的，condition内部也是使用同样的方式，内部维护了一个 <strong>等待队列</strong>，所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态。</p>
<p>另外注意到ConditionObject中有两个成员变量：</p>
<p><code>private transient Node firstWaiter;</code></p>
<p><code>private transient Node lastWaiter;</code></p>
<p>在AQS中condition队列可以存在多个如下所示，但是同步队列之可能是一个，值得注意的是，同步队列是一个双向链表队列，而等待队列是一个单向的队列。</p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210803142409623.png" alt="image-20210803142409623" style="zoom:33%;" />



<p>下面从await方法入手来学习Condition的机制是如何运转的。</p>
<h3 id="3-1-等待await"><a href="#3-1-等待await" class="headerlink" title="3.1 等待await"></a>3.1 等待await</h3><p><code>public class ConditionObject implements Condition</code></p>
<p>AQS#ConditionObject内部类实现了Condition接口的await方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">// 判断线程是否中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  	<span class="comment">// 将节点添加到等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">  	<span class="comment">// 进入等待队列中的线程需要释放lock让给别的线程</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 如果节点不在同步队列，则挂起当前线程，知道进入同步队列或者被中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 调用await的线程会一直阻塞在上面的while循环，知道被唤醒或者相应中断，才会执行下面的方法</span></span><br><span class="line">  	<span class="comment">// 进入同步队列尝试获取lock，和之前一样，为了限制一直空转，会在第二次循环之后，park此节点，知道队列中轮到这个线程出队</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">      	<span class="comment">// 清除掉取消的节点，踢出等待队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">  			<span class="comment">//处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AQS#addConditionWaiter</strong> <strong>添加节点到等待队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法应该比较好理解吧，就是添加一个节点，到等待队列。</p>
<p>⚠️ 这里和把节点添加到同步队列还有点区别，不知道大家还有没有印象，在同步队列添加节点的时候，先判断tail是否为空，如果不是空，则直接添加；如果是空，则调用了<code>enq(Node node)</code>方法，先生成一个head节点，然后在把当前节点添加到后面，循环了两遍的。</p>
<p>这里是直接创建当前节点，然后将firstWaiter指针指向了node；</p>
<p><strong>AQS#fullyRelease 释放lock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也不难，想一下，线程都已经调用await方法了，而且上一步就已经把节点添加到了等待队列中了，那么接下来要做什么呢？那肯定是释放锁lock了。对，这个方法就是做这个的。release方法之前已经介绍了，无非就是对state做一下减法，把对战线程清空一下，给新来的线程腾地方。</p>
<p><strong>下面才是await的关键核心代码</strong>：‼️</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>isOnSyncQueue(node)</code>判断当前节点是否在同步队列中，为什么要这个判断呢？原因很简单，当别的线程或者自己调用了signal方法之后，会把当前节点转移到同步队列中，在同步队列中说明什么呢，说明接下来这个线程要去竞争锁了，也就是被唤醒了，当竞争锁成功之后，这个线程就可以await后面的方法了。</p>
<p><code>(interruptMode = checkInterruptWhileWaiting(node)) != 0</code></p>
<p>如果当前线程被中断，则可以直接跳出循环，去竞争锁。</p>
<h3 id="3-2-通知signal"><a href="#3-2-通知signal" class="headerlink" title="3.2 通知signal"></a>3.2 通知signal</h3><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中</strong>，使得该节点能够有机会获得lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。signal方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 先检测当前线程是否已经获取lock，如果没有获得锁，肯定是说不通的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span></span><br><span class="line">	Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>signal方法首先会检测当前线程是否已经获取lock，如果没有获取lock会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的doSignal方法也是基于该节点。下面我们来看看doSignal方法做了些什么事情。</p>
<p><strong>AQS#doSignal</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//1. 将头结点从等待队列中移除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//2. while中transferForSignal方法对头结点做真正的处理</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体逻辑请看注释，真正对头节点做处理的逻辑在<strong>transferForSignal</strong>放，该方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	  <span class="comment">//1. 更新状态为0，加入同步队列的节点的初始状态是0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">//2.将该节点移入到同步队列中去</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">  	<span class="comment">// p节点是node的前置节点，需要将前驱节点的状态设置成Node.SIGNAL</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键逻辑请看注释，这段代码主要做了两件事情</p>
<p>1.将头结点的状态更改为CONDITION；</p>
<p>2.调用enq方法，将该节点尾插入到同步队列中，并且把前驱节点的状态设置成Node.SIGNAL</p>
<p>现在我们可以得出结论：<strong>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出</strong>。</p>
<p><strong>signalAll方法通知所有等待线程</strong></p>
<p>sigllAll与sigal方法的区别体现在doSignalAll方法上，前面我们已经知道doSignal方法只会对等待队列的头节点进行操作，而doSignalAll的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6844903602419400718">https://juejin.cn/post/6844903602419400718</a></p>
<p><a href="https://juejin.cn/post/6844903654873382925">https://juejin.cn/post/6844903654873382925</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之中断机制</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h1><p>Java语言提供一种机制来试图“终止”一些特殊的线程，比如一下空转的线程一直消耗系统资源，可以使用中断的方式来停止这一类的线程，这就是Java中断机制。</p>
<h2 id="1、中断注意的地方"><a href="#1、中断注意的地方" class="headerlink" title="1、中断注意的地方"></a>1、中断注意的地方</h2><p>1、<strong>Java中线程间是协作式，而非抢占式</strong>. 调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。</p>
<p>2、isInterrupted() 判定当前线程是否处于中断状态。</p>
<p>3、静态方法 interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为 false。</p>
<p>4、<strong>如果方法里如果抛出中断异常 InterruptedException，则线程的中断标志位会被复位成false</strong>，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()。</p>
<p>5、Java 中所有的阻塞方法都会抛出 InterruptedException，比如wait(), join(),sleep()。</p>
<h2 id="2、Java中断提供的方法"><a href="#2、Java中断提供的方法" class="headerlink" title="2、Java中断提供的方法"></a>2、Java中断提供的方法</h2><p>在Java中提供了3个有关中断的方法：</p>
<h3 id="Thread-currentThread-isInterrupted"><a href="#Thread-currentThread-isInterrupted" class="headerlink" title="Thread.currentThread().isInterrupted()"></a>Thread.currentThread().isInterrupted()</h3><blockquote>
<p>判断当前的线程是否被中断</p>
</blockquote>
<h3 id="thread-interrupt"><a href="#thread-interrupt" class="headerlink" title="thread.interrupt();"></a>thread.interrupt();</h3><blockquote>
<p>中断一个线程，将中断标志设置成true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-interrupted"><a href="#Thread-interrupted" class="headerlink" title="Thread.interrupted()"></a>Thread.interrupted()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断线程是否被中断，并清除中断标志，改成false；</p>
</blockquote>
<p>验证一下就可以了 👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.err.println(Thread.currentThread().isInterrupted());</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">    System.err.println(Thread.currentThread().isInterrupted());</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">    System.err.println(<span class="string">&quot;interrupted &quot;</span> + interrupted);</span><br><span class="line">    System.err.println(Thread.currentThread().isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、中断例子"><a href="#3、中断例子" class="headerlink" title="3、中断例子"></a>3、中断例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterrupterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.err.println(<span class="number">1</span>);</span><br><span class="line">                System.err.println(Thread.interrupted());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;after sleep &quot;</span>+ Thread.currentThread().isInterrupted());</span><br><span class="line">                  Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">                    System.err.println(<span class="string">&quot;interrupted &quot;</span>+ Thread.currentThread().isInterrupted() + <span class="string">&quot;/ &quot;</span> + interrupted);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    System.err.println(<span class="string">&quot;final sleep &quot;</span>+ Thread.currentThread().isInterrupted());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，中断一场不要【 吞掉 】，要不在程序中相应中断一场，进行相应的逻辑处理，或者将一场继续向上抛，由上层处理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dayarch.top/p/java-concurrency-interrupt-mechnism.html">https://dayarch.top/p/java-concurrency-interrupt-mechnism.html</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之同步锁</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程系列合集</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Lock框架继承关系图"><a href="#Lock框架继承关系图" class="headerlink" title="Lock框架继承关系图"></a>Lock框架继承关系图</h2><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802193933121.png" alt="image-20210802193933121"  />



<h2 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h2><ul>
<li>Java多线程与并发基础</li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></li>
<li><a href="https://geekibli.github.io/wiki/Java-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/">深入理解同步锁-synchronized关键字</a></li>
<li><a href="https://geekibli.github.io/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">synchronized实现原理概述</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/">深入理解volatile关键字</a></li>
<li>深入理解final关键字</li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BBlocking-Queue/">深入理解并发编程之Blocking Queue</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/">深入理解并发编程之AQS</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReetrantLock/">深入理解ReentrantLock应用及实现</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">深入Condition机制的底层原理</a></li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/">Java多线程之中断机制</a></li>
<li>深入理解并发容器之concurrentHashMap</li>
<li><a href="https://geekibli.github.io/wiki/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/">深入理解并发编程之ThreadLocal</a></li>
<li>深入理解Atomic底层及原理</li>
<li><a href="https://geekibli.github.io/wiki/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">如何构建一个安全可用的线程池</a></li>
<li>JUC-CountDownLatch</li>
<li>JUC-CyclicBarrier</li>
<li>LockSupport工具</li>
<li>并发编程之Unsafe类</li>
</ul>
<h2 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h2><p><a href="https://www.codercc.com/backend/basic/juc/">https://www.codercc.com/backend/basic/juc/</a></p>
<p><a href="https://segmentfault.com/a/1190000015558984">https://segmentfault.com/a/1190000015558984</a></p>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html">https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html</a></p>
<p><a href="https://github.com/AobingJava/JavaFamily">https://github.com/AobingJava/JavaFamily</a></p>
<p><a href="https://dayarch.top/categories/Coding/Java-Concurrency/">https://dayarch.top/categories/Coding/Java-Concurrency/</a></p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">http://tutorials.jenkov.com/java-concurrency/blocking-queues.html</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/wiki/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h2 id="1、泛型定义"><a href="#1、泛型定义" class="headerlink" title="1、泛型定义"></a>1、泛型定义</h2><blockquote>
<p>使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后在进行强制类型转换的代码具有更好的安全性和可读性。  –《Java核心技术》  </p>
</blockquote>
<p>泛型是在编译时期作用的；</p>
<p>泛型变量使用大写形式，在Java库中，一般使用变量E表示集合的元素类型，K和V表示表的关键字与值的类型。</p>
<h2 id="2、通配符"><a href="#2、通配符" class="headerlink" title="2、通配符"></a>2、通配符</h2><h3 id="2-1-无边界通配符"><a href="#2-1-无边界通配符" class="headerlink" title="2.1 无边界通配符"></a>2.1 无边界通配符</h3><p>无边界通配符又成为非限定通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-上边界通配符"><a href="#2-2-上边界通配符" class="headerlink" title="2.2 上边界通配符"></a>2.2 上边界通配符</h3><p>上边界通配符和下边界通配符都属于限定通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List中的类型必须是Number的子类，不然会报编译错误</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传进来的list的类型必须是Number或Number的子类才可以</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>? extends Number<br>如果限定的类型有多个，之间使用 &amp; 进行分割</p>
</blockquote>
<h3 id="2-3-下边界通配符"><a href="#2-3-下边界通配符" class="headerlink" title="2.3 下边界通配符"></a>2.3 下边界通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List的泛型是Number 添加的元素只要是Number下的类型就可以</span></span><br><span class="line">        List&lt;Number&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2L</span>);</span><br><span class="line">        list1.add(<span class="keyword">new</span> BigDecimal(<span class="number">22</span>));</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用类型必须是Number到Object之间的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、泛型的使用"><a href="#3、泛型的使用" class="headerlink" title="3、泛型的使用"></a>3、泛型的使用</h2><blockquote>
<p>泛型必须先声明，再使用，不然会有编译错误；<br>泛型的声明是用过一对&lt;&gt;来完成，约定使用一个大写的字母来表示;<br>通配符不能用作返回值;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testA</span><span class="params">(T t, Test1&lt;T&gt; test1)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是传入的T:&quot;</span> + t);</span><br><span class="line">    t = test1.t;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是赋值后的T:&quot;</span> + t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要从泛型类取数据时，用extends；</li>
<li>要往泛型类写数据时，用super；</li>
<li>既要取又要写，就不用通配符（即extends与super都不用）。</li>
</ul>
<h3 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;K&gt; <span class="function">K <span class="title">test</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-泛型方法"><a href="#3-2-泛型方法" class="headerlink" title="3.2 泛型方法"></a>3.2 泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest4</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;T&gt; 代表泛型的声明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t   本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的泛型方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k   类中定义的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;X&gt; 本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X&gt; <span class="function">X <span class="title">aa</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (X) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法中是无法使用类中声明的泛型类型的</span></span><br><span class="line"><span class="comment">     * 可以使用在本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;X&gt; <span class="function">X <span class="title">bb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-泛型接口"><a href="#3-3-泛型接口" class="headerlink" title="3.3 泛型接口"></a>3.3 泛型接口</h3><p>首先看一下不使用泛型接口的Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先定义接口，声明两个方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">aa</span><span class="params">(Integer a)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Integer <span class="title">bb</span><span class="params">(Integer b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后创建一个类来实现方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo</span> <span class="keyword">implements</span> <span class="title">IGeneric</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是没有使用泛型的接口设计，但是aa方法的操作类型相当于在接口中写死了，如果此时我们需要一个String类型的aa方法，那是不是还要在声明一个String类型的接口，然后再去实现呢，这样是不是显得代码很臃肿，代码重复；<br>所以我们可以看一下使用泛型之后是怎么样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义泛型接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面是根据不同类型的实现类</span><br><span class="line">泛型传如Integer类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericInteger</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型传入String类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericString</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aa</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bb</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4、泛型擦除"><a href="#4、泛型擦除" class="headerlink" title="4、泛型擦除"></a>4、泛型擦除</h2><p>在虚拟机上没有泛型类型对象，所有的对象都属于普通类。Java在处理泛型类型的时候，会处理成一个相应的原始类型。  擦除类型变量，并替换为限定类型，如果没有限定类型，默认使用Object替代。如果有限定类型，并且是多个，会使用第一个限定的类型来替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这个T是一个无限定的变量，泛型擦除之后会直接使用Object替换。<br>当然调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ....</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>
<p>擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换，也就是说，编译器调用方法是其实是执行了一下两个虚拟机指令：</p>
<ul>
<li>对原始方法Pair.getFirst()方法的调用</li>
<li>将返回的Object类型强制转换为Employee类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">foo</span><span class="params">(T [] args)</span></span></span><br></pre></td></tr></table></figure>
<p>在擦除类型之后变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable T <span class="title">foo</span><span class="params">(Comparable [] args)</span></span></span><br></pre></td></tr></table></figure>
<p>参数类型T已经被擦除，只留下限定类型Comparable;</p>
<blockquote>
<p>总之有关Java泛型转换的事实：</p>
<ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都用它们的限定类型替换</li>
<li>==桥方法被合成来保证多态==</li>
<li>为了保持类型安全型，必要时插入强制类型转换</li>
</ul>
</blockquote>
<p>第一条应该很好理解，这也是为什么会有泛型擦除这个概念，是因为JVM不能操作泛型；<br>第二条就是解释泛型如何进行类型的擦除；<br>第三条是泛型方法可能与多态的理念矛盾，所以使用桥方法来过渡或兼容；<br>第四条上面也有提到，会出现强制类型转换的情况；  </p>
<h2 id="5、泛型的约束与局限性"><a href="#5、泛型的约束与局限性" class="headerlink" title="5、泛型的约束与局限性"></a>5、泛型的约束与局限性</h2><p>当然泛型的设计在java中并没有那么完美，它确实可以解决代码结构重用等问题，但是也是有一些局限性，下面是我根据《Java核心技术》进行的总结：</p>
<h3 id="5-1-不能使用基础数据类型实例化类型参数"><a href="#5-1-不能使用基础数据类型实例化类型参数" class="headerlink" title="5.1 不能使用基础数据类型实例化类型参数"></a>5.1 不能使用基础数据类型实例化类型参数</h3><p>原因是类型擦除之后，如果使用Object原始类型，Object是无法存储基本数据类型的值。所以只能通过其包装类型声明；</p>
<h3 id="5-2-运行时查询类型只适用与原始类型"><a href="#5-2-运行时查询类型只适用与原始类型" class="headerlink" title="5.2 运行时查询类型只适用与原始类型"></a>5.2 运行时查询类型只适用与原始类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest5</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoTest5&lt;String&gt; demoTest5 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        DemoTest5&lt;Integer&gt; demoTest4 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        System.err.println(demoTest4.getClass().equals(demoTest5.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demoTest4.getClass().equals(demoTest5.getClass())其实比较的是DemoTest5这个类类型，我们输出一下demoTest4.getClass()的结果看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class com.ibli.javaBase.generics.DemoTest5</span><br></pre></td></tr></table></figure>
<p>所以这里有一道非常经典的面试题，<a href="https://blog.csdn.net/IBLiplus/article/details/108672223">如何判断一个泛型他的具体类型是什么，这里我们可以使用反射去拿到泛型的具体类型；</a></p>
<h3 id="5-3-不能创造参数化类型的数组"><a href="#5-3-不能创造参数化类型的数组" class="headerlink" title="5.3 不能创造参数化类型的数组"></a>5.3 不能创造参数化类型的数组</h3><p>对于参数化类型的数组，在类型擦除之后，会变成Object[]类型，如果此时试图存储一个String类型的元素，就会抛出一个Array-StoreException异常；<br>主要目的还是处于到数组安全的保护，可以参考几篇文章:  </p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/ask/195960">1、如果Java不支持参数化类型数组，那么Arrays.asList()如何处理它们？</a><br><a href="https://blog.csdn.net/qq_41286138/article/details/105250938">2、java不能创建参数化类型的泛型数组</a><br><a href="https://www.cnblogs.com/shuilangyizu/p/5916402.html">3、java.lang.ArrayStoreException</a></p>
</blockquote>
<h3 id="5-4-Varargs警告"><a href="#5-4-Varargs警告" class="headerlink" title="5.4 Varargs警告"></a>5.4 Varargs警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例的场景，编译器会发出警告！<br>抑制这种警告的方式有两种：</p>
<ul>
<li>在调用方法上增加注解@SuppressWarnings(“unchecked”)</li>
<li>还可以使用@SafeVarargs注解直接标注方法<blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_41286138/article/details/105250938">java不能创建参数化类型的泛型数组</a>  </p>
</blockquote>
</li>
</ul>
<h3 id="5-5-不能实例化类型变量"><a href="#5-5-不能实例化类型变量" class="headerlink" title="5.5 不能实例化类型变量"></a>5.5 不能实例化类型变量</h3><p>不能使用new T(..) 或则new T[…]和T.class这样的表达式的类型变量；因为类型擦除后，T变成Object，显然我们在这里并不是想要创建一个Object实例。解决办法是在调用者提供一个构造器表达式，下面是用Supplier函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T first;</span><br><span class="line">        <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cannot infer type arguments for Pair2&lt;&gt;</span></span><br><span class="line"><span class="comment">         * 当函数头返回值为Pair时,无法推断,改为Pair2后可以推断.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> c1</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Class&lt;T&gt; c1)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c1.newInstance(),c1.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Supplier是一个函数接口，返回一个无参数并且返回类型为T的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMakePair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.接受Supplier&lt;T&gt;--它是一个函数式接口。表示无参数且返回类型为T的函数。</span></span><br><span class="line"><span class="comment">         * 因为不能实例化类型变量，如：</span></span><br><span class="line"><span class="comment">         * public Pair() &#123;first = new T();second = new T();&#125;</span></span><br><span class="line"><span class="comment">         * 所以最好的方式是让调用者提供一个构造器表达式.形式如下:</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> constr</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair = Pair.build(String::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(pair.getFirst().length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public void buildT()&#123;</span></span><br><span class="line"><span class="comment">         2.传统的方式是通过Class.newInstance方法来构造泛型对象.</span></span><br><span class="line"><span class="comment">         但由于细节过于复杂,T.class是不合法的.它会被擦除为Object.class.如下:</span></span><br><span class="line"><span class="comment">         Illegal class literal for the type parameter T</span></span><br><span class="line"><span class="comment">         T.class.newInstance();</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         * 3.</span></span><br><span class="line"><span class="comment">         * T.class是不合法的,但若API涉及如下</span></span><br><span class="line"><span class="comment">         * reason:因为String.class是Class&lt;String&gt;的一个实例.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair1 = Pair.build(String.class);</span><br><span class="line">        System.out.println(pair1.getFirst().length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="5-6-不能构造泛型数组"><a href="#5-6-不能构造泛型数组" class="headerlink" title="5.6 不能构造泛型数组"></a>5.6 不能构造泛型数组</h3><p>就像不能实例化一个泛型实例一样，也不能实例化数组。数组本身也有类型，用来监控存储在JVM中的数组，这个类型会被擦除，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] foo(T[] a)&#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除，会让这个方法永远构造Comparabel[2]数组；</p>
<h3 id="5-7-泛型类的静态上下文中类型变量无效"><a href="#5-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="5.7 泛型类的静态上下文中类型变量无效"></a>5.7 泛型类的静态上下文中类型变量无效</h3><p>这个应该是比较好理解的，上文也提到过了，泛型类型是作用在泛型类上的，一些静态的方法或这静态的属性不能够使用泛型类的变量类型，编译器会直接报错；</p>
<h3 id="5-8-不能抛出或者捕获泛型类的实例"><a href="#5-8-不能抛出或者捕获泛型类的实例" class="headerlink" title="5.8 不能抛出或者捕获泛型类的实例"></a>5.8 不能抛出或者捕获泛型类的实例</h3><p>Java既不能抛出也不能捕获泛型类对象，实际上，甚至泛型类扩展Throwable都是不合法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (T ex)&#123;  此处无法捕获    <span class="keyword">catch</span>必须捕获具体的异常</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在异常规范中使用类型变量是允许的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex)&#123;  </span><br><span class="line">        t.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-9-可以消除对受查异常的检查"><a href="#5-9-可以消除对受查异常的检查" class="headerlink" title="5.9 可以消除对受查异常的检查"></a>5.9 可以消除对受查异常的检查</h3><p>Java异常处理要求必须为所有的受查异常提供一个处理器，但是使用泛型，可以规避这一点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的方法，编译器会认为t是一个非受查异常;</p>
<h3 id="5-10-注意擦除后的冲突"><a href="#5-10-注意擦除后的冲突" class="headerlink" title="5.10 注意擦除后的冲突"></a>5.10 注意擦除后的冲突</h3><p>比如一个泛型类的equals方法，擦除之后，和Object的equals冲突；解决办法是重新命名引发错误的方法；</p>
<h2 id="6、泛型的继承关系"><a href="#6、泛型的继承关系" class="headerlink" title="6、泛型的继承关系"></a>6、泛型的继承关系</h2><p>如果Manage extends Employee,那么Pair&lt; Manage &gt;是Pair&lt; Employee &gt;的子类吗？ 不是的！<br>但是泛型类可以扩展或实现其他的泛型类，很典型的一个例子ArrayList:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList[E]继承了AbstractList[E];</p>
<h2 id="对于Java泛型的一些思考"><a href="#对于Java泛型的一些思考" class="headerlink" title="对于Java泛型的一些思考"></a>对于Java泛型的一些思考</h2><blockquote>
<p>编译器如何推断出具体的类型？ 参考资料：<a href="https://blog.csdn.net/u011240877/article/details/53545041#%E6%93%A6%E9%99%A4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">深入理解 Java 泛型</a></p>
</blockquote>
<blockquote>
<p align="middle"> -------------------   他日若遂凌云志 敢笑黄巢不丈夫 ------------------- </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/wiki/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java基础之注解机制详解"><a href="#Java基础之注解机制详解" class="headerlink" title="Java基础之注解机制详解"></a>Java基础之注解机制详解</h1><blockquote>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、<br>局部变量等进行注解。它是框架学习和设计者必须掌握的基础。</p>
</blockquote>
<h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：<br>— 生成文档，通过代码里标识的元数据生成javadoc文档。<br>— 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。<br>— 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 </p>
<ul>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理， 例如使用反射注入实例。<br>这么来说是比较抽象的，我们具体看下注解的常见分类： <ul>
<li><strong>Java自带的标准注解</strong>， 包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，<br>用这些注解标明后编译器就会进行检查。   </li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，<br>@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，<br>@Documented用于标明是否生成javadoc文档。 </li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。<br>接下来我们通过这个分类角度来理解注解。  </li>
</ul>
</li>
</ul>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    /**</span><br><span class="line">        * 重载父类的test方法</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 被弃用的方法</span><br><span class="line">        */</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void oldMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 忽略告警</span><br><span class="line">        * </span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    public List processList() &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：   </p>
<ul>
<li>@Override：表示当前的方法定义将覆盖父类中的方法  </li>
<li>@Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告  </li>
<li>@SuppressWarnings：表示关闭编译器警告信息 我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。  </li>
</ul>
<h3 id="内置注解-Override"><a href="#内置注解-Override" class="headerlink" title="内置注解 - @Override"></a>内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。<br>这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，<br>若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。    </p>
<h3 id="内置注解-Deprecated"><a href="#内置注解-Deprecated" class="headerlink" title="内置注解 - @Deprecated"></a>内置注解 - @Deprecated</h3><p>这个注解的定义如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。  </p>
<h3 id="内置注解-SuppressWarnings"><a href="#内置注解-SuppressWarnings" class="headerlink" title="内置注解 - @SuppressWarnings"></a>内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。<br>它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<p>// TODO</p>
<blockquote>
<p>参考资料<br><a href="https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html">https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/wiki/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><ul>
<li><p>linux 在文档中查找关键字个数<br><code>grep -o “关键字” 文档名 | wc -l </code><br><code>grep -o “关键字” 文档名 | sort | uniq -c</code></p>
</li>
<li><p>清除history记录<br><code>vim .bash_history</code><br>命令模式下（Esc之后输入:） 输入 set nu 每行数据前面显示行号<br><code>11,20d</code> 回车 11～20行的记录就被删除了<br>然后命令模式下 wq 保存退出就可以了<br>如果在此查看还是有记录，可以退出当前回话之后，再进去查看，就会不再显示删除的记录了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Common commands</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-MVCC多版本并发控制</title>
    <url>/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>MVCC在MySQL InnoDB中的实现主要是为了 「<font color=red> 提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 </font>」</p>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><blockquote>
<p>当前读</p>
</blockquote>
<p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<blockquote>
<p>快照读</p>
</blockquote>
<p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p>
<p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p>
<p><font color=red >MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</font></p>
<h2 id="MVCC有什么好处，解决了什么问题"><a href="#MVCC有什么好处，解决了什么问题" class="headerlink" title="MVCC有什么好处，解决了什么问题"></a>MVCC有什么好处，解决了什么问题</h2><p>多版本并发控制（MVCC）是一种用来「 <font color=green>解决读-写冲突的无锁并发控制</font> 」，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的  <font color=red>3个隐式字段</font>，<font color=red>undo日志</font> ，<font color=red>Read View</font> 来实现的。所以我们先来看看这个三个point的概念</p>
<h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<blockquote>
<p>DB_TRX_ID</p>
</blockquote>
<p>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p>
<blockquote>
<p>DB_ROLL_PTR</p>
</blockquote>
<p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p>
<blockquote>
<p>DB_ROW_ID</p>
</blockquote>
<p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p>
<blockquote>
<p>insert undo log</p>
</blockquote>
<p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
<blockquote>
<p>update undo log</p>
</blockquote>
<p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，<font color=red>主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护）</font>，如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本;</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/8845ddca3b23">1、MVCC多版本并发控制</a><br><a href="https://blog.csdn.net/chosen0ne/article/details/18093187">2、MVCC浅析</a><br><a href="https://database.51cto.com/art/202010/629317.htm">3、乐观锁、悲观锁和MVCC，今天让你一次搞懂</a><br><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc">4、面试官：谈谈你对Mysql的MVCC的理解？</a><br><a href="https://www.cnblogs.com/shujiying/p/11347632.html">5、Mysql中MVCC的使用及原理详解</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务特性与实现原理</title>
    <url>/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务特性与实现原理"><a href="#事务特性与实现原理" class="headerlink" title="事务特性与实现原理"></a>事务特性与实现原理</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote>
<p>原子性(Atomicity)</p>
</blockquote>
<p>事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。</p>
<blockquote>
<p>一致性(Consistency)</p>
</blockquote>
<p>事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p>
<blockquote>
<p>隔离性(Isolation)</p>
</blockquote>
<p>并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。</p>
<blockquote>
<p>持久性(Durability)</p>
</blockquote>
<p>事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p>
<p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面<br>1.事务的并发执行<br>2.事务故障或系统故障</p>
<h2 id="事务实现原理"><a href="#事务实现原理" class="headerlink" title="事务实现原理"></a>事务实现原理</h2><img src="https://oscimg.oschina.net/oscnet/up-7b54f7847cee22930ec53a4058179a2b531.png" width=460 height=300>

<ul>
<li>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。</li>
<li>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</li>
</ul>
<h3 id="回滚日志（undo）"><a href="#回滚日志（undo）" class="headerlink" title="回滚日志（undo）"></a>回滚日志（undo）</h3><p>undo log属于 「 逻辑日志 」，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<p>undo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。</p>
<p>因此，undo log有两个作用：提供回滚和多个行版本控制(MVCC)。</p>
<h3 id="重做日志（redo）"><a href="#重做日志（redo）" class="headerlink" title="重做日志（redo）"></a>重做日志（redo）</h3><p>redo log重做日志记录的是新数据的备份，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据恢复到最新的状态。</p>
<p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p>
<p>MySQL中redo log刷新规则采用一种称为Checkpoint的机制（利用LSN实现），为了确保安全性，又引入double write机制。</p>
<h2 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h2><p>开启事务：start transaction<br>回滚事务：rollback<br>提交事务：commit</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">1、详细分析MySQL事务日志(redo log和undo log)</a><br><a href="https://www.cnblogs.com/takumicx/p/9998844.html">2、数据库事务的概念及其实现原理</a><br><a href="https://zhuanlan.zhihu.com/p/281927963">3、数据库事务实现原理</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter index out of range (1 &gt; number of parameters, which is 0).</title>
    <url>/wiki/Parameter-index-out-of-range-1-number-of-parameters-which-is-0/</url>
    <content><![CDATA[<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 12:39:31.179 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:39:31.186 [http-nio-8081-exec-2] ERROR com.alibaba.otter.canal.client.adapter.support.Util - sqlRs has error, sql: SELECT COUNT(1) FROM ( select t.redtom_id as id, t.username, t.nickname, t.avatar, t.status, t.mobile, t.mobile_region_no, t.email, t.gender, t.password,t.salt,t.birthday,t.introduce,t.country,t.region,t.level,t.is_vip,t.follows    ,t.fans,t.likes_num, t.collects_num, t.instagram_account, t.youtube_account, t.facebook_account, t.twitter_account,t.create_ip, t.create_time,t.update_time from rd_member r where t.create_time&gt;=&#x27;&#123;0&#125;&#x27;) _CNT</span><br><span class="line">2021-07-06 12:39:31.188 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">java.lang.RuntimeException: java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:65) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:62) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br></pre></td></tr></table></figure>

<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我执行的操作如下：👇<br><code>curl http://127.0.0.1:8081/etl/es7/customer.yml -X POST -d &quot;params=2019-08-31 00:00:00&quot;</code></p>
<p>但是我的 es7/rd_member.yml的配置文件如下：</p>
<p><code>etlCondition:&quot;where a.c_time&gt;=&#39;&#123;0&#125;&#39;&quot; # etl 的条件参数</code></p>
<p>应该改成：<br><code>etlCondition:&quot;where a.c_time&gt;=&#123;&#125;&quot; # etl 的条件参数</code></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Other Question</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务隔离级别</title>
    <url>/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。另外，这篇分布式事务不理解？一次给你讲清楚！推荐大家阅读。</p>
<blockquote>
<p>Read Uncommitted（读取未提交内容）</p>
</blockquote>
<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<blockquote>
<p>Read Committed（读取提交内容）</p>
</blockquote>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<blockquote>
<p>Repeatable Read（可重读）</p>
</blockquote>
<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<blockquote>
<p>Serializable（可串行化）</p>
</blockquote>
<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<h2 id="事务隔离级别产生的问题"><a href="#事务隔离级别产生的问题" class="headerlink" title="事务隔离级别产生的问题"></a>事务隔离级别产生的问题</h2><img src="https://oscimg.oschina.net/oscnet/up-ee3cb778a32220ff81103f9163d22f774b2.png"> 


<blockquote>
<p>脏读(Drity Read)</p>
</blockquote>
<p>某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，但是此时的事务B还未commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务B-&gt;rollback操作</span><br><span class="line">事务A读取到的是脏数据</span><br></pre></td></tr></table></figure>


<blockquote>
<p>不可重复读(Non-repeatable read)</p>
</blockquote>
<p>在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，并commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务A多次读取的结果不一致</span><br></pre></td></tr></table></figure>

<blockquote>
<p>幻读(Phantom Read) </p>
</blockquote>
<p><font color=red >幻读和不可重复读的区别在于，幻读主要表现在数据的删除和插入，而不可重复读表现在数据的更新。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新delete price=100 这条记录，并commit</span><br><span class="line">事务A读取的price=100</span><br><span class="line">price这条记录已经不存在，但是事务A还是可以读取到</span><br></pre></td></tr></table></figure>

<p>1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。<br>　　2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/xiewenfeng520/article/details/99407038">1、mysql数据库的隔离级别</a><br><a href="https://blog.csdn.net/sinat_15805929/article/details/91127491">2、MYSQL数据库的四种隔离级别</a><br><a href="https://www.jianshu.com/p/c53c8ab650b5">3、MySQL幻读
</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis-list底层实现</title>
    <url>/wiki/Redis-list%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Redis-List-底层实现"><a href="#Redis-List-底层实现" class="headerlink" title="Redis List 底层实现"></a>Redis List 底层实现</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">   </p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote>
<p>连锁更新问题 | quicklist | ziplist | linkedlist </p>
</blockquote>
<h2 id="List底层数据结构"><a href="#List底层数据结构" class="headerlink" title="List底层数据结构"></a>List底层数据结构</h2><p>在 3.0 版本的 Redis 中，List 类型有两种实现方式：<br>数据结构底层采用压缩列表ziplist或linkedlist两种数据结构进行存储，首先以ziplist进行存储，在不满足ziplist的存储要求后转换为linkedlist列表。<br>当列表对象同时满足以下两个条件时，列表对象使用ziplist进行存储，否则用linkedlist存储。</p>
<h3 id="ziplist转换成linkedlist的条件"><a href="#ziplist转换成linkedlist的条件" class="headerlink" title="ziplist转换成linkedlist的条件"></a>ziplist转换成linkedlist的条件</h3><p><strong>1、触发一下任意一条即进行转换：</strong></p>
<ul>
<li>列表对象保存的所有字符串元素的长度小于64字节  </li>
<li>列表对象保存的元素数量小于512个。</li>
</ul>
<p><strong>2、redis.conf配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-max-ziplist-value 64 </span><br><span class="line">list-max-ziplist-entries 512 </span><br></pre></td></tr></table></figure>
<p><strong>3、ziplist和linkedlist底层实现</strong><br><a href="">1、使用压缩列表（ziplist）实现的列表对象。</a><br><a href="">2、使用双端链表（linkedlist）实现的列表对象。</a>  </p>
<p>在 3.2 版本后新增了 quicklist 数据结构实现了 list，现在就来分析下 quicklist 的结构。    </p>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p><img src="https://oscimg.oschina.net/oscnet/up-558f859ac71d40fd122bae2ebdb0a9eb055.png"><br>ziplist会引入频繁的内存申请和释放，而linkedlist由于指针也会造成内存的浪费，而且每个节点是单独存在的，会造成很多内存碎片，<br>所以结合两个结构的特点，设计了quickList。<br>quickList 是一个 ziplist 组成的双向链表。每个节点使用 ziplist 来保存数据。本质上来说， quicklist 里面保存着一个一个小的 ziplist。</p>
<h3 id="quicklist表头结构"><a href="#quicklist表头结构" class="headerlink" title="quicklist表头结构"></a>quicklist表头结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向头部(最左边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向尾部(最右边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ziplist中的entry节点计数器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//quicklist的quicklistNode节点计数器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存ziplist的大小，配置文件设定，占16bits</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存压缩程度值，配置文件设定，占16bits，0表示不压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<ul>
<li>head 和 tail 分别指向这个双端链表的表头和表尾, quicklist 存储的节点是一个叫做 quicklistNode 的结构, 如果这个 quicklist 是空的,<br>那么 head 和 tail 会同时成为空指针, 如果这个双端链表的大小为 1, 那么 head 和 tail 会同时指向一个相同的节点</li>
<li>count 是一个计数器, 表示当前这个 list 结构一共存储了多少个元素, 它的类型是 unsigned long, 所以一个 list 能存储的最多的元素在 字长为 64 bit 的机器上是 (1 &lt;&lt; 64) - 1, 字长为 32 bit 的机器上是 (1 &lt;&lt; 32) - 1</li>
<li>len 表示了这个双端链表的长度(quicklistNodes 的数量)</li>
<li>fill 表示了单个节点(quicklistNode)的负载比例(fill factor), 这是什么意思呢 <blockquote>
<p>Lists 结构使用了一种特殊的编码方式来节省空间, Lists 中每一个节点所能存储的东西可以通过最大长度或者一个最大存储的空间大小来限制,<br>对于想限制每个节点最大存储空间的用户, 用 -5 到 -1 来表示这个限制值  </p>
</blockquote>
</li>
<li>5: 最大存储空间: 64 Kb &lt;– 通常情况下不要设置这个值    </li>
<li>4: 最大存储空间: 32 Kb &lt;– 非常不推荐</li>
<li>3: 最大存储空间: 16 Kb &lt;– 不推荐</li>
<li>2: 最大存储空间: 8 Kb &lt;– 推荐</li>
<li>1: 最大存储空间: 4 Kb &lt;– 推荐    </li>
</ul>
<p>对于正整数则表示最多能存储到你设置的那个值, 当前的节点就装满了<br>通常在 -2 (8 Kb size) 或 -1 (4 Kb size) 时, 性能表现最好<br>但是如果你的使用场景非常独特的话, 调整到适合你的场景的值！！！！</p>
<p><strong>redis.conf, 其中有一个可配置的参数叫做 list-max-ziplist-size, 默认值为 -2, 它控制了 quicklist 中的 fill 字段的值, 负数限制 quicklistNode 中的 ziplist 的字节长度, 正数限制 quicklistNode 中的 ziplist 的最大长度</strong>  </p>
<ul>
<li>compress 则表示 quicklist 中的节点 quicklistNode, 除开最两端的 compress 个节点之后, 中间的节点都会被压缩<blockquote>
<p>Lists 在某些情况下是会被压缩的, 压缩深度是表示除开 list 两侧的这么多个节点不会被压缩, 剩下的节点都会被尝试进行压缩, 头尾两个节点一定不会被进行压缩,<br>因为要保证 push/pop 操作的性能, 有以下的值可以设置:<br>0: 关闭压缩功能</p>
</blockquote>
</li>
</ul>
<p> 1: 深度 1 表示至少在 1 个节点以后才会开始尝试压缩, 方向为从头到尾或者从尾到头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[head]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[tail]</span><br><span class="line">[head], [tail] 永远都是不会被压缩的状态; 中间的节点则会被压缩</span><br></pre></td></tr></table></figure>
<p>2 不会尝试压缩 head 或者 head-&gt;next 或者 tail-&gt;prev 或者 tail 但是会压缩这中间的所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[head]-&gt;[next]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[prev]-&gt;[tail]</span><br></pre></td></tr></table></figure>
<p>3: 以此类推，最大为2的16次方。  </p>
<h3 id="quicklistNode-节点"><a href="#quicklistNode-节点" class="headerlink" title="quicklistNode 节点"></a>quicklistNode 节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前驱节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后继节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不设置压缩数据参数recompress时指向一个ziplist结构</span></span><br><span class="line">    <span class="comment">//设置压缩数据参数recompress指向quicklistLZF结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩列表ziplist的总长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;                  <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ziplist中包的节点数，占16 bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;          <span class="comment">/* count of items in ziplist */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示是否采用了LZF压缩算法压缩quicklist节点，1表示压缩过，2表示没压缩，占2 bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;        <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩，默认是2，占2bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;       <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记quicklist节点的ziplist之前是否被解压缩过，占1bit长度</span></span><br><span class="line">    <span class="comment">//如果recompress为1，则等待被再次压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试时使用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//额外扩展位，占10bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>prev 和 next 分别指向当前 quicklistNode 的前一个和后一个节点</li>
<li>zl 指向实际的 ziplist</li>
<li>sz 存储了当前这个 ziplist 的占用空间的大小, 单位是字节</li>
<li>count 表示当前有多少个元素存储在这个节点的 ziplist 中, 它是一个 16 bit 大小的字段, 所以一个 quicklistNode 最多也只能存储 65536 个元素</li>
<li>encoding 表示当前节点中的 ziplist 的编码方式, 1(RAW) 表示默认的方式存储, 2(LZF) 表示用 LZF 算法压缩后进行的存储 </li>
<li>container 表示 quicklistNode 当前使用哪种数据结构进行存储的, 目前支持的也是默认的值为 2(ZIPLIST), 未来也许会引入更多其他的结构</li>
<li>recompress 是一个 1 bit 大小的布尔值, 它表示当前的 quicklistNode 是不是已经被解压出来作临时使用</li>
<li>attempted_compress 只在测试的时候使用</li>
<li>extra 是剩下多出来的 bit, 可以留作未来使用</li>
</ul>
<h3 id="quicklistLZF-结构定义"><a href="#quicklistLZF-结构定义" class="headerlink" title="quicklistLZF 结构定义"></a>quicklistLZF 结构定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copytypedef struct quicklistLZF &#123;</span><br><span class="line">    unsigned int sz;  //压缩后的ziplist大小</span><br><span class="line">    char compressed[];//柔性数组，存放压缩后的ziplist字节数组</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<p>当指定使用lzf压缩算法压缩ziplist的entry节点时，quicklistNode结构的zl成员指向quicklistLZF结构;   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://zhuanlan.zhihu.com/p/102422311">Redis列表list 底层原理</a><br>2、<a href="https://cloud.tencent.com/developer/article/1710612">Redis中string、list的底层数据结构原理</a><br>3、<a href="https://cloud.tencent.com/developer/article/1619920">《闲扯Redis五》List数据类型底层之quicklist</a><br>4、<a href="https://blog.csdn.net/men_wen/article/details/70229375">Redis源码剖析和注释（七）— 快速列表(quicklist)</a><br>5、<a href="https://blog.csdn.net/qq_31720329/article/details/99938219">redis 列表结构 底层实现(quicklist)</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-overview</title>
    <url>/wiki/Redis-overview/</url>
    <content><![CDATA[<h1 id="Redis-（Remote-Dictionary-Server）"><a href="#Redis-（Remote-Dictionary-Server）" class="headerlink" title="Redis （Remote Dictionary Server）"></a>Redis （Remote Dictionary Server）</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中<br>进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。<br>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。<br>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限<br>制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。<br>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高<br>性能的 tag 系统等等。<br>另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。<br>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因<br>此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h2 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456<br>授权密码：auth 123456  </p>
<h2 id="Redis-有哪几种数据淘汰策略？"><a href="#Redis-有哪几种数据淘汰策略？" class="headerlink" title="Redis 有哪几种数据淘汰策略？"></a>Redis 有哪几种数据淘汰策略？</h2><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但 DEL 和几个例外）<br>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>allkeys-random: 回收随机的键使得新添加的数据有空间存放。<br>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。  </p>
<h2 id="Redis-有哪些适合的场景？"><a href="#Redis-有哪些适合的场景？" class="headerlink" title="Redis 有哪些适合的场景？"></a>Redis 有哪些适合的场景？</h2><h3 id="（1）会话缓存（Session-Cache）"><a href="#（1）会话缓存（Session-Cache）" class="headerlink" title="（1）会话缓存（Session Cache）"></a>（1）会话缓存（Session Cache）</h3><p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Mem<br>cached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车<br>信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为<br>人知的商业平台 Magento 也提供 Redis 的插件。</p>
<h3 id="（2）全页缓存（FPC）"><a href="#（2）全页缓存（FPC）" class="headerlink" title="（2）全页缓存（FPC）"></a>（2）全页缓存（FPC）</h3><p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实<br>例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。<br>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。<br>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快<br>速度加载你曾浏览过的页面。  </p>
<h3 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h3><p>Redis 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队<br>列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop<br>操作。<br>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是<br>利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作<br>为 broker，你可以从这里去查看。</p>
<h3 id="（4）排行榜-计数器"><a href="#（4）排行榜-计数器" class="headerlink" title="（4）排行榜/计数器"></a>（4）排行榜/计数器</h3><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也<br>使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。<br>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下<br>面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执<br>行：<br>ZRANGE user_scores 0 10 WITHSCORESAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可<br>以在这里看到。<br>###（5）发布/订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见<br>人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建<br>立聊天系统！</p>
<h3 id="Redis-常见的性能问题和解决方案"><a href="#Redis-常见的性能问题和解决方案" class="headerlink" title="Redis 常见的性能问题和解决方案"></a>Redis 常见的性能问题和解决方案</h3><p>1、master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件<br>2、如果数据比较重要，某个 slave 开启 AOF 备份，策略设置成每秒同步一次<br>3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内<br>4、尽量避免在压力大得主库上增加从库<br>5、主从复制不要采用网状结构，尽量是线性结构，Master&lt;–Slave1&lt;—-Slave2 ….  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-哈希表实现</title>
    <url>/wiki/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Redis之Hash表底层实现"><a href="#Redis之Hash表底层实现" class="headerlink" title="Redis之Hash表底层实现"></a>Redis之Hash表底层实现</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">  </p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><blockquote>
<p>字段dict | 渐进式哈希 | ziplist |  哈希表</p>
</blockquote>
<h2 id="字典底层结构"><a href="#字典底层结构" class="headerlink" title="字典底层结构"></a>字典底层结构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-95f75bf34c0a82057f05be6630b16163e42.png">  </p>
<h3 id="dict-字典结构体"><a href="#dict-字典结构体" class="headerlink" title="dict 字典结构体"></a>dict 字典结构体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dict&#123;</span><br><span class="line">    dictType *type;//类型特定函数，包括一些自定义函数，这些函数使得key和</span><br><span class="line">                   //value能够存储</span><br><span class="line">    void *private;//私有数据</span><br><span class="line">    dictht ht[2];//两张hash表 </span><br><span class="line">    int rehashidx;//rehash索引，字典没有进行rehash时，此值为-1</span><br><span class="line">    unsigned long iterators; //正在迭代的迭代器数量</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<ul>
<li>type和private这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对应的一些复制，比较函数也不一样，这两个属性配合起来可以实现多态的方法调用；</li>
<li>ht[2]，两个hash表</li>
<li>rehashidx，这是一个辅助变量，用于记录rehash过程的进度，以及是否正在进行rehash等信息，当此值为-1时，表示该dict此时没有rehash过程</li>
<li>iterators，记录此时dict有几个迭代器正在进行遍历过程</li>
</ul>
<h3 id="dictht-哈希表结构体"><a href="#dictht-哈希表结构体" class="headerlink" title="dictht 哈希表结构体"></a>dictht 哈希表结构体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dictht&#123;</span><br><span class="line">    dictEntry **table;//存储数据的数组 二维</span><br><span class="line">    unsigned long size;//数组的大小</span><br><span class="line">    unsigned long sizemask;//哈希表的大小的掩码，用于计算索引值，总是等于 </span><br><span class="line">                           //size-1</span><br><span class="line">    unsigned long used;//// 哈希表中中元素个数</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h3 id="dictEntry-哈希数组结构"><a href="#dictEntry-哈希数组结构" class="headerlink" title="dictEntry 哈希数组结构"></a>dictEntry 哈希数组结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dictEntry&#123;</span><br><span class="line">    void *key;//键</span><br><span class="line">    union&#123;</span><br><span class="line">        void val;</span><br><span class="line">        unit64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">        double d;</span><br><span class="line">    &#125;v;//值</span><br><span class="line">    struct dictEntry *next；//指向下一个节点的指针</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。<br>这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。  </p>
<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。<br>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。<br>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。  </p>
<h3 id="触发扩容的条件："><a href="#触发扩容的条件：" class="headerlink" title="触发扩容的条件："></a>触发扩容的条件：</h3><ul>
<li>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li>
<li>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。<br>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</li>
</ul>
<h3 id="为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？"><a href="#为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？" class="headerlink" title="为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？"></a>为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？</h3><ul>
<li>BGSAVE时，dict要是进行扩容，则此时就需要为dictht[1]分配内存，若是dictht[0]的数据量很大时，就会占用更多系统内存，造成内存页过多分离，<br>所以为了避免系统耗费更多的开销去回收内存，此时最好不要进行扩容；</li>
<li>缩容时，结合缩容的条件，此时负载因子&lt;0.1，说明此时dict中数据很少，就算为dictht[1]分配内存，也消耗不了多少资源；</li>
</ul>
<h2 id="渐进式哈希"><a href="#渐进式哈希" class="headerlink" title="渐进式哈希"></a>渐进式哈希</h2><p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，<br>但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。<br>所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，<br>第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。</p>
<ul>
<li>渐进式哈希其实就是慢慢的，一步一步的将hash表的数据迁移到另一个hash表中</li>
<li>redis会有一个定时任务去检测是否需要进行rehash</li>
<li>rehash的过程中会在字典dict中维护一个rehashidx的标志</li>
<li>在rehash的过程中，两个hash表中都会有数据，此时如果有数据新增，将会存在ht[1]也就是第二个哈希表上；</li>
<li>在rehash的过程中，如果有删改查，则优先选择第一张表，如果第一张表没有查到数据，则查找第二章哈希表；</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://www.cnblogs.com/ysocean/p/9080942.html">Redis详解（四）—— redis的底层数据结构</a><br>2、<a href="https://www.cnblogs.com/reecelin/p/13362104.html">Redis底层数据结构之hash</a><br>3、<a href="https://blog.csdn.net/mccand1234/article/details/93411326">Redis Hash数据结构的底层实现</a><br>4、<a href="https://baijiahao.baidu.com/s?id=1651767862408344160&wfr=spider&for=pc">图解redis五种数据结构底层实现(动图哦)</a><br>5、<a href="https://www.jianshu.com/p/c63d8448a7b0">redis hash底层数据结构</a><br>6、<a href="https://www.cnblogs.com/reecelin/p/13362104.html">Redis底层数据结构之hash</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-字符串底层原理</title>
    <url>/wiki/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Redis底层实现及原理"><a href="#Redis底层实现及原理" class="headerlink" title="Redis底层实现及原理"></a>Redis底层实现及原理</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">  </p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><blockquote>
<p>SDS embstr 二进制安全 空间预分配</p>
</blockquote>
<h2 id="String类型不同的编码方式"><a href="#String类型不同的编码方式" class="headerlink" title="String类型不同的编码方式"></a>String类型不同的编码方式</h2><ul>
<li><strong>使用整数存储：</strong> 只对长度小于或等于 21 字节，并且可以被解释为整数的字符串进行编码</li>
<li><strong>使用EMBSTR 编码：</strong> 尝试将 RAW 编码的字符串编码为 EMBSTR 编码，</li>
<li><strong>使用SDS编码:</strong> 这个对象没办法进行编码，尝试从 SDS 中移除所有空余空间 下面举个例子看一下👇</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-01a9f52dd08c514531b8701a47aa90aa029.png"  width="600" height="413" align="bottom" />

<h3 id="embstr与动态字符串"><a href="#embstr与动态字符串" class="headerlink" title="embstr与动态字符串"></a>embstr与动态字符串</h3><ul>
<li>embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为redisObject分配对象，embstr省去了第一次）。 相对地，释放内存的次数也由两次变为一次。</li>
<li>embstr的redisObject和sds放在一起，更好地利用缓存带来的优势</li>
<li>但是redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改。</li>
</ul>
<h2 id="SDS-simple-dynamic-string"><a href="#SDS-simple-dynamic-string" class="headerlink" title="SDS(simple dynamic string)"></a>SDS(simple dynamic string)</h2><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">     //记录buf数组中已使用字节的数量</span><br><span class="line">     //等于 SDS 保存字符串的长度</span><br><span class="line">     int len;</span><br><span class="line">     //记录 buf 数组中未使用字节的数量</span><br><span class="line">     int free;</span><br><span class="line">     //字节数组，用于保存字符串</span><br><span class="line">     char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDS有什么优点"><a href="#SDS有什么优点" class="headerlink" title="SDS有什么优点"></a>SDS有什么优点</h3><h4 id="1、常数复杂度获取字符串长度"><a href="#1、常数复杂度获取字符串长度" class="headerlink" title="1、常数复杂度获取字符串长度"></a><strong>1、常数复杂度获取字符串长度</strong></h4><p>sdshdr 中由于 len 属性的存在，获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)，而对于 C 语言来说， 获取字符串的长度通常是遍历字符串计数来实现的，时间复杂度为 O(n)。</p>
<h4 id="2、杜绝缓冲区溢出"><a href="#2、杜绝缓冲区溢出" class="headerlink" title="2、杜绝缓冲区溢出"></a><strong>2、杜绝缓冲区溢出</strong></h4><p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候， 会首先根据记录的 len<br>属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<h4 id="3、减少修改字符串时带来的内存重分配次数"><a href="#3、减少修改字符串时带来的内存重分配次数" class="headerlink" title="3、减少修改字符串时带来的内存重分配次数"></a><strong>3、减少修改字符串时带来的内存重分配次数</strong></h4><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，<br>字符串长度减小时会造成内存泄露。而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：</p>
<p>3.1 字符串长度增加操作时，进行空间预分配</p>
<blockquote>
<p>对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
</blockquote>
<p>3.2 字符串长度减少操作时，惰性空间释放</p>
<blockquote>
<p>对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。<br>（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。</p>
</blockquote>
<h4 id="4、二进制安全"><a href="#4、二进制安全" class="headerlink" title="4、二进制安全"></a><strong>4、二进制安全</strong></h4><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取； 而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS<br>不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<h4 id="5、兼容部分C字符串函数"><a href="#5、兼容部分C字符串函数" class="headerlink" title="5、兼容部分C字符串函数"></a><strong>5、兼容部分C字符串函数</strong></h4><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<h3 id="为什么字符串长度大于44就是用raw方式编码"><a href="#为什么字符串长度大于44就是用raw方式编码" class="headerlink" title="为什么字符串长度大于44就是用raw方式编码"></a>为什么字符串长度大于44就是用raw方式编码</h3><p>这个是因为C语言函数库分配内存的长度只能是2/4/8/16/32/64；最大分配64位的长度；<br>但是redisObj的长度加上字符串对象头的长度，占用20位，所以字符串长度最多是44位，超过这个长度，就是用raw方式进行编码；  – 《Redis深度历险-String数据结构》  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1606944">《闲扯Redis二》String数据类型之底层解析</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1660571063765620837&wfr=spider&for=pc">每个程序员都应该知道的Redis知识 - String底层原理</a><br>3、<a href="https://www.cnblogs.com/ysocean/p/9080942.html">Redis详解（四）—— redis的底层数据结构</a><br>4、<a href="https://yq.aliyun.com/articles/666402">redis string底层数据结构</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-缓存穿透、击穿和雪崩</title>
    <url>/wiki/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="缓存击穿，穿透和雪崩"><a href="#缓存击穿，穿透和雪崩" class="headerlink" title="缓存击穿，穿透和雪崩"></a>缓存击穿，穿透和雪崩</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先说一下为什么会写这片文章，因为这个对我来说是印象非常深刻的，那是还在实习的时候，当时接了一个任务（其实就是练手的），大致需求是写一个白名单，然后有一个功能对白名单开放。因为是新功能，需要在部分地区试点，如果没有问题才会放开到全国城市运行。就是这么一个小的功能，让当时的我，呵呵。我记得那是第一次使用Redis,根本不知道什么是缓存雪崩啊，缓存击穿啊，穿透呀这些，还有更可怕的缓存一致性问题（TODO 下期再说）。          当时团队十几位大佬review我的代码，哼。这就是为什么印象会深刻一些吧，关键那是我第一个review代码，还是第一次使用redis，整个review就像是十几个大佬在面试我。真是怀疑人生了。。我是废物，别笑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大致伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermit</span><span class="params">(String cityCode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先查询缓存中是否存在</span></span><br><span class="line">    String tmpCity = getCache(cityCode);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isNotBlank(tmpCity))&#123;</span><br><span class="line">        reture Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中没有在去查数据库</span></span><br><span class="line">    <span class="function">reture <span class="title">judgeForDb</span><span class="params">(cityCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我上面的例子其实就是典型的缓存穿透的问题。因为仅仅是开放了十几个城市来试点功能，所以大部分的查询都是缓存不命中的。</p>
<p>下面引出今天我们的三个关键词：</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>要查询的数据，缓存中基本上没有，所以大概率情况下缓存是不命中的，而是去数据库中去查询数据，导致缓存相当于是一个摆设。如果Key不是热点访问还可以，如果是热点Key，而且并发量也会很大的情况下，绝大多数的请求都会打到数据库上，很容易造成数据库宕机。</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、布隆过滤器进行校验，bloom filter典型应用场景（用户名是否存在，黑名单机制，单词错误检测）<br>2、缓存空值方法，这个网上也是说的比较多的，这种方式也是可以的  </p>
<h5 id="在此我说一下我的解决方案："><a href="#在此我说一下我的解决方案：" class="headerlink" title="在此我说一下我的解决方案："></a>在此我说一下我的解决方案：</h5><p>1、校验一个城市是否是城市白名单的城市时，直接查询缓存，存储的数据结构是使用的hash；<br>2、如果没有查到这个城市，则认为这个城市不在白名单中，因为我是先查的hash，然后在查询hash中的具体城市。如果hash的值都没有查到，那说明缓存失效了；<br>3、针对缓存失效的情况，可以再查DB来更新缓存，这个时候有人要较真了，会不会出线缓存击穿的情况呀，这个看具体场景，因为我的业务是不需要的，所以这里就直接查库更新缓存了，如果需要的话，那可以上缓存击穿的解决方案，或者看看上面两种解决方案有没有合适的，哈哈哈；<br>4、因为城市是在后台进行配置的，所以我是在增删改的操作时，保证了缓存数据的一致性的前提下，才选择相信缓存的。这是我当时的解决方案。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>某个热点Key在一段时间内失效了，此时有大量请求瞬时抵达，会严重增加数据库的压力。因为我们的缓存数据一般都是要设置过期时间的，当缓存失效时，会去查询数据库同时更新缓存数据。</p>
</blockquote>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、可以加锁，来保证只有第一个请求进来时达到数据库上，然后更新缓存，第二个请求进来是就会命中缓存，当然如果是分布式服务，那就需要使用分布式锁了。<br>2、合理设置缓存时间，可以将热点Key时间设置长一些，或者根据业务将失效时间设置在业务量比较小的波段，都是可以的。有的解决方案会不设置Key的过期时间，这个，看情况吧，不建议这样。 如果大量的key不设置过期时间，则长期占用内存也是不好的。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存雪崩顾名思义，就是大量Key在一段时间或者瞬时失效，或者Redis服务重启（所有Key失效，因为是存在内存中），从而导致大量请求打到数据库上，增加数据库压力</p>
</blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、将热点key设置不同波段的过期时间，把过期时间散列开。<br>2、也可以使用分布式锁来限制高并发的请求，和缓存击穿的解决方案同理。<br>3、对于Redis重启或宕机的问题，可以考虑集群部署，并保证数据的同步和一致性；</p>
<blockquote>
 <p align="middle" > 生活远不止眼前的苟且 </p></blockquote>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/wiki/Spring-Overview/</url>
    <content><![CDATA[<hr>
<p>title: Spring-Overview<br>toc: true<br>date: 2021-07-28 17:32:41<br>tags: Spring<br>categories: [Spring Family , Spring Framework]</p>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>The Spring Framework provides a comprehensive<br> programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.</p>
<p>A key element of Spring is infrastructural support at the application level: Spring focuses on the “plumbing” of enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to specific deployment environments.</p>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul>
<li>先梳理脉络，先宏观，再细节</li>
<li>Spring源码注释很重要</li>
<li>见名知意 学习spring的命名规范</li>
<li>猜测和验证</li>
<li>坚持看 不要三分钟热度</li>
</ul>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><blockquote>
<p>Spring框架官方网站</p>
</blockquote>
<p><a href="https://spring.io/projects/spring-framework#overview">【官网】</a>可以下载Spirng源码在本地查看更舒服！ 源码请戳    👉👉 <a href="https://spring.io/projects/spring-framework#overview">【源码】</a> 👈👈</p>
<blockquote>
<p>Spring5最新完整教程IDEA版通俗易懂 </p>
</blockquote>
<p>视频教程 狂神说 （这个大佬在B站很火的）原链接请点击👉 <a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=20">【传送】</a></p>
<blockquote>
<p>24集彻底搞懂aop ioc mvc底层原理</p>
</blockquote>
<p>视频目录比较好 👉 <a href="https://www.bilibili.com/video/BV1Bt4y1S7nW?p=7">【2020年史上最新Spring源码合集，24集彻底搞懂aop ioc mvc底层原理。】</a></p>
<blockquote>
<p>手撕SpringIOC源码</p>
</blockquote>
<p>马士兵教育 <a href="https://www.bilibili.com/video/BV1CT4y1P7tK?p=1">【400分钟学完Spring源码设计及原理，手撕SpringIOC源码，从我做起】</a></p>
<blockquote>
<p>图灵学院公开课 </p>
</blockquote>
<p>课程目录还不错 5个小时 21年录制比较新 <a href="https://www.bilibili.com/video/BV1Ya411F73A?from=search&seid=11823196289005055636">【2021年新版Java-Spring底层原理，阿里P8大佬全套讲解】</a></p>
<blockquote>
<p>Mybatis + Spring 源码解读 VIP公开课<br><a href="https://www.bilibili.com/video/BV1Gv411s7hL?p=1">【终于有字节跳动技术大牛把【mybatis底层原理：spring整理mybatis】讲明白了】</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>SpringBean循环依赖</title>
    <url>/wiki/SpringBean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring-Bean-循环依赖"><a href="#Spring-Bean-循环依赖" class="headerlink" title="Spring Bean 循环依赖"></a>Spring Bean 循环依赖</h1><h2 id="为什么会存在循环依赖"><a href="#为什么会存在循环依赖" class="headerlink" title="为什么会存在循环依赖"></a>为什么会存在循环依赖</h2><img src="https://oscimg.oschina.net/oscnet/up-4ac2f1ac005d007a18a0823719edb29abf7.png" width=300 height=168>

<p>如上图👆所示，A对象的一个属性是B,B对象的一个属性是A,而Spring中的bean默认情况下都是单例的，所以这两个Bean就产生了循环依赖的问题！</p>
<blockquote>
<p>那么循环依赖的问题出现在什么情况呢</p>
</blockquote>
<p>想一下属性赋值的方式有几种呢？</p>
<ul>
<li>构造器赋值<blockquote>
<p>这种形式循环依赖问题无法解决</p>
</blockquote>
</li>
<li>GET/SET方法<blockquote>
<p>调用SET方法进行赋值的时候，可以通过三级缓存的策略来解决循环依赖的问题</p>
</blockquote>
</li>
</ul>
<p>所以，三级缓存的策略是针对于使用SET方法对属性赋值的场景下的！</p>
<h2 id="循环依赖如何解决"><a href="#循环依赖如何解决" class="headerlink" title="循环依赖如何解决"></a>循环依赖如何解决</h2><img src="https://oscimg.oschina.net/oscnet/up-eabac6749e665ea36856dce17c2119658a7.png">

<p>在实例化的过程中，将处于半成品的对象全部放到缓存中，方便后续来进行调用；<br>只要有了当前对象的引用地址，那么后续来进行赋值即可；</p>
<blockquote>
<p>d 能不能将创建好的对象也放到缓存中呢？</p>
</blockquote>
<p>不能，如果放在一起将无法区分对象是成品对象还是半成品对象了<br>所以再次引出多级缓存的概念，可以创建两个缓存对象，一个用来存放已经实例化的半成品对象，另一个存放完成实例化并且完成初始化的成品对象，这个应该比较好理解吧！</p>
<blockquote>
<p>思考一下以上的设计有没有问题呢？</p>
</blockquote>
<h3 id="为什么需要三级缓存？"><a href="#为什么需要三级缓存？" class="headerlink" title="为什么需要三级缓存？"></a>为什么需要三级缓存？</h3><p>Spring在解决对象Bean循环依赖的问题的解决方案是使用了「三级缓存」；<br>为什么需要三级缓存，也就是三个Map对象；</p>
<blockquote>
<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 三级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>







<blockquote>
<p>三级缓存中分别保存的是什么内容</p>
</blockquote>
<ul>
<li>一级缓存： 成品对象</li>
<li>二级缓存： 半成品对象</li>
<li>三级缓存； lambda表达式</li>
</ul>
<blockquote>
<p>如果只有二级缓存可不可行</p>
</blockquote>
<p>在Spring源码中，只有addSingleton方法和doCreateBean方法中向三级缓存中添加东西的；</p>
<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">           <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">           <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">           <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">       Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">       <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">               singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">               <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                   ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                   <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       singletonObject = singletonFactory.getObject();</span><br><span class="line">                       <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                       <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> singletonObject;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">       Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">           <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName, <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">               <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">boolean</span> recordSuppressedExceptions = <span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   singletonObject = singletonFactory.getObject();</span><br><span class="line">                   newSingleton = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IllegalStateException var16) &#123;</span><br><span class="line">                   singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> var16;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (BeanCreationException var17) &#123;</span><br><span class="line">                   BeanCreationException ex = var17;</span><br><span class="line">                   <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                       Iterator var8 = <span class="keyword">this</span>.suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                           Exception suppressedException = (Exception)var8.next();</span><br><span class="line">                           ex.addRelatedCause(suppressedException);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> singletonObject;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring梳理启动脉络</title>
    <url>/wiki/Spring%E6%A2%B3%E7%90%86%E5%90%AF%E5%8A%A8%E8%84%89%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="Spring是如何启动的"><a href="#Spring是如何启动的" class="headerlink" title="Spring是如何启动的"></a>Spring是如何启动的</h1><p>Spring最大的核心就是Bean容器；<br>容器： 从对象创建，使用和销毁全部由容器帮我们控制，用户仅仅使用就可以。</p>
<h2 id="两大核心"><a href="#两大核心" class="headerlink" title="两大核心"></a>两大核心</h2><ul>
<li>IOC 控制反转</li>
<li>AOP 面向切面编程</li>
</ul>
<p>思考：我们是如何使用Spring的呢？</p>
<blockquote>
<p> 加入从配置文件中加载bean 我们猜想一下大致流程是怎样的</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">getPerson</span> <span class="attr">class</span>=<span class="string">com.ibli.Person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">id</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">age</span> <span class="attr">value</span>=<span class="string">20</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件如上👆，这里是伪代码！</p>
<p>先猜想大致流程：</p>
<img src="https://oscimg.oschina.net/oscnet/up-c5313f104a205f008fde4f4b729507c80e7.png">


<p>通过上面猜想创建的对象流程，创建出对象，对象已经好了，就是使用了，那么如何使用呢？</p>
<p>一般情况下我们会可以这样使用，写一下伪代码吧👇：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建一个ApplicationContext对象</span><br><span class="line">Object obj = applicationContext.getBean(<span class="string">&quot;bean name); </span></span><br></pre></td></tr></table></figure>

<p>思考，创建的对象如何存储？ 或者容器到底是什么呢？ 应该可以猜到是Map结构，具体是什么Map,先不管；</p>
<img src="https://oscimg.oschina.net/oscnet/up-baea159953c9590bba80022b251df95a255.png" >

<blockquote>
<p>1、首先容器是创建好的，容器创建好之后，才可以加载配置文件</p>
</blockquote>
<p>也就是我们猜想的Map</p>
<blockquote>
<p>2、加载配置文件</p>
</blockquote>
<p>配置文件可能会有多种方式，比如XML格式，property格式，yaml格式，注解格式，这个格式各不相同，又是如何加载的呢？<br>Spring提供了一个接口，BeanDefinitionReader,它有一个抽象实现类AbstractBeanDefinitionReader，不同配置文件的Reader来继承这个抽象类，实现它们自己的逻辑；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GroovyBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">GroovyObject</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、读取的配置文件会转换成Spring定义的格式，也就是BeanDefinition；</p>
</blockquote>
<p>BeanDefinition定义了类的所有相关的数据； 此时得到的BeanDefinition的属性值只是「符号类型」,并不是真正的属性值；</p>
<p>我们可能会见过这中加载数据源的方式👇</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">dataSource</span> <span class="attr">class</span>=<span class="string">com.alibab.durid.pool.DruidDataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">url</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.url&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">username</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.username&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">password</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.password&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>数据源的具体配置是放在配置文件中的，当通过XmlBeanDefinitionReader读取并解析到的BeanDefinition，仅仅是将Xml中的文件数据存放到BeanDefinition中，属性的值是${jdbc.url}而不是真正的我们数据源的地址；</p>
<blockquote>
<p>4、得到所有的BeanDefinition之后，通过BeanFactoryPostProcessor来处理上一步骤中，属性value不是真实数据的问题</p>
</blockquote>
<p>比如PlaceHolderConfigurerSupport(占位符处理) 经过工厂后置处理器处理之后，BeanDefinition的属性值就是真实需要的数据了；</p>
<blockquote>
<p>5、BeanDefinition数据准备完成之后，由BeanFactory来完成Bean的创建</p>
</blockquote>
<ul>
<li>实例化 对象中分配堆内存等操作<blockquote>
<p>反射调用无参构造函数 创建对象 但是属性是空的</p>
</blockquote>
</li>
<li>初始化</li>
</ul>
<blockquote>
<p>6、初始化之前需要准备的工作 </p>
</blockquote>
<p>1、准备BeanPostProcessors<br>2、观察者模式，准备监听器 事件 广播器</p>
<blockquote>
<p>7、初始化环节有很多步骤</p>
</blockquote>
<ul>
<li><p>对象的填充</p>
<blockquote>
<p>其实就是调用get/set方法对属性赋值</p>
</blockquote>
</li>
<li><p>调用aware方法</p>
<blockquote>
<p>如果我们的对象中的属性是BeanFactory 我们不用自己去完成setBeanFactory方法，只需要当前类实现BeanFactoryAware方法即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>处理before操作</p>
</li>
<li><p>调用init方法</p>
</li>
<li><p>执行after方法</p>
<blockquote>
<p>before和after此处是调用的BeanPostProcessor的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前置方法</span><br><span class="line">postProcessBeforeInitialization</span><br><span class="line">// 后置方法</span><br><span class="line">postProcessAfterInitialization</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>8、执行到此，完成对象的创建，得到一个可以使用的对象</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring加载配置文件原理</title>
    <url>/wiki/Spring%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Spring如何加载配置文件到应用程序"><a href="#Spring如何加载配置文件到应用程序" class="headerlink" title="Spring如何加载配置文件到应用程序"></a>Spring如何加载配置文件到应用程序</h1><h2 id="加载Xml文件配置，获取对象"><a href="#加载Xml文件配置，获取对象" class="headerlink" title="加载Xml文件配置，获取对象"></a>加载Xml文件配置，获取对象</h2><blockquote>
<p>xml文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ibli.javaBase.reflection.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gaolei&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-ioc.xml&quot;</span>);</span><br><span class="line">        User user = (User) ac.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-加载Xml文件流程"><a href="#Spring-加载Xml文件流程" class="headerlink" title="Spring 加载Xml文件流程"></a>Spring 加载Xml文件流程</h2><blockquote>
<p>首先猜想一下宏观的流程</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-6aaea943c32e32e44e672c1850975bd40ae.png">

<p>我们可以大体猜想流程是什么样的，如下👇</p>
<img src="https://oscimg.oschina.net/oscnet/up-992d3c9c618a021852b873f08b756824901.png">

<p>接下来debug源码看一下具体流程：</p>
<blockquote>
<p>ClassPathXmlApplicationContext调用refresh方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// Spring 启动入口</span></span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   Spring 启动入口 this.refresh(); 👆</p>
<blockquote>
<p>调用AbstractRefreshableApplicationContext下的refreshBeanFactory</p>
</blockquote>
<p>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.hasBeanFactory()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">           <span class="keyword">this</span>.closeBeanFactory();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</span><br><span class="line">           beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</span><br><span class="line">           <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">// 从这里进入下一步 👇</span></span><br><span class="line">           <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">               <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + <span class="keyword">this</span>.getDisplayName(), var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=red>关键方法是this.loadBeanDefinitions(beanFactory);</font></p>
<blockquote>
<p> 找到XmlBeanDefinitionReader 这是读取配置的关键所在</p>
</blockquote>
<p>关键对象 <font color=red>XmlBeanDefinitionReader</font> 这个在 「梳理Spring启动脉络」中提到了，Spring提供的抽象接口！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">       XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">       beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">       beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">       beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">       <span class="comment">// 初始化beanDefinitionReader对象</span></span><br><span class="line">       <span class="keyword">this</span>.initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">       <span class="comment">// 加载配置文件 获得BeanDefinitions</span></span><br><span class="line">       <span class="keyword">this</span>.loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继续调用 loadBeanDefinitions 这个有很多重载方法，一直点下去就行！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        Resource[] configResources = <span class="keyword">this</span>.getConfigResources();</span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        String[] configLocations = <span class="keyword">this</span>.getConfigLocations();</span><br><span class="line">         <span class="comment">//spring-ioc.xml</span></span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>configLocations 就是我们Xml配置文件的路径</p>
<blockquote>
<p>接下来一直调用loadBeanDefinitions方法 直到这一步 👇</p>
</blockquote>
<p>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">                Throwable var4 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                    <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var6 = <span class="keyword">this</span>.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var24) &#123;</span><br><span class="line">                    var4 = var24;</span><br><span class="line">                    <span class="keyword">throw</span> var24;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                inputStream.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                                var4.addSuppressed(var23);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            inputStream.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里看到 <font color=red >nputStream</font> 很明显，这里是通过IO流读取制定位置的文件的 !</p>
<blockquote>
<p> 获取到文件输入流之后，将输入流转换成Document文件去解析</p>
</blockquote>
<p>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换成Document的关键方法</span></span><br><span class="line">Document doc = <span class="keyword">this</span>.doLoadDocument(inputSource, resource);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>调用doRegisterBeanDefinitions方法</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions<br>调用parseBeanDefinitions方法去解析数据</p>
<blockquote>
<p>调用DefaultBeanDefinitionDocumentReader的parseBeanDefinitions方法 来解析Element</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">           NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">               Node node = nl.item(i);</span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                   Element ele = (Element)node;</span><br><span class="line">                   <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       delegate.parseCustomElement(ele);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           delegate.parseCustomElement(root);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用parseDefaultElement方法</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;import&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;alias&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;bean&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;beans&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里看到<code>if (delegate.nodeNameEquals(ele, &quot;bean&quot;))</code> 会不会很兴奋呢，接下来就是解析的方法了👇 </p>
<blockquote>
<p> 跳转到 processBeanDefinition(ele, delegate);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是的 就是这个方法了 👉</span></span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> + bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>parseBeanDefinitionElement 将元素数据解析到beanDefinition</p>
</blockquote>
<p>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        String id = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String nameAttr = ele.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, <span class="string">&quot;,; &quot;</span>);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = (String)aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将element数据最终转换成一个beanDefinition对象 是不是很惊奇 哈哈哈</span></span><br><span class="line">     👉 AbstractBeanDefinition beanDefinition = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.error(var9.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-RTO重传计数器的计算</title>
    <url>/wiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>之前的文章已经介绍了TCP超时重传的过程中使用了定时器的策略，当定时器规定时间内未收到确认报文之后，就会触发报文的重传，同时定时器复位；那么定时器超时时间（RTO Retramission Timeout）是如何计算的呢？</p>
</blockquote>
<h2 id="什么是RTT？"><a href="#什么是RTT？" class="headerlink" title="什么是RTT？"></a>什么是RTT？</h2><p>了解RTO如何计算之前，首先明确一个概念「 <strong>RTT</strong> 」；</p>
<image src="https://oscimg.oschina.net/oscnet/up-9b45623a3b0652d842ffa3eecea13e92183.png" width=550 height=400>   

<p>如上图所示，从client发送第一个「SYN」报文，到Server接受到报文，并且返回「SYN ACK」报文之后，client接受到Server的「ACK」报文之后，client所经历的时间，叫做1个RTT时间；</p>
<h2 id="如何在重传下有效测量RTT？"><a href="#如何在重传下有效测量RTT？" class="headerlink" title="如何在重传下有效测量RTT？"></a>如何在重传下有效测量RTT？</h2><p><img src="https://oscimg.oschina.net/oscnet/up-6c558bfea1825bf5d3b2da74e087cdde43a.png"></p>
<p>如上图两种情况：<br>第一种，左侧a图所示，当一端发送的数据报丢失后要进行重传，到重传之后接收到确认报文之后，这种场景下该如何计算RTT呢？开始时间是按照第一次发送数据报时间呢还是按照重传数据报的时间呢？</p>
<blockquote>
<p>按照常理来说，如右侧b图所示，RTT时间应该以RTT2为准；</p>
</blockquote>
<p>第二种，左侧b图所示，第一次发送数据报文时，由于网络时延导致RTO时间内没有收到接收段的确认报文，发送端进行重发，但是在刚刚重发之后就收到了第一次报文的确认报文，那这种情况RTT该如何计算呢？</p>
<blockquote>
<p>如右侧a图所示，RTT时间应该以RTT1为准；</p>
</blockquote>
<p>就像上面提及的两种情况，一会以第一个RTT1为准，一会以RTT2为准，那么TCP协议如何正确的计算出RTT呢？</p>
<h2 id="使用Timestamp方式计算RTT"><a href="#使用Timestamp方式计算RTT" class="headerlink" title="使用Timestamp方式计算RTT"></a>使用Timestamp方式计算RTT</h2><p>之前的文章中在介绍TCP超时与重传的笔记中有介绍通过使用Timtstamp的方式来区分相同Seq序列号的不同报文，<br>其实在TCP报文首部存储Timestamp的时候，会存储报文的发送时间和确认时间，如下所示：<br><image src="https://oscimg.oschina.net/oscnet/up-ad80265bbba417c72a8d02a5c0be7be5f83.png" width=800 height=230> </p>
<h2 id="如何计算RTO？"><a href="#如何计算RTO？" class="headerlink" title="如何计算RTO？"></a>如何计算RTO？</h2><p>上面👆说到了RTT如何计算，那个RTO和RTT有什么关系呢？<br><image src="https://oscimg.oschina.net/oscnet/up-e25afa62f99830eb02c4c1df0c015dbde8a.png"><br> RTO的取值将会影响到TCP的传输效率以及网络的吞吐量；</p>
<blockquote>
<p>通常来说RTO应该略大于RTT，如果RTO小于RTT，则会造成发送端频繁重发，可能会造成网络阻塞；如果RTO设置的过大，则接受端已经收到确认报文之后的一段时间内仍然不能发送其他报文，会造成两端性能的浪费和网络吞吐量的下降；</p>
</blockquote>
<h3 id="平滑RTO"><a href="#平滑RTO" class="headerlink" title="平滑RTO"></a>平滑RTO</h3><p>网络的RTT是不断的变化的，所以计算RTO的时候，应当考虑RTO的平滑性，尽量避免RTT波动带来的干扰，以抵挡瞬时变化；</p>
<p><strong>平滑RTO在文档RFC793定义，给出如下计算方式：</strong></p>
<ul>
<li>SRTT (smoothed round-trip time) = ( α * SRTT ) + ((1 - α) * RTT)<blockquote>
<p>α 从 0到 1(RFC 推荐 0.9)，越大越平滑</p>
</blockquote>
</li>
<li>RTO = min[ UBOUND, max[ LBOUND, (β * SRTT) ] ]<blockquote>
<p>如 UBOUND为1分钟，LBOUND为 1 秒钟， β从 1.3 到 2 之间 </p>
</blockquote>
</li>
</ul>
<p>这种计算方式不适用于 RTT 波动大(方差大)的场景,如果网络的RTT波动很大，会造成RTO调整不及时；</p>
<h3 id="追踪RTT方差计算RTO"><a href="#追踪RTT方差计算RTO" class="headerlink" title="追踪RTT方差计算RTO"></a>追踪RTT方差计算RTO</h3><blockquote>
<p>RFC6298(RFC2988)，其中α = 1/8， β = 1/4，K = 4，G 为最小时间颗粒:</p>
</blockquote>
<ul>
<li><strong>首次计算 RTO，R为第 1 次测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRTT(smoothed round-trip time) = R</span><br><span class="line">RTTVAR(round-trip time variation) = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li>
<li><strong>后续计算 RTO，R’为最新测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRTT= (1-α)*SRTT+α*R’</span><br><span class="line">RTTVAR=(1-β)*RTTVAR+β*|SRTT-R’|</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-四次挥手/断开连接</title>
    <url>/wiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h1><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="https://oscimg.oschina.net/oscnet/up-8d9a6b405e874bc02b91e453bd277c46d46.png" width=450 height=550>

<ul>
<li>开始客户端和服务端都是处理【established】状态</li>
<li>客户端发送「FIN」报文之后，进入FIN-WAIT-1状态</li>
<li>服务端收到客户端的FIN之后，恢复一个ACK，同时进入CLOSE_WAIT状态</li>
<li>客户端接收到ACK之后，进入到FIN-WAIT-2状态</li>
<li>服务端接着发送FIN报文，同时进入LAST-ACK状态</li>
<li>客户端接收到服务端的FIN报文之后，发送ACK报文，并进入TIME_WAIT状态</li>
<li>客户端在经历2个MSL时间之后，进入CLOSE状态</li>
<li>服务端接收到客户端的ACK之后，进入CLOSE状态</li>
</ul>
<blockquote>
<p>并不是所有的四次挥手都是上述流程，当客户端和服务端同时发送关闭连接的请求如下👇：</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-d859884b062bda56a946ae9e3c0c148235b.png" width=450 height=550>

<p>可以看到双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。</p>
<blockquote>
<p>挥手一定需要四次吗？</p>
</blockquote>
<p>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。<br>等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。<br>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？</p>
<blockquote>
<p>为什么要有 TIME_WAIT?</p>
</blockquote>
<p>断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。</p>
<blockquote>
<p><font color=red >那么为什么要等 2MSL 呢？</font></p>
</blockquote>
<ul>
<li>就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。</li>
<li>假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</li>
</ul>
<blockquote>
<p>等待 2MSL 会产生什么问题？</p>
</blockquote>
<p>如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。<br>如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-如何减少小报文提升网络效率</title>
    <url>/wiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<h1 id="如何减少小报文提升网络效率"><a href="#如何减少小报文提升网络效率" class="headerlink" title="如何减少小报文提升网络效率"></a>如何减少小报文提升网络效率</h1><p>每一个TCP报文段都包含20字节的IP头部和20字节的TCP首部，如果报文段的数据部分很少的话，网络效率会很差；</p>
<h2 id="SWS-Silly-Window-syndrome-糊涂窗口综合症"><a href="#SWS-Silly-Window-syndrome-糊涂窗口综合症" class="headerlink" title="SWS(Silly Window syndrome) 糊涂窗口综合症"></a>SWS(Silly Window syndrome) 糊涂窗口综合症</h2><image src="https://oscimg.oschina.net/oscnet/up-777275434842bda3be80da2687c4556ee3b.png" width=600 height=450 >

<p>如上图👆所示场景，在之前的滑动窗口已经了解过，随着服务端处理连接数据能力越来越低，服务端的可用窗口不断压缩，最终导致窗口关闭；</p>
<h3 id="SWS-避免算法"><a href="#SWS-避免算法" class="headerlink" title="SWS 避免算法"></a>SWS 避免算法</h3><p>SWS 避免算法对发送方和接收方都做客</p>
<ul>
<li>接收方<blockquote>
<p>David D Clark 算法:窗口边界移动值小于 min(MSS, 缓存/2)时，<br>通知窗口为 0</p>
</blockquote>
</li>
<li>发送方<blockquote>
<p>Nagle 算法:<br>1、TCP_NODELAY 用于关闭 Nagle 算法<br>2、没有已发送未确认报文段时，立刻发送数据<br>3、存在未确认报文段时，直到:1-没有已发送未确认报文段，或者 2-数据长度达到MSS时再发送</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-delayed-acknowledgment-延迟确认"><a href="#TCP-delayed-acknowledgment-延迟确认" class="headerlink" title="TCP delayed acknowledgment 延迟确认"></a>TCP delayed acknowledgment 延迟确认</h2><p>实际情况下，没有携带任何数据的ACK报文也会造成网络效率低下的，因为确认报文也包含40字节的头部信息，但仅仅是为了传输ACK=1这样的信息，为了解决这种情况，TCP有一种机制，叫做延迟确认，如下👇：</p>
<ul>
<li>当有响应数据要发送时,ack会随着响应数据立即发送给对方.</li>
<li>如果没有响应数据,ack的发送将会有一个延迟,以等待看是否有响应数据可以一起发送</li>
<li>如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack</li>
</ul>
<h3 id="那个延迟的时间如何设置呢？"><a href="#那个延迟的时间如何设置呢？" class="headerlink" title="那个延迟的时间如何设置呢？"></a>那个延迟的时间如何设置呢？</h3><image src="https://oscimg.oschina.net/oscnet/up-5933d7b1310c191603f366eb55669a7cdc8.png" width=400 height=250>

<p>上面👆是Linux操作系统对于TCP延时的定义。</p>
<p>HZ是什呢？其实那是和操作系统的时钟相关的，具体的操作系统间各有差别；<br>如何查看Linux操作系统下的HZ如何设置呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /boot/config- `-uname -r` | grep &#x27;^GONFIG_HZ=&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h2><blockquote>
<p>sendfile 零拷贝技术</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-拥塞控制之慢启动</title>
    <url>/wiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>由于TCP是面向字节流的传输协议，可以发送不定长的字节流数据，TCP连接发送数据时会“先天性”尝试占用整个带宽，而当所有的TCP连接都尝试占用网络带宽时，就会造成网络的堵塞，而TCP慢启动算法则是为了解决这一场景；</p>
<h2 id="全局思考"><a href="#全局思考" class="headerlink" title="全局思考"></a>全局思考</h2><img src="https://oscimg.oschina.net/oscnet/up-b70475e1aadd0776c54efdd5ecf26ef2606.png" width=700 height=400>

<p>拥塞控制要面向整体思考，如上👆网络拓扑图，当左边的网络节点通过路由交换设备向右边的设备传输报文的时候，中间的某一链路的带宽肯定是一定的，这里假设1000M带宽，当左边R1以700Mb/s的速度向链路中发送数据，同时R2以600Mb/s的速率发送报文，那势必会有300Mb的数据报丢失；「路由交换设备基于存储转发来实现报文的发送」大量报文都是时，路由设备的缓冲队列肯定是慢的，这也会造成某些数据报在网络链路中停留时间过长，从而导致TCP通讯变慢，甚至网络瘫痪；</p>
<p>理想的情况下，当链路带宽占满以后，链路以最大带宽传输数据，当然显示中是不可能的，当发生轻度拥塞时，链路的吞吐量就开始下降了，发展到严重阻塞时，链路的吞吐量会严重地下降，甚至瘫痪；</p>
<p>那么，慢启动是如何发挥作用的呢？</p>
<h2 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h2><blockquote>
<p>拥塞窗口cwnd(congestion window)</p>
</blockquote>
<ul>
<li>通告窗口rwnd(receiver‘s advertised window) <blockquote>
<p>其实就是RCV.WND，标志在TCP首部的Window字段！</p>
</blockquote>
</li>
<li>发送窗口swnd = min(cwnd，rwnd)<blockquote>
<p>前面学习滑动窗口的时候提到发送窗口大致等于接受窗口，当引入拥塞窗口时，发送窗口就是拥塞窗口和对方接受窗口的最小值</p>
</blockquote>
</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-4fffa8af1fb99c1ce534085f112fa9f065c.png" width=360 height=360>

<blockquote>
<p>每收到一个ACK，cwnd扩充一倍</p>
</blockquote>
<p>慢启动的窗口大小如何设置呢？<br>如上所示，起初拥塞窗口设置成1个报文段大小，当发送端发送一个报文段并且没有发生丢包时，调整拥塞窗口为2个报文段大小，如果还没有发生丢包，一次类推，知道发生丢包停止；发送窗口以「指数」的方式扩大；慢启动是无法确知网络拥塞程度的情况下，以试探性地方式快速扩大拥塞窗口；</p>
<h2 id="慢启动初始窗口"><a href="#慢启动初始窗口" class="headerlink" title="慢启动初始窗口"></a>慢启动初始窗口</h2><p>慢启动的拥塞窗口真的就如上面所说的以一个报文段大小作为初始值吗？  </p>
<img src="https://oscimg.oschina.net/oscnet/up-e632e6592fd276be90e5cf65a8365b3ddfb.png" width=360 height=360>  

<blockquote>
<p>慢启动初始窗口 IW(Initial Window)的变迁</p>
</blockquote>
<ul>
<li>1 SMSS:RFC2001(1997)</li>
<li>2 - 4 SMSS:RFC2414(1998)<blockquote>
<p>IW = min (4<em>SMSS, max (2</em>SMSS, 4380 bytes))</p>
</blockquote>
</li>
<li>10 SMSS:RFC6928(2013)<blockquote>
<p>IW = min (10<em>MSS, max (2</em>MSS, 14600))</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>其实在实际情况下，互联网中的网页都在10个mss左右，如果还是从1个mss开始，则会浪费3个RTT的时间；  </p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-滑动窗口</title>
    <url>/wiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote>
<p>之前学习了PAR方式的TCP超时和重传，其实在考虑发送方发送数据报的同时，也应该考虑接收方对于数据的处理能力，由此引出本次学习的主题 – 滑动窗口</p>
</blockquote>
<h2 id="发送端窗口"><a href="#发送端窗口" class="headerlink" title="发送端窗口"></a>发送端窗口</h2><p>滑动窗口按照传输数据方向分为两种，发送端窗口和接收端窗口；下面先看一下发送端窗口👇：</p>
<image src="https://oscimg.oschina.net/oscnet/up-13e77c53892b884d334614e4fa9550a1113.png">

<p>上图分为四个部分：</p>
<ol>
<li>已发送并收到 Ack 确认的数据:1-31 字节</li>
<li>已发送未收到 Ack 确认的数据:32-45 字节</li>
<li>未发送但总大小在接收方处理范围内:46-51 字节</li>
<li>未发送但总大小超出接收方处理范围:52-字节</li>
</ol>
<h3 id="可用窗口和发送窗口"><a href="#可用窗口和发送窗口" class="headerlink" title="可用窗口和发送窗口"></a>可用窗口和发送窗口</h3><image src="https://oscimg.oschina.net/oscnet/up-b8bb072922232fe6d62aec3520647d869fe.png"> 

<p>如上图这里可以引出两个概念：「可用窗口」和「发送窗口」</p>
<blockquote>
<p>【 <strong>可用窗口</strong> 】： 就是上图中的第三部分，属于还未发送，但是在接收端可以处理范围内的部分；<br>【 <strong>发送窗口</strong> 】： 就是发送端可以发送的最大报文大小，如上图中的第二部分+第三部分合成发送窗口；</p>
</blockquote>
<h3 id="可用窗口耗尽"><a href="#可用窗口耗尽" class="headerlink" title="可用窗口耗尽"></a>可用窗口耗尽</h3><image src="https://oscimg.oschina.net/oscnet/up-333b88e14f6fd5833fd92a9ab45894e60dd.png"> 

<p>可用窗口会在一个短暂的停留，当处于未发送并且接受端可以接受范围内的数据传输完成之后，可用窗口耗尽；<br>当然上面仅仅说的一瞬时的状态，这个状态下，已经发送的报文段还没有确认，并且发送窗口大小没有发生变化，此时发送窗口达到最大状态；</p>
<h3 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h3><image src="https://oscimg.oschina.net/oscnet/up-4436cdb5c6720e3e4a262ec1cad64660a77.png">  

<p>如果在发送窗口中已经发送的报文段已经得到接受端确认之后，那部分数据就会被移除发送窗口，在发送窗口大小不发生变化的情况下，发送窗口向右➡️移动5个字节，因为左边已经发送的5个字节得到确认之后，被移除发送窗口；</p>
<h3 id="可用窗口如何计算"><a href="#可用窗口如何计算" class="headerlink" title="可用窗口如何计算"></a>可用窗口如何计算</h3><image src="https://oscimg.oschina.net/oscnet/up-76f97fc92f6940c7197ff9fcad3c187fd98.png">

<p>再次引出三个概念：</p>
<ul>
<li>SND.WND<blockquote>
<p>SND 指的是发送端，WND指的是window，也就是发送端窗口的意思</p>
</blockquote>
</li>
<li>SND.UNA<blockquote>
<p>UNA 就是un ACK的意思，指的是已经发送但是没有没有确认 它指向窗口的第一个字节处</p>
</blockquote>
</li>
<li>SND.NXT<blockquote>
<p>NXT 是next的位置，是发送方接下来要发送的位置，它指向可用窗口的第一个字节处</p>
</blockquote>
</li>
</ul>
<p><strong>那就很容易得出可用窗口的大小了，计算公式如下：</strong></p>
<blockquote>
<p>Usable Window Size = SND.UNA + SND.WND - SND.NXT </p>
</blockquote>
<h2 id="接收端窗口"><a href="#接收端窗口" class="headerlink" title="接收端窗口"></a>接收端窗口</h2><p>上面介绍了发送端窗口的一些概念，下面👇是接收端窗口的学习：</p>
<image src="https://oscimg.oschina.net/oscnet/up-0313775eaecc790ad26b44c3daa17ced593.png">

<ol>
<li>已经接收并且已经确认 :28-31 字节</li>
<li>还未接收并且接收端可以接受:32-51 字节</li>
<li>还未接收并且超出接收处理能力:51-57 字节</li>
</ol>
<p>这里引出两个概念：</p>
<ul>
<li>RCV.WND<blockquote>
<p>RCV是接收端的意思，WND是接受端窗口的大小</p>
</blockquote>
</li>
<li>RCV.NXT<blockquote>
<p>NXT表示的是接受端接收窗口的开始位置，也就是接收方接下来处理的第一个字节；</p>
</blockquote>
</li>
</ul>
<p>RCV.WND的大小接受端的内存以及缓冲区大小有关，在某种意义上说，接受端的窗口大小和发送端大小大致相同；<br>接受端可接收的数据能力可以通过TCP首部的Window字段设置，但是接受端的处理能力是可能随时变化的，所以接受端和服务端的窗口大小大致是一样的；</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>下面👇根据一个例子来阐述流量控制，模拟一个GET请求，客户端向服务端请求一个260字节的文件，大致流程如下，比较繁琐：</p>
<image src="https://oscimg.oschina.net/oscnet/up-08e7b2cd9ee3ddaa44bca900a1824e08b09.png" width=900 height=480> 

<blockquote>
<p>这里假设MSS和窗口的大小不发生变化，同时客户端和发送端状态如下：<br>【 客户端 】： 发送窗口默认360字节 接收窗口设定200字节<br>【 服务端 】： 发送窗口设定200字节 接收窗口设定360字节</p>
</blockquote>
<p>Step1： 客户端发送140字节的数据到服务端</p>
<blockquote>
<p>【客户端】发送140字节，【SND.NXT】从1-&gt;141 </p>
</blockquote>
<blockquote>
<p>【服务端】状态不变，等待接收客户端传输的140字节</p>
</blockquote>
<p>Step2: 服务端接收140字节，发送80字节响应以及ACK</p>
<blockquote>
<p>【 客户端 】发送140字节之后等待【 服务端 】的ACK</p>
</blockquote>
<blockquote>
<p>【 服务端 】可用窗口右移，【RCV.NXT】从1-&gt;141<br>【 服务端 】发送80字节数据，【SND.NXT】从241-&gt;321</p>
</blockquote>
<p>Step3: 客户端接收响应ACK，并且发送ACK </p>
<blockquote>
<p>【 客户端 】发出的140字节得到确认，【SND.UNA】右移140字节<br>【 客户端 】接收80字节数据，【RCV.NXT】右移80字节，从241-&gt;321</p>
</blockquote>
<p>Step4: 服务端发送一个280字节的文件，但是280字节超出了客户端的接收窗口，所以客户端分成两部分传输，先传输120字节；</p>
<blockquote>
<p>【 服务端 】发送120字节，【SND.NXT】向右移动120字节，从321-&gt;441</p>
</blockquote>
<p>Step5: 客户端接收文件第一部分，并发送ACK</p>
<blockquote>
<p>【 客户端 】接收120字节，【RCV.NXT】从321-&gt;441</p>
</blockquote>
<p>Step6：服务端接收到第二步80字节的ACK</p>
<blockquote>
<p>[ 服务器 ] 80字节得到ACK 【SND.UNA】从241-&gt;321</p>
</blockquote>
<p>Step7: 服务端接收到第4步的确认</p>
<blockquote>
<p>【 服务端 】之前发送文件第一部分的120字节得到确认，【SND.UNA】右移动120，从321-&gt;441</p>
</blockquote>
<p>Step8: 服务端发送文件第二部分的160字节</p>
<blockquote>
<p>【 服务端 】： 发送160字节，【SND.NXT】向右移动160字节，从441-&gt;601</p>
</blockquote>
<p>Step9: 客户端接收到文件第二部分160字节，同时发送ACK</p>
<blockquote>
<p>【 客户端 】接收160字节，【RCV.NXT】向右移动160字节，从441-&gt;601</p>
</blockquote>
<p>Step10: 服务端收到文件第二部分的ACK</p>
<blockquote>
<p>【 服务端 】发送的160字节得到确认，【SND.UNA】向右一定160字节，从441-&gt;601；至此客户端收到服务端发送的完整的文件；</p>
</blockquote>
<p>上面通过表格列举服务端和客户端每个状态在每个步骤的状态，如果不是很好理解，可以看如下示意图辅助理解：</p>
<h3 id="客户端交互流程"><a href="#客户端交互流程" class="headerlink" title="客户端交互流程"></a>客户端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-6ee487f0677efac1a822207f45fc0a2b842.png" width=500 >

<h3 id="服务端交互流程"><a href="#服务端交互流程" class="headerlink" title="服务端交互流程"></a>服务端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-4a0095fb6e7a82a708e4df96dfdacd956aa.png" width="500"> 

<p>上面👆是模拟一个GET请求，服务端发送一个280字节的文件给到客户端，客户端的接收窗口是200字节场景加，客户端和服务端的数据传输与交互流程，通过这个流程来学习滑动窗口的移动状态和流量控制的大致流程；</p>
<h2 id="滑动窗口与操作系统缓冲区"><a href="#滑动窗口与操作系统缓冲区" class="headerlink" title="滑动窗口与操作系统缓冲区"></a>滑动窗口与操作系统缓冲区</h2><p>上面👆讲述的时候，都是假设窗口大小是不变的，而实际上，发送端和接受端的滑动窗口的字节数都吃存储在操作系统缓冲区的，操作系统的缓冲区受操作系统控制，当应用进程增加是，每个进程分配的内存减少，缓冲区减少，分配给每个连接的窗口就会压缩。**<font color="red">而且滑动窗口的大小也受应用进程读取缓冲区数据速度有关</font>**；</p>
<image src="https://oscimg.oschina.net/oscnet/up-3839118daafc840e059fa6f82d283bef7a9.png" width="500">   

<h3 id="应用进程读取缓冲区数据不及时造成窗口收缩"><a href="#应用进程读取缓冲区数据不及时造成窗口收缩" class="headerlink" title="应用进程读取缓冲区数据不及时造成窗口收缩"></a>应用进程读取缓冲区数据不及时造成窗口收缩</h3><p>step1: 客户端发送140字节</p>
<blockquote>
<p>客户端发送到140字节之后，可用窗口收缩到220字节，发送窗口不变</p>
</blockquote>
<p>Step2: 服务端接收140字节 但是应用进程仅仅读取40字节</p>
<blockquote>
<p>服务端应用进程仅仅读取40字节，仍有100字节占用缓冲区大小，导致接受窗口收缩，服务端发送ACK报文时，在首部Window带上接收窗口的大小260</p>
</blockquote>
<p>Step3: 客户端收到确认报文之后，发送窗口收缩到260</p>
<p>Step4: 客户端继续发送180字节数据</p>
<blockquote>
<p>客户端发送180字节之后，可用窗口变成80字节</p>
</blockquote>
<p>Step5: 服务端接收到180字节</p>
<blockquote>
<p>假设应用程序仍然不读取这180字节，最终也导致服务端接收窗口再次收缩180字节，仅剩下80字节，在发送确认报文时，设置首部window=80</p>
</blockquote>
<p>Step6: 客户端收到80字节的窗口时，调整发送窗口大小为80字节，可用窗口也是80字节</p>
<p>Step7: 客户端仍然发送80字节到服务端，此时可用窗口为空</p>
<p>Step8: 服务端应用进程继续不读区这80字节的缓冲区数据，最终导致服务端接收窗口大小为0，不能再接收任何数据，同时发送ACK报文；</p>
<p>Step9：客户端收到确认报文之后，调整发送窗口大小为0，这个状态叫做「 <strong>窗口关闭</strong> 」</p>
<h3 id="窗口收缩导致的丢包"><a href="#窗口收缩导致的丢包" class="headerlink" title="窗口收缩导致的丢包"></a>窗口收缩导致的丢包</h3><image src="https://oscimg.oschina.net/oscnet/up-174e19d4d8de9757707034b8271cb3c69a7.png" width="530">

<p>Step1：客户端服务端开始的窗口大小都是360字节，客户端发送140字节数据</p>
<blockquote>
<p>客户端发送140字节之后，可用窗口变成220字节</p>
</blockquote>
<p>Step2：服务端应用进程骤增，进程缓存区平均分配，造成服务端接收窗口减少，从360变成240字节；</p>
<blockquote>
<p>假设接收了140字节之后，应用进程没有读取，那个可用窗口进一步压缩，变成100字节；</p>
</blockquote>
<p>Step3：假设同一个连接在没有收到服务端确认之后，又发送了180个字节的数据（Retramission）</p>
<blockquote>
<p>先发送了140字节，后发送了180字节，都没有得到确认，客户端可用窗口大小变成40字节</p>
</blockquote>
<p>Step4：服务端收到上面👆第三步发送的180字节的数据，但是接受窗口的大小只有100字节，所以不能接收</p>
<blockquote>
<p>服务端拒绝接收180字节</p>
</blockquote>
<p>Step5：此时客户端才收到之前140字节的确认报文，才知道接收窗口发生了变化</p>
<blockquote>
<p>客户端由于没有收到180字节的确认，加入客户端正在准备发送180字节数据，得到接受端的窗口大小是100字节之后，须强制将右侧窗口向左收缩80字节；</p>
</blockquote>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>这个例子和上面的例子都发生了「 <strong><font color="red">窗口关闭</font></strong> 」</p>
<blockquote>
<p>窗口关闭： 发送端的发送窗口变成0的状态；</p>
</blockquote>
<p>上面讲的两种情况一般不会发生的，因为操作系统不会既收缩窗口，同时减少连接缓存；而是一般先使用窗口收缩策略，之后在压缩缓冲区的方式来规避以上问题；<br>发生窗口关闭之后，发送端不会被动的等待服务端的通知，而是会采用定时嗅探的方式去查看服务端接收窗口是否开放；</p>
<h2 id="Linux中对TCP缓冲区的调整方式"><a href="#Linux中对TCP缓冲区的调整方式" class="headerlink" title="Linux中对TCP缓冲区的调整方式"></a>Linux中对TCP缓冲区的调整方式</h2><ul>
<li><p>net.ipv4.tcp_rmem = 4096 87380 6291456</p>
<blockquote>
<p>读缓存最小值、默认值、最大值，单位字节，覆盖 net.core.rmem_max</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_wmem = 4096 16384 4194304</p>
<blockquote>
<p>写缓存最小值、默认值、最大值，单位字节，覆盖net.core.wmem_max</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_mem = 1541646 2055528 3083292</p>
<blockquote>
<p>系统无内存压力、启动压力模式阀值、最大值，单位为页的数量</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_moderate_rcvbuf = 1 </p>
<blockquote>
<p>开启自动调整缓存模式</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手</title>
    <url>/wiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h2 id="握手🤝的目的"><a href="#握手🤝的目的" class="headerlink" title="握手🤝的目的"></a>握手🤝的目的</h2><ul>
<li>同步Sequence序列号<blockquote>
<p>初始化序<br>列号ISN （Inital Sequence Number）</p>
</blockquote>
</li>
<li>交换TCP通讯的参数<blockquote>
<p>比如最大报文段参数（MSS）、窗口比例因子（Window）、选择性确认（SACK）、制定校验和算法；</p>
</blockquote>
</li>
</ul>
<h2 id="三次握手握手过程"><a href="#三次握手握手过程" class="headerlink" title="三次握手握手过程"></a>三次握手握手过程</h2><image src="https://oscimg.oschina.net/oscnet/up-7ee7a8388d0fc3798344cad07f585bf7961.png" width=500 height=300>

<p>TCP三次握手的大致流程图如上👆  </p>
<p>使用tcpdump抓包分析三次🤝握手报文中Seq和Ack的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump  port 80 -c 3 -S</span><br></pre></td></tr></table></figure>
<p><img src="https://sjwx.easydoc.xyz/47754217/files/kmov1k44.png" alt="image.png">  </p>
<h3 id="第一次握手🤝"><a href="#第一次握手🤝" class="headerlink" title="第一次握手🤝"></a>第一次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [S], seq 3800409106, win 29200, options [mss 1460,sackOK,TS val 839851765 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>
<p>客户端upay访问服务端80端口，发送一个「 seq=3800409106 」 ，同时标志位SYN=1，声明此次握手是要建立连接；</p>
<h3 id="第二次握手🤝"><a href="#第二次握手🤝" class="headerlink" title="第二次握手🤝"></a>第二次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 100.100.15.23.http &gt; upay.60734: Flags [S.], seq 1981710286, ack 3800409107, win 14600, options [mss 1440,nop,nop,sackOK,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>
<p>第二次握手，服务端收到客户端的申请连接强求（SYN=1）之后，在服务端自己准备好的情况下，给客户端发送 「 ACK=1 SYN=1 」的确认报文，SYN=1同样也是声明此次报文是建立连接的报文请求； ack= 3800409107 也就是第一个客户端发给服务端的seq+1（ack是接收方下次期望接口报文的开始位置）</p>
<h3 id="第三次握手握手"><a href="#第三次握手握手" class="headerlink" title="第三次握手握手"></a>第三次握手握手</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [.], ack 1981710287, win 229, length 0</span><br></pre></td></tr></table></figure>
<p>客户端收到服务器返回的确认报文，确认可以进行连接，发送「 ack = 1981710287 」的确认报文，之后就完成了三次握手，TCP的连接就创建成功了，接下来双方就可以发送数据报了；</p>
<h2 id="TCP连接创建构成中状态的变更"><a href="#TCP连接创建构成中状态的变更" class="headerlink" title="TCP连接创建构成中状态的变更"></a>TCP连接创建构成中状态的变更</h2><image src="https://oscimg.oschina.net/oscnet/up-d6920a59ec1cb6a738265b6f182cbdbe2ba.png" width=550 height=400>

<ul>
<li>首先客户端和服务端都是【CLOSED】状态，客户端发起连接请求之后，进入【SYN-SENT】状态，这个状态维持的时间很短，我们使用netstat去查看tcp连接状态的时候，基本上都不会看到这个状态，而服务端是在【LISTEN】状态，等待客户端的请求；</li>
<li>服务端收到客户端请求之后，发送「SYN ACK」确认报文，同时服务端进入【SYN-RECEIVED】状态，等待客户端的确认报文；</li>
<li>客户端收到服务端的同步确认请求之后，发送「ACK」确认报文，同时进入【ESTABLISHED】状态，准备后续的数据传输；</li>
<li>服务端收到三次握手最后的确认报文之后，进入【ESTABLISHED】状态，至此，一个TCP连接算是建立完成了，后面就是双方的通信了；</li>
</ul>
<h2 id="TCB（Transmission-Control-Block）"><a href="#TCB（Transmission-Control-Block）" class="headerlink" title="TCB（Transmission Control Block）"></a>TCB（Transmission Control Block）</h2><blockquote>
<p>保存连接使用的源端口、目的端口、目的 ip、序号、 应答序号、对方窗口大小、己方窗口大小、tcp 状态、tcp 输入/输出队列、应用层输出队 列、tcp 的重传有关变量等</p>
</blockquote>
<h2 id="TCP性能优化和安全问题"><a href="#TCP性能优化和安全问题" class="headerlink" title="TCP性能优化和安全问题"></a>TCP性能优化和安全问题</h2><image src="https://oscimg.oschina.net/oscnet/up-e99592d430e1219134af66e69aee2e6ccbd.png"  width=550 height=400 >

<p>正如我们了解的TCP三次握手🤝的流程，当有大量SYN请求到达服务端时，会进入到【SYN队列】，服务端收到第二次确认报文之后，会进入【ESTABLISHED】状态，服务端操作系统内核会将连接放入到【ACCEPT】队列中，当Nginx或者Tomcat这些应用程序在调用accept（访问内核）的时候，就是在【ACCEPT】队列中取出连接进行处理；</p>
<blockquote>
<p>由此可见，【SYN】队列和【ACCEPT】是会影响服务器连接性能的重要因素，所以对于高并发的场景下，这两个队列一定是要设置的比较大的；</p>
</blockquote>
<h3 id="如何设置SYN队列大小"><a href="#如何设置SYN队列大小" class="headerlink" title="如何设置SYN队列大小"></a>如何设置SYN队列大小</h3><p>服务器端 SYN_RCV 状态</p>
<ul>
<li>net.ipv4.tcp_max_syn_backlog:SYN_RCVD 状态连接的最大个数</li>
<li>net.ipv4.tcp_synack_retries:被动建立连接时，发SYN/ACK的重试次数</li>
</ul>
<p>客户端 SYN_SENT 状态（服务端作为客户端，比如Ngnix转发等）</p>
<ul>
<li>net.ipv4.tcp_syn_retries = 6 主动建立连接时，发 SYN 的重试次数</li>
<li>net.ipv4.ip_local_port_range = 32768 60999 建立连接时的本地端口可用范围</li>
</ul>
<h2 id="Fast-Open机制"><a href="#Fast-Open机制" class="headerlink" title="Fast Open机制"></a>Fast Open机制</h2><image src="https://oscimg.oschina.net/oscnet/up-071f997614b36eb8b4511db0f3ba0637d70.png" width=550 height=400 >

<p>TCP如何对连接的次数以及连接时间进行优化的呢？这里提到Fast Open机制；<br>比如我们有一个Http Get请求，正常的三次握手🤝到收到服务端数据需要2个RTT的时间；FastOpen做出如下优化：</p>
<ul>
<li>第一次创建连接的时候，也是要经历2个RTT时间，但是在服务端发送确认报文的时候，在报文中添加一个cookie；</li>
<li>等到下次客户端再需要创建请求的时候，直接将【SYN】和cookie一并带上，可以一次就创建连接，经过一个RTT客户端就可以收到服务端的数据；</li>
</ul>
<h4 id="如何Linux上打开TCP-Fast-Open"><a href="#如何Linux上打开TCP-Fast-Open" class="headerlink" title="如何Linux上打开TCP Fast Open"></a>如何Linux上打开TCP Fast Open</h4><p> net.ipv4.tcp_fastopen:系统开启 TFO 功能 </p>
<ul>
<li>0:关闭</li>
<li>1:作为客户端时可以使用 TFO</li>
<li>2:作为服务器时可以使用 TFO</li>
<li>3:无论作为客户端还是服务器，都可以使用 TFO</li>
</ul>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><h4 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h4><p>  正常的服务通讯都是由操作系统内核实现的请求报文来创建连接的，但是，可以人为伪造大量不同IP地址的SYN报文，也就是上面👆状态变更图中的SYN请求，但是收到服务端的ACK报文之后，却不发送对于服务端的ACK请求，也就是没有第三次挥手，这样会造成大量处于【SYN-RECEIVED】状态的TCP连接占用大量服务端资源，导致正常的连接无法创建，从而导致系统崩坏；</p>
<h4 id="SYN攻击如何查看"><a href="#SYN攻击如何查看" class="headerlink" title="SYN攻击如何查看"></a>SYN攻击如何查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nap | grep SYN_RECV</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果存在大量【SYN-RECEIVED】的连接，就是发生SYN攻击了；</p>
</blockquote>
<h4 id="如何规避SYN攻击？"><a href="#如何规避SYN攻击？" class="headerlink" title="如何规避SYN攻击？"></a>如何规避SYN攻击？</h4><ul>
<li><p><strong>net.core.netdev_max_backlog</strong></p>
<blockquote>
<p>接收自网卡、但未被内核协议栈处理的报文队列长度</p>
</blockquote>
</li>
<li><p><strong>net.ipv4.tcp_max_syn_backlog</strong></p>
<blockquote>
<p>SYN_RCVD 状态连接的最大个数</p>
</blockquote>
</li>
<li><p><strong>net.ipv4.tcp_abort_on_overflow</strong></p>
<blockquote>
<p>超出处理能力时，对新来的 SYN 直接回包 RST，丢弃连接</p>
</blockquote>
</li>
<li><p>设置SYN Timeout</p>
<blockquote>
<p>由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下，可以成倍的降低服务器的负荷。但过低的SYN Timeout设置可能会影响客户的正常访问。</p>
</blockquote>
</li>
<li><p>设置SYN Cookie (net.ipv4.tcp_syncookies = 1)</p>
<blockquote>
<p>就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，并记录地址信息，以后从这个IP地址来的包会被一概丢弃。这样做的结果也可能会影响到正常用户的访问。</p>
</blockquote>
</li>
</ul>
<image src="https://oscimg.oschina.net/oscnet/up-8cce8662408ffa1f5ed678be972248b92ca.png" width=800 height=350>

<p>当 SYN 队列满后，新的 SYN 不进入队列，计算出 cookie 再 以 SYN+ACK 中的序列号返回客户端，正常客户端发报文时， 服务器根据报文中携带的 cookie 重新恢复连接</p>
<blockquote>
<p>由于 cookie 占用序列号空间，导致此时所有 TCP 可选 功能失效，例如扩充窗口、时间戳等</p>
</blockquote>
<h2 id="TCP-DEFER-ACCEPT"><a href="#TCP-DEFER-ACCEPT" class="headerlink" title="TCP_DEFER_ACCEPT"></a>TCP_DEFER_ACCEPT</h2><p>这个是做什么呢？ 正如上面👆操作系统内核展示图所示，内核中维护两个队列【SYN】队列和【ACCEPT】队列，只有当收到客户端的ACK报文之后，连接会进入到【ACCEPT】，同时服务器的状态是<br>【ESTABLISHED】状态，此时操作系统并不会去激活应用进程，而是会等待，知道收到真正的data分组之后，才会激活应用进程，这是为了提高应用进程的执行效率，避免应用进程的等待；</p>
<blockquote>
<p>TCP三次握手为什么不能是两次或者四次</p>
</blockquote>
<p>参见文章：<a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/wiki/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="TCP协议学习笔记📒"><a href="#TCP协议学习笔记📒" class="headerlink" title="TCP协议学习笔记📒"></a>TCP协议学习笔记📒</h2><blockquote>
<p>下面是本人在学习TCP协议的过程中，记录的笔记，按照学习的过程从前到后整理在这里！<br>可能会有很多的知识没有罗列，只是记录的大概框架，如果有问题或错误，欢迎指正！</p>
</blockquote>
<blockquote>
<p><a href="https://geekibli.github.io/wiki/TCP%E5%A4%B4%E9%83%A8/">1、TCP报文头部</a><br><a href="https://geekibli.github.io/wiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">2、TCP三次握手</a><br><a href="https://geekibli.github.io/wiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/">3、TCP最大报文段（MSS）</a><br><a href="https://geekibli.github.io/wiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/">4、TCP超时与重传</a><br><a href="https://geekibli.github.io/wiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/">5、RTO重传计时器的计算</a><br><a href="https://geekibli.github.io/wiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">6、滑动窗口</a><br><a href="https://geekibli.github.io/wiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/">7、提升网络效率</a><br><a href="https://geekibli.github.io/wiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/">8、TCP拥塞控制之慢启动</a><br><a href="https://geekibli.github.io/wiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/">9、TCP拥塞控制之拥塞避免</a><br><a href="https://geekibli.github.io/wiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/">10、快速重传与快速恢复</a><br><a href="https://geekibli.github.io/wiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/">11、四次挥手</a></p>
</blockquote>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><blockquote>
<p>敖丙Github整理的笔记 </p>
</blockquote>
<p>有大概10篇左右的文章，都是高质量的，原地址请点击着👉 <a href="https://github.com/AobingJava/JavaFamily">【Github】</a></p>
<blockquote>
<p>极客时间《Web协议详解与抓包实战》– 陶辉老师</p>
</blockquote>
<p>这门课程专门讲解网络协议的，包括Http/Https,TLS协议，TCP协议，IP协议等；</p>
<blockquote>
<p>《计算机网络 自顶向下方法》第7版</p>
</blockquote>
<p>很多名校计算机网络课程在使用的教材，非常权威！</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP头部</title>
    <url>/wiki/TCP%E5%A4%B4%E9%83%A8/</url>
    <content><![CDATA[<h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><ul>
<li>如何校验报文段是否损坏？ 如何CRC校验</li>
<li>seq和ack是如何计算的？ </li>
<li>tcp校验位都有那些？ 6个 分别是什么含义？</li>
<li>tcp如何计算首部长度？ 偏移量</li>
<li>TCP Retransmission 重传？ </li>
<li>tcp spurious retransmission 又是什么呢？ </li>
<li>tcp dup ack 是什么？</li>
<li>ack与ACK有什么区别？ 分别有什么作用？</li>
</ul>
<h2 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-d3e5715ff000040a0b18b2c9374d7e55f53.png">   </p>
<p>学习TCP协议首先要看一下它的报文段是如何组成的；TCP报文段组成由两部分，第一部分是报文头部，第二部分是数据部分；</p>
<p>先看一下报文头，也就是TCP首部的组成；</p>
<h3 id="16位端口"><a href="#16位端口" class="headerlink" title="16位端口"></a>16位端口</h3><p>16位端口号：告知主机该报文段是来自哪里（源端口Source Port）以及传给哪个上层协议或应用程序（目的端口Destination Port）的。<br>进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（比如DNS协议对应端口53，HTTP协议对应80，这些端口号可在/etc/services文件中找到）。  </p>
<h3 id="序列号（Seq）"><a href="#序列号（Seq）" class="headerlink" title="序列号（Seq）"></a>序列号（Seq）</h3><p>占32位，也就是4字节长度，序号范围自然也是是0~2^32-1。TCP是面向字节流的，TCP连接中传送的字节流中的每个字节都按顺序编号。整个要传送的字节流的起始序号必须要在连接建立时设置。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。   </p>
<p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。  </p>
<p>**这里存在一个疑问，第一次建立TCP连接的时候，网上一些博客上说seq是client随机生成的，也有的博客说是seq=1； 这里经过我抓包后，看到第一次创建TCP连接的时候，确实是1; **    </p>
<h3 id="确认应答号（Ack）"><a href="#确认应答号（Ack）" class="headerlink" title="确认应答号（Ack）"></a>确认应答号（Ack）</h3><p>Ack占32位，4个字节长度，表示期望收到对方下一个报文段的序号值。 用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。<br>TCP的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。  </p>
<p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。    </p>
<p>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。    </p>
<h3 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了TCP报文段的首部长度 ，它指出了TCP报文段的数据起始处距离TCP报文的起始处有多远。</p>
<blockquote>
<p>注意数据起始处和报文起始处的意思，上面👆已经写到，TCP报文段的组成有两部分，TCP报文首部和数据部分，偏移量记录的是报文段开始和数据开始的长度，也就是报文首部的长度；  </p>
</blockquote>
<p>一个数据偏移量 = 4 byte，由于4位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了TCP首部的最大长度。  </p>
<h3 id="保留Reserved"><a href="#保留Reserved" class="headerlink" title="保留Reserved"></a>保留Reserved</h3><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p>
<h3 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h3><p><img src="https://oscimg.oschina.net/oscnet/up-869702a0e6199a93eb3be514c04e28274a7.png"><br>标志位，一共有6个，分别占1位，共6位。 每一位的值只有 0 和 1，分别表达不同意思。 如上图是使用wireshard抓包展示截图；  </p>
<h4 id="ACK-Acknowlegemt-：确认序号有效"><a href="#ACK-Acknowlegemt-：确认序号有效" class="headerlink" title="ACK(Acknowlegemt)  ：确认序号有效"></a>ACK(Acknowlegemt)  ：确认序号有效</h4><blockquote>
<p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。  </p>
</blockquote>
<h4 id="RST-Reset-：重置连接"><a href="#RST-Reset-：重置连接" class="headerlink" title="RST(Reset)：重置连接"></a>RST(Reset)：重置连接</h4><blockquote>
<p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。 </p>
</blockquote>
<h4 id="SYN-SYNchronization-：发起了一个新连接"><a href="#SYN-SYNchronization-：发起了一个新连接" class="headerlink" title="SYN(SYNchronization)：发起了一个新连接"></a>SYN(SYNchronization)：发起了一个新连接</h4><blockquote>
<p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p>
</blockquote>
<h4 id="PSH-Push-推送"><a href="#PSH-Push-推送" class="headerlink" title="PSH (Push): 推送"></a>PSH (Push): 推送</h4><blockquote>
<p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。  </p>
</blockquote>
<h4 id="FIN：释放一个连接"><a href="#FIN：释放一个连接" class="headerlink" title="FIN：释放一个连接"></a>FIN：释放一个连接</h4><blockquote>
<p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p>
</blockquote>
<h3 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h3><p>占16位。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p>
<blockquote>
<p>例如，假如确认号是701，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。  </p>
</blockquote>
<h3 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h3><p>占16位。 由发送端填充，接收端对TCP报文段执行【CRC算法】，以检验TCP报文段在传输过程中是否损坏，如果损坏这丢弃。</p>
<p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p>
<h3 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p>
<p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><image src="https://oscimg.oschina.net/oscnet/up-e071765090a2bbf6a9944907b288c70cd4a.png" width="400">

<ul>
<li>每个选项开始是1字节kind字段，说明选项的类型</li>
<li>kind为0和1的选项，只占一个字节</li>
<li>其他kind后有一字节len，表示该选项总长度（包括kind和len）</li>
<li>kind为11，12，13表示tcp事务</li>
</ul>
<p><strong>下面是常用选项：</strong><br><image src="https://oscimg.oschina.net/oscnet/up-1043e2bd27321e5ae0bc13be398e989be3e.png" width=800 height=300></p>
<h3 id="MTU（最大传输单元）"><a href="#MTU（最大传输单元）" class="headerlink" title="MTU（最大传输单元）"></a>MTU（最大传输单元）</h3><p>MTU（最大传输单元）是【链路层】中的网络对数据帧的一个限制，以以太网为例，MTU 为 1500 个字节。一个IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装。IP 数据报的分片与重组是在网络层进完成的。</p>
<h3 id="MSS-（最大分段大小）"><a href="#MSS-（最大分段大小）" class="headerlink" title="MSS （最大分段大小）"></a>MSS （最大分段大小）</h3><p>MSS 是 TCP 里的一个概念（首部的选项字段中）。MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 协议在建立连接的时候通常要协商双方的 MSS 值，每一方都有用于通告它期望接收的 MSS 选项（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（需要减去 IP 数据包包头的大小 20Bytes 和 TCP 数据段的包头 20Bytes）所以如果用链路层以太网，MSS 的值往往为 1460。而 Internet 上标准的 MTU 为 576，那么如果不设置，则MSS的默认值就为 536 个字节。TCP报文段的分段与重组是在运输层完成的。</p>
<h2 id="seq和ack的计算逻辑"><a href="#seq和ack的计算逻辑" class="headerlink" title="seq和ack的计算逻辑"></a>seq和ack的计算逻辑</h2><image src="https://oscimg.oschina.net/oscnet/up-710a22f4e6b6c961662879fe2ac6000cca9.png" width=900 height=500> 


<h2 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/15754b4e9458">TCP协议中的seq/ack序号是如何变化的？</a><br><a href="https://www.jianshu.com/p/ef892323e68f">TCP协议详解</a><br><a href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP协议详解（一）：TCP头部结构</a><br><a href="https://blog.csdn.net/zuochao_2013/article/details/80561793">TCP和UDP报文头格式</a><br><a href="https://juejin.cn/post/6844903685563105293">TCP协议详解</a><br><a href="https://juejin.cn/post/6844904131342123022">吃透TCP协议</a>  </p>
<hr>
<p><strong>传送门</strong>    👇</p>
<p><a href="https://geekibli.github.io/wiki/TCP%E5%A4%B4%E9%83%A8/">1、TCP报文头部</a><br><a href="https://geekibli.github.io/wiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">2、TCP三次握手</a><br><a href="https://geekibli.github.io/wiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/">3、TCP最大报文段（MSS）</a><br><a href="https://geekibli.github.io/wiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/">4、TCP超时与重传</a><br><a href="https://geekibli.github.io/wiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/">5、RTO重传计时器的计算</a><br><a href="https://geekibli.github.io/wiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">6、滑动窗口</a><br><a href="https://geekibli.github.io/wiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/">7、提升网络效率</a><br><a href="https://geekibli.github.io/wiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/">8、TCP拥塞控制之慢启动</a><br><a href="https://geekibli.github.io/wiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/">9、TCP拥塞控制之拥塞避免</a><br><a href="https://geekibli.github.io/wiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/">10、快速重传与快速恢复</a><br><a href="https://geekibli.github.io/wiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/">11、四次挥手</a></p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP最大报文段（MSS）</title>
    <url>/wiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MSS产生的背景"><a href="#MSS产生的背景" class="headerlink" title="MSS产生的背景"></a>MSS产生的背景</h2><p>我们都知道TCP协议是运输在传输层的协议，它是面向【字节流】的传输协议；<br>它的上层，应用层传输的数据是无限制的，但是它的下层也就是网络层和链路层由于路由等转发设备有内存等限制是不可能无限制传输任何大小的报文的，它们一定会限制报文的长度，因此 <strong>TCP协议要完成的工作是将从应用层接受到的任意长度数据，切割成多个报文段，MSS就是如何切割报文段的依据。</strong></p>
<image src="https://oscimg.oschina.net/oscnet/up-004bb74a9d5648d949d9549219c677f568f.png" width=450 height=300>


<h2 id="什么是MSS"><a href="#什么是MSS" class="headerlink" title="什么是MSS"></a>什么是MSS</h2><p>MSS（Max Segment Size）：仅指 TCP 承载数据，不包含 TCP 头部的大小，参见 RFC879</p>
<h2 id="MSS-选择目的"><a href="#MSS-选择目的" class="headerlink" title="MSS 选择目的"></a>MSS 选择目的</h2><ul>
<li>尽量每个 Segment 报文段携带更多的数据，以减少头部空间占用比率 </li>
<li>防止 Segment 被某个设备的 IP 层基于 MTU 拆分<blockquote>
<p>IP层基于MTU的数据拆分是效率极差的，一个报文段丢失，所有的报文段都要重传</p>
</blockquote>
</li>
</ul>
<h2 id="MSS默认大小"><a href="#MSS默认大小" class="headerlink" title="MSS默认大小"></a>MSS默认大小</h2><blockquote>
<p>默认 MSS:536 字节(默认 MTU576 字节，20 字节 IP 头部，20 字节 TCP 头部)</p>
</blockquote>
<h2 id="MSS在什么时候使用"><a href="#MSS在什么时候使用" class="headerlink" title="MSS在什么时候使用"></a>MSS在什么时候使用</h2><blockquote>
<p>握手阶段协商 MSS 这个在TCP三次握手的文章中已经提及过了！</p>
</blockquote>
<h2 id="MSS-分类"><a href="#MSS-分类" class="headerlink" title="MSS 分类"></a>MSS 分类</h2><ul>
<li><strong>发送方最大报文段:</strong> <blockquote>
<p>SMSS:SENDER MAXIMUM SEGMENT SIZE</p>
</blockquote>
</li>
<li><strong>接收方最大报文段:</strong> <blockquote>
<p>RMSS:RECEIVER MAXIMUM SEGMENT SIZE</p>
</blockquote>
</li>
</ul>
<h2 id="在TCP常用选项中可以看到【MSS】的选项"><a href="#在TCP常用选项中可以看到【MSS】的选项" class="headerlink" title="在TCP常用选项中可以看到【MSS】的选项"></a>在TCP常用选项中可以看到【MSS】的选项</h2><image src="https://oscimg.oschina.net/oscnet/up-c1229634eb30eaa7391516cbee75258c9e1.png" width=750 height=420>


<h2 id="TCP流与报文段在数据传输中的状态"><a href="#TCP流与报文段在数据传输中的状态" class="headerlink" title="TCP流与报文段在数据传输中的状态"></a>TCP流与报文段在数据传输中的状态</h2><image src="https://oscimg.oschina.net/oscnet/up-1a0015bf7b4d8481a4e624b0920bbb43917.png" width=450 height=620>

<p>从上图可以看到，左边客户端在发送字节流数据给到右边客户端，客户端发送一个连续的字节流，会在TCP层按照MSS大小规定进行拆分成多个小的报文段，分别传送到另一个客户端或者其他的接收端；</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP超时与重传</title>
    <url>/wiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><image src="https://oscimg.oschina.net/oscnet/up-4f1230ee04f4c197dd5c6de167991878366.png" width=680 height=300>

<p>如上图👆所示，设备A向设备B发送消息，消息在网络中会由于各种各样的问题导致丢失，那么该如何解决上述问题呢？</p>
<h2 id="采用定时器重传"><a href="#采用定时器重传" class="headerlink" title="采用定时器重传"></a>采用定时器重传</h2><blockquote>
<p>PAR：Positive Acknowledgment with Retransmission</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-17f5567e452afb45cf18d01e62bdfa33f96.png" width=680 height=330>

<p><strong>最简单的思路是在发送方设置「 定时器 」：</strong></p>
<ul>
<li>当设备A发送第一条消息之后，在定时器规定的时间内，如果收到设备B的确认报文，则设备A继续发送下一个报文，同时定时器复位；</li>
<li>如果第一条消息发送时间超出了定时器规定的时间，则设备A将重新发送第一条消息，同时重新设置定时器；</li>
<li>这种方式是串型发送的，只有第一个消息发送成功之后，才可以发送下一条消息，「 <strong>效率极差</strong> 」；</li>
</ul>
<h2 id="并发能力PAR"><a href="#并发能力PAR" class="headerlink" title="并发能力PAR"></a>并发能力PAR</h2><blockquote>
<p>基于上述PAR效率低下的方式进行改造，在发送端采用并发+定时器的方式进行数据发送；</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-96114b57ac73a41915bea1a7d11e0145102.png" width=600 height="500">

<ul>
<li>首先设备A可以同时发送多个消息或者报文段，每个报文段具有一个标志字段【#XX】去标志唯一，每个报文段连接具有自己的定时器；</li>
<li>设备B规定时间内收到设备A发送的数据之后并且设备A得到设备B的确认之后，设备A将定时器清除</li>
<li>同PAR一样，设备B没有在规定的时间内发送确认报文，设备A将这个报文所对应的定时器复位，重新发送这个报文</li>
</ul>
<h3 id="并发发送带来的问题"><a href="#并发发送带来的问题" class="headerlink" title="并发发送带来的问题"></a>并发发送带来的问题</h3><p>采用并发的方式发送消息或者报文段固然提升了发送端的性能，但是发送端发送的消息可能接受端不能完全处理，<strong>这是双方报文处理速度或者效率不一致的问题</strong>；</p>
<p>所以对于接收端设备B，应该明确自己可能接受的数据量，并且在确认报文中同步到发送端设备A，设备A根据设备B的处理能力来调整发送数据的大小；也就是上图中的「 limit」；</p>
<h2 id="继续延伸"><a href="#继续延伸" class="headerlink" title="继续延伸"></a>继续延伸</h2><p>Sequment序列号和Ack序列号的设计理念或者设计初衷是「 <strong>解决应用层字节流的可靠发送</strong> 」 </p>
<ul>
<li>跟踪「应用层」的发送端数据是否送达</li>
<li>确定「接收端有序的」接收到「字节流」</li>
<li><strong>序列号的值针对的是字节而不是报文</strong> ⚠️⚠️⚠️</li>
</ul>
<blockquote>
<p>TCP的定位就是面向字节流的！</p>
</blockquote>
<h2 id="TCP序列号如何设计的"><a href="#TCP序列号如何设计的" class="headerlink" title="TCP序列号如何设计的"></a>TCP序列号如何设计的</h2><image src="https://oscimg.oschina.net/oscnet/up-f5f274ec300162985b9bef86ebd94f6a81e.png" width=450 height=450>

<p>通过TCP报文头我们可以知道，Sequment序列号包括32位长度；也就是说一个Sequment可以发送2的32次方个字节，大约4G的数量，Sequment就无法表示了，当传输的数据超过“4G”之后，如果这个连接依然要使用的话，Sequment会重新复用；Sequment复用会产生一个问题，也就是序列号回绕；👇</p>
<h2 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h2><blockquote>
<p>序列号回绕 (Protect Against Wrapped Sequence numbers)</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-4edfd2031f0ec6ebdaa23c497e18df359cd.png" width=800 height=380>


<ul>
<li>当一个连接要发送6G的数据是，A、B、C、D分别发送1G的数据，如果继续使用此连接，E下一次发送数据1G，Seq序列号复用，E报文段的序列号和A报文段的序列号表示相同</li>
<li>按照上面的逻辑继续发送数据，F报文段的Seq标志和B报文段的是一样的；</li>
<li>加入B报文段在发送过程中丢失了，直到接受端接收了F报文段的同时B报文段到达接受端，接受端该如何区分相同Seq序列号不同数据的报文段呢？</li>
<li>其实TCP解决这个问题很简单，就是在每个报文段上添加Tcp Timestamp时间戳，类似于版本号的理念；</li>
<li>接收端收到相同Seq序列号的报文段是可以根据时间戳来进行区分；</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>apache-flink-overview</title>
    <url>/wiki/apache-flink-overview/</url>
    <content><![CDATA[<img src="https://flink.apache.org/img/flink-header-logo.svg" width=300 height=300>

<h2 id="学习初衷"><a href="#学习初衷" class="headerlink" title="学习初衷"></a>学习初衷</h2><p>推荐系统数据需要实时处理，使用Apache Flink实时计算用户数据，分析用户行为，达到实时业务数据分析和实现业务相关推荐；</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li><a href="https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ashiamd.github.io</a></li>
<li><a href="https://www.bilibili.com/video/BV1qy4y1q728?p=11&spm_id_from=pageDriver">尚硅谷2021最新Java版Flink 武老师清华硕士，原IBM-CDL负责人</a></li>
<li><a href="https://flink.apache.org/">Apache Flink® — Stateful Computations over Data Streams</a></li>
<li><a href="https://flink.apache.org/zh/">Apache Flink® - 数据流上的有状态计算</a></li>
</ul>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql配置binlog</title>
    <url>/wiki/binlog%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="开启binlog"><a href="#开启binlog" class="headerlink" title="开启binlog"></a>开启binlog</h2><p>[mysqld]<br>log-bin=mysql-bin #添加这一行就ok<br>binlog-format=ROW #选择row模式<br>server_id=1 #配置mysql replaction需要定义，不能和canal的slaveId重复  </p>
<h2 id="查看binlog状态"><a href="#查看binlog状态" class="headerlink" title="查看binlog状态"></a>查看binlog状态</h2><p>mysql&gt; show variables like ‘binlog_format’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>show variables like ‘log_bin’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>canal同步es后部分字段为null</title>
    <url>/wiki/canal%E5%90%8C%E6%AD%A5es%E5%90%8E%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BAnull/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><img src="https://oscimg.oschina.net/oscnet/up-54f2fa4a9dfb35acb02b77c5c6bc8c84c0f.png" width=800 height=400>


<p>配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataSourceKey: defaultDS        # 源数据源的key, 对应上面配置的srcDataSources中的值</span><br><span class="line">destination: example            # cannal的instance或者MQ的topic</span><br><span class="line">groupId: g1 # 对应MQ模式下的groupId, 只会同步对应groupId的数据</span><br><span class="line">esMapping:</span><br><span class="line">  _index: rd_member_fans_info           # es 的索引名称</span><br><span class="line">  _type: _doc                   # es 的doc名称</span><br><span class="line">  _id: _id                      # es 的_id, 如果不配置该项必须配置下面的pk项_id则会由es自动分配</span><br><span class="line">#  pk: id                       # 如果不需要_id, 则需要指定一个属性为主键属性</span><br><span class="line">#  # sql映射</span><br><span class="line">  sql: &#x27;SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.create_time,t.update_time,t.`status` FROM rd_member_fans_info t&#x27;</span><br><span class="line">#  objFields:</span><br><span class="line">#    _labels: array:;           # 数组或者对象属性, array:; 代表以;字段里面是以;分隔的</span><br><span class="line">#    _obj: object               # json对象</span><br><span class="line">  etlCondition: &quot;where t.update_time&gt;=&#123;&#125;&quot; # etl 的条件参数</span><br><span class="line">  commitBatch: 3000 # 提交批大小</span><br></pre></td></tr></table></figure>

<p>⚠️ ⚠️<br>sql执行是没有问题的！</p>
<img src="https://oscimg.oschina.net/oscnet/up-24a77ccd81ae7be4c6d4434f3d1d28edea0.png" width=800 height=400>


<p>canal-adapter 获取binlog数据也没有问题，显示日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 15:39:24.588 [pool-1-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:3,&quot;redtom_id&quot;:1,&quot;fans_redtom_id&quot;:1,&quot;fans_username&quot;:&quot;1&quot;,&quot;fans_introduce&quot;:&quot;1&quot;,&quot;fans_avatar&quot;:&quot;1&quot;,&quot;is_each_following&quot;:1,&quot;follow_channel&quot;:1,&quot;create_time&quot;:1625556851000,&quot;update_time&quot;:1625556851000,&quot;status&quot;:2&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625557164000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;rd_member_fans_info&quot;,&quot;ts&quot;:1625557164587,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br></pre></td></tr></table></figure>


<p>然后看一下我创建索引的mapping<br><img src="https://oscimg.oschina.net/oscnet/up-8eac2e46423574ae04cd8694d2ac7389530.png" width=800 height=400>  </p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>调整sql如下： </p>
<p><code>SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.</code>status<code> as is_deleted , t.create_time,t.update_time FROM rd_member_fans_info t</code></p>
<p>调整了那些东西呢？     <code>status</code> 的顺序提前而已！</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行一下命令：<br><code>curl http://127.0.0.1:8081/etl/es7/rd_member_fans_info.yml -X POST</code></p>
<p>canal-adapter 日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 16:21:33.519 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member_fans_info</span><br><span class="line">2021-07-06 16:21:33.527 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - 数据全量导入完成, 一共导入 3 条数据, 耗时: 7</span><br></pre></td></tr></table></figure>

<p>查看es数据：</p>
<img src="https://oscimg.oschina.net/oscnet/up-69c4ac09e2b8fcd27a5b990e378664d6568.png" width=800 height=400>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>canal同步mysql数据到elasticsearch</title>
    <url>/wiki/canal%E5%90%8C%E6%AD%A5mysql%E6%95%B0%E6%8D%AE%E5%88%B0elasticsearch/</url>
    <content><![CDATA[<h2 id="首先安装elk"><a href="#首先安装elk" class="headerlink" title="首先安装elk"></a>首先安装elk</h2><p>推荐大家到elasic中文社区去下载 👉 <a href="https://elasticsearch.cn/">【传送】</a><br>⚠️ elastcisearch | logstash | kibana 的版本最好保持一直，否则会出现很多坑的，切记！</p>
<p>安装ELK的步骤这里就不做介绍了，可以查看 👉 【TODO】</p>
<h2 id="下载安装canal-adapter"><a href="#下载安装canal-adapter" class="headerlink" title="下载安装canal-adapter"></a>下载安装canal-adapter</h2><p>canal github传送门 👉  <a href="https://github.com/alibaba/canal">【Alibaba Canal】</a></p>
<h3 id="canal-client-模式"><a href="#canal-client-模式" class="headerlink" title="canal-client 模式"></a>canal-client 模式</h3><p>可以参照canal给出的example项目和<a href="https://github.com/alibaba/canal/wiki/ClientExample">官方文档</a>给出的例子来测试</p>
<h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h4><p>保证canal-server 已经正确启动 👈  然后启动下面服务，操作数据库即可看到控制台的日志输出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redtom.canal.deploy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/30 2:57 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanalClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;***.***.***.***&quot;</span>, <span class="number">11111</span>),</span><br><span class="line">                <span class="string">&quot;example&quot;</span>, <span class="string">&quot;canal&quot;</span>, <span class="string">&quot;canal&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            connector.connect();</span><br><span class="line">            <span class="comment">//订阅数据库表,全部表</span></span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            <span class="comment">//回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿</span></span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                Message message = connector.getWithoutAck(BATCH_SIZE);</span><br><span class="line">                <span class="comment">//获取批量ID</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="comment">//获取批量的数量</span></span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="comment">//如果没有数据</span></span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//线程休眠2秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果有数据,处理数据</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。</span></span><br><span class="line">                connector.ack(batchId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印canal server解析binlog获得的实体类信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;CanalEntry.Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="comment">//开启/关闭事务的实体类型，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RowChange对象，包含了一行数据变化的所有特征</span></span><br><span class="line">            <span class="comment">//比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等</span></span><br><span class="line">            CanalEntry.RowChange rowChage;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取操作类型：insert/update/delete类型</span></span><br><span class="line">            CanalEntry.EventType eventType = rowChage.getEventType();</span><br><span class="line">            <span class="comment">//打印Header信息</span></span><br><span class="line">            log.info(<span class="string">&quot;headers:&#123;&#125; &quot;</span>, String.format(<span class="string">&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line">            <span class="comment">//判断是否是DDL语句</span></span><br><span class="line">            <span class="keyword">if</span> (rowChage.getIsDdl()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;================》;isDdl: true,sql: &#123;&#125;&quot;</span>, rowChage.getSql());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取RowChange对象里的每一行数据，打印出来</span></span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="comment">//如果是删除语句</span></span><br><span class="line">                <span class="keyword">if</span> (eventType == CanalEntry.EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//如果是新增语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == CanalEntry.EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                    <span class="comment">//如果是更新的语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//变更前的数据</span></span><br><span class="line">                    log.info(<span class="string">&quot;-------&gt;; before&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//变更后的数据</span></span><br><span class="line">                    log.info(<span class="string">&quot;-------&gt;; after&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;CanalEntry.Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Column column : columns) &#123;</span><br><span class="line">            log.info(<span class="string">&quot; &#123;&#125; :  &#123;&#125;   update= &#123;&#125;&quot;</span>, column.getName(), column.getValue(), column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="canal-adapter-模式"><a href="#canal-adapter-模式" class="headerlink" title="canal-adapter 模式"></a>canal-adapter 模式</h3><p>adapter 配置文件如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span></span><br><span class="line"></span><br><span class="line"><span class="attr">canal.conf:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">tcp</span> <span class="comment">#tcp kafka rocketMQ rabbitMQ</span></span><br><span class="line">  <span class="attr">flatMessage:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">zookeeperHosts:</span></span><br><span class="line">  <span class="attr">syncBatchSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">batchSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">timeout:</span></span><br><span class="line">  <span class="attr">accessKey:</span></span><br><span class="line">  <span class="attr">secretKey:</span></span><br><span class="line">  <span class="attr">consumerProperties:</span></span><br><span class="line">    <span class="comment"># canal tcp consumer</span></span><br><span class="line">    <span class="attr">canal.tcp.server.host:</span> <span class="number">172.25</span><span class="number">.101</span><span class="number">.75</span><span class="string">:11111</span></span><br><span class="line">    <span class="attr">canal.tcp.zookeeper.hosts:</span></span><br><span class="line">    <span class="attr">canal.tcp.batch.size:</span> <span class="number">500</span></span><br><span class="line">    <span class="attr">canal.tcp.username:</span></span><br><span class="line">    <span class="attr">canal.tcp.password:</span></span><br><span class="line">  <span class="attr">srcDataSources:</span></span><br><span class="line">    <span class="attr">defaultDS:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://xxxx:pppp/database?useUnicode=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">pwd</span></span><br><span class="line">  <span class="attr">canalAdapters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">instance:</span> <span class="string">example</span> <span class="comment"># canal instance Name or mq topic name</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line">      <span class="attr">outerAdapters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logger</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">es7</span></span><br><span class="line">        <span class="attr">hosts:</span> <span class="number">172.25</span><span class="number">.101</span><span class="number">.75</span><span class="string">:9300</span> <span class="comment"># 127.0.0.1:9200 for rest mode</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">transport</span> <span class="comment"># or rest</span></span><br><span class="line"><span class="comment">#          # security.auth: test:123456 #  only used for rest mode</span></span><br><span class="line">          <span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment">#        - name: kudu</span></span><br><span class="line"><span class="comment">#          key: kudu</span></span><br><span class="line"><span class="comment">#          properties:</span></span><br><span class="line"><span class="comment">#            kudu.master.address: 127.0.0.1 # &#x27;,&#x27; split multi address</span></span><br></pre></td></tr></table></figure>

<p>我的elasticsearch是7.10.0版本的<br><code>application.yml  bootstrap.yml  es6  es7  hbase  kudu  logback.xml  META-INF  rdb</code><br>所以：👇</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd es7</span><br><span class="line">biz_order.yml  customer.yml  mytest_user.yml</span><br><span class="line">vim customer.yml</span><br></pre></td></tr></table></figure>

<p>customer.yml 配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dataSourceKey:</span> <span class="string">defaultDS</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">esMapping:</span></span><br><span class="line">  <span class="attr">_index:</span> <span class="string">customer</span></span><br><span class="line">  <span class="attr">_id:</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">relations:</span></span><br><span class="line">    <span class="attr">customer_order:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">customer</span></span><br><span class="line">  <span class="attr">sql:</span> <span class="string">&quot;select t.id, t.name, t.email from customer t&quot;</span></span><br><span class="line">  <span class="attr">etlCondition:</span> <span class="string">&quot;where t.c_time&gt;=&#123;&#125;&quot;</span></span><br><span class="line">  <span class="attr">commitBatch:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<h4 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `customer` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_serial` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `customer_order` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>


<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT customer</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_serial&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_time&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;customer_order&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;join&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;relations&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;customer&quot;</span>:<span class="string">&quot;order&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="测试canal-adapter同步效果"><a href="#测试canal-adapter同步效果" class="headerlink" title="测试canal-adapter同步效果"></a>测试canal-adapter同步效果</h4><h5 id="创建一条记录"><a href="#创建一条记录" class="headerlink" title="创建一条记录"></a>创建一条记录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:50:53.725 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;1&quot;,&quot;email&quot;:&quot;1&quot;,&quot;order_id&quot;:1,&quot;order_serial&quot;:&quot;1&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;1&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457053000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457053724,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;customer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;email&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;customer_order&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;customer&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:54:36.402 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;2&quot;,&quot;email&quot;:&quot;2&quot;,&quot;order_id&quot;:2,&quot;order_serial&quot;:&quot;2&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;2&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457275000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:[&#123;&quot;name&quot;:&quot;1&quot;,&quot;email&quot;:&quot;1&quot;,&quot;order_id&quot;:1,&quot;order_serial&quot;:&quot;1&quot;,&quot;customer_order&quot;:&quot;1&quot;&#125;],&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457276401,&quot;type&quot;:&quot;UPDATE&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果<br><img src="https://oscimg.oschina.net/oscnet/up-afadff417c35ecb74811967d8e1da10f134.png" width=700 height=400></p>
<h5 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:56:51.524 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;2&quot;,&quot;email&quot;:&quot;2&quot;,&quot;order_id&quot;:2,&quot;order_serial&quot;:&quot;2&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;2&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457411000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457411523,&quot;type&quot;:&quot;DELETE&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果<br><img src="https://oscimg.oschina.net/oscnet/up-7f49aeda581a547bf528b55bad6d0af27de.png" width=700 height=400></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/puhaiyang/article/details/100171395">使用canal client-adapter完成mysql到es数据同步教程(包括全量和增量)</a></li>
<li><a href="https://github.com/alibaba/canal/issues/1514">es 同步问题 #1514 Github issue</a></li>
<li><a href="https://www.bookstack.cn/read/canal-v1.1.4/f5f4adc96eefafe4.md">canal v1.1.4 文档手册</a></li>
<li><a href="https://www.bookstack.cn/read/canal-v1.1.4/63ebbe076bc97d0f.md">Sync es</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>copy_to参数</title>
    <url>/wiki/copy-to%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/custom-all.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 自定义 _all 字段</a></li>
<li><a href="https://doc.codingdict.com/elasticsearch/319/">Docs » Mapping parameters（映射参数） » Mapping(映射) » copy_to（合并参数）</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>cross-fields跨字段查询</title>
    <url>/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_cross_fields_queries.html#_cross_fields_queries">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » cross-fields 跨字段查询</a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>dis_max查询</title>
    <url>/wiki/dis-max%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>假设有个网站允许用户搜索博客的内容，以下面两篇博客内容文档为例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Quick brown rabbits&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown rabbits are commonly seen.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Keeping pets healthy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;My quick brown fox eats rabbits on a regular basis.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户输入词组 <code>Brown fox</code> 然后点击搜索按钮。事先，我们并不知道用户的搜索项是会在 title 还是在 body 字段中被找到，但是，用户很有可能是想搜索相关的词组。用肉眼判断，文档 2 的匹配度更高，因为它同时包括要查找的两个词：</p>
<p>现在运行以下 bool 查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们发现查询的结果是文档 1 的评分更高：</p>
<img src="https://oscimg.oschina.net/oscnet/up-fa805607436bd64629e31ea8ea574c330cf.png" width=920 height=450>  

<p>为了理解导致这样的原因，需要回想一下 bool 是如何计算评分的：</p>
<p>它会执行 should 语句中的两个查询。<br>加和两个查询的评分。<br>乘以匹配语句的总数。<br>除以所有语句总数（这里为：2）。</p>
<p>文档 1 的两个字段都包含 <code>brown</code> 这个词，所以两个 <code>match</code> 语句都能成功匹配并且有一个评分。文档 2 的 body 字段同时包含 <code>brown</code> 和 <code>fox</code> 这两个词，但 title 字段没有包含任何词。这样， body 查询结果中的高分，加上 title 查询中的 0 分，然后乘以二分之一，就得到比文档 1 更低的整体评分。</p>
<p>在本例中， title 和 body 字段是相互竞争的关系，所以就需要找到单个 最佳匹配 的字段。</p>
<p>如果不是简单将每个字段的评分结果加在一起，而是将 <code>最佳匹配</code> 字段的评分作为查询的整体评分，结果会怎样？这样返回的结果可能是： 同时 包含 <code>brown</code> 和 <code>fox</code> 的单个字段比反复出现相同词语的多个不同字段有更高的相关度。</p>
<h2 id="dis-max-查询"><a href="#dis-max-查询" class="headerlink" title="dis_max 查询"></a>dis_max 查询</h2><p>不使用 <code>bool</code> 查询，可以使用 <code>dis_max</code> 即分离 最大化查询 <code>（Disjunction Max Query）</code> 。分离（Disjunction）的意思是 或（or） ，这与可以把结合（conjunction）理解成 与（and） 相对应。分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回 ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到我们想要的结果为：<br><img src="https://oscimg.oschina.net/oscnet/up-f4e15cd66644b0031abe4757efdcfdd2886.png" width=900 height=450>  </p>
<h2 id="Top-level-parameters-for-dis-maxedit"><a href="#Top-level-parameters-for-dis-maxedit" class="headerlink" title="Top-level parameters for dis_maxedit"></a>Top-level parameters for dis_maxedit</h2><ul>
<li><code>queries</code><br>(Required, array of query objects) Contains one or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, Elasticsearch uses the highest relevance score.</li>
<li><code>tie_breaker</code><br>(Optional, float) Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses. Defaults to 0.0.</li>
</ul>
<p>You can use the tie_breaker value to assign higher relevance scores to documents that contain the same term in multiple fields than documents that contain this term in only the best of those multiple fields, without confusing this with the better case of two different terms in the multiple fields.</p>
<p>If a document matches multiple clauses, the dis_max query calculates the relevance score for the document as follows:</p>
<p>Take the relevance score from a matching clause with the highest score.<br>Multiply the score from any other matching clauses by the tie_breaker value.<br>Add the highest score to the multiplied scores.<br>If the tie_breaker value is greater than 0.0, all matching clauses count, but the clause with the highest score counts most.</p>
<p><code>dis_max</code>，只是取分数最高的那个query的分数而已，完全不考虑其他query的分数，这种一刀切的做法，可能导致在有其他query的影响下，score不准确的情况，这时为了使用结果更准确，最好还是要考虑到其他query的影响;<br>使用 <code>tie_breaker</code> 将其他query的分数也考虑进去, <code>tie_breaker</code> 参数的意义，将其他query的分数乘以<code>tie_breaker</code>，然后综合考虑后与最高分数的那个query的分数综合在一起进行计算，这样做除了取最高分以外，还会考虑其他的query的分数。<code>tie_breaker</code>的值，设置在在0~1之间，是个小数就行，没有固定的值</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_best_fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 最佳字段</a></li>
<li><a href="https://learnku.com/docs/elasticsearch73/7.3">Elasticsearch中文文档</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-dis-max-query.html">Elasticsearch Guide [7.x] » Query DSL » Compound queries » Disjunction max query</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compost安装mongodb</title>
    <url>/wiki/docker-compost%E5%AE%89%E8%A3%85mongodb/</url>
    <content><![CDATA[<blockquote>
<p>mongo 配置文件 -&gt; <a href="https://www.cnblogs.com/xibuhaohao/p/12580331.html">https://www.cnblogs.com/xibuhaohao/p/12580331.html</a></p>
</blockquote>
<h2 id="docker-compose-配置文件"><a href="#docker-compose-配置文件" class="headerlink" title="docker-compose  配置文件"></a>docker-compose  配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.4.7</span> <span class="comment">#根据需要选择自己的镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span> <span class="comment">#对外暴露停供服务的端口，正式生产的时候理论不用暴露。</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/db:/data/db</span> <span class="comment"># 挂载数据目录</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/log:/var/log/mongodb</span>  <span class="comment"># 挂载日志目录</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/config:/etc/mongo</span>  <span class="comment"># 挂载配置目录</span></span><br><span class="line">    <span class="comment"># command: --config /docker/mongodb/mongod.conf # 配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="按照上面👆配置文件设置目录"><a href="#按照上面👆配置文件设置目录" class="headerlink" title="按照上面👆配置文件设置目录"></a>按照上面👆配置文件设置目录</h2><p><code>/data/db/mongodb/data</code><br><code>ls -l</code><br><code>config  db  log</code></p>
<h2 id="mongo-配置文件"><a href="#mongo-配置文件" class="headerlink" title="mongo 配置文件"></a>mongo 配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Where and how to store data.</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/data/db/mongodb/data/db</span></span><br><span class="line">  <span class="attr">journal:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  engine:</span></span><br><span class="line"><span class="comment">#  mmapv1:</span></span><br><span class="line"><span class="comment">#  wiredTiger:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># where to write logging data.</span></span><br><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/data/db/mongodb/data/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network interfaces</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># how the process runs</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">  <span class="attr">timeZoneInfo:</span> <span class="string">/usr/share/zoneinfo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#security:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#operationProfiling:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#replication:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sharding:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Enterprise-Only Options:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#auditLog:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#snmp:</span></span><br></pre></td></tr></table></figure>

<p><code>bindIp: 0.0.0.0</code> 允许远程访问</p>
<h2 id="docker-compose启动mongo"><a href="#docker-compose启动mongo" class="headerlink" title="docker-compose启动mongo"></a>docker-compose启动mongo</h2><p><code>docker-compose up -d</code><br><code>docker ps</code></p>
<h2 id="进入docker"><a href="#进入docker" class="headerlink" title="进入docker"></a>进入docker</h2><p><code>docker ps</code><br><code>docker exec -it xxxxxxxxxx bash</code></p>
<h2 id="mongo创建数据库"><a href="#mongo创建数据库" class="headerlink" title="mongo创建数据库"></a>mongo创建数据库</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><code>mongo</code></p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p><code>show dbs</code></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>use wechat_spider</code>  然后 <code>db</code> 查看</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.createUser(</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">user</span>:&quot;wechat&quot;,</span><br><span class="line">       pwd:&quot;123456&quot;,</span><br><span class="line">       roles:[&#123;role:&quot;readWrite&quot;,db:&quot;wechat_spider&quot;&#125;]</span><br><span class="line">     &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<h2 id="Java客户端链接"><a href="#Java客户端链接" class="headerlink" title="Java客户端链接"></a>Java客户端链接</h2><h3 id="配置mvn"><a href="#配置mvn" class="headerlink" title="配置mvn"></a>配置mvn</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&#x27;wechat&#x27;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="comment">#      port: 3333</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">wechat_spider</span></span><br><span class="line"><span class="comment">#      host: 123.56.77.177</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">39.107</span><span class="number">.117</span><span class="number">.232</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/28 上午10:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;passenger&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContoller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Passenger passenger = <span class="keyword">new</span> Passenger();</span><br><span class="line">        passenger.setName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        passenger.setPassword(<span class="string">&quot;world1&quot;</span>);</span><br><span class="line">        passenger = mongoTemplate.insert(passenger);</span><br><span class="line">        <span class="keyword">if</span> (passenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>DataBase</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用手册</title>
    <url>/wiki/docker%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<blockquote>
<p><b>docker中文文档</b>  <a href="http://www.dockerinfo.net/document">http://www.dockerinfo.net/document</a><br><b>docker doc</b> <a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a><br><b>docker 中文社区</b> <a href="https://www.docker.org.cn/">https://www.docker.org.cn/</a></p>
</blockquote>
<h3 id="搜索可用镜像"><a href="#搜索可用镜像" class="headerlink" title="搜索可用镜像"></a>搜索可用镜像</h3><p><code>docker search tutorial</code></p>
<h3 id="检查运行的镜像"><a href="#检查运行的镜像" class="headerlink" title="检查运行的镜像"></a>检查运行的镜像</h3><p><code>docker inspect efe</code></p>
<h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p><code>docker push</code></p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p><code>docker pull</code></p>
<h3 id="在容器中安装新的程序"><a href="#在容器中安装新的程序" class="headerlink" title="在容器中安装新的程序"></a>在容器中安装新的程序</h3><p><code>apt-get update</code><br><code>apt-get install vim</code></p>
<h3 id="保存对容器的修改"><a href="#保存对容器的修改" class="headerlink" title="保存对容器的修改"></a>保存对容器的修改</h3><p><code>docker commit pid</code></p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker整体架构图</title>
    <url>/wiki/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Docker的总架构图"><a href="#Docker的总架构图" class="headerlink" title="Docker的总架构图"></a>Docker的总架构图</h1><img src='https://cdn.zsite.com/data/upload/d/docker/202104/f_e2031050ce83ec39ca6574875e047811.png' width=500 height=600>

<p>docker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<p>1、用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。<br>2、Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；<br>3、Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。<br>4、Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；<br>5、当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；<br>6、当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。<br>7、libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-analyzer</title>
    <url>/wiki/elasticsearch-analyzer/</url>
    <content><![CDATA[<h2 id="测试常见分析器"><a href="#测试常见分析器" class="headerlink" title="测试常见分析器"></a>测试常见分析器</h2><p><code>GET /_analyze</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code>  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code>   </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="默认分析器"><a href="#默认分析器" class="headerlink" title="默认分析器"></a>默认分析器</h2><p>虽然我们可以在字段层级指定分析器，但是如果该层级没有指定任何的分析器，那么我们如何能确定这个字段使用的是哪个分析器呢？  </p>
<p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：</p>
<ul>
<li>字段映射里定义的 analyzer ，否则</li>
<li>索引设置中名为 default 的分析器，默认为</li>
<li>standard 标准分析器</li>
</ul>
<p>在搜索时，顺序有些许不同：</p>
<ul>
<li>查询自己定义的 analyzer ，否则</li>
<li>字段映射里定义的 analyzer ，否则</li>
<li>索引设置中名为 default 的分析器，默认为</li>
<li>standard 标准分析器</li>
</ul>
<p>有时，在索引时和搜索时使用不同的分析器是合理的。我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。</p>
<p>为了区分，Elasticsearch 也支持一个可选的 <code>search_analyzer</code> 映射，它仅会应用于搜索时（ <code>analyzer</code> 还用于索引时）。还有一个等价的 <code>default_search</code> 映射，用以指定索引层的默认配置。</p>
<p>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：</p>
<p>查询自己定义的 <code>analyzer</code> ，否则<br>字段映射里定义的 <code>search_analyzer</code> ，否则<br>字段映射里定义的 <code>analyzer</code> ，否则<br>索引设置中名为 <code>default_search</code> 的分析器，默认为<br>索引设置中名为 <code>default</code> 的分析器，默认为<code>standard</code> 标准分析器</p>
<h2 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h2><p>多数情况下，会提前知道文档会包括哪些字段。最简单的途径就是在创建索引或者增加类型映射时，为每个全文字段设置分析器。这种方式尽管有点麻烦，但是它让我们可以清楚的看到每个字段每个分析器是如何设置的。</p>
<p>通常，多数字符串字段都是 <code>not_analyzed</code> 精确值字段，比如标签（tag）或枚举（enum），而且更多的全文字段会使用默认的 <code>standard</code> 分析器或 <code>english</code> 或其他某种语言的分析器。这样只需要为少数一两个字段指定自定义分析：或许标题 title 字段需要以支持 输入即查找（find-as-you-type） 的方式进行索引。</p>
<p>可以在索引级别设置中，为绝大部分的字段设置你想指定的 <code>default</code> 默认分析器。然后在字段级别设置中，对某一两个字段配置需要指定的分析器。</p>
<p>📒 📒 📒<br>对于和时间相关的日志数据，通常的做法是每天自行创建索引，由于这种方式不是从头创建的索引，仍然可以用 索引模板（Index Template） 为新建的索引指定配置和映射。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_controlling_analysis.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 控制分析</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-overview</title>
    <url>/wiki/elasticsearch-overview/</url>
    <content><![CDATA[<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li> <a href="https://doc.codingdict.com/elasticsearch/">https://www.codingdict.com/</a></li>
<li> <a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></li>
<li> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indexing-buffer.html">https://www.elastic.co/guide/en/</a></li>
<li> <a href="https://elastic.blog.csdn.net/">铭毅天下</a></li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 查询值前缀不包含某个字符串</title>
    <url>/wiki/elasticsearch-%E6%9F%A5%E8%AF%A2%E5%80%BC%E5%89%8D%E7%BC%80%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<blockquote>
<p>需求 查询IP不是以11.开头的所有文档，然后获取文档访问量前100条</p>
</blockquote>
<p><code>curl -X GET &quot;localhost:9200/yj_visit_data2,yj_visit_data3/_search?pretty&quot; -u elastic:elastic -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;11.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;visitTime&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1577808000000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">1609430399000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term_article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;ip&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;min_doc_count&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch分页查询</title>
    <url>/wiki/elasticsearch%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：</p>
<p><code>size</code><br>显示应该返回的结果数量，默认是 10<br><code>from</code><br>显示应该跳过的初始结果数量，默认是 0<br>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p>
<p><code>GET /_search?size=5</code><br><code>GET /_search?size=5&amp;from=5</code><br><code>GET /_search?size=5&amp;from=10</code>  </p>
<p>⚠️ ⚠️ ⚠️<br>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。  </p>
<p>在分布式系统中深度分页</p>
<blockquote>
<p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
</blockquote>
<p>现在假设我们请求第 1000 页—​结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
<p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/pagination.html">elasticsearch权威指南</a>  </li>
<li><a href="https://blog.csdn.net/laoyang360/article/details/116472697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162549431316780269873046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162549431316780269873046&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-116472697.pc_v2_rank_blog_default&utm_term=%E5%88%86%E9%A1%B5&spm=1018.2226.3001.4450">干货 | 全方位深度解读 Elasticsearch 分页查询</a>  </li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/paginate-search-results.html">Paginate search results</a></li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch基础api</title>
    <url>/wiki/elasticsearch%E5%9F%BA%E7%A1%80cat_api/</url>
    <content><![CDATA[<h2 id="cat-API"><a href="#cat-API" class="headerlink" title="cat API"></a>cat API</h2><h3 id="集群健康状态"><a href="#集群健康状态" class="headerlink" title="集群健康状态"></a>集群健康状态</h3><p>GET _cat/health?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp cluster        status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1625489855 12:57:35  my-application yellow          1         1     35  35    0    0       23             0                  -                 60.3%</span><br></pre></td></tr></table></figure>
<p>或者直接在服务器上调用rest接口：<br>curl -XGET ‘localhost:9200/_cat/health?v&amp;pretty’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1475247709 17:01:49  elasticsearch green           1         1      0   0    0    0        0             0                  -                100.0%</span><br></pre></td></tr></table></figure>

<p>我们可以看到我们名为 my-application 的集群与 yellow 的 status。</p>
<p>无论何时我们请求集群健康，我们可以获得 green，yellow，或者 red 的 status。Green 表示一切正常（集群功能齐全）， yellow 表示所有数据可用，但是有些副本尚未分配（集群功能齐全），red 意味着由于某些原因有些数据不可用。注意，集群是 red，它仍然具有部分功能（例如，它将继续从可用的分片中服务搜索请求），但是您可能需要尽快去修复它，因为您已经丢失数据了。  </p>
<p>另外，从上面的响应中，我们可以看到共计 1 个 node（节点）和 0 个 shard（分片），因为我们还没有放入数据的。注意，因为我们使用的是默认的集群名称（elasticsearch），并且 Elasticsearch 默认情况下使用 unicast network（单播网络）来发现同一机器上的其它节点。有可能您不小心在您的电脑上启动了多个节点，然后它们全部加入到了单个集群。在这种情况下，你会在上面的响应中看到不止 1 个 node（节点）。</p>
<h3 id="查看集群分布"><a href="#查看集群分布" class="headerlink" title="查看集群分布"></a>查看集群分布</h3><p>GET _cat/nodes?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip         heap.percent ram.percent cpu load_1m load_5m load_15m node.role  master name</span><br><span class="line">172.19.0.1           20          61  15    0.02    0.04     0.29 cdhilmrstw *      redtom-es-1</span><br></pre></td></tr></table></figure>


<h3 id="查看所有索引"><a href="#查看所有索引" class="headerlink" title="查看所有索引"></a>查看所有索引</h3><p>GET _cat/indices?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">health status index                             uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   rd-logstash-2021.06.19            p5iej71MQVW12s2awNv8nw   1   1      61236            0     16.3mb         16.3mb</span><br><span class="line">yellow open   demo_index                        k6VTs7tdS0ysot-rPwxG9A   1   1          1            0      5.5kb          5.5kb</span><br><span class="line">green  open   kibana_sample_data_flights        A7c5DViGSISii8FA0dNlGw   1   0      13059            0      5.6mb          5.6mb</span><br></pre></td></tr></table></figure>


<h3 id="查看所有索引的数量"><a href="#查看所有索引的数量" class="headerlink" title="查看所有索引的数量"></a>查看所有索引的数量</h3><p>GET _cat/count?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp count</span><br><span class="line">1625490245 13:04:05  838913</span><br></pre></td></tr></table></figure>


<h3 id="磁盘分配情况"><a href="#磁盘分配情况" class="headerlink" title="磁盘分配情况"></a>磁盘分配情况</h3><p>GET _cat/allocation?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shards disk.indices disk.used disk.avail disk.total disk.percent host       ip         node</span><br><span class="line">    35      308.7mb    20.1gb    215.9gb    236.1gb            8 172.19.0.1 172.19.0.1 redtom-es-1</span><br><span class="line">    23                                                                                 UNASSIGNED</span><br></pre></td></tr></table></figure>


<h3 id="查看shard情况"><a href="#查看shard情况" class="headerlink" title="查看shard情况"></a>查看shard情况</h3><p>GET _cat/shards?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index                             shard prirep state        docs   store ip         node</span><br><span class="line">yj_visit_data                     0     p      STARTED         0    208b 172.19.0.1 redtom-es-1</span><br><span class="line">yj_visit_data                     0     r      UNASSIGNED                           </span><br><span class="line">demo_index                        0     p      STARTED         1   5.5kb 172.19.0.1 redtom-es-1</span><br><span class="line">demo_index                        0     r      UNASSIGNED                           </span><br><span class="line">rbtags                            0     p      STARTED         0    208b 172.19.0.1 redtom-es-1</span><br><span class="line">.kibana_1                         0     p      STARTED       280  11.5mb 172.19.0.1 redtom-es-1</span><br><span class="line">.kibana_task_manager_1            0     p      STARTED         5   5.8mb 172.19.0.1 redtom-es-1</span><br></pre></td></tr></table></figure>
<p>yj_visit_data 设置了一个副本分区，但是没有副节点，所以节点状态显示未分配；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/cat.html">Elastic 官方文档</a></li>
<li><a href="https://doc.codingdict.com/elasticsearch/4/">codingdict.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch字符串查询汇总</title>
    <url>/wiki/elasticsearch%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>filter<br>exists<br>fuzzy<br>ids<br>prefix<br>regexp<br>term<br>terms<br>terms_set<br>wildcard<br>text搜索 interval<br>match<br>match_bool_prefix<br>match_phrase<br>match_phrase_prefix<br>multi_match<br>common<br>query_string<br>simple_query_string</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/weixin_35143514/article/details/112607839">查询是否包含字符串_十九种Elasticsearch字符串搜索方式终极介绍</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch操作索引</title>
    <url>/wiki/elasticsearch%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT customer</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;:&#123;</span><br><span class="line">        &quot;id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">         &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;email&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_serial&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_time&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;customer_order&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;join&quot;,</span><br><span class="line">          &quot;relations&quot;:&#123;</span><br><span class="line">            &quot;customer&quot;:&quot;order&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看索引的mapping"><a href="#查看索引的mapping" class="headerlink" title="查看索引的mapping"></a>查看索引的mapping</h2><p><code>GET yj_visit_data/_mapping</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;yj_visit_data&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_class&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;article&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h2><p><code>GET yj_visit_data/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除所有"><a href="#删除所有" class="headerlink" title="删除所有"></a>删除所有</h2><p><code>POST yj_visit_data/_delete_by_query</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="通过文章删除"><a href="#通过文章删除" class="headerlink" title="通过文章删除"></a>通过文章删除</h2><p><code>POST yj_visit_data/_delete_by_query</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article.keyword&quot;</span>: <span class="string">&quot;2019/01/3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据文章查询"><a href="#根据文章查询" class="headerlink" title="根据文章查询"></a>根据文章查询</h2><p><code>GET yj_visit_data/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article.keyword&quot;</span>: <span class="string">&quot;2019/01/3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST customer/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch映射</title>
    <url>/wiki/elasticsearch%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Elasticsearch 支持如下简单域类型：</p>
<ul>
<li>字符串: string （es7之后编程text）</li>
<li>整数 : byte, short, integer, long</li>
<li>浮点数: float, double</li>
<li>布尔型: boolean</li>
<li>日期: date</li>
</ul>
<h2 id="查看索引的mapping"><a href="#查看索引的mapping" class="headerlink" title="查看索引的mapping"></a>查看索引的mapping</h2><p><code>GET /gb/_mapping/tweet</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;gb&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;date&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;strict_date_optional_time||epoch_millis&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h2><p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p>
<ul>
<li>全文字符串域和精确值字符串域的区别</li>
<li>使用特定语言分析器</li>
<li>优化域以适应部分匹配</li>
<li>指定自定义数据格式</li>
<li>还有更多</li>
</ul>
<p>域最重要的属性是 <code>type</code> 。对于不是 string 的域，你一般只需要设置 type ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认， <code>string</code> (text) 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
<p>string 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index 属性控制怎样索引字符串。它可以是下面三个值：</p>
<h4 id="analyzed"><a href="#analyzed" class="headerlink" title="analyzed"></a>analyzed</h4><p>首先分析字符串，然后索引它。换句话说，以全文索引这个域。</p>
<h4 id="not-analyzed"><a href="#not-analyzed" class="headerlink" title="not_analyzed"></a>not_analyzed</h4><p>  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</p>
<h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>不索引这个域。这个域不会被搜索到。 (比如一些隐私信息)</p>
<p>string 域 index 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 not_analyzed ：</p>
<p>⚠️ ⚠️<br>其他简单类型（例如 long ， double ， date 等）也接受 index 参数，但有意义的值只有 no 和 not_analyzed ， 因为它们永远不会被分析。  </p>
<h3 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h3><p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如 <code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>;</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h2><p>当你首次创建一个索引的时候，可以指定类型的映射。你也可以使用 /_mapping 为新类型（或者为存在的类型更新映射）增加映射。<br>⚠️ ⚠️<br>尽管你可以 增加 一个存在的映射，你不能 修改 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>
<p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。</p>
<p>为了描述指定映射的两种方式，我们先删除 gd 索引：<br><code>DELETE /gb</code><br>然后创建一个新索引，指定 tweet 域使用 english 分析器：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍后，我们决定在 tweet 映射增加一个新的名为 tag 的 not_analyzed 的文本域，使用 _mapping ：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;tag&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>:    <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中</p>
<h2 id="测试映射"><a href="#测试映射" class="headerlink" title="测试映射"></a>测试映射</h2><p>你可以使用 analyze API 测试字符串域的映射。比较下面两个请求的输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tweet&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tag&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tweet 域产生两个词条 black 和 cat ， tag 域产生单独的词条 Black-cats 。换句话说，我们的映射正常工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/mapping-intro.html">Elasticsearch权威指南</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch稳定性调优</title>
    <url>/wiki/elasticsearch%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p>
</blockquote>
<h2 id="稳定性调优"><a href="#稳定性调优" class="headerlink" title="稳定性调优"></a>稳定性调优</h2><p>一 Linux参数调优</p>
<p>修改系统资源限制 👇<br>单用户可以打开的最大文件数量，可以设置为官方推荐的65536或更大些 <code>echo &quot;* - nofile 655360&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户内存地址空间 <code>echo &quot;* - as unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户线程数 <code>echo &quot;* - nproc 2056474&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户文件大小 <code>echo &quot;* - fsize unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户锁定内存 <code>echo &quot;* - memlock unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单进程可以使用的最大map内存区域数量 <code>echo &quot;vm.max_map_count = 655300&quot; &gt;&gt;/etc/sysctl.conf</code><br>TCP全连接队列参数设置， 这样设置的目的是防止节点数较多（比如超过100）的ES集群中，节点异常重启时全连接队列在启动瞬间打满，造成节点hang住，整个集群响应迟滞的情况<br><code>echo &quot;net.ipv4.tcp_abort_on_overflow = 1&quot; &gt;&gt;/etc/sysctl.conf </code><br><code>echo &quot;net.core.somaxconn = 2048&quot; &gt;&gt;/etc/sysctl.conf</code><br>降低tcp alive time，防止无效链接占用链接数 <code>echo 300 &gt;/proc/sys/net/ipv4/tcp_keepalive_time</code></p>
<h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><h3 id="jvm-options"><a href="#jvm-options" class="headerlink" title="jvm.options"></a>jvm.options</h3><p>-Xms和-Xmx设置为相同的值，<code>推荐设置为机器内存的一半左右，剩余一半留给系统cache使用</code>。</p>
<p>jvm内存建议不要低于2G，否则有可能因为内存不足导致ES无法正常启动或OOM<br>jvm建议不要超过32G，否则<code>jvm会禁用内存对象指针压缩技术</code>，造成内存浪费</p>
<h3 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><p>设置内存熔断参数，防止写入或查询压力过高导致OOM，具体数值可根据使用场景调整。<br><code>indices.breaker.total.limit: 30% </code><br><code>indices.breaker.request.limit: 6% </code><br><code>indices.breaker.fielddata.limit: 3%</code></p>
<p>调小查询使用的cache，避免cache占用过多的jvm内存，具体数值可根据使用场景调整。<br><code>indices.queries.cache.count: 500 </code><br><code>indices.queries.cache.size: 5%</code></p>
<p>单机多节点时，主从shard分配以ip为依据，分配到不同的机器上，避免单机挂掉导致数据丢失。<br><code>cluster.routing.allocation.awareness.attributes: ip </code><br><code>node.attr.ip: 1.1.1.1</code></p>
<h2 id="ES使用方式"><a href="#ES使用方式" class="headerlink" title="ES使用方式"></a>ES使用方式</h2><h3 id="节点数较多的集群，增加专有master，提升集群稳定性"><a href="#节点数较多的集群，增加专有master，提升集群稳定性" class="headerlink" title="节点数较多的集群，增加专有master，提升集群稳定性"></a>节点数较多的集群，增加专有master，提升集群稳定性</h3><p>ES集群的元信息管理、index的增删操作、节点的加入剔除等集群管理的任务都是由master节点来负责的，master节点定期将最新的集群状态广播至各个节点。所以，master的稳定性对于集群整体的稳定性是至关重要的。当集群的节点数量较大时（比如超过30个节点），集群的管理工作会变得复杂很多。此时应该创建专有master节点，这些节点只负责集群管理，不存储数据，不承担数据读写压力；其他节点则仅负责数据读写，不负责集群管理的工作。</p>
<p>这样把集群管理和数据的写入/查询分离，互不影响，防止因读写压力过大造成集群整体不稳定。 将专有master节点和数据节点的分离，需要修改ES的配置文件，然后滚动重启各个节点。</p>
<blockquote>
<p>专有master节点的配置文件（conf/elasticsearch.yml）增加如下属性：<br>node.master: true<br>node.data: false<br>node.ingest: false<br>数据节点的配置文件增加如下属性（与上面的属性相反）：<br>node.master: false<br>node.data: true<br>node.ingest: true </p>
</blockquote>
<h3 id="控制index、shard总数量"><a href="#控制index、shard总数量" class="headerlink" title="控制index、shard总数量"></a>控制index、shard总数量</h3><p>上面提到，ES的元信息由master节点管理，定期同步给各个节点，也就是每个节点都会存储一份。这个元信息主要存储在clusterstate中，如所有node元信息（indices、节点各种统计参数）、所有index/shard的元信息（mapping, location, size）、元数据ingest等。</p>
<p>ES在创建新分片时，要根据现有的分片分布情况指定分片分配策略，从而使各个节点上的分片数基本一致，此过程中就需要深入遍历clusterstate。当集群中的index/shard过多时，clusterstate结构会变得过于复杂，导致遍历clusterstate效率低下，集群响应迟滞。基础架构部数据库团队曾经在一个20个节点的集群里，创建了4w+个shard，<code>导致新建一个index需要60s+才能完成</code>。 当index/shard数量过多时，可以考虑从以下几方面改进：</p>
<ul>
<li>降低数据量较小的index的shard数量</li>
<li>把一些有关联的index合并成一个index</li>
<li>数据按某个维度做拆分，写入多个集群</li>
</ul>
<h3 id="Segment-Memory优化"><a href="#Segment-Memory优化" class="headerlink" title="Segment Memory优化"></a>Segment Memory优化</h3><p>前面提到，ES底层采用Lucene做存储，而Lucene的一个index又由若干segment组成，每个segment都会建立自己的倒排索引用于数据查询。Lucene为了加速查询，为每个segment的倒排做了一层前缀索引，这个索引在Lucene4.0以后采用的数据结构是<code>FST</code> (Finite State Transducer)。Lucene加载segment的时候将其全量装载到内存中，加快查询速度。<code>这部分内存被称为SegmentMemory， 常驻内存，占用heap，无法被GC</code>。</p>
<p>前面提到，为利用JVM的对象指针压缩技术来节约内存，通常建议JVM内存分配不要超过32G。当集群的数据量过大时，SegmentMemory会吃掉大量的堆内存，而JVM内存空间又有限，此时就需要想办法降低SegmentMemory的使用量了，常用方法有下面几个：</p>
<ul>
<li>定期删除不使用的index</li>
<li>对于不常访问的index，可以通过close接口将其关闭，用到时再打开</li>
<li>通过force_merge接口强制合并segment，降低segment数量</li>
<li>基础架构部数据库团队在此基础上，对FST部分进行了优化，释放高达40%的Segment Memory内存空间。</li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch统计每年每小时访问量</title>
    <url>/wiki/elasticsearch%E7%BB%9F%E8%AE%A1%E6%AF%8F%E5%B9%B4%E6%AF%8F%E5%B0%8F%E6%97%B6%E8%AE%BF%E9%97%AE%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>需求背景，要统计文章在一年的时间内，每个小时的访问情况，按照0点举例子，每个文章，一年内每一天0点的访问次数累加起来；</p>
</blockquote>
<h2 id="Elasticsearch索引如下"><a href="#Elasticsearch索引如下" class="headerlink" title="Elasticsearch索引如下"></a>Elasticsearch索引如下</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;yj_visit_data&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_class&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;article&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;c&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ip&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;p&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ua&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;visitTime&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Java-RestHighLevelClient写法"><a href="#Java-RestHighLevelClient写法" class="headerlink" title="Java RestHighLevelClient写法"></a>Java RestHighLevelClient写法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDateDist</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">        searchRequest.indices(<span class="string">&quot;yj_visit_data2&quot;</span>);</span><br><span class="line">        TermsAggregationBuilder termsAggregation = AggregationBuilders.terms(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">                .field(<span class="string">&quot;article.keyword&quot;</span>).size(<span class="number">2200</span>)</span><br><span class="line">                .subAggregation(AggregationBuilders.dateHistogram(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                        .field(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                        .calendarInterval(DateHistogramInterval.HOUR));</span><br><span class="line"></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        sourceBuilder.aggregation(termsAggregation);</span><br><span class="line">        sourceBuilder.query(QueryBuilders.rangeQuery(<span class="string">&quot;visitTime&quot;</span>).gt(<span class="string">&quot;1609430400000&quot;</span>).lte(<span class="string">&quot;1625068799000&quot;</span>));</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">900000</span>));</span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        SearchResponse search = restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        Aggregations aggregations = search.getAggregations();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;agg -&gt; &#123;&#125;&quot;</span>, aggregations.asList().size());</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; buckets = ((ParsedStringTerms) aggregations.asList().get(<span class="number">0</span>)).getBuckets();</span><br><span class="line">        List&lt;ArticleHourData&gt; hourDataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">            List&lt;? extends Histogram.Bucket&gt; innerBuckets = ((ParsedDateHistogram) bucket.getAggregations().asList().get(<span class="number">0</span>)).getBuckets();</span><br><span class="line">            hourDataList.add(calcBucket(innerBuckets, bucket.getKeyAsString()));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;result ----&gt; &#123;&#125;&quot;</span>, JSONObject.toJSONString(hourDataList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArticleHourData <span class="title">calcBucket</span><span class="params">(List&lt;? extends Histogram.Bucket&gt; innerBuckets, String article)</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">&quot;innerBuckets get(0) ---&gt; &#123;&#125;&quot;</span>, JSON.toJSONString(innerBuckets.get(<span class="number">0</span>)));</span><br><span class="line">       Map&lt;String, ? extends List&lt;? extends Histogram.Bucket&gt;&gt; hourMap = innerBuckets.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(bucket -&gt; getHour(bucket.getKeyAsString())));</span><br><span class="line">       log.info(<span class="string">&quot;collect  ======&gt; &#123;&#125; &quot;</span>, JSONObject.toJSONString(hourMap.keySet()));</span><br><span class="line"></span><br><span class="line">       ArticleHourData hourData = ArticleHourData.builder().article(article).build();</span><br><span class="line">       <span class="keyword">if</span> (hourMap.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> hourData;</span><br><span class="line">       &#125;</span><br><span class="line">       HashMap&lt;String, Long&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String hour : hourMap.keySet()) &#123;</span><br><span class="line">           List&lt;? extends Histogram.Bucket&gt; list = hourMap.get(hour);</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           hashMap.put(hour, list.stream().mapToLong(Histogram.Bucket::getDocCount).sum());</span><br><span class="line">       &#125;</span><br><span class="line">       hourData.setCountMap(hashMap);</span><br><span class="line">       <span class="keyword">return</span> hourData;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取时间的小时"><a href="#获取时间的小时" class="headerlink" title="获取时间的小时"></a>获取时间的小时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getHour</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">      date = date.replace(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot; UTC&quot;</span>);</span><br><span class="line">      SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS Z&quot;</span>);</span><br><span class="line">      Date d = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          d = format.parse(date);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(DateUtil.asLocalDateTime(d).getHour());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Python写法"><a href="#Python写法" class="headerlink" title="Python写法"></a>Python写法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecoder</span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">import</span> logging,json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">es = Elasticsearch([&#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;39.107.117.232&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">9200</span>&#125;], http_auth=(<span class="string">&#x27;elastic&#x27;</span>, <span class="string">&#x27;elastic&#x27;</span>), timeout = <span class="number">90000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqs = &#123;</span><br><span class="line">   <span class="string">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;art&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;field&quot;</span>: <span class="string">&quot;article.keyword&quot;</span>,</span><br><span class="line">            <span class="string">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;art_total&quot;</span>: &#123; </span><br><span class="line">               <span class="string">&quot;value_count&quot;</span>: &#123;</span><br><span class="line">                  <span class="string">&quot;field&quot;</span>: <span class="string">&quot;article.keyword&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;_time&quot;</span>: &#123; </span><br><span class="line">                <span class="string">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;field&quot;</span>: <span class="string">&quot;visitTime&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;calendar_interval&quot;</span>: <span class="string">&quot;hour&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_search_result = es.search(index=<span class="string">&quot;yj_visit_data2&quot;</span> , body=sqs)</span><br><span class="line">_result_json = json.dumps(_search_result,sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;: &#x27;</span>), ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">aggregations = _search_result[<span class="string">&#x27;aggregations&#x27;</span>]</span><br><span class="line">art = aggregations[<span class="string">&#x27;art&#x27;</span>]</span><br><span class="line">buckets = art[<span class="string">&#x27;buckets&#x27;</span>]</span><br><span class="line"><span class="comment">#print(type(buckets)) ; print(buckets)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHour</span>(<span class="params">time</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)(time[<span class="number">11</span>:<span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个小时的点击数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByMonth</span>(<span class="params">dataList , hourTar</span>):</span></span><br><span class="line">    _count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataList:</span><br><span class="line">        timestamp = data[<span class="string">&#x27;key_as_string&#x27;</span>]</span><br><span class="line">        hour = getHour(timestamp)</span><br><span class="line">        <span class="keyword">if</span> hour == hourTar: </span><br><span class="line">            _count = (<span class="built_in">int</span>)(data[<span class="string">&#x27;doc_count&#x27;</span>]) + _count   </span><br><span class="line">    <span class="keyword">return</span> _count        </span><br><span class="line">            </span><br><span class="line">   </span><br><span class="line">final_list = []</span><br><span class="line"><span class="comment"># 循环计算每一个文章</span></span><br><span class="line"><span class="keyword">for</span> outBucket <span class="keyword">in</span> buckets: </span><br><span class="line">   simple_result = &#123;&#125;</span><br><span class="line">   _time = outBucket[<span class="string">&#x27;_time&#x27;</span>]</span><br><span class="line">   innerBuckets = _time[<span class="string">&#x27;buckets&#x27;</span>]</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;time inner bucker size&quot;</span> , <span class="built_in">len</span>(innerBuckets))</span><br><span class="line">   simple_list = []</span><br><span class="line">   <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">24</span>):</span><br><span class="line">      simple_list.append(countByMonth(innerBuckets,num))</span><br><span class="line">   simple_result[<span class="number">0</span>] = outBucket[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line">   simple_result[<span class="number">1</span>] = simple_list</span><br><span class="line">   final_list.append(simple_result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;final result ----&gt; &quot;</span>,final_list)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch被破坏的相似度</title>
    <url>/wiki/elasticsearch%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
    <content><![CDATA[<p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。</p>
<p>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤：用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。</p>
<p>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。</p>
<p>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。</p>
<p>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。</p>
<p>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。</p>
<p>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。</p>
<p>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。</p>
<p>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF 。</p>
<p>不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html">Elasticsearch: 权威指南 » 基础入门 » 排序与相关性 » 什么是相关性?</a></li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-is-broken.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 被破坏的相关度！</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch调优实践</title>
    <url>/wiki/elasticsearch%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-0/</url>
    <content><![CDATA[<blockquote>
<p>从性能和稳定性两方面，从linux参数调优、ES节点配置和ES使用方式三个角度入手，介绍ES调优的基本方案。当然，ES的调优绝不能一概而论，需要根据实际业务场景做适当的取舍和调整</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p>
</blockquote>
<h2 id="Linux优化"><a href="#Linux优化" class="headerlink" title="Linux优化"></a>Linux优化</h2><h3 id="关闭交换分区，防止内存置换降低性能。"><a href="#关闭交换分区，防止内存置换降低性能。" class="headerlink" title="关闭交换分区，防止内存置换降低性能。"></a>关闭交换分区，防止内存置换降低性能。</h3><p>将 <code>/etc/fstab</code> 文件中包含swap的行注释掉<br><code>sed -i &#39;/swap/s/^/#/&#39; /etc/fstabswapoff -a</code></p>
<h3 id="磁盘挂载选项"><a href="#磁盘挂载选项" class="headerlink" title="磁盘挂载选项"></a>磁盘挂载选项</h3><p>noatime：禁止记录访问时间戳，提高文件系统读写性能<br>data=writeback： 不记录data journal，提高文件系统写入性能<br>barrier=0：barrier保证journal先于data刷到磁盘，上面关闭了journal，这里的barrier也就没必要开启了<br>nobh：关闭buffer_head，防止内核打断大块数据的IO操作<br>mount -o noatime,data=writeback,barrier=0,nobh /dev/sda /es_data</p>
<h3 id="对于SSD磁盘，采用电梯调度算法"><a href="#对于SSD磁盘，采用电梯调度算法" class="headerlink" title="对于SSD磁盘，采用电梯调度算法"></a>对于SSD磁盘，采用电梯调度算法</h3><p>因为SSD提供了更智能的请求调度算法，不需要内核去做多余的调整 (仅供参考)<br><code>echo noop &gt; /sys/block/sda/queue/scheduler</code></p>
<h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><p>conf/elasticsearch.yml文件：</p>
<h3 id="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"><a href="#适当增大写入buffer和bulk队列长度，提高写入性能和稳定性" class="headerlink" title="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"></a>适当增大写入buffer和bulk队列长度，提高写入性能和稳定性</h3><p><code>indices.memory.index_buffer_size: 15%</code><br><code>thread_pool.bulk.queue_size: 1024</code></p>
<h3 id="计算disk使用量时，不考虑正在搬迁的shard"><a href="#计算disk使用量时，不考虑正在搬迁的shard" class="headerlink" title="计算disk使用量时，不考虑正在搬迁的shard"></a>计算disk使用量时，不考虑正在搬迁的shard</h3><p>在规模比较大的集群中，可以防止新建shard时扫描所有shard的元数据，提升shard分配速度。<br><code>cluster.routing.allocation.disk.include_relocations: false</code></p>
<h2 id="三-ES使用方式"><a href="#三-ES使用方式" class="headerlink" title="三 ES使用方式"></a>三 ES使用方式</h2><h3 id="控制字段的存储选项"><a href="#控制字段的存储选项" class="headerlink" title="控制字段的存储选项"></a>控制字段的存储选项</h3><p>ES底层使用Lucene存储数据，主要包括行存（StoreFiled）、列存（DocValues）和倒排索引（InvertIndex）三部分。 大多数使用场景中，没有必要同时存储这三个部分，可以通过下面的参数来做适当调整：</p>
<h4 id="StoreFiled"><a href="#StoreFiled" class="headerlink" title="StoreFiled"></a>StoreFiled</h4><p>行存，其中占比最大的是source字段，它控制doc原始数据的存储。在写入数据时，ES把doc原始数据的整个json结构体当做一个string，存储为source字段。查询时，可以通过source字段拿到当初写入时的整个json结构体。 所以，如果没有取出整个原始json结构体的需求，可以通过下面的命令，在mapping中关闭source字段或者只在source中存储部分字段，数据查询时仍可通过ES的docvaluefields获取所有字段的值。<br>注意：关闭source后， update, updatebyquery, reindex等接口将无法正常使用，所以有update等需求的index不能关闭source。</p>
<ul>
<li>关闭 _source<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="source只存储部分字段"><a href="#source只存储部分字段" class="headerlink" title="_source只存储部分字段"></a>_source只存储部分字段</h4><p>通过includes指定要存储的字段或者通过excludes滤除不需要的字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;includes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;*.count&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.*&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;excludes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;meta.description&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.other.*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="docvalues-控制列存。"><a href="#docvalues-控制列存。" class="headerlink" title="docvalues 控制列存。"></a>docvalues 控制列存。</h4><p>ES主要使用列存来支持sorting, aggregations和scripts功能，对于没有上述需求的字段，可以通过下面的命令关闭docvalues，降低存储成本。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ndex：控制倒排索引。"><a href="#ndex：控制倒排索引。" class="headerlink" title="ndex：控制倒排索引。"></a>ndex：控制倒排索引。</h4><p>ES默认对于所有字段都开启了倒排索引，用于查询。对于没有查询需求的字段，可以通过下面的命令关闭倒排索引。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="allES的一个特殊的字段"><a href="#allES的一个特殊的字段" class="headerlink" title="allES的一个特殊的字段"></a>allES的一个特殊的字段</h4><ul>
<li>ES把用户写入json的所有字段值拼接成一个字符串后，做分词，然后保存倒排索引，用于支持整个json的全文检索。<br>这种需求适用的场景较少，可以通过下面的命令将all字段关闭，节约存储成本和cpu开销。（ES 6.0+以上的版本不再支持_all字段，不需要设置）<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fieldnames"><a href="#fieldnames" class="headerlink" title="fieldnames"></a>fieldnames</h4>该字段用于exists查询，来确认某个doc里面有无一个字段存在。若没有这种需求，可以将其关闭。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_field_names&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启最佳压缩"><a href="#开启最佳压缩" class="headerlink" title="开启最佳压缩"></a>开启最佳压缩</h3><p>对于打开了上述_source字段的index，可以通过下面的命令来把lucene适用的压缩算法替换成 DEFLATE，提高数据压缩率。<br><code>PUT /my_index/_settings&#123;    &quot;index.codec&quot;: &quot;best_compression&quot;&#125;</code></p>
<h3 id="bulk批量写入"><a href="#bulk批量写入" class="headerlink" title="bulk批量写入"></a>bulk批量写入</h3><p>写入数据时尽量使用下面的bulk接口批量写入，提高写入效率。每个bulk请求的doc数量设定区间推荐为1k~1w，具体可根据业务场景选取一个适当的数量。</p>
<h3 id="调整translog同步策略"><a href="#调整translog同步策略" class="headerlink" title="调整translog同步策略"></a>调整translog同步策略</h3><p>默认情况下，translog的持久化策略是，对于每个写入请求都做一次flush，刷新translog数据到磁盘上。这种频繁的磁盘IO操作是严重影响写入性能的，如果可以接受一定概率的数据丢失（这种硬件故障的概率很小），可以通过下面的命令调整 translog 持久化策略为异步周期性执行，并适当调整translog的刷盘周期。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;translog&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;durability&quot;</span>: <span class="string">&quot;async&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整refresh-interval"><a href="#调整refresh-interval" class="headerlink" title="调整refresh_interval"></a>调整refresh_interval</h3><p>写入Lucene的数据，并不是实时可搜索的，ES必须通过refresh的过程把内存中的数据转换成Lucene的完整segment后，才可以被搜索。默认情况下，ES每一秒会refresh一次，产生一个新的segment，这样会导致产生的segment较多，从而segment merge较为频繁，系统开销较大。如果对数据的实时可见性要求较低，可以通过下面的命令提高refresh的时间间隔，降低系统开销。</p>
<p><code>PUT my_index&#123;  &quot;settings&quot;: &#123;    &quot;index&quot;: &#123;        &quot;refresh_interval&quot; : &quot;30s&quot;    &#125;  &#125;&#125;</code></p>
<h3 id="merge并发控制"><a href="#merge并发控制" class="headerlink" title="merge并发控制"></a>merge并发控制</h3><p>ES的一个index由多个shard组成，而一个shard其实就是一个Lucene的index，它又由多个segment组成，且Lucene会不断地把一些小的segment合并成一个大的segment，这个过程被称为merge。默认值是Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))，当节点配置的cpu核数较高时，merge占用的资源可能会偏高，影响集群的性能，可以通过下面的命令调整某个index的merge过程的并发度：</p>
<p><code>PUT /my_index/_settings&#123;    &quot;index.merge.scheduler.max_thread_count&quot;: 2&#125;</code></p>
<h3 id="写入数据不指定-id，让ES自动产生"><a href="#写入数据不指定-id，让ES自动产生" class="headerlink" title="写入数据不指定_id，让ES自动产生"></a>写入数据不指定_id，让ES自动产生</h3><p>当用户显示指定id写入数据时，ES会先发起查询来确定index中是否已经有相同id的doc存在，若有则先删除原有doc再写入新doc。这样每次写入时，ES都会耗费一定的资源做查询。如果用户写入数据时不指定doc，ES则通过内部算法产生一个随机的id，并且保证id的唯一性，这样就可以跳过前面查询id的步骤，提高写入效率。 所以，在不需要通过id字段去重、update的使用场景中，写入不指定id可以提升写入速率。基础架构部数据库团队的测试结果显示，无id的数据写入性能可能比有_id的高出近一倍，实际损耗和具体测试场景相关。</p>
<h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>对于数据量较大的index，一般会配置多个shard来分摊压力。这种场景下，一个查询会同时搜索所有的shard，然后再将各个shard的结果合并后，返回给用户。对于高并发的小查询场景，每个分片通常仅抓取极少量数据，此时查询过程中的调度开销远大于实际读取数据的开销，且查询速度取决于最慢的一个分片。开启routing功能后，ES会将routing相同的数据写入到同一个分片中（也可以是多个，由index.routingpartitionsize参数控制）。如果查询时指定routing，那么ES只会查询routing指向的那个分片，可显著降低调度开销，提升查询效率。 routing的使用方式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 写入PUT my_index/my_type/<span class="number">1</span>?routing=user1&#123;  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span>&#125;</span><br><span class="line"># 查询GET my_index/_search?routing=user1,user2 &#123;  <span class="attr">&quot;query&quot;</span>: &#123;    <span class="attr">&quot;match&quot;</span>: &#123;      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span>    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为string类型的字段选取合适的存储方式"><a href="#为string类型的字段选取合适的存储方式" class="headerlink" title="为string类型的字段选取合适的存储方式"></a>为string类型的字段选取合适的存储方式</h3><h4 id="存为text类型的字段（string字段默认类型为text）："><a href="#存为text类型的字段（string字段默认类型为text）：" class="headerlink" title="存为text类型的字段（string字段默认类型为text）："></a>存为text类型的字段（string字段默认类型为text）：</h4><pre><code>做分词后存储倒排索引，支持全文检索，可以通过下面几个参数优化其存储方式：
 -  norms：用于在搜索时计算该doc的_score（代表这条数据与搜索条件的相关度），如果不需要评分，可以将其关闭。
 - indexoptions：控制倒排索引中包括哪些信息（docs、freqs、positions、offsets）。对于不太注重score/highlighting的使用场景，可以设为 docs来降低内存/磁盘资源消耗。
 - fields: 用于添加子字段。对于有sort和聚合查询需求的场景，可以添加一个keyword子字段以支持这两种功能。

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;norms&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;index_options&quot;</span>: <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```    </span><br><span class="line">#### 存为keyword类型的字段</span><br><span class="line">不做分词，不支持全文检索。text分词消耗CPU资源，冗余存储keyword子字段占用存储空间。如果没有全文索引需求，只是要通过整个字段做搜索，可以设置该字段的类型为keyword，提升写入速率，降低存储成本。 设置字段类型的方法有两种：一是创建一个具体的index时，指定字段的类型；二是通过创建template，控制某一类index的字段类型。</span><br><span class="line"></span><br><span class="line">-  通过mapping指定 tags 字段为keyword类型</span><br><span class="line">```json</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 通过template，指定my_index*类的index，其所有string字段默认为keyword类型<br>PUT _template/my_template<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;order&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;template&quot;</span>: <span class="string">&quot;my_index*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_default_&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="attr">&quot;strings&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查询时，使用query-bool-filter组合取代普通query"><a href="#查询时，使用query-bool-filter组合取代普通query" class="headerlink" title="查询时，使用query-bool-filter组合取代普通query"></a>查询时，使用query-bool-filter组合取代普通query</h3><p>默认情况下，ES通过一定的算法计算返回的每条数据与查询语句的相关度，并通过score字段来表征。但对于非全文索引的使用场景，用户并不care查询结果与查询条件的相关度，只是想精确的查找目标数据。此时，可以通过query-bool-filter组合来让ES不计算score，并且尽可能的缓存filter的结果集，供后续包含相同filter的查询使用，提高查询效率。</p>
<ul>
<li>普通查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot; : &#123; &quot;user&quot; : &quot;Kimchy&quot; &#125;   &#125;&#125;</code></li>
<li>query-bool-filter 加速查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123; &quot;user&quot;: &quot;Kimchy&quot; &#125;      &#125;    &#125;  &#125;&#125;</code></li>
</ul>
<h3 id="index按日期滚动，便于管理"><a href="#index按日期滚动，便于管理" class="headerlink" title="index按日期滚动，便于管理"></a>index按日期滚动，便于管理</h3><p>写入ES的数据最好通过某种方式做分割，存入不同的index。<br>常见的做法是将数据按模块/功能分类，写入不同的index，然后按照时间去滚动生成index。这样做的好处是各种数据分开管理不会混淆，也易于提高查询效率。<code>同时index按时间滚动，数据过期时删除整个index，要比一条条删除数据或deletebyquery效率高很多</code>，因为删除整个index是直接删除底层文件，而deletebyquery是查询-标记-删除。</p>
<p>举例说明，假如有[modulea,moduleb]两个模块产生的数据，那么index规划可以是这样的：一类index名称是modulea + {日期}，另一类index名称是module_b+ {日期}。对于名字中的日期，可以在写入数据时自己指定精确的日期，也可以通过ES的ingest pipeline中的index-name-processor实现（会有写入性能损耗）。</p>
<h3 id="按需控制index的分片数和副本数"><a href="#按需控制index的分片数和副本数" class="headerlink" title="按需控制index的分片数和副本数"></a>按需控制index的分片数和副本数</h3><p>分片（shard）：一个ES的index由多个shard组成，每个shard承载index的一部分数据。</p>
<p>副本（replica）：index也可以设定副本数（numberofreplicas），也就是同一个shard有多少个备份。对于查询压力较大的index，可以考虑提高副本数（numberofreplicas），通过多个副本均摊查询压力。</p>
<p>shard数量（numberofshards）设置过多或过低都会引发一些问题：shard数量过多，则批量写入/查询请求被分割为过多的子写入/查询，导致该index的写入、查询拒绝率上升；对于数据量较大的inex，当其shard数量过小时，无法充分利用节点资源，造成机器资源利用率不高 或 不均衡，影响写入/查询的效率。</p>
<p>对于每个index的shard数量，可以根据数据总量、写入压力、节点数量等综合考量后设定，然后根据数据增长状态定期检测下shard数量是否合理。基础架构部数据库团队的推荐方案是：</p>
<p>对于数据量较小（100GB以下）的index，往往写入压力查询压力相对较低，一般设置3<del>5个shard，numberofreplicas设置为1即可（也就是一主一从，共两副本） 。<br>对于数据量较大（100GB以上）的index：<br>一般把单个shard的数据量控制在（20GB</del>50GB）<br>让index压力分摊至多个节点：可通过index.routing.allocation.totalshardsper_node参数，强制限定一个节点上该index的shard数量，让shard尽量分配到不同节点上<br>综合考虑整个index的shard数量，如果shard数量（不包括副本）超过50个，就很可能引发拒绝率上升的问题，此时可考虑把该index拆分为多个独立的index，分摊数据量，同时配合routing使用，降低每个查询需要访问的shard数量。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch踩坑</title>
    <url>/wiki/elasticsearch%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="search-max-buckets"><a href="#search-max-buckets" class="headerlink" title="search.max_buckets"></a>search.max_buckets</h2><p>This limit can be set by changing the [search.max_buckets] cluster level setting.]];</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;search.max_buckets&quot;</span>: <span class="number">100000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Required-one-of-fields-field-script"><a href="#Required-one-of-fields-field-script" class="headerlink" title="Required one of fields [field, script]"></a>Required one of fields [field, script]</h2><p>[Elasticsearch exception [type=illegal_argument_exception, reason=Required one of fields [field, script], but none were specified. ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      NativeSearchQuery nativeSearchQuery = <span class="keyword">new</span> NativeSearchQuery(QueryBuilders.matchAllQuery(), <span class="keyword">null</span>);</span><br><span class="line">      Script script = <span class="keyword">new</span> Script(<span class="string">&quot;doc[&#x27;article.keyword&#x27;]&quot;</span>);</span><br><span class="line">      nativeSearchQuery.addAggregation(AggregationBuilders.terms(<span class="string">&quot;art&quot;</span>)</span><br><span class="line">              .field(<span class="string">&quot;article.keyword&quot;</span>).size(<span class="number">10</span>)</span><br><span class="line">              .subAggregation(AggregationBuilders.dateHistogram(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                      .field(<span class="string">&quot;visitTime&quot;</span>) <span class="comment">// 这一行没有写</span></span><br><span class="line">                      .calendarInterval(DateHistogramInterval.HOUR)));</span><br><span class="line">      SearchHits&lt;YjVisitData&gt; search = elasticsearchRestTemplate.search(nativeSearchQuery, YjVisitData.class);</span><br><span class="line">      System.err.println(<span class="string">&quot;search.getAggregations().asList() &#123;&#125;&quot;</span> + search.getAggregations().asList().size());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch重要配置</title>
    <url>/wiki/elasticsearch%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>虽然Elasticsearch仅需要很少的配置，但有许多设置需要手动配置，并且在进入生产之前绝对必须进行配置。</p>
<p><code>path.data</code> 和 <code>path.logs</code><br><code>cluster.name</code><br><code>node.name</code><br><code>bootstrap.memory_lock</code><br><code>network.host</code><br><code>discovery.zen.ping.unicast.hosts</code><br><code>discovery.zen.minimum_master_nodes</code><br><code>path.data</code> 和 <code>path.logs</code><br>如果使用.zip或.tar.gz归档，则数据和日志目录是$ES_HOME的子文件夹。 如果这些重要的文件夹保留在其默认位置，则存在将Elasticsearch升级到新版本时被删除的高风险。  </p>
<p>在生产使用中，肯定得更改数据和日志文件夹的位置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path:</span></span><br><span class="line">  <span class="attr">logs:</span> <span class="string">/var/log/elasticsearch</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">/var/data/elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>RPM和Debian发行版已经使用数据和日志的自定义路径。  </p>
<p><code>path.data</code> 设置可以设置为多个路径，在这种情况下，所有路径将用于存储数据（属于单个分片的文件将全部存储在同一数据路径上）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_3</span></span><br></pre></td></tr></table></figure>
<h2 id="cluster-name"><a href="#cluster-name" class="headerlink" title="cluster.name"></a>cluster.name</h2><p>节点只能在群集与群集中的所有其他节点共享其cluster.name时才能加入群集。 默认名称为elasticsearch，但您应将其更改为描述集群用途的适当名称。<br><code>cluster.name: logging-prod</code><br>确保不要在不同的环境中重复使用相同的集群名称，否则可能会导致加入错误集群的节点。  </p>
<h2 id="node-name"><a href="#node-name" class="headerlink" title="node.name"></a>node.name</h2><p>默认情况下，Elasticsearch将使用随机生成的uuid的第一个字符作为节点id。 请注意，节点ID是持久化的，并且在节点重新启动时不会更改，因此默认节点名称也不会更改。<br>配置一个更有意义的名称是值得的，这是重启节点后也能一直保持的优势：<br><code>node.name: prod-data-2</code><br>node.name也可以设置为服务器的HOSTNAME，如下所示：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">node.name:</span> <span class="string">$&#123;HOSTNAME&#125;</span></span><br><span class="line"><span class="string">bootstrap.memory_lock</span></span><br></pre></td></tr></table></figure>
<p>没有JVM被交换到磁盘上这事对于节点的健康来说是至关重要的。一种实现方法是将bootstrap.memory_lock设置为true。<br>要使此设置生效，需要首先配置其他系统设置。 有关如何正确设置内存锁定的更多详细信息，请参阅启用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#mlockall">bootstrap.memory_lock</a>。  </p>
<h2 id="network-host"><a href="#network-host" class="headerlink" title="network.host"></a>network.host</h2><p>默认情况下，Elasticsearch仅仅绑定在本地回路地址——如：127.0.0.1与[::1]。这在一台服务器上跑一个开发节点是足够的。<br>提示</p>
<p>事实上，多个节点可以在单个节点上相同的$ES_HOME位置一同运行。这可以用于测试Elasticsearch形成集群的能力,但这种配置方式不推荐用于生产环境。</p>
<p>为了将其它服务器上的节点形成一个可以相互通讯的集群，你的节点将不能绑定在一个回路地址上。 这里有更多的网路配置，通常你只需要配置network.host：<br><code>network.host: 192.168.1.10</code><br>network.host也可以配置成一些能识别的特殊的值，譬如：_local_、_site、_global_，它们可以结合指定:ip4与ip6来使用。更多相信信息请参见：<a href="https://aqlu.gitbooks.io/elasticsearch-reference/content/Modules/Network_Settings.html">网路配置</a></p>
<p>重要 👇</p>
<p>一旦你自定义了network.host的配置，Elasticsearch将假设你已经从开发模式转到了生产模式，并将升级系统检测的警告信息为异常信息。更多信息请参见：开发模式vs生产模式</p>
<h2 id="discovery-zen-ping-unicast-hosts（单播发现）"><a href="#discovery-zen-ping-unicast-hosts（单播发现）" class="headerlink" title="discovery.zen.ping.unicast.hosts（单播发现）"></a>discovery.zen.ping.unicast.hosts（单播发现）</h2><p>开箱即用，无需任何网络配置，Elasticsearch将绑定到可用的回路地址，并扫描9300年到9305的端口去连接同一机器上的其他节点,试图连接到相同的服务器上运行的其他节点。它提供了不需要任何配置就能自动组建集群的体验。<br>当与其它机器上的节点要形成一个集群时，你需要提供一个在线且可访问的节点列表。像如下来配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts:</span><br><span class="line">   - 192.168.1.10:9300</span><br><span class="line">   - 192.168.1.11 #①</span><br><span class="line">   - seeds.mydomain.com #②</span><br></pre></td></tr></table></figure>
<p>① 未指定端口时，将使用默认的<code>transport.profiles.default.port</code>值，如果此值也为设置则使用<code>transport.tcp.port</code></p>
<p>② 主机名将被尝试解析成能解析的多个IP</p>
<h2 id="discovery-zen-minimum-master-nodes"><a href="#discovery-zen-minimum-master-nodes" class="headerlink" title="discovery.zen.minimum_master_nodes"></a>discovery.zen.minimum_master_nodes</h2><p>为防止数据丢失，配置discovery-zen-minimum_master_nodes将非常重要，他规定了必须至少要有多少个master节点才能形成一个集群。<br>没有此设置时，一个集群在发生网络问题是可能会分裂成多个集群——脑裂——这将导致数据丢失。更多详细信息请参见：通过minimum_master_nodes避免脑裂<br>为避免脑裂，你需要根据master节点数来设置法定人数：<br><code>(master_eligible_nodes / 2) + 1</code><br>换句话说，如果你有三个master节点，最小的主节点数因被设置为(3/2)+1或者是2<br><code>discovery.zen.minimum_master_nodes: 2</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#mlockall">elastic 官方文档</a></li>
<li><a href="https://www.codingdict.com/document">codingdict.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>field name is null or empty</title>
    <url>/wiki/field-name-is-null-or-empty/</url>
    <content><![CDATA[<h2 id="canal-adapter-报错信息"><a href="#canal-adapter-报错信息" class="headerlink" title="canal adapter 报错信息"></a>canal adapter 报错信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring FrameworkServlet &#x27;dispatcherServlet&#x27;</span><br><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization started</span><br><span class="line">2021-07-06 12:46:31.968 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization completed in 9 ms</span><br><span class="line">2021-07-06 12:46:31.995 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:46:32.027 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - field name is null or empty</span><br><span class="line">java.lang.IllegalArgumentException: field name is null or empty</span><br><span class="line">	at org.elasticsearch.index.query.BaseTermQueryBuilder.&lt;init&gt;(BaseTermQueryBuilder.java:113) ~[na:na]</span><br><span class="line">	at org.elasticsearch.index.query.TermQueryBuilder.&lt;init&gt;(TermQueryBuilder.java:75) ~[na:na]</span><br><span class="line">	at org.elasticsearch.index.query.QueryBuilders.termQuery(QueryBuilders.java:202) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.lambda$executeSqlImport$1(ESEtlService.java:141) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:60) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.executeSqlImport(ESEtlService.java:64) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:105) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_292]</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke</span><br></pre></td></tr></table></figure>


<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>操作是向数据库中插入一条数据，通过canal-adapter同步到elasticsearch中，接口发生以上错误！<br>现象是canal-adapter检测到和mysql的数据变化，但是同步到es的时候发生了错误；<br>猜想大概是某个为空导致存到es的时候发生异常；</p>
<p>然后查看es7下的mapping配置：</p>
<img src="https://oscimg.oschina.net/oscnet/up-93dc9d1f9074d9d44946f2d5c3780dd7e13.png" width=400 height=300>

<p>发现我的sql查id的时候写错了，别名应该写成_id,对应elasticsearch的_id</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Other Question</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>flink 提交任务</title>
    <url>/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>下面演示如何通过admin页面提交任务 👇</p>
<h2 id="准备task-jar"><a href="#准备task-jar" class="headerlink" title="准备task jar"></a>准备task jar</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>mvn install -DskipTest</code> 可以得到相应的jar</p>
<h2 id="admin提交jar"><a href="#admin提交jar" class="headerlink" title="admin提交jar"></a>admin提交jar</h2><img src='https://oscimg.oschina.net/oscnet/up-6f96aa46a523c9cd32f12177775b6d6fab9.png' width=900 height=450> 

<p>提交完jar包之后，需要设置相关参数，这个根据自己的实际情况来设置，下面是参考样例： </p>
<ul>
<li>Enter Class : com.ibli.flink.StreamWordCount<br>也就是程序入口，我们这是写了一个main方法，如果是程序的话，可以写对应bootstrap的启动类</li>
<li>Program Arguments : –host localhost –port 7777 </li>
</ul>
<p>点击 <code>submit</code>  之后查看提交的任务状态</p>
<h2 id="查看任务"><a href="#查看任务" class="headerlink" title="查看任务"></a>查看任务</h2><img src='https://oscimg.oschina.net/oscnet/up-f11b32799d87f90c6e78732db82f191be3b.png' width=900 height=450>  

<p>可以看到是有两个任务，并且都是在执行状态；<br>点击一个任务，还可以查看任务详情信息，和一些其他的信息，非常全面；</p>
<img src="https://oscimg.oschina.net/oscnet/up-9678050d3906aae9ccead23d02927d46851.png" width=900 height=450>

<h2 id="查看运行时任务列表"><a href="#查看运行时任务列表" class="headerlink" title="查看运行时任务列表"></a>查看运行时任务列表</h2><img src='https://oscimg.oschina.net/oscnet/up-da8bf04ac90ae3c16095a6ebf25175b4452.png' width=900 height=350>


<h2 id="查看任务管理列表"><a href="#查看任务管理列表" class="headerlink" title="查看任务管理列表"></a>查看任务管理列表</h2><img src="https://oscimg.oschina.net/oscnet/up-a85746f93dc171f3d320a17c07294682bb3.png" width=900 height=450>

<p>点击任务可以跳转到详情页面 👇 下面是执行日志 </p>
<img src= 'https://oscimg.oschina.net/oscnet/up-a11c7ccc522c77d100d57a9c2a08ec9183b.png' width=900 height=500>

<p>我们还可以看到任务执行的标准输出结果✅</p>
<img src="https://oscimg.oschina.net/oscnet/up-3d990a6318fab3a11e7336fdcd271851fda.png" width=900 height=400>

<h2 id="任务源数据"><a href="#任务源数据" class="headerlink" title="任务源数据"></a>任务源数据</h2><p>通过nc 输入数据，由程序读取7777端口输入流并解析数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gaolei:geekibli gaolei$ nc -lk 7777</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure>

<h2 id="取消任务如下"><a href="#取消任务如下" class="headerlink" title="取消任务如下"></a>取消任务如下</h2><img src='https://oscimg.oschina.net/oscnet/up-05199d86b957e0adec4e4d91390a0aebbec.png' width=900 height=400> 

<p>再次查看已完成任务列表 如下：</p>
<img src='https://oscimg.oschina.net/oscnet/up-78c97d4c4aec1641a22165735764c54b969.png' width=900 height=400>]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Flink</title>
    <url>/wiki/flink%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<img src="https://flink.apache.org/img/flink-header-logo.svg" width=300 height=300>


<p>官方地址请戳👉 <a href="https://flink.apache.org/">【传送】</a> </p>
<blockquote>
<p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.  </p>
</blockquote>
<p>Apache Flink 是一个框架和分布式处理器引擎，用于对无界和有界数据进行状态计算；  </p>
<h2 id="Why-Flink"><a href="#Why-Flink" class="headerlink" title="Why Flink"></a>Why Flink</h2><ul>
<li>流数据更真实地反应了我们的生活方式</li>
<li>传统的数据架构是基于有限数据集的</li>
<li>我们的目标<br>1、低延迟 毫秒级响应<br>2、高吞吐 能够处理海量数据 分布式<br>3、结果的准确性和良好的容错性  </li>
</ul>
<h2 id="Where-need-Flink"><a href="#Where-need-Flink" class="headerlink" title="Where need Flink"></a>Where need Flink</h2><ul>
<li>电商和市场营销<br>数据报表、广告投放、业务流程需要</li>
<li>物联网（IOT）<br>传感器实时数据采集和显示，实时报警，交通运输业</li>
<li>电信业<br>基站流量调配</li>
<li>银行和金融业<br>实时结算和通知推送、实时检测异常行为</li>
</ul>
<h2 id="传统数据处理架构"><a href="#传统数据处理架构" class="headerlink" title="传统数据处理架构"></a>传统数据处理架构</h2><img src="https://oscimg.oschina.net/oscnet/up-5c77526cb1dbc4696143519dff42c447149.png" width=500 height=300>

<p>传统的数据处理架构如上👆<br>CRM(用户关系系统)， Order System(订单系统), Web App (用户点击时间)，当用户出发行为之后需要系统作出响应，首先由上层的计算层处理计算逻辑，计算层的逻辑计算依赖下面的存储层，计算层计算完成之后，将响应返回给客户端。<br>这种基于传统数据库方式无法满足高并发场景，数据库的并发量都是很低的。</p>
<h2 id="分析处理流程"><a href="#分析处理流程" class="headerlink" title="分析处理流程"></a>分析处理流程</h2><img src="https://oscimg.oschina.net/oscnet/up-060fc9ea54c7bfc0e2d5d73b2d674cad5d4.png" width="500" height="300">
分析处理流程架构如上👆，数据先有传统的关系数据库，经过提取，清洗过滤等，将数据存放到数据仓库，然后通过一些sql处理，生成数据报表和一些其他的查询。  

<ul>
<li>问题也很明显，实时性太差了，处理流程太长，无法满足毫秒级需求</li>
<li>数据来源不唯一，能满足海量数据和高并发的需求，但是无法满足实时的需求</li>
</ul>
<h2 id="有状态的流式处理"><a href="#有状态的流式处理" class="headerlink" title="有状态的流式处理"></a>有状态的流式处理</h2><img src="https://oscimg.oschina.net/oscnet/up-cdf03c1c17f534673e73968bb4a094aadbc.png" width="500" height="300">
把当前做流式计算所需要的数据不存放在数据库中，而是简单粗暴的直接放到本地内存中；

<h3 id="内存不稳定？"><a href="#内存不稳定？" class="headerlink" title="内存不稳定？"></a>内存不稳定？</h3><p>周期性的检查点，数据存盘和故障检测；    </p>
<h2 id="lambda架构"><a href="#lambda架构" class="headerlink" title="lambda架构"></a>lambda架构</h2><p>用两台系统同时保障低延迟和结果准确；<br><img src="https://oscimg.oschina.net/oscnet/up-d33708041d13956206958f26e3b5b209a37.png" width="500" height="300"></p>
<ul>
<li>这套架构分成两个流程，上面为批处理流程，数据收集到一定程序，交给批处理器处理，最终产生一个批处理结果</li>
<li>下面的流程为流式处理流程，保证能快速得到结果</li>
<li>最终有我们在应用层根据实际问题选择具体的处理结果交给应用程序这种架构有什么缺陷？<br>可能得到的结果是不准确的，我们可以先快速的得到一个实时计算的结果，隔一段时间之后在来看批处理产生的结果。<br>实现两台系统和维护两套系统，成本很大；  </li>
</ul>
<h2 id="第三代流式处理架构"><a href="#第三代流式处理架构" class="headerlink" title="第三代流式处理架构"></a>第三代流式处理架构</h2><p>Apache Flink 可以完美解决上面的问题👆<br><img src="https://oscimg.oschina.net/oscnet/up-0cec29eb67e668b76cd1387a0cfe71e47a0.png" width="350" height="350"><br>Strom无法满足海量数据； Sparking Stream 无法满足低延迟；  </p>
<h3 id="基于事件驱动-（Event-driven）"><a href="#基于事件驱动-（Event-driven）" class="headerlink" title="基于事件驱动 （Event-driven）"></a>基于事件驱动 （Event-driven）</h3><img src="https://oscimg.oschina.net/oscnet/up-cf462b316ee2d27df780fd551ce8ecc72cb.png" width="450" height="330">
  

<h3 id="处理无界和有界数据"><a href="#处理无界和有界数据" class="headerlink" title="处理无界和有界数据"></a>处理无界和有界数据</h3><p>任何类型的数据都可以形成一种事件流。信用卡交易、传感器测量、机器日志、网站或移动应用程序上的用户交互记录，所有这些数据都形成一种流。<br>数据可以被作为 无界 或者 有界 流来处理。  </p>
<ul>
<li><p><b>无界流</b> 有定义流的开始，但没有定义流的结束。它们会无休止地产生数据。无界流的数据必须持续处理，即数据被摄取后需要立刻处理。我们不能等到所有数据都到达再处理，因为输入是无限的，在任何时候输入都不会完成。处理无界数据通常要求以特定顺序摄取事件，例如事件发生的顺序，以便能够推断结果的完整性。</p>
</li>
<li><p><b>有界流&lt;/&gt; 有定义流的开始，也有定义流的结束。有界流可以在摄取所有数据后再进行计算。有界流所有数据可以被排序，所以并不需要有序摄取。有界流处理通常被称为批处理</p>
</li>
</ul>
<img src="https://flink.apache.org/img/bounded-unbounded.png" width="600" height="330" >

<p><b>Apache Flink 擅长处理无界和有界数据集</b> 精确的时间控制和状态化使得 Flink 的运行时(runtime)能够运行任何处理无界流的应用。有界流则由一些专为固定大小数据集特殊设计的算法和数据结构进行内部处理，产生了出色的性能。</p>
<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li>支持事件时间（event-time）和处理时间（processing-time）语义</li>
<li>精确一次的状态一致性保证</li>
<li>低延迟 每秒处理数百万个事件，毫秒级延迟</li>
<li>与众多常用的存储系统链接</li>
<li>高可用，动态扩展，支持7*24全天运行</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1、<a href="https://www.bilibili.com/video/BV1qy4y1q728?from=search&seid=13654102476223768024">尚硅谷 2021 Flink Java版</a><br>2、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/">Apache Flink Documentation</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>flink简单上手</title>
    <url>/wiki/flink%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="mac-安装-flink"><a href="#mac-安装-flink" class="headerlink" title="mac 安装 flink"></a>mac 安装 flink</h2><p><b>1、执行 brew install apache-flink 命令</b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gaolei:/ gaolei$ brew install apache-flink</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Auto-updated Homebrew!  </span><br><span class="line">Updated 1 tap (homebrew/services).</span><br><span class="line">No changes to formulae.</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://archive.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">🍺  /usr/local/Cellar/apache-flink/1.9.1: 166 files, 277MB, built in 15 minutes 29 seconds</span><br></pre></td></tr></table></figure>

<p><b>2、执行flink启动脚本</b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/apache-flink/1.9.1/libexec/bin</span><br><span class="line">./start-cluster.sh</span><br></pre></td></tr></table></figure>

<h2 id="WordCount批处理Demo"><a href="#WordCount批处理Demo" class="headerlink" title="WordCount批处理Demo"></a>WordCount批处理Demo</h2><h3 id="创建maven项目，导入依赖"><a href="#创建maven项目，导入依赖" class="headerlink" title="创建maven项目，导入依赖"></a>创建maven项目，导入依赖</h3><p> 注意自己的flink版本 👇👇</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写批处理程序"><a href="#编写批处理程序" class="headerlink" title="编写批处理程序"></a>编写批处理程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 1、创建执行环境</span></span><br><span class="line">       ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">       <span class="comment">// 2、读取文件数据</span></span><br><span class="line">       String inputPath = <span class="string">&quot;/Users/gaolei/Documents/DemoProjects/flink-start/src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">       DataSource&lt;String&gt; dataSource = env.readTextFile(inputPath);</span><br><span class="line">       <span class="comment">// 对数据集进行处理 按照空格分词展开 转换成（word，1）二元组</span></span><br><span class="line">       AggregateOperator&lt;Tuple2&lt;String, Integer&gt;&gt; result = dataSource.flatMap(<span class="keyword">new</span> MyFlatMapper())</span><br><span class="line">               <span class="comment">// 按照第一个位置 -&gt; word 分组</span></span><br><span class="line">               .groupBy(<span class="number">0</span>)</span><br><span class="line">               .sum(<span class="number">1</span>);</span><br><span class="line">       result.print();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 首先按照空格分词</span></span><br><span class="line">           String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历所有的word 包装成二元组输出</span></span><br><span class="line">           <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">               collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备数据源文件"><a href="#准备数据源文件" class="headerlink" title="准备数据源文件"></a>准备数据源文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello spark</span><br><span class="line">hello world</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br><span class="line">how are you</span><br><span class="line">what is your name</span><br></pre></td></tr></table></figure>

<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(is,1)</span><br><span class="line">(what,1)</span><br><span class="line">(you,1)</span><br><span class="line">(flink,1)</span><br><span class="line">(name,1)</span><br><span class="line">(world,1)</span><br><span class="line">(hello,4)</span><br><span class="line">(your,1)</span><br><span class="line">(are,1)</span><br><span class="line">(java,1)</span><br><span class="line">(how,1)</span><br><span class="line">(spark,1)</span><br></pre></td></tr></table></figure>




<h2 id="flink-处理流式数据"><a href="#flink-处理流式数据" class="headerlink" title="flink 处理流式数据"></a>flink 处理流式数据</h2><p>1、通过 <code>nc -lk &lt;port&gt;</code> 打开一个socket服务，监听7777端口 用于模拟实时的流数据</p>
<p>2、java代码处理流式数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并行度，默认值 = 当前计算机的CPU逻辑核数（设置成1即单线程处理）</span></span><br><span class="line">        <span class="comment">// env.setMaxParallelism(32);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line"><span class="comment">//        String inputPath = &quot;/tmp/Flink_Tutorial/src/main/resources/hello.txt&quot;;</span></span><br><span class="line"><span class="comment">//        DataStream&lt;String&gt; inputDataStream = env.readTextFile(inputPath);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在终端数据数据，如下：</p>
<img src="https://oscimg.oschina.net/oscnet/up-cca0ffbec5b010a4be539bab681d7276234.png" width="500" height="300">  

<p>4、在首次启动的时候遇到一个错误 ❌<br><code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/flink/streaming/api/datastream/DataStream</code><br>处理方法可参照 参考资料 👇</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/VIP099/article/details/106457522">Exception in thread “main” java.lang.NoClassDefFoundError 解决方案</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 运行时架构</title>
    <url>/wiki/flink%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Flink运行时组件"><a href="#Flink运行时组件" class="headerlink" title="Flink运行时组件"></a>Flink运行时组件</h2><ol>
<li><p>JobManager (作业管理器)<br>JobManager 具有许多与协调 Flink 应用程序的分布式执行有关的职责：它决定何时调度下一个 task（或一组 task）、对完成的 task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复等等。这个进程由三个不同的组件组成：</p>
<ul>
<li><p><code>ResourceManager</code><br>ResourceManager 负责 Flink 集群中的资源提供、回收、分配 - 它管理 <code>task slots</code>，这是 Flink 集群中资源调度的单位。Flink 为不同的环境和资源提供者（例如 YARN、Mesos、Kubernetes 和 standalone 部署）实现了对应的 <code>ResourceManager</code>。在 standalone 设置中，ResourceManager 只能分配可用 TaskManager 的 slots，而不能自行启动新的 TaskManager。</p>
</li>
<li><p><code>Dispatcher</code><br>Dispatcher 提供了一个 <code>REST</code> 接口，用来提交 Flink 应用程序执行，并为每个提交的作业启动一个新的 <code>JobMaster</code>。它还运行 Flink WebUI 用来提供作业执行信息。</p>
</li>
<li><p><code>JobMaster</code><br><code>JobMaster</code> 负责管理单个 <code>JobGraph</code> 的执行。Flink 集群中可以同时运行多个作业，每个作业都有自己的 <code>JobMaster。</code><br>始终至少有一个 <code>JobManager</code>。高可用（HA）设置中可能有多个 <code>JobManager</code>，其中一个始终是 leader，其他的则是 <code>standby</code>。</p>
</li>
</ul>
</li>
<li><p>TaskManager （任务管理器）</p>
</li>
</ol>
<ul>
<li><p>Flink中的工作进程，通常在flink中会有多个TaskManager运行，每一个TaskMaganer都包含一定数量的插槽（slots）. 插槽的数量限制了TaskManager能够执行的任务数量；</p>
</li>
<li><p>启动之后，TaskManager会向资源管理器注册他的插槽，收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用，JobManager就可以向插槽分配任务（tasks）来执行了</p>
</li>
<li><p>在执行的过程中，一个TaskManager可以跟其他运行同一应用程序的TaskManager交换数据。</p>
</li>
</ul>
<h2 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h2><img src="https://oscimg.oschina.net/oscnet/up-89cc1f4eb3aa51db738324a144a29b91db1.png" width=760 height=500>

<h2 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h2><p>Flink 运行时由两种类型的进程组成：一个 JobManager 和一个或者多个 TaskManager。</p>
<img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/processes.svg" width=760 height=500> 

<p>Client 不是运行时和程序执行的一部分，而是用于准备数据流并将其发送给 JobManager。之后，客户端可以断开连接（分离模式），或保持连接来接收进程报告（附加模式）。客户端可以作为触发执行 Java/Scala 程序的一部分运行，也可以在命令行进程./bin/flink run …中运行。</p>
<p>可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为standalone 集群启动、在容器中启动、或者通过YARN或Mesos等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。</p>
<h2 id="思考问题🤔"><a href="#思考问题🤔" class="headerlink" title="思考问题🤔"></a>思考问题🤔</h2><blockquote>
<ul>
<li>怎样实现并行计算？ 多线程</li>
<li>并行的任务，需要占用多少solt？</li>
<li>一个流处理程序，到底包含多少个任务？</li>
</ul>
</blockquote>
<h1 id="Tasks-和算子链"><a href="#Tasks-和算子链" class="headerlink" title="Tasks 和算子链"></a>Tasks 和算子链</h1><p><code>并行度（Parallelism）</code></p>
<p>一个特定算子的子任务（subtask）的个数被称之为并行度； 一般情况下，一个Stream的并行度就是其所有算子中最大的并行度。<br>整个流也有一个并行度，就是所有算子所有任务的并行度之和；<br>对于分布式执行，Flink 将算子的 subtasks 链接成 tasks。每个 task 由一个线程执行。将算子链接成 task 是个有用的优化：它减少线程间切换、缓冲的开销，并且减少延迟的同时增加整体吞吐量。链行为是可以配置的；请参考链文档以获取详细信息。<br><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_chains.svg" width=760 height=500></p>
<h2 id="TaskManager-和-Slots"><a href="#TaskManager-和-Slots" class="headerlink" title="TaskManager 和 Slots"></a>TaskManager 和 Slots</h2><img src='https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_slots.svg' width=800 height=380>]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/wiki/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p><code>git init </code><br><code>git add .</code><br><code>git commit -m &lt;message&gt;</code><br><code>git remote add &lt;name&gt; &lt;url&gt;</code><br><code>git push</code><br><code>git push &lt;name&gt;</code><br><code>git push --set-upstream &lt;name&gt; &lt;branch&gt;</code></p>
<h2 id="批量删除分支"><a href="#批量删除分支" class="headerlink" title="批量删除分支"></a>批量删除分支</h2><p>远程：<code>git branch -r| grep &#39;ss-1&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;</code><br>本地：<code>git branch -a | grep &#39;feature-re-1&#39; | xargs git branch -D</code></p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>https协议</title>
    <url>/wiki/https%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26690712">《 HTTPS 升级指南 》 深入理解 HTTPS 原理、过程与实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62246556">HTTPS实现原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26682342">深入理解HTTPS原理、过程与实践</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>hutool导出excel</title>
    <url>/wiki/hutool%E5%AF%BC%E5%87%BAexcel/</url>
    <content><![CDATA[<blockquote>
<p>如果你仅需一个Java导出excel的工具，👇就可以满足你的临时需求，当然代码下面这么写肯定是不规范的，可以稍后完善！</p>
</blockquote>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Export方法示例"><a href="#Export方法示例" class="headerlink" title="Export方法示例"></a>Export方法示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(List&lt;IPData&gt; rows)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       ExcelWriter writer = ExcelUtil.getWriter(<span class="keyword">true</span>);</span><br><span class="line">       writer.renameSheet(<span class="string">&quot;所有数据&quot;</span>);     <span class="comment">//甚至sheet的名称</span></span><br><span class="line">       writer.addHeaderAlias(<span class="string">&quot;ip&quot;</span>, <span class="string">&quot;IP&quot;</span>);</span><br><span class="line">       writer.write(rows, <span class="keyword">true</span>);</span><br><span class="line">       writer.setOnlyAlias(<span class="keyword">true</span>);</span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/IP1.xlsx&quot;</span>);</span><br><span class="line">       writer.flush(fileOutputStream);</span><br><span class="line">       writer.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to GeekIBLi</title>
    <url>/wiki/index/</url>
    <content><![CDATA[<h2 id="道阻-且长"><a href="#道阻-且长" class="headerlink" title="道阻 且长"></a>道阻 且长</h2><h2 id="不错的学习网站推荐"><a href="#不错的学习网站推荐" class="headerlink" title="不错的学习网站推荐"></a>不错的学习网站推荐</h2><p><a href="https://e.juejin.cn/">掘金 博客</a><br><a href="https://www.codingdict.com/">https://www.codingdict.com/</a><br><a href="https://time.geekbang.org/">极客时间</a><br><a href="https://ashiamd.github.io/docsify-notes/#/README">ashiamd.github.io</a><br><a href="https://bytedance.feishu.cn/base/appwBhd98QJ9cpMggHc5QMVHlfd">字节跳动后端面试题集</a><br><a href="https://www.zhihu.com/column/c_1155449617721315328">知乎 Java快速进阶通道</a><br><a href="https://hollischuang.github.io/toBeTopJavaer/#/">To Be Top Javaer - Java工程师成神之路</a><br><a href="https://blog.div-wang.com/">Div-wang</a><br><a href="https://www.pdai.tech/">Java 全栈知识体系</a></p>
<h2 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h2><p><a href="https://www.processon.com/u/5b3adb64e4b0a8a7ffc22b90">ProcessOn</a><br><a href="https://www.slidestalk.com/">示说</a></p>
<blockquote>
<p>「 提供了很多优质的PPT 还有很多大厂的沙龙视屏以及材料」</p>
</blockquote>
<h2 id="技术团队推荐"><a href="#技术团队推荐" class="headerlink" title="技术团队推荐"></a>技术团队推荐</h2><p><a href="https://xiaomi-info.github.io/">小米信息部技术团队</a><br><a href="https://tech.youzan.com/">有赞技术团队</a><br><a href="https://tech.meituan.com/">美团技术团队</a></p>
<h2 id="面试题合集"><a href="#面试题合集" class="headerlink" title="面试题合集"></a>面试题合集</h2><p><a href="https://juejin.cn/post/6844904096957218823">2020年大厂Java面试前复习的正确姿势（800+面试题附答案解析）</a><br><a href="https://juejin.cn/post/6844904125939843079">Java集合面试题（总结最全面的面试题）</a></p>
<p><b> 两年学说话 一生学闭嘴 </b></p>
]]></content>
      <categories>
        <category>Overview</category>
      </categories>
  </entry>
  <entry>
    <title>kafka-overview</title>
    <url>/wiki/kafka-overview/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/hellozpc/article/details/105680217">kafka详细教程</a></li>
<li><a href="http://download.kafka-eagle.org/">Kafka 集群管理</a></li>
<li><a href="https://www.orchome.com/kafka/index">OrcHome kafka中文教程</a></li>
<li><a href="https://juejin.cn/post/6847902220667748359">面试官：说说Kafka处理请求的全流程</a></li>
<li><a href="https://juejin.cn/post/6844904046340341768">蘑菇街千亿级消息Kafka上云实践</a></li>
<li><a href="https://www.imooc.com/article/262018">kafka 集群搭建</a></li>
<li><a href="https://wiki.eryajf.net/pages/2953.html">kafka-2-11集群部署</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>most_fields类型</title>
    <url>/wiki/most-fields%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="多字段映射"><a href="#多字段映射" class="headerlink" title="多字段映射"></a>多字段映射</h2><p>首先要做的事情就是对我们的字段索引两次：一次使用词干模式以及一次非词干模式。为了做到这点，采用 <code>multifields</code> 来实现，已经在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-fields.html">multifields</a> 有所介绍：</p>
<p><code>DELETE /my_index</code>  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123; <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span> &#125;, </span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123; </span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;std&quot;</span>:   &#123; </span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>title 字段使用 english 英语分析器来提取词干。</li>
<li>title.std 字段使用 standard 标准分析器，所以没有词干提取。</li>
</ul>
<p>接着索引一些文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里用一个简单 match 查询 title 标题字段是否包含 jumping rabbits （跳跃的兔子）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;jumping rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为有了 <code>english</code> 分析器，这个查询是在查找以 jump 和 rabbit 这两个被提取词的文档。两个文档的 title 字段都同时包括这两个词，所以两个文档得到的评分也相同：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只是查询 <code>title.std</code> 字段，那么只有文档 2 是匹配的。尽管如此，如果同时查询两个字段，然后使用 <code>bool</code> 查询将评分结果 合并 ，那么两个文档都是匹配的（ <code>title</code> 字段的作用），而且文档 2 的相关度评分更高（ <code>title.std</code> 字段的作用）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:   <span class="string">&quot;most_fields&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;title.std&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望将所有匹配字段的评分合并起来，所以使用 <code>most_fields</code> 类型。这让 <code>multi_match</code> 查询用 <code>bool</code> 查询将两个字段语句包在里面，而不是使用 <code>dis_max</code> (最佳字段) 查询。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.8226396</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.10741998</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文档 2 现在的评分要比文档 1 高。</p>
<p>用广度匹配字段 <code>title</code> 包括尽可能多的文档——以提升召回率——同时又使用字段 <code>title.std</code> 作为 信号 将相关度更高的文档置于结果顶部。</p>
<p>每个字段对于最终评分的贡献可以通过自定义值 <code>boost</code> 来控制。比如，使 <code>title</code> 字段更为重要，这样同时也降低了其他信号字段的作用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:       <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:        <span class="string">&quot;most_fields&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>:      [ <span class="string">&quot;title^10&quot;</span>, <span class="string">&quot;title.std&quot;</span> ] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>title 字段的 boost 的值为 10 使它比 title.std 更重要。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/most-fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 多数字段</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>kibana添加用户及控制权限</title>
    <url>/wiki/kibana%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%8F%8A%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<blockquote>
<p>操作步骤： 【修改elasticsearch配置文件】 -&gt; 【重启elasticsearch】 -&gt; 【初始化账号&amp;密码】 -&gt; 【修改kibana配置文件】 -&gt; 【重启kibana】 -&gt; 【初始账号登录kibana】 -&gt; 【创建、配置角色】 -&gt; 【创建新用户】</p>
</blockquote>
<h2 id="配置elasticsearch"><a href="#配置elasticsearch" class="headerlink" title="配置elasticsearch"></a>配置elasticsearch</h2><p>开启自带的xpack的验证功能<br><code>xpack.security.enabled: true</code></p>
<p>配置单节点模式<br><code>discovery.type: single-node</code></p>
<h3 id="坑1-集群节点配置报错"><a href="#坑1-集群节点配置报错" class="headerlink" title="坑1: 集群节点配置报错"></a>坑1: 集群节点配置报错</h3><p><code>cluster.initial_master_nodes</code></p>
<h3 id="坑2-本次存储节点配置报错"><a href="#坑2-本次存储节点配置报错" class="headerlink" title="坑2: 本次存储节点配置报错"></a>坑2: 本次存储节点配置报错</h3><p>maybe these locations are not writable or multiple nodes were started without increasing [node.max_local_storage_nodes] (was [1])?<br><code>node.max_local_storage_nodes: 2</code></p>
<h2 id="为内置账号设置密码"><a href="#为内置账号设置密码" class="headerlink" title="为内置账号设置密码"></a>为内置账号设置密码</h2><p>在elasticsearch的bin下执行以下命令：<br><code>./elasticsearch-setup-passwords interactive</code></p>
<img src="https://oscimg.oschina.net/oscnet/up-2073ba41d73f8d4b16cd39e420ee017f62d.png" width="800" height='480'>


<h2 id="配置kibana"><a href="#配置kibana" class="headerlink" title="配置kibana"></a>配置kibana</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用初始用户kibana</span><br><span class="line">elasticsearch.username: &quot;kibana_system&quot;</span><br><span class="line">elasticsearch.password: &quot;密码&quot;</span><br></pre></td></tr></table></figure>

<p>重启kibana之后使用初始账号 <code>elastic</code> 登录</p>
<h2 id="创建、配置角色"><a href="#创建、配置角色" class="headerlink" title="创建、配置角色"></a>创建、配置角色</h2><img src='https://oscimg.oschina.net/oscnet/up-be2569d2151c190b3f49f2faebae05dd19a.png' width=840 height=750>


<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><img src='https://oscimg.oschina.net/oscnet/up-b662c15522750b55863cf006e9c8a9d63c4.png' width=840 height=750>


<h2 id="查看新用户访问界面"><a href="#查看新用户访问界面" class="headerlink" title="查看新用户访问界面"></a>查看新用户访问界面</h2><p>角色里面配置了kibana的访问权限，只开通了discover和dashboard两个入口<br><img src='https://oscimg.oschina.net/oscnet/up-3371b430006a3b65cffc8a41f04cb02f423.png' width=800 height=450></p>
<p>索引的话，有好几个索引，但是只配置了一个索引的权限<br><img src='https://oscimg.oschina.net/oscnet/up-10b5d2b6e179b6c200c691631dd43fc1713.png' width=800 height=450></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/QiaoRui_/article/details/97375237">kibana7.2添加登录及权限</a></li>
<li><a href="https://www.cnblogs.com/tq1226112215/p/8435127.html">Elasticsearch 安装</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka安装与初体验</title>
    <url>/wiki/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="Kafka的安装"><a href="#Kafka的安装" class="headerlink" title="Kafka的安装"></a>Kafka的安装</h2><h3 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure>
<p>默认端口：2181<br>默认安装位置：/usr/local/Cellar/zookeeper<br>配置文件位置：/usr/local/etc/zookeeper<br>日志文件位置：/usr/local/var/log/zookeeper/zookeeper.log  </p>
<h3 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-d339f3f26756d950d6099483c5d033619bd.png"></p>
<h3 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></table></figure>
<p>默认端口：9092<br>默认安装位置：/usr/local/Cellar/kafka<br>配置文件位置：/usr/local/etc/kafka<br>日志文件位置：/usr/local/var/lib/kafka-logs  </p>
<h3 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h3><p>nohup kafka-server-start /usr/local/etc/kafka/server.properties &amp;<br><img src="https://oscimg.oschina.net/oscnet/up-6dcc2cdd724f403f0a5f1af44448cb5c523.png"></p>
<h2 id="订阅发布Demo"><a href="#订阅发布Demo" class="headerlink" title="订阅发布Demo"></a>订阅发布Demo</h2><h3 id="创建一个Topic"><a href="#创建一个Topic" class="headerlink" title="创建一个Topic"></a>创建一个Topic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>
<h3 id="查看创建的Topic"><a href="#查看创建的Topic" class="headerlink" title="查看创建的Topic"></a>查看创建的Topic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<h3 id="生产者生产消息"><a href="#生产者生产消息" class="headerlink" title="生产者生产消息"></a>生产者生产消息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure>

<h3 id="消费者消费消息"><a href="#消费者消费消息" class="headerlink" title="消费者消费消息"></a>消费者消费消息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server 127.0.0.1:9092 --topic test1 --from-beginning</span><br></pre></td></tr></table></figure>
<p>–from-beginning: 将从第一个消息开始接收</p>
<h2 id="SpringBoot集成Kafka"><a href="#SpringBoot集成Kafka" class="headerlink" title="SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h2><p><strong>源码地址：<a href="https://gitee.com/IBLiplus/kafka-demo.git">https://gitee.com/IBLiplus/kafka-demo.git</a></strong><br>项目启动前按照上述安装启动步骤，在本地启动kafka.<br>创建Maven项目，引入一下依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加如下配置，端口号可以自己定<br>配置文件：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port=9010</span></span><br><span class="line"><span class="string">spring.kafka.bootstrap-servers=</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line"><span class="comment"># 发生错误后，消息重发的次数。</span></span><br><span class="line"><span class="string">spring.kafka.producer.retries=</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</span></span><br><span class="line"><span class="string">spring.kafka.producer.batch-size=</span> <span class="number">16384</span></span><br><span class="line"><span class="comment"># 设置生产者内存缓冲区的大小。</span></span><br><span class="line"><span class="string">spring.kafka.producer.buffer-memory=</span> <span class="number">33554432</span></span><br><span class="line"><span class="comment"># 键的序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.producer.key-serializer=</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment"># 值的序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.producer.value-serializer</span> <span class="string">=</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment"># acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。</span></span><br><span class="line"><span class="comment"># acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。</span></span><br><span class="line"><span class="comment"># acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</span></span><br><span class="line"><span class="string">spring.kafka.producer.acks=</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 自动提交的时间间隔 在spring boot 2.X 版本中这里采用的是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-commit-interval=</span> <span class="string">1S</span></span><br><span class="line"><span class="comment"># 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span></span><br><span class="line"><span class="comment"># latest（默认值）在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）</span></span><br><span class="line"><span class="comment"># earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-offset-reset=</span> <span class="string">earliest</span></span><br><span class="line"><span class="comment"># 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span></span><br><span class="line"><span class="string">spring.kafka.consumer.enable-auto-commit=</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 键的反序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.consumer.key-deserializer=</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="comment"># 值的反序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.consumer.value-deserializer=</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="comment"># 在侦听器容器中运行的线程数。</span></span><br><span class="line"><span class="string">spring.kafka.listener.concurrency=</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#listner负责ack，每调用一次，就立即commit</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-mode=</span> <span class="string">manual_immediate</span></span><br><span class="line"><span class="string">spring.kafka.listener.missing-topics-fatal=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>生产者生产消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDemo</span> </span>&#123;</span><br><span class="line">    Logger log = LoggerFactory.getLogger(ProductDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义topic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_TEST = <span class="string">&quot;topic.test&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_GROUP1 = <span class="string">&quot;topic.group1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_GROUP2 = <span class="string">&quot;topic.group2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;准备发送消息为：&#123;&#125;&quot;</span>, obj);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(TOPIC_TEST, obj);</span><br><span class="line">        future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//发送失败的处理</span></span><br><span class="line">                log.info(TOPIC_TEST + <span class="string">&quot; - 生产者 发送消息失败：&quot;</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//成功的处理</span></span><br><span class="line">                log.info(TOPIC_TEST + <span class="string">&quot; - 生产者 发送消息成功：&quot;</span> + stringObjectSendResult.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    Logger log = LoggerFactory.getLogger(ConsumerDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = ProductDemo.TOPIC_TEST, groupId = ProductDemo.TOPIC_GROUP1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional message = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent()) &#123;</span><br><span class="line">            Object msg = message.get();</span><br><span class="line">            log.info(<span class="string">&quot;topic_test 消费了： Topic:&quot;</span> + topic + <span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = ProductDemo.TOPIC_TEST, groupId = ProductDemo.TOPIC_GROUP2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test1</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional message = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent()) &#123;</span><br><span class="line">            Object msg = message.get();</span><br><span class="line">            log.info(<span class="string">&quot;topic_test1 消费了： Topic:&quot;</span> + topic + <span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private ProductDemo productDemo;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/kafka/test&quot;)</span><br><span class="line">public void testKafka()&#123;</span><br><span class="line">    logger.info(&quot;start test&quot;);</span><br><span class="line">    productDemo.send(&quot;hello kafka&quot;);</span><br><span class="line">    logger.info(&quot;end test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p align="middle">山脚太拥挤 我们更高处见。</p></blockquote>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>multi_match 查询</title>
    <url>/wiki/multi-match-%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>multi_match 查询为能在多个字段上反复执行相同查询提供了一种便捷方式。</p>
<p>📒 📒 📒</p>
<blockquote>
<p>multi_match 多匹配查询的类型有多种，其中的三种恰巧与 了解我们的数据 中介绍的三个场景对应，即：<code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）。</p>
</blockquote>
<p>默认情况下，查询的类型是 <code>best_fields</code> ，这表示它会为每个字段生成一个 <code>match</code> 查询，然后将它们组合到 <code>dis_max</code> 查询的内部，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;queries&quot;</span>:  [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;tie_breaker&quot;</span>: <span class="number">0.3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个查询用 multi_match 重写成更简洁的形式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:                <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:                 <span class="string">&quot;best_fields&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>:               [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;body&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;tie_breaker&quot;</span>:          <span class="number">0.3</span>,</span><br><span class="line">        <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ ⚠️ ⚠️</p>
<ul>
<li>best_fields 类型是默认值，可以不指定。</li>
<li>如 minimum_should_match 或 operator 这样的参数会被传递到生成的 match 查询中。</li>
</ul>
<h2 id="查询字段名称的模糊匹配"><a href="#查询字段名称的模糊匹配" class="headerlink" title="查询字段名称的模糊匹配"></a>查询字段名称的模糊匹配</h2><p>字段名称可以用 <code>模糊匹配</code> 的方式给出：任何与模糊模式正则匹配的字段都会被包括在搜索条件中，例如可以使用以下方式同时匹配 <code>book_title</code> 、 <code>chapter_title</code> 和 <code>section_title</code> （书名、章名、节名）这三个字段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: <span class="string">&quot;*_title&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提升单个字段的权重"><a href="#提升单个字段的权重" class="headerlink" title="提升单个字段的权重"></a>提升单个字段的权重</h2><p>可以使用 ^ 字符语法为单个字段提升权重，在字段名称的末尾添加 ^boost ，其中 boost 是一个浮点数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;*_title&quot;</span>, <span class="string">&quot;chapter_title^2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chapter_title 这个字段的 boost 值为 2 ，而其他两个字段 book_title 和 section_title 字段的默认 boost 值为 1 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-match-query.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » multi_match 查询</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-multi-match-query.html">Elasticsearch Guide [7.x] » Query DSL » Full text queries » Multi-match query</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-工作原理</title>
    <url>/wiki/mybatis-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Mybatis工作原理"><a href="#Mybatis工作原理" class="headerlink" title="Mybatis工作原理"></a>Mybatis工作原理</h1><h2 id="Mybatis整体框架"><a href="#Mybatis整体框架" class="headerlink" title="Mybatis整体框架"></a>Mybatis整体框架</h2><p><img src="https://oscimg.oschina.net/oscnet/up-978b1c01a681073e4a020fdce7703887901.png">  </p>
<h2 id="工作原理解析"><a href="#工作原理解析" class="headerlink" title="工作原理解析"></a>工作原理解析</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0015501b933b36728b8f66f281d78358e97.png">  </p>
<p>1）读取MyBatis配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<blockquote>
<p>读取配置文件将mybatis-config.xml转换为org.apache.ibatis.session.Configuration类，这里mybatis包含9个全局配置；</p>
</blockquote>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<blockquote>
<p>扫描Mapping目录下的***Mapper.xml文件； </p>
</blockquote>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(name = &quot;sqlSessionFactory&quot;)</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(HikariDataSource dataSource) throws Exception &#123;</span><br><span class="line">    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();</span><br><span class="line">    bean.setDataSource(dataSource);</span><br><span class="line">    bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:com/****/mapping/**/*.xml&quot;));</span><br><span class="line">    return bean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成工厂实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);</span><br><span class="line">    <span class="keyword">private</span> Resource configLocation;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> Resource[] mapperLocations;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> TransactionFactory transactionFactory;</span><br><span class="line">    <span class="keyword">private</span> Properties configurationProperties;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> String environment = SqlSessionFactoryBean.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="keyword">private</span> Interceptor[] plugins;</span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt;[] typeHandlers;</span><br><span class="line">    <span class="keyword">private</span> String typeHandlersPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] typeAliases;</span><br><span class="line">    <span class="keyword">private</span> String typeAliasesPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;</span><br><span class="line">    <span class="keyword">private</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends VFS&gt; vfs;</span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
<blockquote>
<p>SqlSession对象完成和数据库的交互： </p>
</blockquote>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<blockquote>
<p>3种执行期类型（Simple Pre Batch）  Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</p>
</blockquote>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<blockquote>
<p>借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。 </p>
</blockquote>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。<br>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="http://c.biancheng.net/view/4304.html">MyBatis的工作原理 C语言网</a>  </p>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/wiki/mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>title: mybatis配置文件解析<br>toc: true<br>date: 2021-07-28 17:05:46<br>tags: mybatis<br>categories: [Spring Family]</p>
<hr>
<h1 id="Mybatis配置文件"><a href="#Mybatis配置文件" class="headerlink" title="Mybatis配置文件"></a>Mybatis配置文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 引入数据库属性文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>  <span class="attr">resource</span>=<span class="string">&quot;database.properties&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;username&quot; value=&quot;sa&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- mybatis配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 别名的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;typeAlias type=&quot;com.xit.pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.xit.pojo&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">&lt;!-- 配置运行环境 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 由JDBC管理事务 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置数据源：连接池 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入Mapper映射文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xit/pojo/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- URL方式 --&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- &lt;mapper url=&quot;file:///C:/eclipse-workspace/mybatis-01/src/com/xit/pojo/UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Mybatis有几部分全局配置"><a href="#Mybatis有几部分全局配置" class="headerlink" title="Mybatis有几部分全局配置"></a>Mybatis有几部分全局配置</h2><p>properties=&gt;ettings=&gt;typeAliases=&gt;typeHandlers=&gt;objectFactory=&gt;plugins=&gt;environment=&gt;databaseIdProvider=&gt;mappers</p>
<h2 id="Mybatis-加载Mapper文件有几种方式？"><a href="#Mybatis-加载Mapper文件有几种方式？" class="headerlink" title="Mybatis 加载Mapper文件有几种方式？"></a>Mybatis 加载Mapper文件有几种方式？</h2><p><img src="https://oscimg.oschina.net/oscnet/up-418b861802897058c608593b4b159d5baa2.png"><br>以上是Mybatis官方文档介绍的样例👆，<a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">原文链接请点击这</a>  </p>
<p>  <strong>有4种方式；按照优先级从高到底依次是：</strong>  </p>
<ul>
<li>package</li>
<li>resource</li>
<li>url</li>
<li>class</li>
</ul>
<p>下面是Mybatis加载mybatis-config.xml文件配置的源码，从代码中也可以看到加载的4中方式和优先级！👇<br><strong>org.apache.ibatis.builder.xml.XMLConfigBuilder#typeHandlerElement</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = parent.getChildren().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    XNode child = (XNode)var2.next();</span><br><span class="line">                    String resource;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">                        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">                        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                        XMLMapperBuilder mapperParser;</span><br><span class="line">                        InputStream inputStream;</span><br><span class="line">                        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(resource);</span><br><span class="line">                            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(url);</span><br><span class="line">                            inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">## Mybatis有几种执行器</span><br><span class="line">mybatis有<span class="number">3</span>中执行器； </span><br><span class="line">```text</span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">    SIMPLE, <span class="comment">// 默认</span></span><br><span class="line">    REUSE,</span><br><span class="line">    BATCH;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExecutorType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mysql乐观锁实现分布式锁</title>
    <url>/wiki/mysql%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="基于数据表乐观锁实现分布式锁"><a href="#基于数据表乐观锁实现分布式锁" class="headerlink" title="基于数据表乐观锁实现分布式锁"></a>基于数据表乐观锁实现分布式锁</h1><h2 id="整体的实际思路"><a href="#整体的实际思路" class="headerlink" title="整体的实际思路"></a>整体的实际思路</h2><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源的时候，<br>我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。  </p>
<h2 id="基于数据表实现分布式锁的几个要点"><a href="#基于数据表实现分布式锁的几个要点" class="headerlink" title="基于数据表实现分布式锁的几个要点"></a>基于数据表实现分布式锁的几个要点</h2><p>1、这把锁依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解决操作失败，就会导致记录一直在数据库中，其他线程无法在获得锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁的操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库表中数据已经存在了。  </p>
<p><strong>当然，我们也可以有其它方式解决上面的问题：</strong>  </p>
<p>1、数据库是单点？那就搞两个数据库，数据库之前双向同步，一旦挂掉快速切换到备库上。<br>2、没有失效时间？可以做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>3、非阻塞？可以写一个while循环，直到insert成功再返回成功。<br>4、非重入？可以在数据库表中加一个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库中可以查到的话，就直接把锁分配给它即可。   </p>
<h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h2><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，<br>可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。  </p>
<blockquote>
<p>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，<br>每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。<br>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。<strong>一般的实现乐观锁的方式就是记录数据版本</strong>。  </p>
</blockquote>
<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<br>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。    </p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。<br>但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。  </p>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。  </p>
<h3 id="1、使用版本号实现乐观锁"><a href="#1、使用版本号实现乐观锁" class="headerlink" title="1、使用版本号实现乐观锁"></a>1、使用版本号实现乐观锁</h3><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查询出商品信息</span><br><span class="line">select (status,status,version) from t_goods where id=#&#123;id&#125;</span><br><span class="line">2.根据商品信息生成订单</span><br><span class="line">3.修改商品status为2</span><br><span class="line">update t_goods</span><br><span class="line">set status=2,version=version+1</span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，<br>因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，<br>对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p>
<blockquote>
<p>这一点其实在微服务架构中只要做好数据隔离就可以避免，比如user这张数据表，按照边界划分应该属于用户中心服务的，其他服务比如仓储，物流等需要<br>用户的信息，应该有用户中心暴露出接口，而不是仓储去数据库查询user这张表的数据，甚至update user的数据。</p>
</blockquote>
<h3 id="2、使用时间戳"><a href="#2、使用时间戳" class="headerlink" title="2、使用时间戳"></a>2、使用时间戳</h3><p>一般都是使用update_time字段，并且这个字段肯定是跟随数据库时间配置的，即 update on current_timestamp ；</p>
<h2 id="乐观锁的优点与不足"><a href="#乐观锁的优点与不足" class="headerlink" title="乐观锁的优点与不足"></a>乐观锁的优点与不足</h2><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。<br>能够提升数据库的吞吐量；<br>但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/lmb55/article/details/78495629">基于数据库的分布式锁实现</a><br><a href="https://blog.csdn.net/tianjiabin123/article/details/72625156">分布式锁方式（一、基于数据库的分布式锁）</a><br><a href="https://zhuanlan.zhihu.com/p/42056183">分布式锁看这篇就够了</a><br><a href="https://blog.csdn.net/lmb55/article/details/78266667">乐观锁与悲观锁深入学习</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用命令</title>
    <url>/wiki/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="binlog相关命令"><a href="#binlog相关命令" class="headerlink" title="binlog相关命令"></a>binlog相关命令</h2><p>mysql&gt; show variables like ‘binlog_format’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>show variables like ‘log_bin’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>



<h2 id="用户-amp-权限"><a href="#用户-amp-权限" class="headerlink" title="用户&amp;权限"></a>用户&amp;权限</h2><h3 id="创建用户并授权"><a href="#创建用户并授权" class="headerlink" title="创建用户并授权"></a>创建用户并授权</h3><p>root用户登录： mysql -u root -p 然后输入密码<br>创建用户： <code>create user &#39;yjuser&#39;@&#39;%&#39; identified by &#39;u-bx.com&#39;;</code><br>授权用户只读权限： <code>grant SELECT on mirror.* to &#39;yjuser&#39;@&#39;%&#39; IDENTIFIED by &#39;u-bx.com&#39;;</code><br>刷新权限：<code>flush privileges;</code></p>
<h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><p><code>select User();</code></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>netty实现简易RPC调用</title>
    <url>/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93RPC%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于Netty手写一个RPC简易远程调用"><a href="#基于Netty手写一个RPC简易远程调用" class="headerlink" title="基于Netty手写一个RPC简易远程调用"></a>基于Netty手写一个RPC简易远程调用</h1><p><img src="https://oscimg.oschina.net/oscnet/up-b813c676214fc02b6f107ca7f6133a635fb.png">    </p>
<h2 id="抽象协议"><a href="#抽象协议" class="headerlink" title="抽象协议"></a>抽象协议</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerProtocol</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于二进制流调用协议</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 形参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] params;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="RpcRegistry-基于Netty实现的RPC注册中心"><a href="#RpcRegistry-基于Netty实现的RPC注册中心" class="headerlink" title="RpcRegistry 基于Netty实现的RPC注册中心"></a>RpcRegistry 基于Netty实现的RPC注册中心</h3><blockquote>
<p>1、 ServerBootstrap 启动8080端口，等待客户端链接；<br>2、 RegisterHandler用来处理RPC接口的发现和注册；    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer post;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRegistry</span><span class="params">(Integer post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        server.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 接受客户端请求的处理</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//配置通用解码器</span></span><br><span class="line">                        <span class="keyword">int</span> fieldLength = <span class="number">4</span>;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, fieldLength, <span class="number">0</span>, fieldLength));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(fieldLength));</span><br><span class="line">                        <span class="comment">//对象编码器</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> RegisterHandler());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(<span class="keyword">this</span>.post).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Rpc registry started in port &quot;</span> + <span class="keyword">this</span>.post);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RpcRegistry(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RegisterHandler-执行RPC的发现和注册"><a href="#RegisterHandler-执行RPC的发现和注册" class="headerlink" title="RegisterHandler 执行RPC的发现和注册"></a>RegisterHandler 执行RPC的发现和注册</h3><blockquote>
<p>1、扫描固定包下或者路径下的类;<br>2、接口为key，具体实例作为value；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; REGISTRY_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、扫描所有需要注册的类</span></span><br><span class="line">        scannerClass(<span class="string">&quot;com.ibli.netty.rpc.provider&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行注册</span></span><br><span class="line">        doRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        InvokerProtocol request = (InvokerProtocol) msg;</span><br><span class="line">        <span class="keyword">if</span> (REGISTRY_MAP.containsKey(request.getClassName())) &#123;</span><br><span class="line">            Object provider = REGISTRY_MAP.get(request.getClassName());</span><br><span class="line">            Method method = provider.getClass().getMethod(request.getMethodName(), request.getParams());</span><br><span class="line">            result = method.invoke(provider, request.getValues());</span><br><span class="line">            ctx.write(result);</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNameList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String className : classNameList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                Class&lt;?&gt; i = clazz.getInterfaces()[<span class="number">0</span>];</span><br><span class="line">                REGISTRY_MAP.put(i.getName(), clazz.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scannerClass</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(packageName.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                scannerClass(packageName + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                classNameList.add(packageName + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>).trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API以及实现"><a href="#API以及实现" class="headerlink" title="API以及实现"></a>API以及实现</h2><h3 id="RPC接口-定义一个简单的服务接口"><a href="#RPC接口-定义一个简单的服务接口" class="headerlink" title="RPC接口 定义一个简单的服务接口"></a>RPC接口 定义一个简单的服务接口</h3><blockquote>
<p>作为一个微服务对外暴露的API;  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRpcService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC接口实现"><a href="#RPC接口实现" class="headerlink" title="RPC接口实现"></a>RPC接口实现</h3><blockquote>
<p>provider实现具体的接口，提供具体的服务；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRpcService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC调用方"><a href="#RPC调用方" class="headerlink" title="RPC调用方"></a>RPC调用方</h2><h3 id="调用RPC"><a href="#调用RPC" class="headerlink" title="调用RPC"></a>调用RPC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IRpcService rpc = RpcProxy.create(IRpcService.class);</span><br><span class="line">        System.err.println(rpc.add(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">        System.err.println(rpc.mul(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        System.err.println(rpc.sub(<span class="number">14</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="RpcProxy-动态代理对象请求RPC"><a href="#RpcProxy-动态代理对象请求RPC" class="headerlink" title="RpcProxy 动态代理对象请求RPC"></a>RpcProxy 动态代理对象请求RPC</h2><blockquote>
<p>通过Netty Bootstrap访问8080端口；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        MethodProxy proxy = <span class="keyword">new</span> MethodProxy(clazz);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.isInterface() ?</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;clazz&#125; :</span><br><span class="line">                clazz.getInterfaces();</span><br><span class="line">        T result = (T) Proxy.newProxyInstance(clazz.getClassLoader(), interfaces, proxy);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rpcInvoke(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">rpcInvoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装请求的内容</span></span><br><span class="line">            InvokerProtocol msg = <span class="keyword">new</span> InvokerProtocol();</span><br><span class="line">            msg.setClassName(<span class="keyword">this</span>.clazz.getName());</span><br><span class="line">            msg.setMethodName(method.getName());</span><br><span class="line">            msg.setParams(method.getParameterTypes());</span><br><span class="line">            msg.setValues(args);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> RpcProxyHandler consumerHandler = <span class="keyword">new</span> RpcProxyHandler();</span><br><span class="line">            EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Bootstrap client = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                client.group(group)</span><br><span class="line">                        .channel(NioSocketChannel.class)</span><br><span class="line">                        .handler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">//接收课客户端请求的处理流程</span></span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">int</span> fieldLength = <span class="number">4</span>;</span><br><span class="line">                                <span class="comment">//通用解码器设置</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, fieldLength, <span class="number">0</span>, fieldLength));</span><br><span class="line">                                <span class="comment">//通用编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(fieldLength));</span><br><span class="line">                                <span class="comment">//对象编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                                <span class="comment">//对象解码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;handler&quot;</span>, consumerHandler);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                ChannelFuture future = client.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">                future.channel().writeAndFlush(msg).sync();</span><br><span class="line">                future.channel().closeFuture().sync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> consumerHandler.getResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC调用方接受并处理调用结果"><a href="#RPC调用方接受并处理调用结果" class="headerlink" title="RPC调用方接受并处理调用结果"></a>RPC调用方接受并处理调用结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.response = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>netty实现简易tomcat</title>
    <url>/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/</url>
    <content><![CDATA[<h1 id="基于Netty手写一个简易的Tomcat容器"><a href="#基于Netty手写一个简易的Tomcat容器" class="headerlink" title="基于Netty手写一个简易的Tomcat容器"></a>基于Netty手写一个简易的Tomcat容器</h1><p>本文主要基于传统的BIO来实现一个简单的Http请求处理过程；<br>1、Servlet请求无非就是doGet/doPost，所以我们定义抽象Servlet记忆GET/POST方法；<br>2、基于Netty API实现CS通信；<br>3、模拟Spring加载配置文件，注册请求以及控制器；  </p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6bb2d717164854e73513f9ed1355d1844bc.png">   </p>
<h2 id="Netty版本"><a href="#Netty版本" class="headerlink" title="Netty版本"></a>Netty版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;o.netty&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">4.1</span><span class="number">.6</span>.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单"><a href="#GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单" class="headerlink" title="GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单"></a>GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlRequest</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.uri();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.method().name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getParams() &#123;</span><br><span class="line">        QueryStringDecoder decoder = <span class="keyword">new</span> QueryStringDecoder(req.uri());</span><br><span class="line">        <span class="keyword">return</span> decoder.parameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParam</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = getParams();</span><br><span class="line">        List&lt;String&gt; strings = params.get(name);</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="GlResponse-基于Netty-amp-FullHttpResponse的API操作"><a href="#GlResponse-基于Netty-amp-FullHttpResponse的API操作" class="headerlink" title="GlResponse 基于Netty&amp;FullHttpResponse的API操作"></a>GlResponse 基于Netty&amp;FullHttpResponse的API操作</h2><blockquote>
<p>FullHttpResponse作为返回请求的主体；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlResponse</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                    HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK,</span><br><span class="line">                    Unpooled.wrappedBuffer(string.getBytes(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            response.headers().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            ctx.write(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="GlServlet-定义抽象servlet，定义GET方法和POST方法"><a href="#GlServlet-定义抽象servlet，定义GET方法和POST方法" class="headerlink" title="GlServlet 定义抽象servlet，定义GET方法和POST方法"></a>GlServlet 定义抽象servlet，定义GET方法和POST方法</h2><blockquote>
<p>定义抽象的Servlet和doGet方法和doPost方法，具体的业务去实现自己的方法和逻辑；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (GET.equals(request.getMethod())) &#123;</span><br><span class="line">               doGet(request, response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               doPost(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="FirstServlet-具体的业务Servlet实现抽象Servlet的方法"><a href="#FirstServlet-具体的业务Servlet实现抽象Servlet的方法" class="headerlink" title="FirstServlet 具体的业务Servlet实现抽象Servlet的方法"></a>FirstServlet 具体的业务Servlet实现抽象Servlet的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This is first servlet from NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondServlet-具体的业务Servlet实现抽象Servlet方法"><a href="#SecondServlet-具体的业务Servlet实现抽象Servlet方法" class="headerlink" title="SecondServlet 具体的业务Servlet实现抽象Servlet方法"></a>SecondServlet 具体的业务Servlet实现抽象Servlet方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This second request form NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="web-nio-properties-配置文件"><a href="#web-nio-properties-配置文件" class="headerlink" title="web-nio.properties 配置文件"></a>web-nio.properties 配置文件</h2><blockquote>
<p>配置请求和处理器，Spring中是通过Controller下的@XXXMapping注解去扫描并加载到工厂的；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servlet.one.className=com.ibli.netty.tomcat.nio.servlet.FirstServlet</span><br><span class="line">servlet.one.url=/firstServlet.<span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">servlet.two.className=com.ibli.netty.tomcat.nio.servlet.SecondServlet</span><br><span class="line">servlet.two.url=/secondServlet.<span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<h2 id="GlTomcat"><a href="#GlTomcat" class="headerlink" title="GlTomcat"></a>GlTomcat</h2><blockquote>
<p>启动服务端，在网页中访问本地8080端口，输入配置文件中定义的url进行测试：  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> Properties webXml = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GlServlet&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;String, GlServlet&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GlTomcat().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat的启动入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、加载web配置文件，解析配置</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Boss线程</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// Worker线程</span></span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2、创建Netty服务端对象</span></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3、 配置服务端参数</span></span><br><span class="line">        server.group(bossGroup, workGroup)</span><br><span class="line">                <span class="comment">// 配置主线程的处理逻辑</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 子线程的回调逻辑</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel client)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 处理具体的回调逻辑</span></span><br><span class="line">                        <span class="comment">// 责任链模式</span></span><br><span class="line">                        <span class="comment">//返回-编码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">                        <span class="comment">//请求-解码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">                        <span class="comment">//用户自己的逻辑处理</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> GlTomcatHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 配置主线程可分配的最大线程数</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//保持长链接</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future = server.bind(<span class="keyword">this</span>.PORT).sync();</span><br><span class="line">            System.err.println(<span class="string">&quot;Gl tomcat started in pory &quot;</span> + <span class="keyword">this</span>.PORT);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     * 这其实使用了策略模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String WEB_INF = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(WEB_INF + <span class="string">&quot;web-nio.properties&quot;</span>);</span><br><span class="line">            webXml.load(fis);</span><br><span class="line">            <span class="keyword">for</span> (Object k : webXml.keySet()) &#123;</span><br><span class="line">                String key = k.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&quot;.url&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//servlet.two.url</span></span><br><span class="line">                    String servletName = key.replaceAll(<span class="string">&quot;\\.url&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    String url = webXml.getProperty(key);</span><br><span class="line">                    <span class="comment">//servlet.two.className</span></span><br><span class="line">                    String className = webXml.getProperty(servletName + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">                    <span class="comment">//反射创建servlet实例</span></span><br><span class="line">                    <span class="comment">// load-on-startup &gt;=1 :web启动的时候初始化  0：用户请求的时候才启动</span></span><br><span class="line">                    GlServlet obj = (GlServlet) Class.forName(className).newInstance();</span><br><span class="line">                    <span class="comment">// 将url和servlet建立映射关系</span></span><br><span class="line">                    servletMapping.put(url, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">                HttpRequest req = (HttpRequest) msg;</span><br><span class="line">                GlRequest request = <span class="keyword">new</span> GlRequest(ctx,req);</span><br><span class="line">                GlResponse response = <span class="keyword">new</span> GlResponse(ctx,req);</span><br><span class="line">                String url = request.getUrl();</span><br><span class="line">                <span class="keyword">if</span> (servletMapping.containsKey(url))&#123;</span><br><span class="line">                    servletMapping.get(url).service(request,response);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    response.write(<span class="string">&quot;404 Not Fount&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><blockquote>
<p>请求 : <a href="http://localhost:8080/secoundServlet.do">http://localhost:8080/secoundServlet.do</a> 这的地址写错误  ⚠️<br><img src="https://oscimg.oschina.net/oscnet/up-4652c388dd368f575bc5c0719f68a8632df.png">  </p>
</blockquote>
<blockquote>
<p>请求 : <a href="http://localhost:8080/secondServlet.do">http://localhost:8080/secondServlet.do</a><br><img src="https://oscimg.oschina.net/oscnet/up-cc90b46288898bfe801e33f3a94bfab5070.png">  </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>python3基础语法</title>
    <url>/wiki/python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：<br><code># -*- coding: cp-1252 -*-</code></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>第一个字符必须是字母表中字母或下划线 _ 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。<br>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</li>
</ul>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>import keyword<br>keyword.kwlist<br>[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 # 开头,多行注释可以用多个 # 号，还有 ‘’’ 和 “””：</p>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>

<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \，例如：</p>
<p><code>total = [&#39;item_one&#39;, &#39;item_two&#39;, &#39;item_three&#39;,         &#39;item_four&#39;, &#39;item_five&#39;]</code></p>
<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li>int (整数) , 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li>bool (布尔), 如 True。</li>
<li>float (浮点数), 如 1.23、3E-2</li>
<li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</li>
<li>转义符 \</li>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
<li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li>
<li>Python中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li>
</ul>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p>记住：空行也是程序代码的一部分。</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression : </span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression : </span><br><span class="line">   suite </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">   suite</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line"><span class="comment">## print 输出</span></span><br><span class="line"><span class="built_in">print</span> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=<span class="string">&quot;&quot;</span>：</span><br><span class="line"></span><br><span class="line"><span class="comment">## import 与 from...import</span></span><br><span class="line">在 python 用 <span class="keyword">import</span> 或者 <span class="keyword">from</span>...<span class="keyword">import</span> 来导入相应的模块。</span><br><span class="line"></span><br><span class="line">将整个模块(somemodule)导入，格式为： <span class="keyword">import</span> somemodule</span><br><span class="line"></span><br><span class="line">从某个模块中导入某个函数,格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> somefunction</span><br><span class="line"></span><br><span class="line">从某个模块中导入多个函数,格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> firstfunc, secondfunc, thirdfunc</span><br><span class="line"></span><br><span class="line">将某个模块中的全部函数导入，格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令行参数</span></span><br><span class="line"></span><br><span class="line">很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</span><br></pre></td></tr></table></figure>
<p>$ python -h<br>usage: python [option] … [-c cmd | -m mod | file | -] [arg] …<br>Options and arguments (and corresponding environment variables):<br>-c cmd : program passed in as string (terminates option list)<br>-d     : debug output from parser (also PYTHONDEBUG=x)<br>-E     : ignore environment variables (such as PYTHONPATH)<br>-h     : print this help message and exit</p>
<p>[ etc. ]</p>
<p>```<br>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数;</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python3基本数据类型</title>
    <url>/wiki/python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
<li>Python3 的六个标准数据类型中：</li>
</ul>
<p><code>不可变数据</code>（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br><code>可变数据</code>（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 int、float、bool、complex（复数）。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">float</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">bool</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>⚠️ isinstance 和 type 的区别在于：<br>type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型。</p>
<blockquote>
<p>⚠️ 注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加 True==1，False==0 是会返回 Ture，但可以通过 is 来判断类型。<br>1、Python可以同时为多个变量赋值，如a, b = 1, 2。<br>2、一个变量可以通过赋值指向不同类型的对象。<br>3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。<br>4、在混合计算时，Python会把整型转换成为浮点数。</p>
</blockquote>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。<br>字符串的截取的语法格式如下：<br><code>变量[头下标:尾下标]</code><br>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：<br><code>变量[头下标:尾下标]</code><br>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br></pre></td></tr></table></figure>

<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<p>创建格式：<br><code>parame = &#123;value01,value02,...&#125;</code> 或者 <code>set(value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure>

<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<pre><code class="python">#!/usr/bin/python3

dict = &#123;&#125;
dict[&#39;one&#39;] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;

tinydict = &#123;&#39;name&#39;: &#39;runoob&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.runoob.com&#39;&#125;


print (dict[&#39;one&#39;])       # 输出键为 &#39;one&#39; 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre>
<p>注意：<br>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用 { }。</p>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<img src = 'https://oscimg.oschina.net/oscnet/up-2af36cf02d5a8c9ba5c9148154bbdd83207.png' whdth='700'>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作elasticsearch</title>
    <url>/wiki/python%E6%93%8D%E4%BD%9Celasticsearch/</url>
    <content><![CDATA[<h2 id="下载python对应的elasticsearch依赖包"><a href="#下载python对应的elasticsearch依赖包" class="headerlink" title="下载python对应的elasticsearch依赖包"></a>下载python对应的elasticsearch依赖包</h2><p><code>pip3 install elasticsearch==7.10.0</code></p>
<h2 id="python操作elasticsearch代码"><a href="#python操作elasticsearch代码" class="headerlink" title="python操作elasticsearch代码"></a>python操作elasticsearch代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;init ...&quot;</span>)</span><br><span class="line">es = Elasticsearch([&#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;XXXXXX&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">9200</span>&#125;], http_auth=(<span class="string">&#x27;elastic&#x27;</span>, <span class="string">&#x27;XXXXXX&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(es.get(index=&#x27;yj_ip_pool&#x27;, doc_type=&#x27;_doc&#x27;, id=&#x27;9256058&#x27;))</span></span><br><span class="line">countRes = es.count(index=<span class="string">&#x27;yj_ip_pool&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(countRes)</span><br></pre></td></tr></table></figure>

<h2 id="查询效果"><a href="#查询效果" class="headerlink" title="查询效果"></a>查询效果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gaolei:awesome-python3-webapp gaolei$ /usr/local/opt/python/bin/python3.7 /Users/gaolei/Documents/DemoProjects/awesome-python3-webapp/www/es_test.py</span><br><span class="line">init ...</span><br><span class="line">&#123;&#x27;count&#x27;: 20095400, &#x27;_shards&#x27;: &#123;&#x27;total&#x27;: 1, &#x27;successful&#x27;: 1, &#x27;skipped&#x27;: 0, &#x27;failed&#x27;: 0&#125;&#125;</span><br><span class="line">gaolei:awesome-python3-webapp gaolei$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么禁止开发人员修改 serialVersionUID 字段的值?</title>
    <url>/wiki/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%BF%AE%E6%94%B9-serialVersionUID-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>序列化是一种对象持久化的手段。普遍应用在网络传输、RMI 等场景中。类通 过实现 java.io.Serializable 接口以启用其序列化功能。<br><a href="http://www.hollischuang.com/archives/1150">Java 对象的序列化与反序列化、深入分析 Java 的序列化与反序列化、单例与 序列化的那些事儿</a>  </p>
</blockquote>
<p>在这几篇文章中，分别介绍过了序列化涉及到的类和接口、如何自定义序列化 策略、transient 关键字和序列化的关系等，还通过学习 ArrayList 对序列化的实现源 码深入学习了序列化。并且还拓展分析了一下序列化对单例的影响等。<br>但是，还有一个知识点并未展开介绍，那就是关于 serialVersionUID 。这个 字段到底有什么用?如果不设置会怎么样?为什么《Java 开发手册》中有以下规定:</p>
<img src='https://oscimg.oschina.net/oscnet/up-5b1a6020460edc9c688c054bdbad957cc28.png'>   


<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Serializable 和 Externalizable<br>类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接 口的类将无法进行序列化或反序列化。可序列化类的所有子类型本身都是可序列 化的。<br>如果读者看过 Serializable 的源码，就会发现，他只是一个空的接口，里 面什么东西都没有。Serializable 接口没有方法或字段，仅用于标识可序列化的 语义。但是，如果一个类没有实现这个接口，想要被序列化的话，就会抛出 java. io.NotSerializableException 异常。</p>
<p>它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢?<br>原因是在执行序列化的过程中，会执行到以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在进行序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果都不是则直接抛出 NotSerializableException。<br>Java 中还提供了 Externalizable 接口，也可以实现它来提供序列化能力。</p>
<p>Externalizable 继承自 Serializable，该接口中定义了两个抽象方法: writeExternal() 与 readExternal()。<br>当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重 写 writeExternal() 与 readExternal() 方法。否则所有变量的值都会变成默认值。</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可 以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h2 id="自定义序列化策略"><a href="#自定义序列化策略" class="headerlink" title="自定义序列化策略"></a>自定义序列化策略</h2><p>在序列化过程中，如果被序列化的类中定义了 writeObject 和 readObject 方法， 虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的 序列化和反序列化。</p>
<p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteOb- ject 方法以及 ObjectInputStream 的 defaultReadObject 方法。<br>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程， 比如可以在序列化的过程中动态改变序列化的数值。</p>
<p>所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用 tran- sient 修 饰， 并 自 己 重 写 writeObject 和 readObject 方 法， 如 java.util. ArrayList 中就有这样的实现。</p>
<p>我们随便找几个 Java 中实现了序列化接口的类，如 String、Integer 等，我们 可以发现一个细节，那就是这些类除了实现了 Serializable 外，还定义了一个 serialVersionUID</p>
<img src='https://oscimg.oschina.net/oscnet/up-74a9507ed04462e44fb2b7dd941d6b00fd4.png'>

<p>那么，到底什么是 serialVersionUID 呢?为什么要设置这样一个字段呢?</p>
<h2 id="什么是-serialVersionUID"><a href="#什么是-serialVersionUID" class="headerlink" title="什么是 serialVersionUID"></a>什么是 serialVersionUID</h2><p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。我们都知道， Java 对象是保存在 JVM 的堆内存中的，也就是说，如果 JVM 堆不存在了，那么对 象也就跟着消失了。</p>
<p>而序列化提供了一种方案，可以让你在即使 JVM 停机的情况下也能把对象保存 下来的方案。就像我们平时用的 U 盘一样。把 Java 对象序列化成可存储或传输的形 式(如二进制流)，比如保存在文件中。这样，当再次需要这个对象的时候，从文件中 读取出二进制流，再从二进制流中反序列化出对象。</p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重 要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化 ID，就是我们在代码中 定义的 serialVersionUID。</p>
<h2 id="如果-serialVersionUID-变了会怎样"><a href="#如果-serialVersionUID-变了会怎样" class="headerlink" title="如果 serialVersionUID 变了会怎样"></a>如果 serialVersionUID 变了会怎样</h2><p>我们举个例子吧，看看如果 serialVersionUID 被修改了会发生什么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Initializes The Object User1 user = new User1(); user.setName(&quot;hollis&quot;);</span></span><br><span class="line">                <span class="comment">//Write Obj to File ObjectOutputStream oos = null; try &#123;</span></span><br><span class="line">                oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">                oos.writeObject(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(</span><br><span class="line">            IOException e)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                IOUtils.closeQuietly(oos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">我们先执行以上代码，把一个 User1 对象写入到文件中。然后我们修改一下 User1 类，把 serialVersionUID 的值改为 <span class="number">2L</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后执行以下代码，把文件中的对象反序列化出来:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo2</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Read Obj from File</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">                ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">                    User1 newUser = (User1) ois.readObject();</span><br><span class="line">                    System.out.println(newUser);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    IOUtils.closeQuietly(ois);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FileUtils.forceDelete(file);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">执行结果如下</span><br><span class="line">```java</span><br><span class="line">java.io.InvalidClassException: com.hollis.User1; local <span class="class"><span class="keyword">class</span> <span class="title">incompatible</span>: <span class="title">stream</span> <span class="title">classdesc</span></span></span><br><span class="line"><span class="class"><span class="title">serialVersionUID</span> </span>= <span class="number">1</span>, local <span class="class"><span class="keyword">class</span> <span class="title">serialVersionUID</span> </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，以上代码抛出了一个 java.io.InvalidClassException，并且 指出 serialVersionUID 不一致。</p>
<p>这是因为，在进行反序列化时，JVM 会把传来的字节流中的 serialVersio- nUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致 的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 Invalid- CastException。</p>
<p>这也是《Java 开发手册》中规定，在兼容性升级中，在修改类的时候，不要 修改 serialVersionUID 的原因。除非是完全不兼容的两个版本。所以，serialVersionUID 其实是验证版本一致性的。</p>
<p>如果读者感兴趣，可以把各个版本的 JDK 代码都拿出来看一下，那些向下兼容 的类的 serialVersionUID 是没有变化过的。比如 String 类的 serialVersionUID一直都是 -6849794470754667710L。</p>
<p>但是，作者认为，这个规范其实还可以再严格一些，那就是规定:<br>如果一个类实现了 Serializable 接口，就必须手动添加一个 private static final long serialVersionUID变量，并且设置初始值。</p>
<h2 id="为什么要明确定一个-serialVersionUID"><a href="#为什么要明确定一个-serialVersionUID" class="headerlink" title="为什么要明确定一个 serialVersionUID"></a>为什么要明确定一个 serialVersionUID</h2><p>如果我们没有在类中明确的定义一个 serialVersionUID 的话，看看会发生什么。</p>
<p>尝试修改上面的 demo 代码，先使用以下类定义一个对象，该类中不定义 serialVersionUID，将其写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们修改 User1 类，向其中增加一个属性。在尝试将其从文件中读取出来， 并进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执 行 结 果:java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc serialVersionUID = -2986778152837257883, local class serialVersionUID = 7961728318907695402</p>
<p>同样，抛出了 InvalidClassException，并且指出两个 serialVersio- nUID 不同，分别是 -2986778152837257883 和 7961728318907695402。<br>从这里可以看出，系统自己添加了一个 serialVersionUID。 所以，一旦类实现了 Serializable，就建议明确的定义一个 serialVersionUID。不然在修改类的时候，就会发生异常。</p>
<p>serialVersionUID 有两种显示的生成方式:</p>
<p>一是默认的1L，比如:private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段，比如:private static final long serialVersionUID = xxxxL;</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>serialVersionUID 是用来验证版本一致性的。所以在做兼容性升级的时候， 不要改变类中 serialVersionUID 的值。</p>
<p>如果一个类实现了 Serializable 接口，一定要记得定义 serialVersionUID，否则会发生异常。可以在 IDE 中通过设置，让他帮忙提示，并且可以一键快速生成一 个 serialVersionUID。</p>
<p>之所以会发生异常，是因为反序列化过程中做了校验，并且如果没有明确定义的 话，会根据类的属性自动生成一个。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="">Java技术灵魂15问</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>修改mysql表创建时间</title>
    <url>/wiki/%E4%BF%AE%E6%94%B9mysql%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<ul>
<li><p>修改服务器时间<br><code>date -s &quot;2021-07-14 21:22:10&quot;</code></p>
</li>
<li><p>执行DDL<br><code>alter table mirror_user comment &#39;用户表&#39;;</code></p>
</li>
<li><p>服务器时间修正<br><code>ntpdate ntp1.aliyun.com</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>倒排索引</title>
    <url>/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。  </p>
<p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：  </p>
<p>The quick brown fox jumped over the lazy dog<br>Quick brown foxes leap over lazy dogs in summer<br>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p>
<img src="https://oscimg.oschina.net/oscnet/up-ea663f731dfb8db97706ffd2d34a2297576.png" width=230 height=300>  

<p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：  </p>
<img src="https://oscimg.oschina.net/oscnet/up-6b1b6fb36d1467bfab8d222ace66f4f3dc7.png" width=230 height=160>
两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。  

<p>但是，我们目前的倒排索引有一些问题：</p>
<p><code>Quick</code> 和 <code>quick</code> 以独立的词条出现，然而用户可能认为它们是相同的词。<br><code>fox</code> 和 <code>foxes</code> 非常相似, 就像 <code>dog</code> 和 <code>dogs</code> ；他们有相同的词根。<br><code>jumped</code> 和 <code>leap</code>, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。<br>使用前面的索引搜索 <code>+Quick</code> <code>+fox</code> 不会得到任何匹配文档。（记住，+ 前缀表明这个词必须存在。）只有同时出现 <code>Quick</code> 和 <code>fox</code> 的文档才满足这个查询条件，但是第一个文档包含 <code>quick fox</code> ，第二个文档包含 <code>Quick foxes</code> 。</p>
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
<p><code>Quick</code> 可以小写化为 <code>quick</code> 。<br><code>foxes</code> 可以 词干提取 –变为词根的格式– 为 <code>fox</code> 。类似的， <code>dogs</code> 可以为提取为 <code>dog</code> 。<br><code>jumped</code> 和 <code>leap</code> 是同义词，可以索引为相同的单词 <code>jump</code> 。<br>现在索引看上去像这样：<br><img src="https://oscimg.oschina.net/oscnet/up-5ee716c408738e8394f2d9809f8be8354ba.png" width=230 height=270><br>这还远远不够。我们搜索 <code>+Quick</code> <code>+fox</code> 仍然 会失败，因为在我们的索引中，已经没有 <code>Quick</code> 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 <code>+quick</code> <code>+fox</code> ，这样两个文档都会匹配！</p>
<p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Elasticsearch 内存占用及分配</title>
    <url>/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>Elasticsearch 和 Lucene 对内存使用情况： </p>
<img src='https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/es-cache.png' width=500 height=550>


<p>Elasticsearch 限制的内存大小是 JAVA 堆空间的大小，不包括Lucene 缓存倒排索引数据空间。</p>
<p>Lucene 中的 倒排索引 segments 存储在文件中，为提高访问速度，都会把它加载到内存中，从而提高 Lucene 性能。所以建议至少留系统一半内存给Lucene。<br><code>Node Query Cache</code> (负责缓存f ilter 查询结果)，每个节点有一个，被所有 shard 共享，filter query查询结果要么是 yes 要么是no，不涉及 scores 的计算。<br>集群中每个节点都要配置，默认为：indices.queries.cache.size:10%</p>
<p><code>Indexing Buffer</code> 索引缓冲区，用于存储新索引的文档，当其被填满时，缓冲区中的文档被写入磁盘中的 <code>segments</code> 中。节点上所有 <code>shard</code> 共享。<br>缓冲区默认大小： indices.memory.index_buffer_size: 10%<br>如果缓冲区大小设置了百分百则 indices.memory.min_index_buffer_size 用于这是最小值，默认为 48mb。indices.memory.max_index_buffer_size 用于最大大小，无默认值。</p>
<p><code>segments</code><br>segments会长期占用内存，其初衷就是利用OS的cache提升性能。只有在Merge之后，才会释放掉标记为Delete的segments，释放部分内存。</p>
<p><code>Shard Request Cache</code> 用于缓存请求结果，但之缓存request size为0的。比如说 hits.total, aggregations 和 suggestions.<br>默认最大为indices.requests.cache.size:1%</p>
<p><code>Field Data Cache</code> 字段缓存重要用于对字段进行排序、聚合是使用。因为构建字段数据缓存代价昂贵，所以建议有足够的内训来存储。<br><code>Fielddata</code> 是 「 延迟 」 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中，也就不会使用大量的内存，所以可以考虑分配较小的heap给Elasticsearch。因为heap越小意味着Elasticsearch的GC会比较快，并且预留给Lucene的内存也会比较大。。<br>如果没有足够的内存保存fielddata时，Elastisearch会不断地从磁盘加载数据到内存，并剔除掉旧的内存数据。剔除操作会造成严重的磁盘I/O，并且引发大量的GC，会严重影响Elastisearch的性能。</p>
<p>默认情况下Fielddata会不断占用内存，直到它触发了fielddata circuit breaker。<br>fielddata circuit breaker会根据查询条件评估这次查询会使用多少内存，从而计算加载这部分内存之后，Field Data Cache所占用的内存是否会超过indices.breaker.fielddata.limit。如果超过这个值，就会触发fielddata circuit breaker，abort这次查询并且抛出异常，防止OOM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">indices.breaker.fielddata.limit:60% (默认heap的60%)  (es7之后改成70%)</span><br></pre></td></tr></table></figure>
<p>如果设置了indices.fielddata.cache.size，当达到size时，cache会剔除旧的fielddata。</p>
<blockquote>
<p>indices.breaker.fielddata.limit 必须大于 indices.fielddata.cache.size，否则只会触发fielddata circuit breaker，而不会剔除旧的fielddata。</p>
</blockquote>
<h2 id="配置Elasticsearch堆内存"><a href="#配置Elasticsearch堆内存" class="headerlink" title="配置Elasticsearch堆内存"></a>配置Elasticsearch堆内存</h2><p>Elasticsearch默认安装后设置的内存是 <code>1GB</code>，这是远远不够用于生产环境的。<br>有两种方式修改Elasticsearch的堆内存：</p>
<blockquote>
<ol>
<li>设置环境变量：<code>export ES_HEAP_SIZE=10g</code> 在es启动时会读取该变量；</li>
<li>启动时作为参数传递给es： <code>./bin/elasticsearch -Xmx10g -Xms10g</code></li>
</ol>
</blockquote>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>给es分配内存时要注意，至少要分配一半儿内存留给 Lucene。<br>分配给 es 的内存最好不要超过 32G ，因为如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。如果大于32G 每个指针占用 8字节，并且会占用更多的内存带宽，降低了cpu性能。</p>
<p>还有一点， 要关闭 <code>swap</code> 内存交换空间，禁用swapping。频繁的swapping 对服务器来说是致命的。<br>总结：给es JVM栈的内存最好不要超过32G，留给Lucene的内存越大越好，Lucene把所有的segment都缓存起来，会加快全文检索。</p>
<h2 id="关闭交换区"><a href="#关闭交换区" class="headerlink" title="关闭交换区"></a>关闭交换区</h2><p>这应该显而易见了，但仍然需要明确的写出来：把内存换成硬盘将毁掉服务器的性能，想象一下：涉及内存的操作是需要快速执行的。如果介质从内存变为了硬盘，一个10微秒的操作变成需要10毫秒。而且这种延迟发生在所有本该只花费10微秒的操作上，就不难理解为什么交换区对于性能来说是噩梦。</p>
<p>最好的选择是禁用掉操作系统的交换区。可以用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure>
<p>来禁用，你可能还需要编辑 <code>/etc/fstab</code> 文件。细节可以参考你的操作系统文档。</p>
<p>如果实际环境不允许禁用掉 <code>swap</code>，你可以尝试降低 <code>swappiness</code>。此值控制操作系统使用交换区的积极性。这可以防止在正常情况下使用交换区，但仍允许操作系统在紧急情况下将内存里的东西放到交换区。</p>
<p>对于大多数Linux系统来说，这可以用 <code>sysctl</code> 值来配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 将此值配置为1会比0好，在kernal内核的某些版本中，0可能会引起OOM异常。</span></span><br></pre></td></tr></table></figure>
<p>最后，如果两种方法都不可用，你应该在ElasticSearch的配置中启用 <code>mlockall.file</code>。这允许JVM锁定其使用的内存，而避免被放入操作系统交换区。</p>
<p>在elasticsearch.yml中，做如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.mlockall: true</span><br></pre></td></tr></table></figure>

<h2 id="查看node节点数据"><a href="#查看node节点数据" class="headerlink" title="查看node节点数据"></a>查看node节点数据</h2><p><code>GET /_cat/nodes?v&amp;h=id,ip,port,v,master,name,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p>
<p><code>GET /_cat/nodes?v&amp;h=id,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size</code></p>
<p><code>GET /_cat/nodes?v&amp;h=id,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-CAP理论</title>
    <url>/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。<br>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p>
<img src="https://oscimg.oschina.net/oscnet/up-1d3052b25a13428857fde791eaa01c02e9b.png">

<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值，即写操作之后的读操作，必须返回该值。（分为弱一致性、强一致性和最终一致性）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<h2 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h2><blockquote>
<p>CA without P</p>
</blockquote>
<p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
<blockquote>
<p>CP without A</p>
</blockquote>
<p>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要<font color=red>牺牲用户的体验</font>，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<blockquote>
<p>AP wihtout C</p>
</blockquote>
<p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h2 id="解决方案——BASE"><a href="#解决方案——BASE" class="headerlink" title="解决方案——BASE"></a>解决方案——BASE</h2><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果。</p>
<p>核心思想：即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
<blockquote>
<p>基本可用Basically Available</p>
</blockquote>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<p>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<blockquote>
<p>软状态Soft state</p>
</blockquote>
<p>软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<blockquote>
<p>最终一致性Eventually consistent</p>
</blockquote>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/lixinkuan328/article/details/95535691">https://blog.csdn.net/lixinkuan328/article/details/95535691</a></p>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>theory</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-一致性哈希算法</title>
    <url>/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。</p>
<h2 id="哈希指标"><a href="#哈希指标" class="headerlink" title="哈希指标"></a>哈希指标</h2><blockquote>
<p>评估一个哈希算法的优劣，有如下指标，而一致性哈希全部满足：</p>
</blockquote>
<ul>
<li>均衡性(Balance)：将关键字的哈希地址均匀地分布在地址空间中，使地址空间得到充分利用，这是设计哈希的一个基本特性。</li>
<li>单调性(Monotonicity): 单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。</li>
<li>分散性(Spread): 哈希经常用在分布式环境中，终端用户通过哈希函数将自己的内容存到不同的缓冲区。此时，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>
<li>负载(Load): 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote>
<p>将节点通过hash映射到hash环上，理想的情况是多个节点直接分布均匀</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-ac8ab4cd06d150b14ddfe58e2cdcbdb7dff.png" >


<p>当我们的对象通过hash算法分配在hash环上的时候，它是固定分配到一个节点的空间上的，当我们在BC之间插入一个节点时，仅仅会影响到BC这一段空间上的数据，而不是整个环上的数据都要跟着变化；</p>
<blockquote>
<p>现实情况下，节点之间可能分配不均匀</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-3a12f9634fed9d5f67debfcdd7fe22f1fae.png">

<p>这和传统的hash取模一样，同样会数据倾斜的问题！</p>
<blockquote>
<p>虚拟节点</p>
</blockquote>
<p>这个时候虚拟节点就此诞生，下面让我们来看一下虚拟节点在一致性Hash中的作用。当我们在Hash环上新增若干个点，那么每个点之间的距离就会接近相等。按照这个思路我们可以新增若干个片/表，但是成本有限，我们通过复制多个A、B、C的副本({A1-An},{B1-Bn},{C1-Cn})一起参与计算，按照顺时针的方向进行数据分布，按照下图示意:<br><img src="https://oscimg.oschina.net/oscnet/up-88c2aef2ec993ede090695ffe78f53f999a.png"></p>
<p>此时A=[A,C1)&amp;[A1,C2)&amp;[A2,B4)&amp;[A3,A4)&amp;[A4,B1)；B=[B,A1)&amp;[B2,C)&amp;[B3,C3)&amp;[B4,C4)&amp;[B1,A)；C=[C1,B)&amp;[C2,B2)&amp;[C,B3)&amp;[B3,C3)&amp;[C4,A3)；由图可以看出分布点越密集，平衡性约好。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>一致性哈希算法有多种具体的实现，包括 Chord 算法，KAD 算法等，都比较复杂。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 、<a href="https://blog.csdn.net/kefengwang/article/details/81628977">一致性哈希算法的原理与实现</a><br>2、<a href="https://www.cnblogs.com/xialihua1023/p/10304932.html">浅谈一致性Hash原理及应用</a></p>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>theory</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-秒杀系统设计</title>
    <url>/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="秒杀系统的挑战"><a href="#秒杀系统的挑战" class="headerlink" title="秒杀系统的挑战"></a>秒杀系统的挑战</h1><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>秒杀活动的特点就是短时间内聚集大量请求瞬时到达服务端，此时数据库已经无法支撑如此大数据量的请求了。单个的数据库QPS仅有几百，你可能会想，那我是不是可以部署一个数据库集群呢，在数据库集群前使用Nginx分发，将负载平均分摊到每一个数据库不就可以了吗。<br>这种方式一定程度上是可以的，但是国内真正的互联网大厂肯定不是这样做的，在高并发的情况下完全可以使用内存操作来代替访问数据库，比如Redis集群。在网络带宽允许的情况下，Redis的集群的系统吞吐量肯定和数据库集群不是一个量级的，这里要查几十倍几百倍。</p>
<h2 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h2><p>超卖最直接的后果就是可能会对公司造成直接的经济损失。防止超卖是秒杀系统必须要保证的一点。超卖的解决办法就是加锁，保证在高并发的情况下库存可以正常的正确的扣减。</p>
<h2 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h2><h3 id="产品层策略"><a href="#产品层策略" class="headerlink" title="产品层策略"></a>产品层策略</h3><p>秒杀器一般下单和购买及其迅速，根据购买记录可以甄别出一部分。可以通过校验码达到一定的方法，这就要求校验码足够安全，不被破解，采用的方式有：秒杀专用验证码，电视公布验证码，秒杀答题。</p>
<h3 id="前端控制"><a href="#前端控制" class="headerlink" title="前端控制"></a>前端控制</h3><p>除此之外前段可以添加点击次数限制，点击一定次数之后，将按钮置灰色，或者在js层级进行控制，用户看到的是每次都点击成功了，但是仅仅发起一次服务端请求；</p>
<h3 id="后端控制"><a href="#后端控制" class="headerlink" title="后端控制"></a>后端控制</h3><ul>
<li>添加消息队列，消息执行一定数量时，队列后续的消息不在执行</li>
<li>后端架构按照模块拆分，用户不同的请求分散转发到各个模块的服务器，负载均衡</li>
<li>数据库分库分表（分片策略）和redis集群</li>
<li>升级服务器带宽，压力测试，保证系统吞吐量</li>
<li>过载保护，限流，请求拒绝和服务降级</li>
</ul>
<h2 id="链接加盐"><a href="#链接加盐" class="headerlink" title="链接加盐"></a>链接加盐</h2><p>链接加盐一定程度上可以保护恶意攻击，比如下单接口，如果暴露之后，就会存在恶意攻击，一个用户下了几百个单的情况或者一个IP下了很多单子，类似与黄牛抢票之后再去售卖。</p>
<h1 id="秒杀系统架构图（参考）"><a href="#秒杀系统架构图（参考）" class="headerlink" title="秒杀系统架构图（参考）"></a>秒杀系统架构图（参考）</h1><img src='https://oscimg.oschina.net/oscnet/up-a6fa908f7ee0f098a7a7eb4965dd282124b.png'>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/KWb3POodisbOEsQVblsoGw"> 敖丙带你设计【秒杀系统】</a><br><a href="https://mp.weixin.qq.com/s/z2S1EjWQDwKm5Ud36IenNw">《吊打面试官》系列-秒杀系统设计</a><br><a href="https://cloud.tencent.com/developer/article/1520361">这是我读过写得最好的【秒杀系统架构】分析与实战！</a><br><a href="https://www.infoq.cn/article/ypqschsrdsk8bv5nhny4">这一次，彻底弄懂“秒杀系统”</a></p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分析与分析器</title>
    <url>/wiki/%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>包含下面的过程：</p>
<p>首先，将一块文本分成适合于倒排索引的独立的 <code>词条</code> ，之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall<br>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p>
<h3 id="Token-过滤器"><a href="#Token-过滤器" class="headerlink" title="Token 过滤器"></a>Token 过滤器</h3><p>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。<br>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p>
<h2 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h2><p>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<br><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p>
<h3 id="标准分析器"><a href="#标准分析器" class="headerlink" title="标准分析器"></a>标准分析器</h3><p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</code></p>
<h3 id="简单分析器"><a href="#简单分析器" class="headerlink" title="简单分析器"></a>简单分析器</h3><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set, trans</code></p>
<h3 id="空格分析器"><a href="#空格分析器" class="headerlink" title="空格分析器"></a>空格分析器</h3><p>空格分析器在空格的地方划分文本。它会产生<br><code>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</code></p>
<h3 id="语言分析器"><a href="#语言分析器" class="headerlink" title="语言分析器"></a>语言分析器</h3><p>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p>
<h3 id="英语-分词器会产生下面的词条："><a href="#英语-分词器会产生下面的词条：" class="headerlink" title="英语 分词器会产生下面的词条："></a>英语 分词器会产生下面的词条：</h3><p><code>set, shape, semi, transpar, call, set_tran, 5</code><br>注意看 <code>transparent、</code> <code>calling</code> 和 <code>set_trans</code> 已经变为词根格式。</p>
<h2 id="什么时候使用分析器"><a href="#什么时候使用分析器" class="headerlink" title="什么时候使用分析器"></a>什么时候使用分析器</h2><p>当我们 <code>索引</code> 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p>
<p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p>
<p>当你查询一个 <code>全文</code> 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。<br>当你查询一个 <code>精确值</code> 域时，不会分析查询字符串，而是搜索你指定的精确值。</p>
<h2 id="测试分析器"><a href="#测试分析器" class="headerlink" title="测试分析器"></a>测试分析器</h2><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 <code>analyze API</code> 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Text to analyze&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果中每个元素代表一个单独的词条：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;text&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;to&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;analyze&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>token</code> 是实际存储到索引中的词条。 <code>position</code> 指明词条在原始文本中出现的位置。 <code>start_offset</code> 和 <code>end_offset</code> 指明字符在原始字符串中的位置。</p>
<p>每个分析器的 <code>type</code> 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于​keep_types token 过滤器​。</p>
<p>analyze API 是一个有用的工具，它有助于我们理解Elasticsearch索引内部发生了什么，随着深入，我们会进一步讨论它。</p>
<h2 id="指定分析器"><a href="#指定分析器" class="headerlink" title="指定分析器"></a>指定分析器</h2><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文 <code>字符串</code> 域，使用 <code>标准</code> 分析器对它进行分析。</p>
<p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域—​不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。</p>
<p>要做到这一点，我们必须手动指定这些域的映射。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>启动ELK脚本命令</title>
    <url>/wiki/%E5%90%AF%E5%8A%A8ELK%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="esuser-授权"><a href="#esuser-授权" class="headerlink" title="esuser 授权"></a>esuser 授权</h2><p><code>chown -R esuser /usr/local/elasticsearch/*</code></p>
<h2 id="elastcisearch-启动脚本"><a href="#elastcisearch-启动脚本" class="headerlink" title="elastcisearch 启动脚本"></a>elastcisearch 启动脚本</h2><p><code>nohup ./elasticsearch-7.10.0/bin/elasticsearch &gt;&gt; ./elasticsearch-7.10.0/nohup.out 2&gt;&amp;1 &amp;</code></p>
<h2 id="kibana-启动脚本"><a href="#kibana-启动脚本" class="headerlink" title="kibana 启动脚本"></a>kibana 启动脚本</h2><p><code>nohup ./bin/kibana &gt;&gt; ./nohup.out 2&gt;&amp;1 &amp;</code></p>
<h2 id="logstash-启动脚本"><a href="#logstash-启动脚本" class="headerlink" title="logstash 启动脚本"></a>logstash 启动脚本</h2><p><code>nohup /usr/local/logstash/logstash-7.10.0/bin/logstash -f /usr/local/logstash/logstash-7.10.0/config/redtom-logstash.conf</code></p>
<p><code>nohup /usr/local/logstash/logstash-7.10.0/bin/logstash -f /usr/local/logstash/logstash-7.10.0/config/redtom-logstash.conf &gt;&gt; /usr/local/logstash/logstash-7.10.0/nohup.out 2&gt;&amp;1 &amp;</code></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BIO实现简易tomcat</title>
    <url>/wiki/%E5%9F%BA%E4%BA%8EBIO%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/</url>
    <content><![CDATA[<h1 id="基于传统的BIO手写一个简易Tomcat"><a href="#基于传统的BIO手写一个简易Tomcat" class="headerlink" title="基于传统的BIO手写一个简易Tomcat"></a>基于传统的BIO手写一个简易Tomcat</h1><p>本文主要基于传统的BIO来实现一个简单的Http请求处理过程；<br>1、Servlet请求无非就是doGet/doPost，所以我们定义抽象Servlet记忆GET/POST方法；<br>2、基于Socket和ServerSocket实现CS通信；<br>3、模拟Spring加载配置文件，注册请求以及控制器；  </p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6fb1dfc1fbbb3ae4d616c0a9572b08b4ad.png">   </p>
<h2 id="GlRequest-封装一个请求"><a href="#GlRequest-封装一个请求" class="headerlink" title="GlRequest 封装一个请求"></a>GlRequest 封装一个请求</h2><blockquote>
<p>当然是一个很简单的请求，这里只处理请求的URL和请求方法；<br>获取请求，也就是输入流，解析数据Url和Method，并做相应的处理；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlRequest</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析http请求的具体内容；</span></span><br><span class="line">            String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ((len = is.read(buff)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                content = <span class="keyword">new</span> String(buff, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            String line = content.split(<span class="string">&quot;\\n&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            String [] arr = line.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.method = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.url = arr[<span class="number">1</span>].split(<span class="string">&quot;\\?&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GlResponse-定义返回值response"><a href="#GlResponse-定义返回值response" class="headerlink" title="GlResponse 定义返回值response"></a>GlResponse 定义返回值response</h2><blockquote>
<p>处理请求返回值，将业务处理的结果通过输出流输出；<br>输出大致分为两部分，第一是返回的数据，第二是返回数据的Header;  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlResponse</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream = os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;HTTP/1.1 200 OK\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;Content-Type: text/html;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">                .append(string);</span><br><span class="line">        outputStream.write(sb.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GlServlet-定义抽象servlet，定义GET方法和POST方法"><a href="#GlServlet-定义抽象servlet，定义GET方法和POST方法" class="headerlink" title="GlServlet 定义抽象servlet，定义GET方法和POST方法"></a>GlServlet 定义抽象servlet，定义GET方法和POST方法</h2><blockquote>
<p>定义抽象的Servlet和doGet方法和doPost方法，具体的业务去实现自己的方法和逻辑；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (GET.equals(request.getMethod())) &#123;</span><br><span class="line">               doGet(request, response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               doPost(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FirstServlet-具体的业务Servlet实现抽象Servlet的方法"><a href="#FirstServlet-具体的业务Servlet实现抽象Servlet的方法" class="headerlink" title="FirstServlet 具体的业务Servlet实现抽象Servlet的方法"></a>FirstServlet 具体的业务Servlet实现抽象Servlet的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This is first servlet from BIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondServlet-具体的业务Servlet实现抽象Servlet方法"><a href="#SecondServlet-具体的业务Servlet实现抽象Servlet方法" class="headerlink" title="SecondServlet 具体的业务Servlet实现抽象Servlet方法"></a>SecondServlet 具体的业务Servlet实现抽象Servlet方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This second request form BIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="web-bio-properties-配置文件"><a href="#web-bio-properties-配置文件" class="headerlink" title="web-bio.properties 配置文件"></a>web-bio.properties 配置文件</h2><blockquote>
<p>配置请求和处理器，Spring中是通过Controller下的@XXXMapping注解去扫描并加载到工厂的；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servlet.one.className=com.ibli.netty.tomcat.bio.servlet.FirstServlet</span><br><span class="line">servlet.one.url=/firstServlet.<span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">servlet.two.className=com.ibli.netty.tomcat.bio.servlet.SecondServlet</span><br><span class="line">servlet.two.url=/secondServlet.<span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<h2 id="GlTomcat测试类"><a href="#GlTomcat测试类" class="headerlink" title="GlTomcat测试类"></a>GlTomcat测试类</h2><blockquote>
<p>启动服务端，在网页中访问本地8080端口，输入配置文件中定义的url进行测试：  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> Properties webXml = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GlServlet&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;String, GlServlet&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟项目main方法，启动加载配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 启动参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GlTomcat().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat的启动入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、加载web配置文件，解析配置</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、启动服务器socket，等待用户请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.PORT);</span><br><span class="line">            System.err.println(<span class="string">&quot;Gl tomcat started in port &quot;</span> + <span class="keyword">this</span>.PORT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                <span class="comment">// 3、获得请求信息，解析HTTP协议的内容</span></span><br><span class="line">                process(client);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String WEB_INF = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(WEB_INF + <span class="string">&quot;web-bio.properties&quot;</span>);</span><br><span class="line">            webXml.load(fis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Object k : webXml.keySet()) &#123;</span><br><span class="line">                String key = k.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&quot;.url&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//servlet.two.url</span></span><br><span class="line">                    String servletName = key.replaceAll(<span class="string">&quot;\\.url&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    String url = webXml.getProperty(key);</span><br><span class="line">                    <span class="comment">//servlet.two.className</span></span><br><span class="line">                    String className = webXml.getProperty(servletName + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">                    <span class="comment">//反射创建servlet实例</span></span><br><span class="line">                    <span class="comment">// load-on-startup &gt;=1 :web启动的时候初始化  0：用户请求的时候才启动</span></span><br><span class="line">                    GlServlet obj = (GlServlet) Class.forName(className).newInstance();</span><br><span class="line">                    <span class="comment">// 将url和servlet建立映射关系</span></span><br><span class="line">                    servletMapping.put(url, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析客户端请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//请求</span></span><br><span class="line">            is = client.getInputStream();</span><br><span class="line">            <span class="comment">//封装返回值</span></span><br><span class="line">            os = client.getOutputStream();</span><br><span class="line">            GlRequest request = <span class="keyword">new</span> GlRequest(is);</span><br><span class="line">            GlResponse response = <span class="keyword">new</span> GlResponse(os);</span><br><span class="line"></span><br><span class="line">            String url = request.getUrl();</span><br><span class="line">            <span class="keyword">if</span> (servletMapping.containsKey(url)) &#123;</span><br><span class="line">                servletMapping.get(url).service(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.write(<span class="string">&quot;404 Not found!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                os.flush();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印请求信息"><a href="#打印请求信息" class="headerlink" title="打印请求信息"></a>打印请求信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request content : GET /fitstServlet.<span class="keyword">do</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost:<span class="number">8080</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_14_5</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">88.0</span><span class="number">.4324</span><span class="number">.150</span> Safari/<span class="number">537.36</span> OPR/<span class="number">74.0</span><span class="number">.3911</span><span class="number">.160</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Sec-Fetch-Site: none</span></span><br><span class="line"><span class="comment">Sec-Fetch-Mode: navigate</span></span><br><span class="line"><span class="comment">Sec-Fetch-User: ?1</span></span><br><span class="line"><span class="comment">Sec-Fetch-Dest: document</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.9</span></span><br></pre></td></tr></table></figure>

<h2 id="客户端发送请求及结果展示"><a href="#客户端发送请求及结果展示" class="headerlink" title="客户端发送请求及结果展示"></a>客户端发送请求及结果展示</h2><blockquote>
<p>请求： <a href="http://localhost:8080/firstServlet.do">http://localhost:8080/firstServlet.do</a><br><img src="https://oscimg.oschina.net/oscnet/up-e4faf840776bb504c26ddd7266033651a09.png">  </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>基础面试题目</title>
    <url>/wiki/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-String不可变"><a href="#1-String不可变" class="headerlink" title="1.String不可变"></a>1.String不可变</h2><p>String 对象的不可变性</p>
<p>了解了 String 对象的实现后，你有没有发现在实现代码中 String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。</p>
<p>我们知道类被 final 修饰代表该类不可继承，而 char[] 被 final+private 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。</p>
<p>Java 这样做的好处在哪里呢？</p>
<p>第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被恶意修改。</p>
<p>第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。</p>
<p>第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。</p>
<p>当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p>
<h3 id="2-String-和-StringBuilder、StringBuffer-的区别？"><a href="#2-String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="2.String 和 StringBuilder、StringBuffer 的区别？"></a>2.String 和 StringBuilder、StringBuffer 的区别？</h3><p><a href="https://www.cnblogs.com/weibanggang/p/9455926.html">https://www.cnblogs.com/weibanggang/p/9455926.html</a></p>
<h2 id="3-描述一下-JVM-加载-class-文件的原理机制？"><a href="#3-描述一下-JVM-加载-class-文件的原理机制？" class="headerlink" title="3.描述一下 JVM 加载 class 文件的原理机制？"></a>3.描述一下 JVM 加载 class 文件的原理机制？</h2><p><a href="https://www.cnblogs.com/williamjie/p/11167920.html">https://www.cnblogs.com/williamjie/p/11167920.html</a></p>
<h2 id="4-char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#4-char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="4.char 型变量中能不能存贮一个中文汉字，为什么？"></a>4.char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>正确答案：</p>
<p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，</p>
<p>所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，</p>
<p>那么，这个char型变量中就不能存储这个特殊汉字。</p>
<p>补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节</p>
<h2 id="5-抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#5-抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="5.抽象类（abstract class）和接口（interface）有什么异同？"></a>5.抽象类（abstract class）和接口（interface）有什么异同？</h2><p><a href="https://blog.csdn.net/aptentity/article/details/68942916">https://blog.csdn.net/aptentity/article/details/68942916</a></p>
<h2 id="6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p><a href="https://blog.csdn.net/machinecat0898/article/details/80071242">https://blog.csdn.net/machinecat0898/article/details/80071242</a></p>
<h2 id="7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？"><a href="#7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？" class="headerlink" title="7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？"></a>7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？</h2><p> 答：都不能。<br>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。<br>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。<br>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 </p>
<h2 id="8-如何实现对象克隆"><a href="#8-如何实现对象克隆" class="headerlink" title="8.如何实现对象克隆"></a>8.如何实现对象克隆</h2><p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html">https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html</a></p>
<h2 id="9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"><a href="#9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制" class="headerlink" title="9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"></a>9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</h2><p><a href="https://www.cnblogs.com/aademeng/articles/11084885.html">https://www.cnblogs.com/aademeng/articles/11084885.html</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
<p>静态内部类：它是用static修饰的，在访问限制上它只能访问外部类中的static所修饰的成员变量或者是方法<br>成员内部类：成员内部类是最普通的内部类，它可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br>【注意】当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br>局部内部类：局部内部类是定义在外围类的方法中的，在访问的时候它可以直接访问外围类的所有成员！但是不能随便访问局部变量，除非这个局部变量被final修饰。<br>匿名内部类：</p>
<h2 id="10-Java-中的-final-关键字有哪些用法？"><a href="#10-Java-中的-final-关键字有哪些用法？" class="headerlink" title="10.Java 中的 final 关键字有哪些用法？"></a>10.Java 中的 final 关键字有哪些用法？</h2><p><a href="https://www.cnblogs.com/dotgua/p/6357951.html">https://www.cnblogs.com/dotgua/p/6357951.html</a><br>多线程下的final语义 👇<br><a href="https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B">https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B</a></p>
<ul>
<li>修饰变量<br>基本类型的变量，值是不可以变化的<br>引用类型的变量，引用是不可以变化的，但是可以修改引用的值<br>方法参数： 保证这个变量在这个方法中的值不会发生变化</li>
<li>修饰方法<br>它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它</li>
<li>修饰类<br>用final修饰的类是无法被继承的</li>
</ul>
<h2 id="11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?"></a>11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep()方法是Thread类</p>
<pre><code>sleep是Thread的静态native方法,可随时调用,会使当前线程休眠,并释放CPU资源,但不会释放对象锁;
</code></pre>
<p>wait()方法是Object类</p>
<pre><code>wait()方法是Object的native方法,只能在同步方法或同步代码块中使用,调用会进入休眠状态,并释放CPU资源与对象锁,需要我们调用notify/notifyAll方法唤醒指定或全部的休眠线程,再次竞争CPU资源.
</code></pre>
<p>注意:<br>sleep(long millis)存在睡眠时间,不算特点<br>因为wait()方法存在重载wait(long timeout),即设置了等待超时时间<br>它们两个都需要再次抢夺CPU资源</p>
<h2 id="12-线程的-sleep-方法和-yield-方法有什么区别？"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别？"></a>12.线程的 sleep()方法和 yield()方法有什么区别？</h2><p>sleep()方法在给其他线程运行机会时不考虑线程的优先级。因此会给低优先级的线程运行的机会，而yield()方法只会给相同优先级或更高优先级的线程运行的机会。<br>线程执行sleep()方法后会转入阻塞状态，所以执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到就绪状态，所以执行yield()方法的线程有可能在进入到就绪状态后又立马被执行。</p>
<h2 id="13-线程的基本状态以及状态之间的关系"><a href="#13-线程的基本状态以及状态之间的关系" class="headerlink" title="13.线程的基本状态以及状态之间的关系"></a>13.线程的基本状态以及状态之间的关系</h2><img src='https://cdn.jsdelivr.net/gh/it-briefcode/it-briefcode-images/images/2020-10/15/15-58-29-0925f9fed78f11a87bbef280245e1e49-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E8%BD%AC%E6%8D%A2-6ff1d1.png' width=600 height=450>
https://blog.csdn.net/zhangdongnihao/article/details/104029972
https://juejin.cn/post/6885159254764814349


<h2 id="14-访问修饰符-public-private-protected-以及不写（默认）时的区别？"><a href="#14-访问修饰符-public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="14.访问修饰符 public,private,protected,以及不写（默认）时的区别？"></a>14.访问修饰符 public,private,protected,以及不写（默认）时的区别？</h2><img src="https://oscimg.oschina.net/oscnet/up-07ccdf4c85f874c49b19c6201cb826dc739.png" width=600 height=280 >

<h2 id="15-请说出与线程同步以及线程调度相关的方法。"><a href="#15-请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="15.请说出与线程同步以及线程调度相关的方法。"></a>15.请说出与线程同步以及线程调度相关的方法。</h2><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；<br>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；<br>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<blockquote>
<p>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</p>
</blockquote>
<h2 id="16-synchronized-关键字的用法？"><a href="#16-synchronized-关键字的用法？" class="headerlink" title="16.synchronized 关键字的用法？"></a>16.synchronized 关键字的用法？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncDemo.class)&#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Java-中如何实现序列化，有什么意义？"><a href="#17-Java-中如何实现序列化，有什么意义？" class="headerlink" title="17.Java 中如何实现序列化，有什么意义？"></a>17.Java 中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p>
<h2 id="18-阐述-JDBC-操作数据库的步骤"><a href="#18-阐述-JDBC-操作数据库的步骤" class="headerlink" title="18.阐述 JDBC 操作数据库的步骤"></a>18.阐述 JDBC 操作数据库的步骤</h2><p>下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。<br>（1） 加载驱动。<br><code>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);</code><br>（2） 创建连接。<br><code>Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;,&quot;scott&quot;, &quot;tiger&quot;);</code><br>（3） 创建语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">&quot;select * from emp where sal between ? and ?&quot;</span>);</span><br><span class="line">ps.setint(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">ps.setint(<span class="number">2</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>（4）执行语句。<br><code>ResultSet rs = ps.executeQuery();</code><br>（5）处理结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">	System.out.println(rs.getint(<span class="string">&quot;empno&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">	rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（6） 关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(con != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			con.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<h2 id="19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><a href="#19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？" class="headerlink" title="19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？"></a>19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？</h2><p>与 Statement 相比，<br>①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；<br>③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<blockquote>
<p>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
</blockquote>
<h2 id="20-在进行数据库编程时，连接池有什么作用？"><a href="#20-在进行数据库编程时，连接池有什么作用？" class="headerlink" title="20.在进行数据库编程时，连接池有什么作用？"></a>20.在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），<code>为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销</code>，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。</p>
<blockquote>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
</blockquote>
<h2 id="21-什么是-DAO-模式"><a href="#21-什么是-DAO-模式" class="headerlink" title="21.什么是 DAO 模式?"></a>21.什么是 DAO 模式?</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。<br>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 DataAccessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h2 id="22-Java-中是如何支持正则表达式操作的？"><a href="#22-Java-中是如何支持正则表达式操作的？" class="headerlink" title="22.Java 中是如何支持正则表达式操作的？"></a>22.Java 中是如何支持正则表达式操作的？</h2><p>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作。面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;北京市(朝阳区)(西城区)(海淀区)&quot;</span>;</span><br><span class="line">		Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\()&quot;</span>);</span><br><span class="line">		Matcher m = p.matcher(str);</span><br><span class="line">		<span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多桶排序</title>
    <url>/wiki/%E5%A4%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>多值桶（ terms 、 histogram 和 date_histogram ）动态生成很多桶。 Elasticsearch 是如何决定这些桶展示给用户的顺序呢？</p>
<p>默认的，桶会根据 doc_count 降序排列。这是一个好的默认行为，因为通常我们想要找到文档中与查询条件相关的最大值：售价、人口数量、频率。但有些时候我们希望能修改这个顺序，不同的桶有着不同的处理方式。</p>
<h2 id="内置排序"><a href="#内置排序" class="headerlink" title="内置排序"></a>内置排序</h2><p>这些排序模式是桶 固有的 能力：它们操作桶生成的数据 ，比如 doc_count 。 它们共享相同的语法，但是根据使用桶的不同会有些细微差别。</p>
<p>让我们做一个 terms 聚合但是按 doc_count 值的升序排序：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;_count&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

<p>用关键字 _count ，我们可以按 doc_count 值的升序排序。</p>
<p>我们为聚合引入了一个 order 对象， 它允许我们可以根据以下几个值中的一个值进行排序：</p>
<ul>
<li>_count<br>按文档数排序。对 terms 、 histogram 、 date_histogram 有效。</li>
<li>_term<br>按词项的字符串值的字母顺序排序。只在 terms 内使用。</li>
<li>_key<br>按每个桶的键值数值排序（理论上与 _term 类似）。 只在 histogram 和 date_histogram 内使用。</li>
</ul>
<h2 id="按度量排序"><a href="#按度量排序" class="headerlink" title="按度量排序"></a>按度量排序</h2><p>有时，我们会想基于度量计算的结果值进行排序。 在我们的汽车销售分析仪表盘中，我们可能想按照汽车颜色创建一个销售条状图表，但按照汽车平均售价的升序进行排序。</p>
<p>我们可以增加一个度量，再指定 order 参数引用这个度量即可：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;avg&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>计算每个桶的平均售价。</p>
</li>
<li><p>桶按照计算平均值的升序排序。</p>
</li>
</ul>
<p>我们可以采用这种方式用任何度量排序，只需简单的引用度量的名字。不过有些度量会输出多个值。 extended_stats 度量是一个很好的例子：它输出好几个度量值。</p>
<p>如果我们想使用多值度量进行排序， 我们只需以关心的度量为关键词使用点式路径：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 . 符号，根据感兴趣的度量进行排序。</li>
</ul>
<h2 id="深度度量排序"><a href="#深度度量排序" class="headerlink" title="深度度量排序"></a>深度度量排序</h2><p>在前面的示例中，度量是桶的直接子节点。平均售价是根据每个 term 来计算的。 在一定条件下，我们也有可能对 更深 的度量进行排序，比如孙子桶或从孙桶。</p>
<p>我们可以定义更深的路径，将度量用尖括号（ &gt; ）嵌套起来，像这样： my_bucket&gt;another_bucket&gt;metric 。</p>
<p>需要提醒的是嵌套路径上的每个桶都必须是 单值 的。 filter 桶生成 一个单值桶：所有与过滤条件匹配的文档都在桶中。 多值桶（如：terms ）动态生成许多桶，无法通过指定一个确定路径来识别。</p>
<p>目前，只有三个单值桶： filter 、 global 和 reverse_nested 。让我们快速用示例说明，创建一个汽车售价的直方图，但是按照红色和绿色（不包括蓝色）车各自的方差来排序：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;histogram&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;interval&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&gt;tats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;filter&quot;</span>: &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;color&quot;</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]&#125;&#125;, </span><br><span class="line">                    <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;stats&quot;</span>: &#123;<span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>&#125;&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>按照嵌套度量的方差对桶的直方图进行排序。</p>
</li>
<li><p>因为我们使用单值过滤器 filter ，我们可以使用嵌套排序。</p>
</li>
<li><p>按照生成的度量对统计结果进行排序。</p>
</li>
</ul>
<p>本例中，可以看到我们如何访问一个嵌套的度量。 stats 度量是 red_green_cars 聚合的子节点，而 red_green_cars 又是 colors 聚合的子节点。 为了根据这个度量排序，我们定义了路径 red_green_cars&gt;tats.variance 。我们可以这么做，因为 filter 桶是个单值桶。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>多索引多类型搜索</title>
    <url>/wiki/%E5%A4%9A%E7%B4%A2%E5%BC%95%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。Elasticsearch 转发搜索请求到每一个主分片或者副本分片，汇集查询出的前10个结果，并且返回给我们。</p>
<p>然而，经常的情况下，你想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
<p><code>/_search</code><br>在所有的索引中搜索所有的类型<br><code>/gb/_search</code><br>在 gb 索引中搜索所有的类型<br><code>/gb,us/_search</code><br>在 gb 和 us 索引中搜索所有的文档<br><code>/g*,u*/_search</code><br>在任何以 g 或者 u 开头的索引中搜索所有的类型<br><code>/gb/user/_search</code><br>在 gb 索引中搜索 user 类型<br><code>/gb,us/user,tweet/_search</code><br>在 gb 和 us 索引中搜索 user 和 tweet 类型<br><code>/_all/user,tweet/_search</code><br>在所有的索引中搜索 user 和 tweet 类型<br>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的—​只是会涉及到更多的分片。  </p>
<p>注意 ⚠️<br>搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串排序与多字段</title>
    <url>/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p>
<p>你可以使用 min 和 max 排序模式（默认是 min ），但是这会导致排序以 art 或是 old ，任何一个都不是所希望的。</p>
<p>为了以字符串字段进行排序，这个字段应仅包含一项： 整个 not_analyzed 字符串。 但是我们仍需要 analyzed 字段，这样才能以全文进行查询</p>
<p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： analyzed 用于搜索， not_analyzed 用于排序</p>
<p>但是保存相同的字符串两次在 _source 字段是浪费空间的。 我们真正想要做的是传递一个 单字段 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 fields 参数</p>
<p>该参数允许你转化一个简单的映射如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为一个多字段映射如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;raw&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>tweet 主字段与之前的一样: 是一个 analyzed 全文字段。</p>
</li>
<li><p>新的 tweet.raw 子字段是 not_analyzed.</p>
</li>
</ul>
<p>现在，至少只要我们重新索引了我们的数据，使用 tweet 字段用于搜索，<code>tweet.raw</code> 字段用于排序：<br><code>curl -X GET &quot;localhost:9200/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tweet&quot;</span>: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="string">&quot;tweet.raw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌套桶</title>
    <url>/wiki/%E5%B5%8C%E5%A5%97%E6%A1%B6/</url>
    <content><![CDATA[<h2 id="两层嵌套"><a href="#两层嵌套" class="headerlink" title="两层嵌套"></a>两层嵌套</h2><p>在我们使用不同的嵌套方案时，聚合的力量才能真正得以显现。 在前例中，我们已经看到如何将一个度量嵌入桶中，它的功能已经十分强大了。</p>
<p>但真正令人激动的分析来自于将桶嵌套进 另外一个桶 所能得到的结果。 现在，我们想知道每个颜色的汽车制造商的分布：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; </span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;make&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意前例中的 avg_price 度量仍然保持原位。</p>
</li>
<li><p>另一个聚合 make 被加入到了 color 颜色桶中。</p>
</li>
<li><p>这个聚合是 terms 桶，它会为每个汽车制造商生成唯一的桶。</p>
</li>
</ul>
<p>这里发生了一些有趣的事。 首先，我们可能会观察到之前例子中的 <code>avg_price</code> 度量完全没有变化，还在原来的位置。 一个聚合的每个 层级 都可以有多个度量或桶， <code>avg_price</code> 度量告诉我们每种颜色汽车的平均价格。它与其他的桶和度量相互独立。</p>
<p>这对我们的应用非常重要，因为这里面有很多相互关联，但又完全不同的度量需要收集。聚合使我们能够用一次数据请求获得所有的这些信息。</p>
<p>另外一件值得注意的重要事情是我们新增的这个 make 聚合，它是一个 <code>terms</code> 桶（嵌套在 colors 、 terms 桶内）。这意味着它会为数据集中的每个唯一组合生成（ color 、 make ）元组。</p>
<p>让我们看看返回的响应（为了简单我们只显示部分结果）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>, </span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>正如期望的那样，新的聚合嵌入在每个颜色桶中。</p>
</li>
<li><p>现在我们看见按不同制造商分解的每种颜色下车辆信息。</p>
</li>
<li><p>最终，我们看到前例中的 avg_price 度量仍然维持不变。</p>
</li>
</ul>
<h2 id="三层嵌套"><a href="#三层嵌套" class="headerlink" title="三层嵌套"></a>三层嵌套</h2><p>让我们回到话题的原点，在进入新话题之前，对我们的示例做最后一个修改， 为每个汽车生成商计算最低和最高的价格：<br><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; <span class="attr">&quot;avg&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;make&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">                    <span class="attr">&quot;min_price&quot;</span> : &#123; <span class="attr">&quot;min&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125;, </span><br><span class="line">                    <span class="attr">&quot;max_price&quot;</span> : &#123; <span class="attr">&quot;max&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们需要增加另外一个嵌套的 aggs 层级。</p>
</li>
<li><p>然后包括 min 最小度量。</p>
</li>
<li><p>以及 max 最大度量。</p>
</li>
</ul>
<p>得到以下输出（只显示部分结果）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">10000</span> </span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">20000</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>有了这两个桶，我们可以对查询的结果进行扩展并得到以下信息：  </p>
<p>有四辆红色车。<br>红色车的平均售价是 $32，500 美元。<br>其中三辆红色车是 Honda 本田制造，一辆是 BMW 宝马制造。<br>最便宜的红色本田售价为 $10，000 美元。<br>最贵的红色本田售价为 $20，000 美元。  </p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>快速重传/快速恢复</title>
    <url>/wiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h1><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><blockquote>
<p>d 为何会接收到以个失序数据段？ </p>
</blockquote>
<ul>
<li>若报文丢失，将会产生连续的失序ACK段 </li>
<li>若网络路径与设备导致数据段失序，将会产生少量的失序ACK段</li>
<li>若报文重复，将会产生少量的失序ACK段</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-eaadaebd682089bdd3919de4f0d232749dc.png" width=450 height= 520>

<ul>
<li>当发送端发送pkt0是正常的，由于滑动窗口为满，发送方可以继续发送pkt1，pkt2；</li>
<li>加入pkt1发生了丢包，虽然pkt2接收端接收成功了，但是没有pkt1的数据段，接收端还是发送ACK1的确认报文；</li>
<li>在没有「快速重传」的情况下，发送端需要等到RTO之后，才可以重新发送pkt1</li>
<li>重传成功之后，接收端其实收到了pkt2之前的所有数据段，所以发送ACK3的确认报文<blockquote>
<p>这种需要等待RTO才可以重传的方式效率是比较低的，因此需要快速重传来进行优化；</p>
</blockquote>
</li>
</ul>
<h2 id="快速重传和累积确认"><a href="#快速重传和累积确认" class="headerlink" title="快速重传和累积确认"></a>快速重传和累积确认</h2><img src="https://oscimg.oschina.net/oscnet/up-9da669c35316aafb318674d3364ea07d72d.png" width=450 height=520>

<p>当发送方连续发送pkt3，pkt4，pkt5，pkt6四个数据端，但是pkt5在网络中丢包了，那后面发送的pkt6，pkt7，pkt8的确认报文都返回ACK5，希望发送方吃昂传pkt5的数据段；这个时候，发送方收到连续3个相同的确认报文，便立即重新发送pkt5的数据段；</p>
<blockquote>
<p>接收方:</p>
</blockquote>
<ul>
<li>当接收到一个失序数据段时，立刻发送它所期待的缺口 ACK 序列号</li>
<li>当接收到填充失序缺口的数据段时，立刻发 送它所期待的下一个 ACK 序列号</li>
</ul>
<blockquote>
<p>发送方</p>
</blockquote>
<ul>
<li>当接收到3个重复的失序 ACK 段(4个相同的失序ACK段)时，不再等待重传定时器的触发，立刻基于快速重传机制重发报文段</li>
</ul>
<p>当pkt5重新发送并被接收端接收之后，接收端发送ACK9的确认报文，而不是再分别发送ACK6，ACK7，ACK8，这个称谓「 <strong><font color=red>累计确认</font></strong> 」。</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><blockquote>
<p>快速重传下一定要进入慢启动吗?</p>
</blockquote>
<p>接受端收到重复ACK，意味着网络仍在流动，而如果要重新进入慢启动，会导致网络突然减少数据流，拥塞窗口恢复初始窗口，所以，「<strong>在快速恢复下发生丢包的场景下</strong>」，应该使用快速恢复，简单的讲，就是将慢启动阈值设置成当前拥塞窗口的一半，而拥塞窗口也适当放低，而不是一下字恢复到初始窗口大小；</p>
<img src="https://oscimg.oschina.net/oscnet/up-4a7f76cb315a13d1d905f2bfb3a376db087.png" >

<p>快速恢复的流程如上图👆所示！</p>
<blockquote>
<p>快速恢复的具体操作：</p>
</blockquote>
<ul>
<li>将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上 3*MSS</li>
<li>每收到一个重复 ACK，cwnd 增加 1 个 MSS</li>
<li>当新数据 ACK 到达后，设置 cwnd 为 ssthresh</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>拥塞避免</title>
    <url>/wiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/</url>
    <content><![CDATA[<h1 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h1><p>拥塞控制的慢启动是以指数方式快速的通过试探来扩大拥塞窗口的，但是一旦发生网络丢包，则肯定是很多报文段都会都是，因为窗口时称被增长的；为了解决这种问题，需要引入– 拥塞避免</p>
<h2 id="什么是拥塞避免"><a href="#什么是拥塞避免" class="headerlink" title="什么是拥塞避免"></a>什么是拥塞避免</h2><p>拥塞避免为了解决慢启动下，当拥塞窗口超出网络带宽时发生的大量丢包问题，它提出一个「慢启动阈值」的概念，当拥塞窗口到达这个阈值之后，不在以指数方式增长，而选择涨幅比较缓慢的「线性增长」，计算方式：</p>
<blockquote>
<p>cwnd += SMSS*SMSS/cwnd</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-e56d8072b2a74fa9b18ff6ca2d605405d2f.png" width=760 height=360>

<p>当拥塞窗口在线性增长时发生丢包，将慢启动阈值设置为当前窗口的一半，慢启动窗口恢复初始窗口（init wnd）；</p>
<blockquote>
<p>拥塞避免和慢启动是结合使用的，当发生网络丢包是，拥塞控制采用快速重传和快速启动来解决丢包问题！</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统-Overview</title>
    <url>/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/</url>
    <content><![CDATA[<h2 id="博客资料"><a href="#博客资料" class="headerlink" title="博客资料"></a>博客资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_40027052/article/details/78733365">深度解析京东个性化推荐系统演进史</a>  </li>
<li><a href="https://www.cnblogs.com/liuning8023/p/5522619.html">用 Mahout 和 Elasticsearch 实现推荐系统</a></li>
<li><a href="https://tech.meituan.com/2015/01/22/mt-recommend-practice.html">美团推荐算法实践</a></li>
<li><a href="https://blog.csdn.net/love284969214/article/details/82932064">58同城推荐系统设计与实现</a></li>
<li><a href="http://www.360doc.com/content/16/0307/22/31263000_540328712.shtml">微博推荐系统的架构演进之路</a></li>
<li><a href="https://blog.csdn.net/tzs_1041218129/article/details/103331908">Flink 在小红书推荐系统中的应用</a></li>
<li><a href="https://www.slidestalk.com/YunQi/XiaoHongShu_BigData_Platform_Evolution">小红书大数据在推荐系统中的应用</a></li>
<li><a href="https://www.slidestalk.com/u223/rs_in_kuaikan">快看漫画个性化推荐探索与实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45123018">数据仓库系列篇——唯品会大数据架构</a></li>
<li><a href="https://developer.aliyun.com/article/763941">推荐系统基本概念和架构</a></li>
<li><a href="https://bp.aliyun.com/detail/140">PAI平台搭建企业级个性化推荐系统 - Aliyun</a></li>
<li><a href="https://www.aliyun.com/product/bigdata/product/learn"></a></li>
<li><a href="https://toutiao.io/posts/35tpcy/preview">蘑菇街推荐工程实践</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Recommend System</category>
        <category>Overview</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-死锁</title>
    <url>/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/44125bb12ebf">死锁是什么？如何避免死锁？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统进程调度策略</title>
    <url>/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/qq_35642036/article/details/82809812">操作系统中的进程调度策略有哪几种</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>段合并</title>
    <url>/wiki/%E6%AE%B5%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://learnku.com/articles/41593">learnku.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>统计去重数据 (近似度量)</title>
    <url>/wiki/%E7%BB%9F%E8%AE%A1%E5%8E%BB%E9%87%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="cardinality用法"><a href="#cardinality用法" class="headerlink" title="cardinality用法"></a>cardinality用法</h2><p>常用写法如下👇<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;months&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;sold&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;month&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p><code>cardinality</code> 度量是一个 <code>近似算法</code>。 它是基于 HyperLogLog++ （HLL）算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。</p>
<p>我们不需要理解技术细节， 但我们最好应该关注一下这个算法的 特性 ：</p>
<ul>
<li>可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）。</li>
<li>小的数据集精度是非常高的。</li>
<li>我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</li>
</ul>
<p>要配置精度，我们必须指定 <code>precision_threshold</code> 参数的值。 这个阈值定义了在何种基数水平下我们希望得到一个近乎精确的结果。参考以下示例：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;precision_threshold&quot;</span> : <span class="number">100</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ ⚠️<br><code>precision_threshold</code> 接受 0–40000 之间的数字，更大的值还是会被当作 40000 来处理 </p>
<p>示例会确保当字段唯一值在 100 以内时会得到非常准确的结果。尽管算法是无法保证这点的，但如果基数在阈值以下，几乎总是 100% 正确的。高于阈值的基数会开始节省内存而牺牲准确度，同时也会对度量结果带入误差。</p>
<p>对于指定的阈值，<code>HLL</code> 的数据结构会大概使用 <code>precision_threshold</code> * 8 字节的内存，所以就必须在牺牲内存和获得额外的准确度间做平衡。</p>
<p>在实际应用中， 100 的阈值可以在唯一值为百万的情况下仍然将误差维持 5% 以内</p>
<h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>如果想要获得唯一值的数目， 通常 需要查询整个数据集合（或几乎所有数据）。 所有基于所有数据的操作都必须迅速，原因是显然的。 <code>HyperLogLog</code> 的速度已经很快了，它只是简单的对数据做哈希以及一些位操作。</p>
<p>但如果速度对我们至关重要，可以做进一步的优化。 因为 HLL 只需要字段内容的哈希值，我们可以在索引时就预先计算好。 就能在查询时跳过哈希计算然后将哈希值从 <code>fielddata</code> 直接加载出来。</p>
<blockquote>
<p>预先计算哈希值只对内容很长或者基数很高的字段有用，计算这些字段的哈希值的消耗在查询时是无法忽略的。<br>  尽管数值字段的哈希计算是非常快速的，存储它们的原始值通常需要同样（或更少）的内存空间。这对低基数的字符串字段同样适用，Elasticsearch 的内部优化能够保证每个唯一值只计算一次哈希。<br>  基本上说，预先计算并不能保证所有的字段都更快，它只对那些具有高基数和/或者内容很长的字符串字段有作用。需要记住的是，预计算只是简单的将查询消耗的时间提前转移到索引时，并非没有任何代价，区别在于你可以选择在 什么时候 做这件事，要么在索引时，要么在查询时。</p>
</blockquote>
<p>创建索引时添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /cars/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;transactions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;color&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;hash&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;murmur3&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多值字段的类型是 <code>murmur3</code> ，这是一个哈希函数。</p>
</blockquote>
<p>现在当我们执行聚合时，我们使用 <code>color.hash</code> 字段而不是 color 字段：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color.hash&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在 <code>cardinality</code> 度量会读取 “<code>color.hash</code>“ 里的值（预先计算的哈希值），取代动态计算原始值的哈希。</p>
<p>单个文档节省的时间是非常少的，但是如果你聚合一亿数据，每个字段多花费 10 纳秒的时间，那么在每次查询时都会额外增加 1 秒，如果我们要在非常大量的数据里面使用 <code>cardinality</code> ，我们可以权衡使用预计算的意义，是否需要提前计算 hash，从而在查询时获得更好的性能，做一些性能测试来检验预计算哈希是否适用于你的应用场景。。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合 条形图</title>
    <url>/wiki/%E8%81%9A%E5%90%88-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合 高级概念</title>
    <url>/wiki/%E8%81%9A%E5%90%88-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h2><p><code>桶</code> 简单来说就是满足特定条件的文档的集合：</p>
<ul>
<li>一个雇员属于 男性 桶或者 女性 桶</li>
<li>奥尔巴尼属于 纽约 桶</li>
<li>日期2014-10-28属于 十月 桶<br>当聚合开始被执行，每个文档里面的值通过计算来决定符合哪个桶的条件。如果匹配到，文档将放入相应的桶并接着进行聚合操作。</li>
</ul>
<p>桶也可以被嵌套在其他桶里面，提供层次化的或者有条件的划分方案。例如，辛辛那提会被放入俄亥俄州这个桶，而 整个 俄亥俄州桶会被放入美国这个桶。</p>
<p>Elasticsearch 有很多种类型的桶，能让你通过很多种方式来划分文档（<code>时间</code>、<code>最受欢迎的词</code>、<code>年龄区间</code>、<code>地理位置</code> 等等）。其实根本上都是通过同样的原理进行操作：基于条件来划分文档。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>桶能让我们划分文档到有意义的集合，但是最终我们需要的是对这些桶内的文档进行一些指标的计算。分桶是一种达到目的的手段：它提供了一种给文档分组的方法来让我们可以计算感兴趣的指标。</p>
<p>大多数 <code>指标</code> 是简单的数学运算（例如最小值、平均值、最大值，还有汇总），这些是通过文档的值来计算。在实践中，指标能让你计算像平均薪资、最高出售价格、95%的查询延迟这样的数据。</p>
<h2 id="桶和指标的组合"><a href="#桶和指标的组合" class="headerlink" title="桶和指标的组合"></a>桶和指标的组合</h2><p><code>聚合</code> 是由桶和指标组成的。 聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。也有可能有一些桶嵌套在其他桶里面。例如，我们可以通过所属国家来划分文档（桶），然后计算每个国家的平均薪酬（指标）。</p>
<p>由于桶可以被嵌套，我们可以实现非常多并且非常复杂的聚合：</p>
<p>1.通过国家划分文档（桶）</p>
<p>2.然后通过性别划分每个国家（桶）</p>
<p>3.然后通过年龄区间划分每种性别（桶）</p>
<p>4.最后，为每个年龄区间计算平均薪酬（指标）</p>
<p>最后将告诉你每个 &lt;国家, 性别, 年龄&gt; 组合的平均薪酬。所有的这些都在一个请求内完成并且只遍历一次数据！</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤和聚合</title>
    <url>/wiki/%E8%BF%87%E6%BB%A4%E5%92%8C%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h2 id="过滤和聚合"><a href="#过滤和聚合" class="headerlink" title="过滤和聚合"></a>过滤和聚合</h2><p>聚合范围限定还有一个自然的扩展就是过滤。因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合上。</p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>如果我们想找到售价在 $10,000 美元之上的所有汽车同时也为这些车计算平均售价， 可以简单地使用一个 <code>constant_score</code> 查询和 <code>filter</code> 约束：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;gte&quot;</span>: <span class="number">10000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;single_avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根本上讲，使用 <code>non-scoring</code> 查询和使用 <code>match</code> 查询没有任何区别。查询（包括了一个过滤器）返回一组文档的子集，聚合正是操作这些文档。使用 <code>filtering query</code> 会忽略评分，并有可能会缓存结果数据等等。</p>
<h2 id="过滤桶"><a href="#过滤桶" class="headerlink" title="过滤桶"></a>过滤桶</h2><p>但是如果我们只想对聚合结果过滤怎么办？ 假设我们正在为汽车经销商创建一个搜索页面， 我们希望显示用户搜索的结果，但是我们同时也想在页面上提供更丰富的信息，包括（与搜索匹配的）上个月度汽车的平均售价。</p>
<p>这里我们无法简单的做范围限定，因为有两个不同的条件。搜索结果必须是 ford ，但是聚合结果必须满足 ford AND sold &gt; now - 1M 。</p>
<p>为了解决这个问题，我们可以用一种特殊的桶，叫做 filter （注：过滤桶） 。 我们可以指定一个过滤桶，当文档满足过滤桶的条件时，我们将其加入到桶内。</p>
<p>查询结果如下：<br><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;recent_sales&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;filter&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;sold&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;now-1M&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;average_price&quot;</span>:&#123;</span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 过滤 桶在 查询 范围基础上应用过滤器。</p>
</li>
<li><p>avg 度量只会对 ford 和上个月售出的文档计算平均售价。</p>
</li>
</ul>
<p>因为 <code>filter</code> 桶和其他桶的操作方式一样，所以可以随意将其他桶和度量嵌入其中。所有嵌套的组件都会 “继承” 这个过滤，这使我们可以按需针对聚合过滤出选择部分。</p>
<h2 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器"></a>后过滤器</h2><p>目前为止，我们可以同时对搜索结果和聚合结果进行过滤（不计算得分的 filter 查询），以及针对聚合结果的一部分进行过滤（ filter 桶）。</p>
<p>我们可能会想，”只过滤搜索结果，不过滤聚合结果呢？” 答案是使用 post_filter 。</p>
<p>它是接收一个过滤器的顶层搜索请求元素。这个过滤器在查询 之后 执行（这正是该过滤器的名字的由来：它在查询之后 post 执行）。正因为它在查询之后执行，它对查询范围没有任何影响，所以对聚合也不会有任何影响。</p>
<p>我们可以利用这个行为对查询条件应用更多的过滤器，而不会影响其他的操作，就如 UI 上的各个分类面。让我们为汽车经销商设计另外一个搜索页面，这个页面允许用户搜索汽车同时可以根据颜色来过滤。颜色的选项是通过聚合获得的：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;post_filter&quot;</span>: &#123;    </span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;color&quot;</span> : <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;all_colors&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>post_filter 元素是 top-level 而且仅对命中结果进行过滤。</p>
</blockquote>
<p>查询 部分找到所有的 ford 汽车，然后用 terms 聚合创建一个颜色列表。因为聚合对查询范围进行操作，颜色列表与福特汽车有的颜色相对应。</p>
<p>最后， post_filter 会过滤搜索结果，只展示绿色 ford 汽车。这在查询执行过 后 发生，所以聚合不受影响。</p>
<p>这通常对 UI 的连贯一致性很重要，可以想象用户在界面商选择了一类颜色（比如：绿色），期望的是搜索结果已经被过滤了，而 不是 过滤界面上的选项。如果我们应用 filter 查询，界面会马上变成 只 显示 绿色 作为选项，这不是用户想要的！</p>
<p>⚠️ ⚠️ ⚠️</p>
<h2 id="性能考虑（Performance-consideration）"><a href="#性能考虑（Performance-consideration）" class="headerlink" title="性能考虑（Performance consideration）"></a>性能考虑（Performance consideration）</h2><p>当你需要对搜索结果和聚合结果做不同的过滤时，你才应该使用 post_filter ， 有时用户会在普通搜索使用 post_filter 。</p>
<p>不要这么做！ post_filter 的特性是在查询 之后 执行，任何过滤对性能带来的好处（比如缓存）都会完全失去。</p>
<p>在我们需要不同过滤时， post_filter 只与聚合一起使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择合适类型的过滤（如：搜索命中、聚合或两者兼有）通常和我们期望如何表现用户交互有关。选择合适的过滤器（或组合）取决于我们期望如何将结果呈现给用户。</p>
<ul>
<li>在 filter 过滤中的 non-scoring 查询，同时影响搜索结果和聚合结果。</li>
<li>filter 桶影响聚合。</li>
<li>post_filter 只影响搜索结果。</li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象特征</title>
    <url>/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是保证软件部件具有优良的模块性的基础，封装的目标就是实现软件内部的“高内聚、低耦合”。防止程序相互依赖而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、也更为有力，面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，或者说是一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</p>
<p>将一个类中的成员变量全部定义为私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p>
<p>继承是子类自动共享父类资源（数据或者方法）的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在该编程时不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态性增强了软件的灵活性和扩展性，简单一句话理解多态的话就是，编译看左边，运行看右边</p>
<blockquote>
<p>编译看左边 – 是指 想要成功的保存,就要使用左边也就是 只能使用父类提供的功能!!如果父类中没有，那么会编译报错<br>运行看右边 – 是指 想要得到结果,就要看右边也就是 使用子类的方法体!!!</p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-垃圾收集器</title>
    <url>/wiki/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1、什么是垃圾收集器"><a href="#1、什么是垃圾收集器" class="headerlink" title="1、什么是垃圾收集器"></a>1、什么是垃圾收集器</h1><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。 就像没有最好的算法一样，垃圾收集器也没有最好，只有最合适。我们能做的就是根据具体的应用场景选择最合适的垃圾收集器。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731155230422.png" alt="image-20210731155230422" style="zoom: 33%;" />

<p>上图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<h1 id="2、串行，并行和并发"><a href="#2、串行，并行和并发" class="headerlink" title="2、串行，并行和并发"></a>2、串行，并行和并发</h1><h2 id="2-1-串行"><a href="#2-1-串行" class="headerlink" title="2.1 串行"></a>2.1 串行</h2><p>计算机中的串行是用 Serial 表示。A 和 B 两个任务运行在一个 CPU 线程上，在 A 任务执行完之前不可以执行 B。即，在整个程序的运行过程中，仅存在一个运行上下文，即一个调用栈一个堆。程序会按顺序执行每个指令。</p>
<h2 id="2-2-并行"><a href="#2-2-并行" class="headerlink" title="2.2 并行"></a>2.2 并行</h2><p>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，<strong>并行性使多个程序同一时刻可在不同 CPU 上同时执行</strong>。比如，A 和 B 两个任务可以同时运行在不同的 CPU 线程上，效率较高，但受限于 CPU 线程数，如果任务数量超过了 CPU 线程数，那么每个线程上的任务仍然是顺序执行的。</p>
<h2 id="2-3-并发"><a href="#2-3-并发" class="headerlink" title="2.3 并发"></a>2.3 并发</h2><p>并发指多个线程在宏观(相对于较长的时间区间而言)上表现为同时执行，而实际上是轮流穿插着执行，<strong>并发的实质是一个物理 CPU 在若干道程序之间多路复用</strong>，其目的是提高有限物理资源的运行效率。 并发与并行串行并不是互斥的概念，如果是在一个CPU线程上启用并发，那么自然就还是串行的，而如果在多个线程上启用并发，那么程序的执行就可以是既并发又并行的。</p>
<h2 id="2-4-JVM-垃圾收集中的串行、并行和并发"><a href="#2-4-JVM-垃圾收集中的串行、并行和并发" class="headerlink" title="2.4 JVM 垃圾收集中的串行、并行和并发"></a>2.4 JVM 垃圾收集中的串行、并行和并发</h2><p>在 JVM 垃圾收集器中也涉及到如上的三个概念。</p>
<ul>
<li>串行（Serial）：使用单线程进行垃圾回收的回收器。</li>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<p>在了解了这些概念之后，我们开始具体介绍常用的垃圾收集器。</p>
<h1 id="3、主流的垃圾收集器"><a href="#3、主流的垃圾收集器" class="headerlink" title="3、主流的垃圾收集器"></a>3、主流的垃圾收集器</h1><h2 id="3-1-Serial收集器"><a href="#3-1-Serial收集器" class="headerlink" title="3.1 Serial收集器"></a>3.1 Serial收集器</h2><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了（新生代采用复制算法，老生代采用标志整理算法）。大家看名字就知道这个收集器是一个单线程收集器了。 它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在<code>进行垃圾收集工作的时候必须暂停其他所有的工作线程</code>（ “Stop The World” ：将用户正常工作的线程全部暂停掉），直到它收集结束。 </p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731143820628.png" alt="image-20210731143820628" style="zoom:50%;" />

<p>上图中：</p>
<ul>
<li>新生代采用复制算法，Stop-The-World</li>
<li>老年代采用标记-整理算法，Stop-The-World</li>
</ul>
<p>当它进行GC工作的时候，虽然会造成Stop-The-World，正如每种算法都有存在的原因，该串行收集器也有存在的原因：因为简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，没有线程交互的开销，专心做GC，自然可以获得最高的单线程效率。</p>
<p>所以Serial收集器对于运行在client模式下的应用是一个很好的选择（到目前为止，它依然是虚拟机运行在client模式下的默认新生代收集器） 串行收集器的缺点很明显，虚拟机的开发者当然也是知道这个缺点的，所以一直都在缩减Stop The World的时间。 在后续的垃圾收集器设计中停顿时间在不断缩短（但是仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）</p>
<h3 id="3-1-1-特点"><a href="#3-1-1-特点" class="headerlink" title="3.1.1 特点"></a>3.1.1 特点</h3><ul>
<li>针对新生代的收集器；</li>
<li>采用复制算法；</li>
<li>单线程收集；</li>
<li>进行垃圾收集时，必须暂停所有工作线程，直到完成； 即会”Stop The World”；</li>
</ul>
<h3 id="3-1-2-应用场景"><a href="#3-1-2-应用场景" class="headerlink" title="3.1.2 应用场景"></a>3.1.2 应用场景</h3><ul>
<li><code>依然是HotSpot在Client模式下默认的新生代收集器；</code></li>
<li>也有优于其他收集器的地方： 简单高效（与其他收集器的单线程相比）；</li>
<li>对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</li>
</ul>
<h3 id="3-1-3-参数设置"><a href="#3-1-3-参数设置" class="headerlink" title="3.1.3 参数设置"></a>3.1.3 参数设置</h3><p>添加该参数来显式的使用串行垃圾收集器: “-XX:+UseSerialGC”</p>
<h2 id="3-2-ParNew收集器"><a href="#3-2-ParNew收集器" class="headerlink" title="3.2 ParNew收集器"></a>3.2 ParNew收集器</h2><blockquote>
<p> Serial收集器的多线程版本-使用多条线程进行GC</p>
</blockquote>
<p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 CMS收集器是一个被认为具有划时代意义的并发收集器，因此如果有一个垃圾收集器能和它一起搭配使用让其更加完美，那这个收集器必然也是一个不可或缺的部分了。 收集器的运行过程如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731144404779.png" alt="image-20210731144404779" style="zoom:50%;" />

<h3 id="3-2-1-应用场景："><a href="#3-2-1-应用场景：" class="headerlink" title="3.2.1 应用场景："></a>3.2.1 应用场景：</h3><p>在Server模式下，ParNew收集器是一个非常重要的收集器，<strong>因为除Serial外，目前只有它能与CMS收集器配合工作</strong>； 但<font color=red>在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</font></p>
<h3 id="3-2-2-设置参数"><a href="#3-2-2-设置参数" class="headerlink" title="3.2.2 设置参数"></a>3.2.2 设置参数</h3><p>指定使用CMS后，会默认使用ParNew作为新生代收集: “-XX:+UseConcMarkSweepGC” 强制指定使用ParNew:<br>“-XX:+UseParNewGC” 指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相: “-XX:ParallelGCThreads”</p>
<h3 id="3-2-3-为什么只有ParNew能与CMS收集器配合"><a href="#3-2-3-为什么只有ParNew能与CMS收集器配合" class="headerlink" title="3.2.3 为什么只有ParNew能与CMS收集器配合"></a>3.2.3 为什么只有ParNew能与CMS收集器配合</h3><ul>
<li>CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>；</li>
<li>CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；</li>
<li>因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；</li>
</ul>
<h2 id="3-3-Parallel-Scavenge收集器"><a href="#3-3-Parallel-Scavenge收集器" class="headerlink" title="3.3 Parallel Scavenge收集器"></a>3.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 Parallel Scavenge收集器关注点是吞吐量（如何高效率的利用CPU）。 CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。 <strong>所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。（吞吐量：CPU用于用户代码的时间/CPU总消耗时间的比值，即=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)。比如，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。） 运行示意图：</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731144823884.png" alt="image-20210731144823884" style="zoom:50%;" />

<h3 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1 特点"></a>3.3.1 特点</h3><ul>
<li>新生代收集器；</li>
<li>采用复制算法；</li>
<li>多线程收集；</li>
<li>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）；</li>
</ul>
<h3 id="3-3-2-应用场景"><a href="#3-3-2-应用场景" class="headerlink" title="3.3.2 应用场景"></a>3.3.2 应用场景</h3><ul>
<li>高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；</li>
<li>当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互；</li>
<li>例如，那些执行批量处理、订单处理（对账等）、工资支付、科学计算的应用程序；</li>
</ul>
<h3 id="3-3-3-设置参数"><a href="#3-3-3-设置参数" class="headerlink" title="3.3.3 设置参数"></a>3.3.3 设置参数</h3><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量：</p>
<ul>
<li>控制最大垃圾收集停顿时间 “-XX:MaxGCPauseMillis”</li>
<li>控制最大垃圾收集停顿时间，大于0的毫秒数； MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；因为可能导致垃圾收集发生得更频繁； 设置垃圾收集时间占总时间的比率 “-XX:GCTimeRatio”</li>
<li>设置垃圾收集时间占总时间的比率，0 &lt; n &lt; 100的整数； GCTimeRatio相当于设置吞吐量大小； 垃圾收集执行时间占应用程序执行时间的比例的计算方法是： 1 / (1 + n) 。 例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5% = 1/(1+19)；默认值是1% = 1/(1+99)，即n=99； 垃圾收集所花费的时间是年轻一代和老年代收集的总时间； 如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；</li>
</ul>
<h2 id="3-4-Serial-Old收集器"><a href="#3-4-Serial-Old收集器" class="headerlink" title="3.4 Serial Old收集器"></a>3.4 Serial Old收集器</h2><p>Serial收集器的老年代版本，它同样是一个单线程收集器。 它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731143820628.png" alt="image-20210731143820628" style="zoom:50%;" />

<h3 id="3-4-1-特点"><a href="#3-4-1-特点" class="headerlink" title="3.4.1 特点"></a>3.4.1 特点</h3><ul>
<li><strong>针对老年代；</strong></li>
<li>采用”标记-整理-压缩”算法（Mark-Sweep-Compact）；</li>
<li>单线程收集；</li>
</ul>
<h3 id="3-4-2-应用场景"><a href="#3-4-2-应用场景" class="headerlink" title="3.4.2 应用场景"></a>3.4.2 应用场景</h3><ul>
<li>主要用于Client模式；</li>
<li>而在Server模式有两大用途：<br>（A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配Parallel Scavenge收集器）；<br>（B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用；</li>
</ul>
<h2 id="3-5-Parallel-Old收集器"><a href="#3-5-Parallel-Old收集器" class="headerlink" title="3.5 Parallel Old收集器"></a>3.5 Parallel Old收集器</h2><p>Parallel Scavenge收集器的老年代版本。 使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 在JDK1.6才有的。</p>
<h3 id="3-5-1-特点"><a href="#3-5-1-特点" class="headerlink" title="3.5.1 特点"></a>3.5.1 特点</h3><ul>
<li><strong>针对老年代；</strong></li>
<li>采用”标记-整理-压缩”算法；</li>
<li>多线程收集； Parallel Scavenge/Parallel Old收集器运行示意图如下</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731145301909.png" alt="image-20210731145301909" style="zoom:50%;" />

<h3 id="3-5-2-应用场景"><a href="#3-5-2-应用场景" class="headerlink" title="3.5.2 应用场景"></a>3.5.2 应用场景</h3><ul>
<li>JDK1.6及之后用来代替老年代的Serial Old收集器；</li>
<li>特别是在Server模式，多CPU的情况下； 这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge（新生代）加Parallel Old（老年代）收集器的”给力”应用组合；</li>
</ul>
<h3 id="3-5-3-设置参数"><a href="#3-5-3-设置参数" class="headerlink" title="3.5.3 设置参数"></a>3.5.3 设置参数</h3><p>指定使用Parallel Old收集器: “-XX:+UseParallelOldGC”</p>
<h2 id="3-6-CMS（Concurrent-Mark-Sweep）收集器"><a href="#3-6-CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="3.6 CMS（Concurrent Mark Sweep）收集器"></a>3.6 CMS（Concurrent Mark Sweep）收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。<code>它非常适合在注重用户体验的应用上使用</code>。</p>
<h3 id="3-6-1-特点"><a href="#3-6-1-特点" class="headerlink" title="3.6.1 特点"></a>3.6.1 特点</h3><ul>
<li><strong>针对老年代</strong></li>
<li>基于”标记-清除”算法(不进行压缩操作，会产生内存碎片)</li>
<li>以获取最短回收停顿时间为目标</li>
<li>并发收集、低停顿</li>
<li>需要更多的内存 CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器； 第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</li>
</ul>
<h3 id="3-6-2-应用场景"><a href="#3-6-2-应用场景" class="headerlink" title="3.6.2 应用场景"></a>3.6.2 应用场景</h3><ul>
<li>与用户交互较多的场景；（如常见WEB、B/S-浏览器/服务器模式系统的服务器上的应用）</li>
<li>希望系统停顿时间最短，注重服务的响应速度； 以给用户带来较好的体验；</li>
</ul>
<h3 id="3-6-3-CMS收集器运作过程"><a href="#3-6-3-CMS收集器运作过程" class="headerlink" title="3.6.3 CMS收集器运作过程"></a>3.6.3 CMS收集器运作过程</h3><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程可分为四个步骤：</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731145628763.png" alt="image-20210731145628763" style="zoom:50%;" />

<ul>
<li>初始标记： 暂停所有的其他线程，初始标记仅仅标记GC Roots能直接关联到的对象，速度很快；</li>
<li>并发标记 并发标记就是进行GC Roots Tracing的过程； 同时开启GC和用户线程，<strong>用一个闭包结构去记录可达对象</strong>。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方；</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录（采用多线程并行执行来提升效率）；需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</li>
<li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫，回收所有的垃圾对象； 由于整个过程耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。 所以总体来说，CMS的内存回收是与用户线程一起“并发”执行的。</li>
</ul>
<h3 id="3-6-4参数设置"><a href="#3-6-4参数设置" class="headerlink" title="3.6.4参数设置"></a>3.6.4参数设置</h3><p>指定使用CMS收集器 “-XX:+UseConcMarkSweepGC”</p>
<h3 id="3-6-5-CMS收集器缺点"><a href="#3-6-5-CMS收集器缺点" class="headerlink" title="3.6.5 CMS收集器缺点"></a>3.6.5 CMS收集器缺点</h3><h4 id="3-6-5-1-对CPU资源敏感"><a href="#3-6-5-1-对CPU资源敏感" class="headerlink" title="3.6.5.1 对CPU资源敏感"></a>3.6.5.1 对CPU资源敏感</h4><p>面向并发设计的程序都对CPU资源比较敏感（并发程序的特点）。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。（在对账系统中，不适合使用CMS收集器）。 CMS的默认收集线程数量是=(CPU数量+3)/4； 当CPU数量越多，回收的线程占用CPU就少。 也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。（比如 CPU=2时，那么就启动一个线程回收，占了50%的CPU资源。） （一个回收线程会在回收期间一直占用CPU资源）</p>
<p>针对这种情况，曾出现了”增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）； 类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间； 但效果并不理想，JDK1.6后就官方不再提倡用户使用。</p>
<h4 id="3-6-5-2-无法处理浮动垃圾"><a href="#3-6-5-2-无法处理浮动垃圾" class="headerlink" title="3.6.5.2 无法处理浮动垃圾"></a>3.6.5.2 无法处理浮动垃圾</h4><p>无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败 在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；</p>
<p><strong>解决办法：</strong> 这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集； 也可以认为CMS所需要的空间比其他垃圾收集器大； 可以使用”-XX:CMSInitiatingOccupancyFraction”，设置CMS预留老年代内存空间； </p>
<h4 id="3-6-5-3-产生大量内存碎片"><a href="#3-6-5-3-产生大量内存碎片" class="headerlink" title="3.6.5.3 产生大量内存碎片"></a>3.6.5.3 产生大量内存碎片</h4><p>由于CMS是基于“标记+清除”算法来回收老年代对象的，因此长时间运行后会产生大量的空间碎片问题，可能导致新生代对象晋升到老生代失败。 由于碎片过多，将会给大对象的分配带来麻烦。因此会出现这样的情况，<strong>老年代还有很多剩余的空间，但是找不到连续的空间来分配当前对象，这样不得不提前触发一次Full GC</strong>。</p>
<ul>
<li>解决办法 使用”-XX:+UseCMSCompactAtFullCollection”和”-XX:+CMSFullGCsBeforeCompaction”，需要结合使用。</li>
<li>UseCMSCompactAtFullCollection “-XX:+UseCMSCompactAtFullCollection”</li>
</ul>
<p>为了解决空间碎片问题，CMS收集器提供−XX:+UseCMSCompactAlFullCollection标志，使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程； 但合并整理过程无法并发，停顿时间会变长； 默认开启（但不会进行，需要结合CMSFullGCsBeforeCompaction使用）；</p>
<ul>
<li>CMSFullGCsBeforeCompaction 由于合并整理是无法并发执行的，空间碎片问题没有了，但是有导致了连续的停顿。因此，可以使用另一个参数−XX:CMSFullGCsBeforeCompaction，表示在多少次不压缩的Full GC之后，对空间碎片进行压缩整理。 可以减少合并整理过程的停顿时间； 默认为0，也就是说每次都执行Full GC，不会进行压缩整理； 由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大；</li>
</ul>
<h3 id="3-6-6-CMS-amp-Parallel-Old"><a href="#3-6-6-CMS-amp-Parallel-Old" class="headerlink" title="3.6.6 CMS&amp;Parallel Old"></a>3.6.6 CMS&amp;Parallel Old</h3><p>总体来看，CMS与Parallel Old垃圾收集器相比，<font color=red>CMS减少了执行老年代垃圾收集时应用暂停的时间； 但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间</font>； （原因：CMS不进行内存空间整理节省了时间，但是可用空间不再是连续的了，垃圾收集也不能简单的使用指针指向下一次可用来为对象分配内存的地址了。</p>
<p>相反，这种情况下，需要使用可用空间列表。即，会创建一个指向未分配区域的列表，每次为对象分配内存时，会从列表中找到一个合适大小的内存区域来为新对象分配内存。这样做的结果是，<font color=red>老年代上的内存的分配比简单实用碰撞指针分配内存消耗大。</font>这也会增加年轻代垃圾收集的额外负担，因为老年代中的大部分对象是在新生代垃圾收集的时候从新生代提升为老年代的。） 当新生代对象无法分配过大对象，就会放到老年代进行分配。</p>
<h2 id="3-7-G1收集器"><a href="#3-7-G1收集器" class="headerlink" title="3.7 G1收集器"></a>3.7 G1收集器</h2><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation)。</p>
<p>G1（Garbage-First）是JDK7-u4才推出商用的收集器；<br>G1 (Garbage-First)是一款<strong>面向服务器的垃圾收集器</strong>，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。<br><strong>G1的使命是在未来替换CMS，并且在JDK1.9已经成为默认的收集器。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731151137749.png" alt="image-20210731151137749" style="zoom:33%;" />



<h3 id="3-7-1-特点"><a href="#3-7-1-特点" class="headerlink" title="3.7.1 特点"></a>3.7.1 特点</h3><h4 id="3-7-1-1-并行与并发"><a href="#3-7-1-1-并行与并发" class="headerlink" title="3.7.1.1 并行与并发"></a>3.7.1.1 并行与并发</h4><p>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731154444389.png" alt="image-20210731154444389" style="zoom:50%;" />

<h4 id="3-7-1-2-分代收集"><a href="#3-7-1-2-分代收集" class="headerlink" title="3.7.1.2 分代收集"></a>3.7.1.2 分代收集</h4><p>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p>
<ul>
<li>能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；</li>
<li>能够采用不同方式处理不同时期的对象；</li>
<li>虽然保留分代概念，但Java堆的内存布局有很大差别；</li>
<li>将整个堆划分为多个大小相等的独立区域（Region）；</li>
<li>新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731151108695.png" alt="image-20210731151108695" style="zoom:50%;" />

<h3 id="3-7-2-空间整合"><a href="#3-7-2-空间整合" class="headerlink" title="3.7.2 空间整合"></a>3.7.2 空间整合</h3><p>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p>
<ul>
<li>从整体看，是基于标记-整理算法；</li>
<li>从局部（两个Region间）看，是基于复制算法；<br>这是一种类似火车算法的实现；<br>不会产生内存碎片，有利于长时间运行；</li>
</ul>
<blockquote>
<p>（火车算法是分代收集器所用的算法，目的是在成熟对象空间中提供限定时间的渐进收集。在后面一篇中会专门介绍）</p>
</blockquote>
<h3 id="3-7-3-可预测的停顿"><a href="#3-7-3-可预测的停顿" class="headerlink" title="3.7.3 可预测的停顿"></a>3.7.3 可预测的停顿</h3><p>这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型。可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒。在低停顿的同时实现高吞吐量。</p>
<h3 id="3-7-4-G1收集器延伸"><a href="#3-7-4-G1收集器延伸" class="headerlink" title="3.7.4 G1收集器延伸"></a>3.7.4 G1收集器延伸</h3><h4 id="3-7-4-1-为什么G1可以实现可预测停顿"><a href="#3-7-4-1-为什么G1可以实现可预测停顿" class="headerlink" title="3.7.4.1 为什么G1可以实现可预测停顿"></a>3.7.4.1 为什么G1可以实现可预测停顿</h4><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731154741680.png" alt="image-20210731154741680" style="zoom:50%;" />

<p>可以有计划地避免在Java堆的进行全区域的垃圾收集； G1收集器将内存分大小相等的独立区域（Region），新生代和老年代概念保留，但是已经不再物理隔离。 G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表； 每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）； 这就保证了在有限的时间内可以获取尽可能高的收集效率；</p>
<h4 id="3-7-4-2-一个对象被不同区域引用的问题"><a href="#3-7-4-2-一个对象被不同区域引用的问题" class="headerlink" title="3.7.4.2 一个对象被不同区域引用的问题"></a>3.7.4.2 一个对象被不同区域引用的问题</h4><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ 在其他的分代收集器，也存在这样的问题（而G1更突出）：回收新生代也不得不同时扫描老年代？ 这样的话会降低Minor GC的效率；</p>
<p><strong>解决方法：</strong></p>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描： 每个Region都有一个对应的Remembered Set； 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）； 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中； 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set； 就可以保证不进行全局扫描，也不会有遗漏。</p>
<h3 id="3-7-5-应用场景"><a href="#3-7-5-应用场景" class="headerlink" title="3.7.5 应用场景"></a>3.7.5 应用场景</h3><ul>
<li><strong>面向服务端应用，针对具有大内存、多处理器的机器；</strong></li>
<li>最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （实践：对账系统中将CMS垃圾收集器修改为G1，降低对账时间20秒以上）</li>
</ul>
<blockquote>
<p>具体什么情况下应用G1垃圾收集器比CMS好，可以参考以下几点（但不是绝对）： 超过50％的Java堆被活动数据占用； 对象分配频率或年代的提升频率变化很大； GC停顿时间过长（长于0.5至1秒）； 建议： 如果现在采用的收集器没有出现问题，不用急着去选择G1； 如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS只有需要实际场景测试才知道。（如果使用G1后发现性能还没有使用CMS好，那么还是选择CMS比较好）</p>
</blockquote>
<h3 id="3-7-6-设置参数"><a href="#3-7-6-设置参数" class="headerlink" title="3.7.6 设置参数"></a>3.7.6 设置参数</h3><p>可以通过下面的参数，来设置一些G1相关的配置。 指定使用G1收集器： “-XX:+UseG1GC”</p>
<p>当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45： “-XX:InitiatingHeapOccupancyPercent”</p>
<p>为G1设置暂停时间目标，默认值为200毫秒： “-XX:MaxGCPauseMillis”</p>
<p>设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region: “-XX:G1HeapRegionSize”</p>
<p>新生代最小值，默认值5%: “-XX:G1NewSizePercent”</p>
<p>新生代最大值，默认值60%: “-XX:G1MaxNewSizePercent”</p>
<p>设置STW期间，并行GC线程数: “-XX:ParallelGCThreads”</p>
<p>设置并发标记阶段，并行执行的线程数: “-XX:ConcGCThreads”</p>
<p>G1在标记过程中，每个区域的对象活性都被计算，在回收时候，就可以根据用户设置的停顿时间，选择活性较低的区域收集，这样既能保证垃圾回收，又能保证停顿时间，而且也不会降低太多的吞吐量。Remark（重新标记）阶段新算法的运用，以及收集过程中的压缩，都弥补了CMS不足。 引用Oracle官网的一句话：“G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS)”。 G1计划作为并发标记-清除收集器(CMS)的长期替代品</p>
<h1 id="4、如何选择垃圾收集器"><a href="#4、如何选择垃圾收集器" class="headerlink" title="4、如何选择垃圾收集器"></a>4、如何选择垃圾收集器</h1><p>垃圾收集器主要可以分为如下三大类：</p>
<ul>
<li><strong>串行收集器</strong>：Serial和Serial Old<br>只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。</li>
<li><strong>并行收集器</strong>[<strong>吞吐量优先</strong>]：Parallel Scanvenge和Parallel Old<br>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场景 。</li>
<li><strong>并发收集器</strong>[<strong>停顿时间优先</strong>]：CMS和G1。<br>用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。 适用于对时间有要求的场景，比如Web应用。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/142273073">https://zhuanlan.zhihu.com/p/142273073</a></p>
<p><a href="https://juejin.cn/post/6844903877024677901">https://juejin.cn/post/6844903877024677901</a></p>
<p><a href="https://juejin.cn/post/6844904159817236494">面试官：你对JVM垃圾收集器了解吗？13连问你是否抗的住！</a></p>
<p><a href="https://juejin.cn/post/6874060477031579661#heading-32">https://juejin.cn/post/6874060477031579661#heading-32</a></p>
<p><a href="https://juejin.cn/post/6844904041080684552">https://juejin.cn/post/6844904041080684552</a></p>
<p><a href="https://juejin.cn/post/6844904159817236494#heading-14">https://juejin.cn/post/6844904159817236494#heading-14</a></p>
<p><a href="https://juejin.cn/post/6844903892774289421#heading-20">https://juejin.cn/post/6844903892774289421#heading-20</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/wiki/Java%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。</p>
<h2 id="位操作基础"><a href="#位操作基础" class="headerlink" title="位操作基础"></a>位操作基础</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p>
<ul>
<li>在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。</li>
<li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li>
<li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，      5，9这些2^i+1的数字。写成int a = 1 « i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 « i) + 1;</li>
<li>另外位操作还有一些复合操作符，如&amp;=、|=、 ^=、«=、»=。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">        System.out.println(a &gt;&gt; <span class="number">2</span>); <span class="comment">// -4：-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4</span></span><br><span class="line">        System.out.println(b &gt;&gt; <span class="number">2</span>); <span class="comment">// 3：15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用位操作小技巧"><a href="#常用位操作小技巧" class="headerlink" title="常用位操作小技巧"></a>常用位操作小技巧</h2><p>下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。</p>
<h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。下面程序将输出0到100之间的所有偶数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">       System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>, d = <span class="number">2</span>;</span><br><span class="line">c ^= d;</span><br><span class="line">d ^= c;</span><br><span class="line">c ^= d;</span><br><span class="line">System.out.println(<span class="string">&quot;c=&quot;</span> + c);</span><br><span class="line">System.out.println(<span class="string">&quot;d=&quot;</span> + d);</span><br></pre></td></tr></table></figure>
<p>可以这样理解：</p>
<p>第一步 a=b 即a=(ab)；<br>第二步 b=a 即b=b(ab)，由于运算满足交换律，b(ab)=bba。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值；<br>第三步 a=b 就是a=ab，由于前面二步可知a=(ab)，b=a，所以a=ab即a=(ab)a。故a会被赋上b的值；</p>
<h3 id="变换符号"><a href="#变换符号" class="headerlink" title="变换符号"></a>变换符号</h3><p>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)</span><br></pre></td></tr></table></figure>
<p>同样可以这样的将11变成-11</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 1011(二进制) –取反-&gt; 0000 0100(二进制) –加1-&gt; 1111 0101(二进制)</span><br></pre></td></tr></table></figure>
<p>因此变换符号只需要取反后加1即可。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(~a + <span class="number">1</span>);</span><br><span class="line">System.out.println(~b + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="求绝对值"><a href="#求绝对值" class="headerlink" title="求绝对值"></a>求绝对值</h3><p>位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)</span><br></pre></td></tr></table></figure>
<p>来得到6。</p>
<p>因此先移位来取符号位，int i = a » 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println(i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println((a ^ j) - j);</span><br></pre></td></tr></table></figure>
<p>注意这种方法没用任何判断表达式，而且有些笔面试题就要求这样做，因此建议读者记住该方法（_讲解过后应该是比较好记了）。</p>
<h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><p>筛素数法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码（注2）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印100以内素数：</span></span><br><span class="line"><span class="comment">// （1）对每个素数，它的倍数必定不是素数；</span></span><br><span class="line"><span class="comment">// （2）有很多重复访问如flag[10]会在访问flag[2]和flag[5]时各访问一次；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max];</span><br><span class="line"><span class="keyword">int</span> [] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flags[m]) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags[n] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。</p>
<p>下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个数指定位上置1</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">e |=  <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure>
<p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断指定位上是0还是1</span></span><br><span class="line"><span class="keyword">if</span> ((e &amp; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) != <span class="number">0</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m += <span class="number">3</span>) &#123;</span><br><span class="line">    bits[m / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (m % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出整个bits</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((bits[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        System.out.print(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.print(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1001001001001001001001001001001001001001</span></span><br></pre></td></tr></table></figure>
<p>可以看出该数组每3个就置成了1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] flags2 = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((((flags2[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags2[n / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (n % <span class="number">32</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="位操作工具类"><a href="#位操作工具类" class="headerlink" title="位操作工具类"></a>位操作工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 位运算的常用方法封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运算数指定位置的值</span></span><br><span class="line"><span class="comment">     * 例如： 0000 1011 获取其第 0 位的值为 1, 第 2 位 的值为 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定位置的值(0 or 1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) ((source &gt;&gt; pos) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置的值置为指定值</span></span><br><span class="line"><span class="comment">     * 例: 0000 1011 需要更新为 0000 1111, 即第 2 位的值需要置为 1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     *            只能取值为 0, 或 1, 所有大于0的值作为1处理, 所有小于0的值作为0处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">setBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            source |= mask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source &amp;= (~mask);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置取反值</span></span><br><span class="line"><span class="comment">     * 例： 0000 1011 指定第 3 位取反, 结果为 0000 0011; 指定第2位取反, 结果为 0000 1111</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">reverseBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) (source ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查运算数的指定位置是否为1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示指定位置值为1, false 表示指定位置值为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        source = (<span class="keyword">byte</span>) (source &gt;&gt;&gt; pos);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (source &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入口函数做测试</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取十进制 11 (二级制 0000 1011) 为例子</span></span><br><span class="line">        <span class="keyword">byte</span> source = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取第2位值并输出, 结果应为 0000 1011</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, getBitValue(source, i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位置为1并输出 , 结果为 75 (0100 1011)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + setBitValue(source, <span class="number">6</span>, (<span class="keyword">byte</span>) <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位取反并输出, 结果应为75(0100 1011)</span></span><br><span class="line">        System.out.println(reverseBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 检查第6位是否为1，结果应为false</span></span><br><span class="line">        System.out.println(checkBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 输出为1的位, 结果应为 0 1 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBitValue(source, i)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitSet类"><a href="#BitSet类" class="headerlink" title="BitSet类"></a>BitSet类</h2><p>BitSet类：大小可动态改变, 取值为true或false的位集合。用于表示一组布尔标志。 此类实现了一个按需增长的位向量。位 set 的每个组件都有一个 boolean 值。用非负的整数将 BitSet 的位编入索引。可以对每个编入索引的位进行测试、设置或者清除。通过逻辑与、逻辑或和逻辑异或操作，可以使用一个 BitSet 修改另一个 BitSet 的内容。默认情况下，set 中所有位的初始值都是 false。</p>
<p>每个位 set 都有一个当前大小，也就是该位 set 当前所用空间的位数。注意，这个大小与位 set 的实现有关，所以它可能随实现的不同而更改。位 set 的长度与位 set 的逻辑长度有关，并且是与实现无关而定义的。</p>
<p>除非另行说明，否则将 null 参数传递给 BitSet 中的任何方法都将导致 NullPointerException。 在没有外部同步的情况下，多个线程操作一个 BitSet 是不安全的。</p>
<p>构造函数: BitSet() or BitSet(int nbits)，默认初始大小为64。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bitIndex, <span class="keyword">boolean</span> value)</span>: 将指定索引处的位设置为指定的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>: 将此 BitSet 中的所有位设置为 <span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cardinality</span><span class="params">()</span>: 返回此 BitSet 中设置为 <span class="keyword">true</span> 的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span>: 返回位置是pos的字位值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet other)</span>: other同该字位集进行与操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet other)</span>: other同该字位集进行或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet other)</span>: other同该字位集进行异或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span>: 清除此 BitSet 中所有的位,set – 用来屏蔽此 BitSet 的 BitSet</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 返回此 BitSet 表示位值时实际使用空间的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>: 返回此 BitSet 的“逻辑大小”：BitSet 中最高设置位的索引加 1。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>: 返回该集合Hash 码， 这个码同集合中的字位值有关。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span>: 如果other中的字位同集合中的字位相同，返回<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span>: 克隆此 BitSet，生成一个与之相等的新 BitSet。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>: 返回此位 set 的字符串表示形式。</span></span><br></pre></td></tr></table></figure>

<p>例1：标明一个字符串中用了哪些字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhichChars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BitSet used = <span class="keyword">new</span> BitSet();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhichChars</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            used.set(str.charAt(i));  <span class="comment">// set bit for char</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String desc = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> size = used.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.get(i))</span><br><span class="line">                desc += (<span class="keyword">char</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> desc + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        WhichChars w = <span class="keyword">new</span> WhichChars(<span class="string">&quot;How do you do&quot;</span>);</span><br><span class="line">        System.out.println(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestThree</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm = <span class="keyword">new</span> BitSet();</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">1</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        System.out.println(bm.get(<span class="number">65</span>));</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestFour</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm1 = <span class="keyword">new</span> BitSet(<span class="number">7</span>);</span><br><span class="line">        System.out.println(bm1.isEmpty() + <span class="string">&quot;--&quot;</span> + bm1.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm2 = <span class="keyword">new</span> BitSet(<span class="number">63</span>);</span><br><span class="line">        System.out.println(bm2.isEmpty() + <span class="string">&quot;--&quot;</span> + bm2.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm3 = <span class="keyword">new</span> BitSet(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm3.isEmpty() + <span class="string">&quot;--&quot;</span> + bm3.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm4 = <span class="keyword">new</span> BitSet(<span class="number">111</span>);</span><br><span class="line">        System.out.println(bm4.isEmpty() + <span class="string">&quot;--&quot;</span> + bm4.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位操作技巧"><a href="#位操作技巧" class="headerlink" title="位操作技巧"></a>位操作技巧</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获得int型最大值</span></span><br><span class="line">System.out.println((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);<span class="comment">// 2147483647， 由于优先级关系，括号不可省略</span></span><br><span class="line">System.out.println(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));<span class="comment">// 2147483647</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 获得int型最小值</span></span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 获得long类型的最大值</span></span><br><span class="line">System.out.println(((<span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">127</span>) - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 乘以2运算</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5. 除以2运算(负奇数的运算不可用)</span></span><br><span class="line">System.out.println(<span class="number">10</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 6. 乘以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 7. 除以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">16</span>&gt;&gt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8. 判断一个数的奇偶性</span></span><br><span class="line">System.out.println((<span class="number">10</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">System.out.println((<span class="number">9</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 9. 不用临时变量交换两个数（面试常考）</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 10. 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">System.out.println((n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>));</span><br><span class="line"><span class="comment">/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1</span></span><br><span class="line"><span class="comment">若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，</span></span><br><span class="line"><span class="comment">结果n变号并且绝对值减1，再减去-1就是绝对值 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 11. 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）</span></span><br><span class="line">System.out.println(b&amp;((a-b)&gt;&gt;<span class="number">31</span>) | a&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 12. 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）</span></span><br><span class="line">System.out.println(a&amp;((a-b)&gt;&gt;<span class="number">31</span>) | b&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 13. 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)</span></span><br><span class="line">System.out.println((a ^ b) &gt; <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 14. 计算2的n次方 n &gt; 0</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;(n-<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 15. 判断一个数n是不是2的幂</span></span><br><span class="line">System.out.println((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果是2的幂，n一定是100... n-1就是1111....</span></span><br><span class="line"><span class="comment">所以做与运算结果为0*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 16. 求两个整数的平均值</span></span><br><span class="line">System.out.println((a+b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17. 从低位到高位,取n的第m位</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line">System.out.println((n &gt;&gt; (m-<span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 18. 从低位到高位.将n的第m位置为1</span></span><br><span class="line">System.out.println(n | (<span class="number">1</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/*将1左移m-1位找到第m位，得到000...1...000</span></span><br><span class="line"><span class="comment">n在和这个数做或运算*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 19. 从低位到高位,将n的第m位置为0</span></span><br><span class="line">System.out.println(n &amp; ~(<span class="number">0</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/* 将1左移m-1位找到第m位，取反后变成111...0...1111</span></span><br><span class="line"><span class="comment">n再和这个数做与运算*/</span></span><br></pre></td></tr></table></figure>

<br>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之AQS底层实现与原理</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>AQS锁限时等待是如何实现的？</p>
<p>公平锁与非公平锁流程是怎样的？</p>
<h1 id="独占锁-amp-共享锁"><a href="#独占锁-amp-共享锁" class="headerlink" title="独占锁&amp;共享锁"></a>独占锁&amp;共享锁</h1><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>即只允许一个线程获取同步状态，当这个线程还没有释放同步状态时，其他线程是获取不了的，只能加入到同步队列，进行等待。</p>
<h1 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁&amp;非公平锁"></a>公平锁&amp;非公平锁</h1><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><strong>公平策略：</strong>在多个线程争用锁的情况下，公平策略倾向于将访问权授予等待时间最长的线程。也就是说，相当于有一个线程等待队列，先进入等待队列的线程后续会先获得锁，这样按照“先来后到”的原则，对于每一个等待线程都是公平的。</p>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。</p>
<blockquote>
<p><em>注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。</em></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802175827435.png" alt="image-20210802175827435" style="zoom:50%;" />

<h1 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h1><p>同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖于一个int类型的成员变量来表示同步状态以及一个FIFO队列构建等待队列。它的子类必须重写AQS定义的几个protected修饰的用来改变同步状态的方法，其他方法主要是用来实现排队和阻塞机制的。</p>
<p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义，可以这样理解两者的关系：</p>
<p>锁是面向使用者的，它定义了使用者和锁交互的接口，隐藏了实现的细节，同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。</p>
<p><strong>AQS的设计是使用模版方法设计模式，它将一个方法开放给子类重写，而同步器给同步组件所提供的模版方法又会重新调用子类所重写的方法。</strong></p>
<h1 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h1><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>1、AQS使用一个int成员变量来表示同步状态</p>
<p>2、使用Node实现FIFO队列，可以用于构建锁或者其他同步装置</p>
<p>AQS资源共享方式：独占Exclusive（排它锁模式）和共享Share（共享锁模式）</p>
<blockquote>
<p>AQS它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802175542181.png" alt="image-20210802175542181" style="zoom:50%;" />

<h2 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h2><p>state状态使用volatile int类型的变量，表示当前同步状态。state的访问方式有三种:</p>
<p><code>getState()</code><br> <code>setState()</code><br> <code>compareAndSetState()</code></p>
<h2 id="Node内部类"><a href="#Node内部类" class="headerlink" title="Node内部类"></a>Node内部类</h2><p>Node类是AQS的绝对核心类，AQS基于Node来构建同步队列和Condition队列；</p>
<p><strong>源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 获取前置节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>CANCELLED</strong><br> waitStatus值为1时表示该线程节点已释放（超时、中断），已取消的节点不会再阻塞。</p>
<p><strong>SIGNAL</strong><br> waitStatus为-1时表示该线程的后续线程需要阻塞，即只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程</p>
<p><strong>CONDITION</strong><br> waitStatus为-2时，表示该线程在condition队列中阻塞（Condition有使用）</p>
<p><strong>PROPAGATE</strong><br> waitStatus为-3时，表示该线程以及后续线程进行无条件传播（CountDownLatch中有使用）共享模式下， PROPAGATE 状态的线程处于可运行状态</p>
<h1 id="AQS之独占-非公平"><a href="#AQS之独占-非公平" class="headerlink" title="AQS之独占+非公平"></a>AQS之独占+非公平</h1><h2 id="获取锁acquire"><a href="#获取锁acquire" class="headerlink" title="获取锁acquire"></a>获取锁acquire</h2><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802195409121.png" alt="image-20210802195409121" style="zoom:50%;" />

<p>ReentrantLock是AQS独占模式的经典实现，ReentrantLock在构造实例是可以指定是否是fair lock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquire方法获取许可"><a href="#acquire方法获取许可" class="headerlink" title="acquire方法获取许可"></a>acquire方法获取许可</h3><p>下面我们就从锁的获取入手开始解读AQS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryAcquire抽象方法"><a href="#tryAcquire抽象方法" class="headerlink" title="tryAcquire抽象方法"></a>tryAcquire抽象方法</h3><p>tryAcquire是个protected方法，具体是实现在对应的子类中，这个方法的功能就是尝试去修改state的状态值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nonfairTryAcquire非公平锁获取许可"><a href="#nonfairTryAcquire非公平锁获取许可" class="headerlink" title="nonfairTryAcquire非公平锁获取许可"></a>nonfairTryAcquire非公平锁获取许可</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 非公平锁进来就开始抢占锁，体现非公平性</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>以ReentrantLock方法的实现为例，看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">						<span class="comment">// 获取当前线程</span></span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">// getState()返回的就是AQS类中的state字段的值</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// c == 0 说明当前锁没有被任何线程占有</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            		<span class="comment">// 使用cas去修改state的值，独占模式下acquires = 1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                		<span class="comment">// 修改state成功之后，将独占线程设置成当前线程，并且返回true，表示抢占锁成功</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果state ！= 0 并且独占线程就是当前线程，表示当前线程持有对象的锁，此时，需要锁重入，state继续累加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>AQS的acquire(int arg)方法中还有一部分就是 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p>
<h3 id="addWaiter添加等待队列"><a href="#addWaiter添加等待队列" class="headerlink" title="addWaiter添加等待队列"></a>addWaiter添加等待队列</h3><p>我们先看一下addWaiter方法，java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</p>
<p>如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 首先创建一个Node节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="comment">// cas 将当前节点设置到同步队列的队尾</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上面cas设置没有成功，则通过enq方法将节点添加到队尾</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">               <span class="comment">// Must initialize 初始化头节点</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过自旋，最终将node节点添加到同步队列中。</p>
<h3 id="acquireQueued获取许可"><a href="#acquireQueued获取许可" class="headerlink" title="acquireQueued获取许可"></a>acquireQueued获取许可</h3><p>节点添加到同步队列之中，然后是一个非常重要的方法 ‼️</p>
<p>acquireQueued方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              	<span class="comment">// 如果node节点是队列中第二个节点（因为第一个正在执行状态）肯定要队列中从第二个节点开始尝试获取锁</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="comment">// 第二个节点调用tryAcquire方法</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   <span class="comment">//把当前节点设置成队列头节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断是否需要挂起队列中后续的节点</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          	<span class="comment">// 如果获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shouldParkAfterFailedAcquire方法"><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h3><p>shouldParkAfterFailedAcquire将队列后续节点挂起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">         	<span class="comment">// 如果前一个节点的waitStatus == Node.SIGNAL 则直接返回true</span></span><br><span class="line">         	<span class="comment">// 因为前一个节点状态是Node.SIGNAL时，才会通知后续节点进行park或者unpark</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//  static final int CANCELLED =  1;</span></span><br><span class="line">         	<span class="comment">// 取消状态的节点直接在等待队列中去除</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 将前一个节点的waitStatus设置成Node.SIGNAL</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">		// 挂起当前线程，走到这肯定是没有拿到执行权的，线程需要挂起等待其他线程释放锁</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后如果获取失败的话，会调用下面这个方法：</p>
<h3 id="cancelAcquire取消获取"><a href="#cancelAcquire取消获取" class="headerlink" title="cancelAcquire取消获取"></a>cancelAcquire取消获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 由于线程要被取消了，所以将 thread 线程清掉</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这步表示将 node 的 pre 指向之前第一个非取消状态的结点（即跳过所有取消状态的结点）,waitStatus &gt; 0 表示当前结点状态为取消状态</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取经过过滤后的 pre 的 next 结点，这一步主要用在后面的 CAS 设置 pre 的 next 节点上</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 将当前结点设置为取消状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前取消结点为尾结点，使用 CAS 则将尾结点设置为其前驱节点，如果设置成功，则尾结点的 next 指针设置为空</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步看得有点绕，我们想想，如果当前节点取消了，那是不是要把当前节点的前驱节点指向当前节点的后继节点</span></span><br><span class="line">    <span class="comment">// 但是我们之前也说了，要唤醒或阻塞结点，须在其前驱节点的状态为 SIGNAL 的条件才能操作，</span></span><br><span class="line">    <span class="comment">//所以在设置 pre 的 next 节点时要保证 pre 结点的状态为 SIGNAL，想通了这一点相信你不难理解以下代码。</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 pre 为 head，或者  pre 的状态设置 SIGNAL 失败，则直接唤醒后继结点去竞争锁，之前我们说过， SIGNAL 的结点取消（或释放锁）后可以唤醒后继结点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁release"><a href="#释放锁release" class="headerlink" title="释放锁release"></a>释放锁release</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease方法也是由子类来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  					<span class="comment">// 判断当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">              	<span class="comment">// 将独占线程设置成null，下一个线程获取到锁时会设置成自己的</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行unparkSuccessor(h);方法了，当前线程释放了锁之后，需要唤醒等待队列中的第二个节点对应的线程。这里注意一点的是，要执行的Node节点的waitStatus肯定是0；？？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="comment">//置零当前线程所在的结点状态，允许失败</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 从第二个节点开始往后找waitStatus&lt;=0的节点，然后执行unpark</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">  <span class="comment">// 找到下一个需要唤醒的结点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Condition在AQS中的实现"><a href="#Condition在AQS中的实现" class="headerlink" title="Condition在AQS中的实现"></a>Condition在AQS中的实现</h1><p>上面已经介绍了<code>AQS</code>所提供的核心功能，当然它还有很多其他的特性，这里我们来继续说下<code>Condition</code>这个组件。</p>
<p>Condition是在java 1.5中才出现的，它用来替代传统的<code>Object</code>的<code>wait()</code>、<code>notify()</code>实现线程间的协作，相比使用<code>Object</code>的<code>wait()</code>、<code>notify()</code>，使用<code>Condition</code>中的<code>await()</code>、<code>signal()</code>这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用`Condition</p>
<p>其中<code>AbstractQueueSynchronizer</code>中实现了<code>Condition</code>中的方法，主要对外提供<code>awaite(Object.wait())</code>和<code>signal(Object.notify())</code>调用。</p>
<h2 id="Condition在java代码中的应用"><a href="#Condition在java代码中的应用" class="headerlink" title="Condition在java代码中的应用"></a>Condition在java代码中的应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一加锁成功&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一执行await被挂起&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一被唤醒成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二加锁成功&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二唤醒线程一&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程一调用了condition.await();之后，线程二才可以获取到锁并且执行自己的任务，线程二调用 condition.signal();之后唤醒线程一，但是还没有执行权限，只有在线程二执行完成之后调用lock.unlock();之后，线程一重新回去到锁，然后执行线程一后续的流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802183143055.png" alt="image-20210802183143055"></p>
<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p>await使当前线程释放锁，也就是执行许可，然后进入Condition队列，等待在某个时刻被某个线程唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  					<span class="comment">// 将当前线程封装成Node节点添加的Condition队列中</span></span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">  					<span class="comment">// 添加到Condition队列中的线程需要释放锁资源</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  					<span class="comment">// 查看当前节点是不是在同步队列中</span></span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="comment">// 当前节点不在同步队列中，那么直接park挂起</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">//  表明已经有的线程调用了signal唤醒当前线程，</span></span><br><span class="line">  					<span class="comment">// 并且节点已经存放到了同步等待队列中，所以可以调用如果acquireQueued请求许可了</span></span><br><span class="line">  					<span class="comment">// savedState是获取许可的个数 这个要和之前释放的许可个数一致</span></span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>addConditionWaiter方法添加一个节点到Condition队列中</strong></p>
<p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#addConditionWaiter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">              	<span class="comment">// 先检查一遍有没有取消状态的节点，如果有的话，清除掉</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 将当前线程封装成Node添加到Condition队列中</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h2><p>唤醒一个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doSignal方法"><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">// 将Condition队列中的节点状态设置成SIGNAL，并将节点添加到同步队列中</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="transferForSignal方法"><a href="#transferForSignal方法" class="headerlink" title="transferForSignal方法"></a>transferForSignal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 将节点状态改成0 </span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 把当前添加到同步队列中，并返回前一个节点</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="comment">// 设置前一个节点的状态为SIGNAL</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        		<span class="comment">// 唤醒当前节点的线程</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/hB5ncpe7_tVovQj1sNlDRA">https://mp.weixin.qq.com/s/hB5ncpe7_tVovQj1sNlDRA</a></p>
<p><a href="https://mp.weixin.qq.com/s/iNz6sTen2CSOdLE0j7qu9A">https://mp.weixin.qq.com/s/iNz6sTen2CSOdLE0j7qu9A</a></p>
<p><a href="https://github.com/AobingJava/JavaFamily">https://github.com/AobingJava/JavaFamily</a></p>
<p><a href="https://segmentfault.com/a/1190000015804888/">https://segmentfault.com/a/1190000015804888/</a></p>
<p><a href="https://juejin.cn/post/6844903997438951437">https://juejin.cn/post/6844903997438951437</a></p>
<p><a href="https://juejin.cn/post/6870099231361728525">https://juejin.cn/post/6870099231361728525</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之深入理解ReentrantLock</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReetrantLock/</url>
    <content><![CDATA[<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，<strong>支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</strong></p>
<h2 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h2><p><strong>支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802160050888.png" alt="image-20210802160050888" style="zoom:50%;" />

<p>下面以非公平锁的lock方法为例，看一下ReentrantLock源码的实现 👇</p>
<h3 id="首先是lock方法"><a href="#首先是lock方法" class="headerlink" title="首先是lock方法"></a>首先是lock方法</h3><p>1、进入lock方法首先对调用compareAndSetState(0,1)去尝试获取锁，这一点正是体现了非公平锁</p>
<p>2、如果第一步没有获取到锁，然后执行第二步acquire(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  					<span class="comment">// 非公平锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>lock方法首先会去cas修改AQS的state状态，独占锁模式下state增加1表示获取锁成功；state设置成功之后，需要将独占线程字段设置成当前线程：<code>exclusiveOwnerThread = thread;</code></p>
<h3 id="AQS-acquire-1"><a href="#AQS-acquire-1" class="headerlink" title="AQS#acquire(1)"></a>AQS#acquire(1)</h3><p>如果没有抢占到锁，那么执行下面的acquire方法，这个方法定义在AQS类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire方法是在子类实现的，在这里我们看一下ReentrantLock的nonfairTryAcquire，也就是非公平锁的实现。</p>
<h3 id="nonfairTryAcquire-int-acquires-方法"><a href="#nonfairTryAcquire-int-acquires-方法" class="headerlink" title="nonfairTryAcquire(int acquires)方法"></a>nonfairTryAcquire(int acquires)方法</h3><p>下面是ReentrantLock，非公平锁的lock实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">  					<span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 锁冲入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>int c = getState() == 0 则表示没有线程占有锁，当前线程来加锁时，可以直接使用cas尝试获取锁。</p>
<p>current == getExclusiveOwnerThread() 表示当前线程已经持有线程锁了，<code> int nextc = c + acquires;</code>则表示支持锁重入，nextc的值则表示锁重入的次数；</p>
<p>以上如果没有加锁成功，则返回false，然后执行AQS的acquireQueue方法，首先将当前节点封装成<code>addWaiter(Node.EXCLUSIVE), arg)</code> 添加到同步队列，同时判断头节点是否获取锁成功，如果成功了，将当前节点添加到头上；</p>
<h3 id="AQS-addWaiter-Node-mode"><a href="#AQS-addWaiter-Node-mode" class="headerlink" title="AQS#addWaiter(Node mode)"></a>AQS#addWaiter(Node mode)</h3><p>添加节点到队列中，Node.EXCLUSIVE独占锁，这里采用的是<strong>尾插法</strong>，在队列的队尾添加新的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果队列不是空的，则直接添加到队尾</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是空的，则调用enq方法，创建队列，并添加到队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-enq-final-Node-node"><a href="#AQS-enq-final-Node-node" class="headerlink" title="AQS#enq(final Node node)"></a>AQS#enq(final Node node)</h3><p>第一个线程获取锁的时候，肯定是无锁的状态，根本走不到这一步，最早走到这里的是第二个去获取锁的线程。</p>
<p>当第二个线程执行到该方法是需要执行<strong>两次循环</strong>：</p>
<p>1、t == null时，需要初始化队列</p>
<p>2、执行下一次循环，将node添加到tail,由于这个方法还是处在并发环境下的，所以，设置队尾的时候还是需要cas操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-acquireQueued-final-Node-node-int-arg"><a href="#AQS-acquireQueued-final-Node-node-int-arg" class="headerlink" title="AQS#acquireQueued(final Node node, int arg)"></a>AQS#acquireQueued(final Node node, int arg)</h3><p><font color=red>这个方法绝对是绝对的AQS核心方法 </font> ‼️</p>
<p>这个方法主要有3个重要操作：</p>
<p>1、判断前置节点是不是head，如果是的话，去尝试获取锁；</p>
<p>2、如果前置节点不是head，要把前置节点的waitState设置成SIGNAL，同时park当前线程，避免一直空转，因为这里是用的  for (;;) {}</p>
<p>3、如果获取锁和park都失败了，则把当前节点设置成cancel状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-cancelAcquire-Node-node"><a href="#AQS-cancelAcquire-Node-node" class="headerlink" title="AQS.cancelAcquire(Node node)"></a>AQS.cancelAcquire(Node node)</h3><p><code>这个方法比较难理解，总结一下就干了下面几个事：</code></p>
<p>1、执行到这个方法的node肯定是要取消的，那个需要thread设置成null</p>
<p>2、查看当前节点之前的节点有没有是取消状态的，一起踢出队列</p>
<p>3、把当前节点设置成Node.CANCELLED状态</p>
<p>4、判断node在队列中的位置，如果是队尾的话，把tail指向node的前置节点，并且把前驱节点的next指向null</p>
<p>5、如果不是tail节点，那么判断是不是head，如果不是head，那么，将node的前驱节点的状态设置成Node.SIGNAL，并且把node的前驱节点node的next节点</p>
<p>6、如果node是head节点，那么直接unpark此线程去执行acquire</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">        Node pred = node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">//cancelled</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">        Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">        <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">        <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">            <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// if执行的逻辑是把前置节点设置成Node.SIGNAL</span></span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  	<span class="comment">// 把node的前置前置节点的下一个节点指向node的下一个节点，因为上面node已经是Node.CANCELLED状态了，需要踢出队列</span></span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前置节点是head，此时没有被人竞争锁资源，直接唤醒当前节点</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>上面是以ReentrantLock的非公平锁为例学习了一下ReentrantLock加锁的过程。那么思考一下公平锁和非公平锁的有什么区别呢？🤔</p>
<p>理解了上面的流程之后，下面直接比较源码遍很好理解两者之间的区别！</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>如何制定ReentarntLock的公平锁和非公平锁？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面看了NonfairSync#lock的实现，下面看一下FairSync#lock的实现：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FairSync和NonfairSync都是ReentrantLock的静态内部类，在FairSync的lock方法中，没有下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">   setExclusiveOwnerThread(Thread.currentThread());</span><br></pre></td></tr></table></figure>

<p>每一个线程都直接调用AQS#acquire(1)方法，而且在ReentrantLock#FairSync#FairSync(int acquires)的实现中，添加了一个判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">               compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>也就是<code>hasQueuedPredecessors</code>方法，这个方法的作用是判断队列中是否有节点在等待，如果有的话，ReentrantLock#FairSync#FairSync(int acquires)直接返回false，当前节点智能进入到队列中。这两点就是公平锁和非公平锁的明显区别体现。</p>
<h2 id="释放锁操作"><a href="#释放锁操作" class="headerlink" title="释放锁操作"></a>释放锁操作</h2><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210802205517221.png" alt="image-20210802205517221"></p>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-release-int-arg"><a href="#AQS-release-int-arg" class="headerlink" title="AQS#release(int arg)"></a>AQS#release(int arg)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease的具体实现仍是有具体的子类来实现的。</p>
<h3 id="ReentrantLock-tryRelease-int-releases-方法"><a href="#ReentrantLock-tryRelease-int-releases-方法" class="headerlink" title="ReentrantLock#tryRelease(int releases)方法"></a>ReentrantLock#tryRelease(int releases)方法</h3><p>1、释放锁的逻辑应该比较好理解，是将state做减法。</p>
<p>2、判断state == 0 , 则表示无锁状态，如果不是0，则表示还在线程重入的状态下，同时设置state</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意一点，设置state的时候是直接赋值的，而没有使用cas，为什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实考虑到上下文就很简单了，此时设置state的时候，有两种状态，无锁和重入锁，肯定不会是多线程的场景。所以不需要cas操作。</p>
<p>接着分析上面的AQS#release方法:</p>
<p>当state设置成功之后，需要判断head节点，然后唤醒head的后驱节点的线程，如果存在的话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  	<span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 这里是共享锁，在ReentarntLock先跳过</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="tryLock-long-time-TimeUnit-unit"><a href="#tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock(long time, TimeUnit unit)"></a>tryLock(long time, TimeUnit unit)</h2><p><strong>方法描述如下：</strong><br><font color=blue>在给定的等待时间内并且线程没有被中断以及锁可用的情况下，去获取锁。</font><br>如果锁可用，方法会直接返回。<br>如果锁不可用，则当前线程将会处于不可用状态以达到线程调度目的，并且休眠直到下面三个事件中的一个发生：<br>①、当前线程获取到锁<br>②、其他线程中断当前线程<br>③、指定的等待时间已过<br>假如当前线程：<br>在该方法的条目上设置其中断状态或在获取锁时中断，并且支持锁获取中断时，将抛出中断异常，当前线程中断状态会被清除。<br>假如给定的等待时间已过，将会返回false。</p>
<p>下面具体阅读源码实现,方法的入参指定了等待时间，和时间的单位，有<code>NANOSECONDS</code>、<code>MICROSECONDS</code>、<code>MILLISECONDS</code>、<code>SECONDS</code>…等单位。</p>
<p>下面具体阅读源码实现,方法的入参指定了等待时间，和时间的单位，有<code>NANOSECONDS</code>、<code>MICROSECONDS</code>、<code>MILLISECONDS</code>、<code>SECONDS</code>…等单位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的内部调用了<code>Sync</code>的<code>tryAcquireNanos</code>，继续往下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//判断中断状态并决定是否抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//尝试获取锁，如果成功则返回true，失败则调用doAcquireNanos进行等待</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcqure</code>和之前分析的是同一个方法，不再赘述。<br>接下来是<code>doAcquireNanos</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果给定的时间值小于等于0，则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//根据给定参数计算截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//将当前线程添加到CLH等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="comment">//初始失败标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在给定时间内循环/自旋尝试获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//取出前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前置节点为首节点，并且当前线程能够成功获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC 前首节点出队，帮助GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否等待超时，如果超时，则返回false</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//这里判断是否可以阻塞线程并做相应操作，跟之前分析的几个方法不一样的是，这里的阻塞多了一个判断，并且是在有限时间内阻塞，类似于sleep</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">//判断中断状态，并决定是否抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doAcquireNanos</code>的阻塞是有时间限制的，所以能在给定的时间内，返回获取锁的操作结果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6870099231361728525">https://juejin.cn/post/6870099231361728525</a></p>
<p><a href="https://www.processon.com/view/5f047c16f346fb1ae598b4dd?fromnew=1">https://www.processon.com/view/5f047c16f346fb1ae598b4dd?fromnew=1</a></p>
<p><a href="https://www.imooc.com/article/51118">https://www.imooc.com/article/51118</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-reindex</title>
    <url>/wiki/elasticsearch-reindex/</url>
    <content><![CDATA[<h2 id="reindex-常规使用"><a href="#reindex-常规使用" class="headerlink" title="reindex 常规使用"></a>reindex 常规使用</h2><blockquote>
<p>Reindex要求为源索引中的所有文档启用_source。<br>Reindex不尝试设置目标索引，它不复制源索引的设置，你应该在运行_reindex操作之前设置目标索引，包括设置映射、碎片计数、副本等。</p>
</blockquote>
<p>如下示例将把文档从twitter索引复制到new_twitter索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &quot;http://127.0.0.1:9200/_reindex?pretty&quot; -H &quot;Content-Type:application/json&quot; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;twitter&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;new_twitter&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>下面是返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">299</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;batches&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">-1.0</span>,</span><br><span class="line">  <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;failures&quot;</span> : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像_update_by_query一样，_reindex获取源索引的快照，但它的目标必须是不同的索引，因此不太可能发生版本冲突。可以像index API那样配置dest元素来控制乐观并发控制。仅仅省略version_type(如上所述)或将其设置为internal，都会导致Elasticsearch盲目地将文档转储到目标中，覆盖任何碰巧具有相同类型和id的文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;internal&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将version_type设置为external将导致Elasticsearch保存源文件的版本，创建任何缺失的文档，并更新目标索引中比源索引中版本更旧的文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;external&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置op_type=create将导致_reindex只在目标索引中创建缺失的文档。所有现有文件将导致版本冲突：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter3&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;op_type&quot;</span>: <span class="string">&quot;create&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>默认情况下，版本冲突将中止_reindex进程，“conflicts”请求体参数可用于指示_reindex处理关于版本冲突的下一个文档，需要注意的是，其他错误类型的处理不受“conflicts”参数的影响，当在请求体中设置“conflicts”:“proceed”时，_reindex进程将继续处理版本冲突，并返回所遇到的版本冲突计数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter3&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;op_type&quot;</span>: <span class="string">&quot;create&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>返回值如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">7</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;batches&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">-1.0</span>,</span><br><span class="line">  <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;failures&quot;</span> : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过向源添加查询来限制文档。这将只复制由kimchy发出的tweet到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;kimchy&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>source中的index可以是一个列表，允许你在一个请求中从多个源复制。这将从twitter和blog索引复制文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: [<span class="string">&quot;twitter&quot;</span>,<span class="string">&quot;blog&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：Reindex API不处理ID冲突，因此最后编写的文档将“胜出”，但顺序通常是不可预测的，因此依赖这种行为不是一个好主意，相反，可以使用脚本确保id是惟一的。<br>还可以通过设置大小来限制处理文档的数量，示例将只复制一个单一的文件从twitter到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>如果你想从twitter索引中获得一组特定的文档，你需要使用sort。排序会降低滚动的效率，但在某些上下文中，这样做是值得的。如果可能的话，选择一个比大小和排序更具选择性的查询。这将把10000个文档从twitter复制到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;blog2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: &#123; <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>source部分支持搜索请求中支持的所有元素。例如，只有原始文档中的一部分字段可以使用源过滤重新索引，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;user&quot;</span>, <span class="string">&quot;_doc&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>与_update_by_query一样，_reindex支持修改文档的脚本。与_update_by_query不同，脚本允许修改文档的元数据。这个例子改变了源文档的版本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;blog2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;external&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;if (ctx._source.foo == \&quot;bar\&quot;) &#123;ctx._version++; ctx._source.remove(\&quot;foo\&quot;)&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>就像在_update_by_query中一样，你可以设置ctx.op更改在目标索引上执行的操作，值为noop，delete。<br>设置ctx.op到任何其他字段都会返回一个错误，在ctx中设置任何其他字段也是如此。可以修改以下值：_id、_index<br>、_version、_routing。<br>将_version设置为null或将它从ctx映射中清除，就像没有在索引请求中发送版本一样;它将导致在目标索引中覆盖文档，而不管目标上的版本或在_reindex请求中使用的版本类型。<br>默认情况下，如果_reindex看到一个带有路由的文档，那么该路由将被保留，除非脚本更改了它，你可以设置路由对dest的请求，以改变这一点：<br>keep：将为每个匹配发送的批量请求上的路由设置为匹配上的路由。这是默认值。<br>discard：将为每个匹配发送的批量请求上的路由设置为null。<br>=<some text>：将为每个匹配发送的批量请求上的路由设置为=之后的所有文本。<br>例如，你可以使用以下请求将所有文档从具有公司名称cat的源索引复制到路由设置为cat的dest索引中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;company&quot;</span>: <span class="string">&quot;cat&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: <span class="string">&quot;=cat&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>默认情况下，_reindex使用滚动批次为1000，可以使用源元素中的size字段更改批大小：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: <span class="string">&quot;=cat&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>_reindex还可以通过像这样指定管道来使用Ingest节点特性：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pipeline&quot;</span>: <span class="string">&quot;some_ingest_pipeline&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>




<h2 id="远程reindex"><a href="#远程reindex" class="headerlink" title="远程reindex"></a>远程reindex</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;pass&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>host参数必须包含scheme, host, port（如：<a href="http://otherhost:9200）,也可以加路径（如：http://otherhost:9200/proxy），username和password是可选的，如果远程集群开启了安全认证，那么是必选的，如果需要使用username和password，需要使用https。">http://otherhost:9200）,也可以加路径（如：http://otherhost:9200/proxy），username和password是可选的，如果远程集群开启了安全认证，那么是必选的，如果需要使用username和password，需要使用https。</a><br>远程主机需要设置白名单，可以通过elasticsearch.yml文件里的reindex.remote.whitelist属性进行设置，如果设置多个值可以使用逗号来进行分隔（如：otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*），这里的配置可以忽略scheme，如：</p>
<p><code>reindex.remote.whitelist: &quot;otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*&quot;</code></p>
<p>必须让每个处理reindex的节点上添加白名单的配置。<br>这个特性应该适用于可能找到的任何版本的Elasticsearch的远程集群，这应该允许通过从旧版本的集群reindex，将Elasticsearch的任何版本升级到当前版本。<br>要启用发送到旧版本Elasticsearch的查询，无需验证或修改即可将查询参数直接发送到远程主机，注意：远程reindex不支持手动或者自动slicing。<br>从远程服务器reindex使用堆上缓冲区，默认最大大小为100mb，如果远程索引包含非常大的文档，则需要使用更小的批处理大小，下面的示例将批处理大小设置为10。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>还可以使用socket_timeout字段设置远程连接上的套接字读取超时，使用connect_timeout字段设置连接超时，他们的默认值为30秒，下面示例例将套接字读取超时设置为1分钟，连接超时设置为10秒：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;socket_timeout&quot;</span>: <span class="string">&quot;1m&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;connect_timeout&quot;</span>: <span class="string">&quot;10s&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="配置SSL参数"><a href="#配置SSL参数" class="headerlink" title="配置SSL参数"></a>配置SSL参数</h2><p>远程reindex支持配置SSL参数，除了在Elasticsearch秘钥库中添加安全设置之外，还需要在elasticsearch.yml文件中进行配置，不可能在_reindex请求体中配置。<br>支持以下设置：<br>reindex.ssl.certificate_authorities<br>应受信任的PEM编码证书文件的路径列表，不同同时指定reindex.ssl.certificate_authorities和reindex.ssl.truststore.path。<br>reindex.ssl.truststore.path<br>包含要信任的证书的Java密钥存储文件的路径，这个密钥存储库可以是“JKS”或“PKCS#12”格式，不能同时指定reindex.ssl.certificate_authorities和reindex.ssl.truststore.path。<br>reindex.ssl.truststore.password<br>reindex.ssl.truststore.path配置的密码，不能和reindex.ssl.truststore.secure_password一起使用。<br>reindex.ssl.truststore.secure_password<br>reindex.ssl.truststore.path配置的密码，不能和reindex.ssl.truststore.password一起使用。<br>reindex.ssl.truststore.type<br>reindex.ssl.truststore.path信任存储库的类型，必须是jks或PKCS12，如果reindex.ssl.truststore.path的结束是”.p12”, “.pfx”或者”pkcs12”，那么该配置的默认值是PKCS12，否则默认值是jks。<br>reindex.ssl.verification_mode<br>指示用于防止中间人攻击和伪造证书的验证类型。可以设置为full（验证主机名和证书路径）、certificate（验证证书路径，但不验证主机名）、none（不执行验证——这在生产环境中是强烈不鼓励的），默认是full。<br>reindex.ssl.certificate<br>指定PEM编码证书的路径或者证书链用于HTTP客户端身份认证，这个配置还需要设置reindex.ssl.key值，不能同时设置reindex.ssl.certificate和reindex.ssl.keystore.path。<br>reindex.ssl.key<br>指定与用于客户端身份验证的证书相关联的PEM编码私钥的路径，不能同时设置reindex.ssl.key和reindex.ssl.keystore.path。<br>reindex.ssl.key_passphrase<br>指定用于解密已加密的PEM编码私钥(reindex.ssl.key)的口令，不能与reindex.ssl.secure_key_passphrase一起使用。<br>reindex.ssl.secure_key_passphrase<br>指定用于解密已加密的PEM编码私钥(reindex.ssl.key)的口令，不能与reindex.ssl.key_passphrase一起使用。<br>reindex.ssl.keystore.path<br>指定密钥存储库的路径，其中包含用于HTTP客户机身份验证的私钥和证书(如果远程集群需要)，这个密钥存储库可以是“JKS”或“PKCS#12”格式，不能同时指定reindex.ssl.key和reindex.ssl.keystore.path。<br>reindex.ssl.keystore.type<br>密钥存储库的类型(reindex.ssl.keystore.path)，必须是jks或者PKCS12，如果reindex.ssl.keystore.path的结束是”.p12”, “.pfx”或者”pkcs12”，那么该配置的默认值是PKCS12，否则默认值是jks。<br>reindex.ssl.keystore.password<br>密钥存储库的密码(reindex.ssl.keystore.path)，此设置不能与reindex.ssl.keystore.secure_password一起使用。<br>reindex.ssl.keystore.secure_password<br>密钥存储库的密码(reindex.ssl.keystore.path)，此设置不能与reindex.ssl.keystore.password一起使用。<br>reindex.ssl.keystore.key_password<br>密钥存储库中密钥的密码(reindex.ssl.keystore.path)，默认为密钥存储库密码，此设置不能与reindex.ssl.keystore.secure_key_password一起使用。<br>reindex.ssl.keystore.secure_key_password<br>密钥存储库中密钥的密码(reindex.ssl.keystore.path)，默认为密钥存储库密码，此设置不能与reindex.ssl.keystore.key_password一起使用。</p>
<h2 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h2><p>除了标准的pretty参数外， reindex还支持refresh, wait_for_completion, wait_for_active_shards, timeout, scroll和requests_per_second。<br>发送refresh url参数将导致对所写请求的所有索引进行刷新，这与Index API的refresh参数不同，后者只会刷新接收新数据的碎片，与index API不同的是，它不支持wait_for。<br>如果请求包含wait_for_completion=false，则Elasticsearch将执行一些执行前检查，启动请求，然后返回一个任务，该任务可与Tasks api一起用于取消或获取任务状态，Elasticsearch还将创建此任务的记录，作为.tasks/task/${taskId}的文档，你可以自己决定是保留或者删除他，当你已经完成了，删除他，这样es会回收他使用的空间。<br>wait_for_active_shards控制在进行重新索引之前必须激活多少个shard副本，超时控制每个写请求等待不可用碎片变为可用的时间，两者在批量API中的工作方式完全相同，由于_reindex使用滚动搜索，你还可以指定滚动参数来控制“搜索上下文”存活的时间(例如?scroll=10m)，默认值是5分钟。<br>requests_per_second可以设置为任何正数(1.4、6、1000等)，并通过在每个批中填充等待时间来控制_reindex发出批索引操作的速率，可以通过将requests_per_second设置为-1来禁用。<br>节流是通过在批之间等待来完成的，这样就可以给_reindex内部使用的滚动设置一个考虑填充的超时，填充时间是批大小除以requests_per_second和写入时间之间的差额，默认情况下批处理大小为1000，所以如果requests_per_second被设置为500：</p>
<p><code>target_time = 1000 / 500 per second = 2 seconds </code>padding time<code> = target_time - write_time = 2 seconds - 0.5 seconds = 1.5 seconds</code></p>
<p>由于批处理是作为单个_bulk请求发出的，因此较大的批处理大小将导致Elasticsearch创建许多请求，然后等待一段时间再启动下一个请求集，这是“bursty”而不是“smooth”，默认值是-1。</p>
<p>响应体 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">639</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;updated&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;created&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;deleted&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;batches&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;noops&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;version_conflicts&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;retries&quot;</span>: &#123;</span><br><span class="line">	<span class="attr">&quot;bulk&quot;</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">&quot;search&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;throttled_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;requests_per_second&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;throttled_until_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failures&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>took<br>整个操作花费的总毫秒数。<br>timed_out<br>如果在reindex期间执行的任何请求超时，则将此标志设置为true。<br>total<br>成功处理的文档数量。<br>updated<br>成功更新的文档数量。<br>created<br>成功创建的文档的数量。<br>deleted<br>成功删除的文档数量。<br>batches<br>由reindex回拉的滚动响应的数量。<br>noops<br>由于用于reindex的脚本返回了ctx.op的noop值而被忽略的文档数量。<br>version_conflicts<br>reindex命中的版本冲突数。<br>retries<br>reindex尝试重试的次数,bulk是重试的批量操作的数量，search是重试的搜索操作的数量。<br>throttled_millis<br>请求休眠以符合requests_per_second的毫秒数。<br>requests_per_second<br>在reindex期间每秒有效执行的请求数。<br>throttled_until_millis<br>在_reindex响应中，该字段应该始终等于零，它只有在使用任务API时才有意义，在任务API中，它指示下一次(毫秒)再次执行节流请求，以符合requests_per_second。<br>failures<br>出现多个错误以数组返回。</p>
<h2 id="使用task-api"><a href="#使用task-api" class="headerlink" title="使用task api"></a>使用task api</h2><p>获取task</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&amp;wait_for_completion=false&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>返回值为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;task&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q:18&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用任务API获取所有正在运行的reindex请求的状态：<br><code>curl -XGET &quot;http://127.0.0.1:9200/_tasks?detailed=true&amp;actions=*reindex&amp;pretty&quot;</code><br>或者根据task id获取<br><code>curl -XGET &quot;http://127.0.0.1:9200/_tasks/8uQK-B00RiWq03awtJok1Q:48?pretty&quot;</code><br>返回值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;completed&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;task&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;node&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span> : <span class="number">48</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;transport&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;action&quot;</span> : <span class="string">&quot;indices:data/write/reindex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;total&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;created&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;batches&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">0.0</span>,</span><br><span class="line">      <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;reindex from [twitter] to [new_twitter][_doc]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start_time_in_millis&quot;</span> : <span class="number">1566216815832</span>,</span><br><span class="line">    <span class="attr">&quot;running_time_in_nanos&quot;</span> : <span class="number">86829</span>,</span><br><span class="line">    <span class="attr">&quot;cancellable&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;headers&quot;</span> : &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;no such index [new_twitter] and [action.auto_create_index] ([twitter,index10,-index1*,+ind*,-myIndex]) doesn&#x27;t match&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span> : <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span> : <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消task"><a href="#取消task" class="headerlink" title="取消task"></a>取消task</h2><p>任何reindex接口都可以使用task cancel api取消：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_tasks/8uQK-B00RiWq03awtJok1Q:48/_cancel?pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;node_failures&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;failed_node_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;Failed node [8uQK-B00RiWq03awtJok1Q]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;node_id&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;caused_by&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;resource_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;task [8uQK-B00RiWq03awtJok1Q:48] doesn&#x27;t support cancellation&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span> : &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消应该很快发生，但可能需要几秒钟，Tasks API将继续列出任务，直到它醒来取消自己。</p>
<h2 id="rethrottle"><a href="#rethrottle" class="headerlink" title="rethrottle"></a>rethrottle</h2><p>可以在url中使用_rethrottle，并使用requests_per_second参数来设置节流：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex/8uQK-B00RiWq03awtJok1Q:250/_rethrottle?requests_per_second=-1&amp;pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;node_failures&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;failed_node_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;Failed node [8uQK-B00RiWq03awtJok1Q]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;node_id&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;caused_by&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;resource_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;task [8uQK-B00RiWq03awtJok1Q:250] is missing&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span> : &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reindex改变属性名称"><a href="#reindex改变属性名称" class="headerlink" title="reindex改变属性名称"></a>reindex改变属性名称</h2><p>_reindex可以重命名属性名，假设你创建了一个包含如下文档的索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/test/_doc/1?refresh&amp;pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;words words&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;flag&quot;</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>在reindex的时候想把flag修改为tag，示例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.tag = ctx._source.remove(\&quot;flag\&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看order2的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">&quot;http://127.0.0.1:9200/order2/_doc/1?pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;order2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;text&quot;</span> : <span class="string">&quot;words words&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;foo&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Reindex支持切片滚动，以并行化重新索引过程。这种并行化可以提高效率，并提供一种方便的方法将请求分解为更小的部分</p>
<h3 id="手动切片"><a href="#手动切片" class="headerlink" title="手动切片"></a>手动切片</h3><p>通过为每个请求提供一个片id和片的总数，手工切片一个重索引请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;slice&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;max&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;slice&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;max&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以通过以下方法来验证：</p>
<p><code>curl -XGET &quot;http://127.0.0.1:9200/_refresh?pretty&quot;</code></p>
<p><code>curl -XPOST &quot;http://127.0.0.1:9200/order2/_search?size=0&amp;filter_path=hits.total&amp;pretty&quot;</code></p>
<p>返回值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="自动切面"><a href="#自动切面" class="headerlink" title="自动切面"></a>自动切面</h3><p>你还可以让_reindex使用切片滚动自动并行化_uid上的切片，使用slices指定要使用的片数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?slices=5&amp;refresh&amp;pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过下面请求进行验证：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/order2/_search?size=0&amp;filter_path=hits.total&amp;pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="reindex多个索引"><a href="#reindex多个索引" class="headerlink" title="reindex多个索引"></a>reindex多个索引</h2><p>如果有许多索引需要reindex，通常最好一次reindex一个索引，而不是使用一个glob模式来获取许多索引。这样，如果有任何错误，可以删除部分完成的索引并从该索引重新开始，从而恢复该过程。它还使并行化过程变得相当简单：将索引列表拆分为reindex并并行运行每个列表。<br>可以使用一次性脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">for index in i1 i2 i3 i4 i5; do</span><br><span class="line">  curl -HContent-Type:application/json -XPOST localhost:<span class="number">9200</span>/_reindex?pretty -d&#x27;&#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;&#x27;$index&#x27;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;&#x27;$index&#x27;-reindexed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#x27;</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="reindex每日索引"><a href="#reindex每日索引" class="headerlink" title="reindex每日索引"></a>reindex每日索引</h2><p>尽管有上述建议，你仍然可以结合使用_reindex和Painless来reindex每日索引，从而将新模板应用于现有文档。<br>假设有以下文件组成的索引:</p>
<p><code>curl -XPUT &quot;http://127.0.0.1:9200/metricbeat-2016.05.30/_doc/1?refresh&amp;pretty&quot; -H &quot;Content-Type:application/json&quot; -d</code><br>{“system.cpu.idle.pct”:  0.908}’</p>
<p><code>curl -XPUT &quot;http://127.0.0.1:9200/metricbeat-2016.05.31/_doc/1?refresh&amp;pretty&quot; -H &quot;Content-Type:application/json&quot; -d&#39;</code><br>{“system.cpu.idle.pct”:  0.105}</p>
<p>metricbeat-*索引的新模板已经加载到Elasticsearch中，但它只适用于新创建的索引。<br>下面的脚本从索引名称中提取日期，并创建一个附加-1的新索引。所有来自metricbeat-2016.05.31的数据将reindex到metricbeat-2016.05.31-1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;metricbeat-*&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;metricbeat&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._index = &#x27;metricbeat-&#x27; + (ctx._index.substring(&#x27;metricbeat-&#x27;.length(),ctx._index.length())) + &#x27;-1&#x27;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以前metricbeat索引中的所有文档现在都可以在*-1索引中找到。</p>
<p><code>curl -XGET &quot;http://127.0.0.1:9200/metricbeat-2016.05.30-1/_doc/1?pretty&quot;</code><br><code>curl -XGET &quot;http://127.0.0.1:9200/metricbeat-2016.05.31-1/_doc/1?pretty&quot;</code></p>
<p>前一种方法还可以与更改字段名称结合使用，以便仅将现有数据加载到新索引中，并在需要时重命名任何字段。</p>
<h2 id="提取索引中的子集合"><a href="#提取索引中的子集合" class="headerlink" title="提取索引中的子集合"></a>提取索引中的子集合</h2><p>_reindex可用于提取索引的随机子集进行测试：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;function_score&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span> : &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">        <span class="attr">&quot;random_score&quot;</span> : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="string">&quot;_score&quot;</span>    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;random_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_reindex默认按_doc排序，因此random_score不会有任何效果，除非你覆盖sort属性为_score。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>极尽HashMap底层原理</title>
    <url>/wiki/%E6%9E%81%E5%B0%BDHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/92481037">HashMap 中的容量与扩容实现，细致入微，值的一品</a></li>
<li><a href="https://www.zhihu.com/search?type=content&q=hashmap">Java 8系列之重新认识HashMap 美团技术团队</a> </li>
</ul>
</blockquote>
<blockquote>
<p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：<br><img src="https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png"></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<img src='https://pic1.zhimg.com/8db4a3bdfb238da1a1c4431d2b6e075c_b.png'>

<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;美团&quot;</span>,<span class="string">&quot;小美&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下:</p>
<p>int threshold;             // 所能容纳的key-value对极限<br>    final float loadFactor;    // 负载因子<br>    int modCount;<br>    int size;</p>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，<code>例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</code></p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159]%EF%BC%8CHashtable%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%B8%BA11%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A1%B6%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hashtable%E6%89%A9%E5%AE%B9%E5%90%8E%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%BF%98%E6%98%AF%E7%B4%A0%E6%95%B0%EF%BC%89%E3%80%82HashMap%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E9%9D%9E%E5%B8%B8%E8%A7%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%8F%96%E6%A8%A1%E5%92%8C%E6%89%A9%E5%AE%B9%E6%97%B6%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81%EF%BC%8CHashMap%E5%AE%9A%E4%BD%8D%E5%93%88%E5%B8%8C%E6%A1%B6%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%97%B6%EF%BC%8C%E4%B9%9F%E5%8A%A0%E5%85%A5%E4%BA%86%E9%AB%98%E4%BD%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://blog.csdn.net/liuqiyao_01/article/details/14475159]，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考[<a href="http://blog.csdn.net/v_july_v/article/details/6105630]%E3%80%82">http://blog.csdn.net/v_july_v/article/details/6105630]。</a></p>
<h2 id="实现-方法"><a href="#实现-方法" class="headerlink" title="实现-方法"></a>实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。<br><img src='https://pic2.zhimg.com/8e8203c1b51be6446cda4026eaaccf19_b.png'></p>
<h2 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。<br><img src='https://pic3.zhimg.com/58e67eae921e4b431782c07444af824e_b.png'></p>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);                      <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;                  <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                  </span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<img src='https://pic1.zhimg.com/e5aa99e811d1814e010afa7779b759d4_b.png'>

<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<img src='https://pic2.zhimg.com/a285d9b2da279a18b052fe5eed69afe9_b.png'>

<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<img src='https://pic2.zhimg.com/b2cb057773e3d67976c535d6ef547d51_b.png'>

<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<img src='https://pic3.zhimg.com/544caeb82a329fa49cc99842818ed1ba_b.png'>

<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             <span class="keyword">return</span> oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">         newCap = oldThr;</span><br><span class="line">     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 计算新的resize上限</span></span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                         next = e.next;</span><br><span class="line">                         <span class="comment">// 原索引</span></span><br><span class="line">                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j] = loHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<img src="https://pic4.zhimg.com/fa10635a66de637fe3cbd894882ff0c7_b.png">  

<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。<br>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<img src="https://pic4.zhimg.com/d39d7eff6e8e04f98f5b53bebe2d4d7f_b.png">  

<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<img src="https://pic2.zhimg.com/5f3cf5300f041c771a736b40590fd7b1_b.png">  

<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之CountDownLatch工具</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCountDownLatch%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>你要问什么是CountDownLatch? 那我可有的说了。</p>
<p>之前干活的时候，有很多处理数据的任务，但是呢，数据量很大，写的java脚本执行下来肯定会比较慢，那怎么办呢，想起来刚毕业那会，有个同事写了一个并发调用的工具，当时感觉碉堡了。</p>
<p>当我查看这个工具的具体实现时，发现它是基于CountDownLatch来封装的，咱当时也没用过CountDownLatch，感觉应该挺难，就直接用了那个工具。</p>
<p>后来发现那个工具使用起来有些繁琐，就比如我刷数据这个事，CountDownLatch直接干是最简单的。</p>
<h2 id="CountDownLatch是什么"><a href="#CountDownLatch是什么" class="headerlink" title="CountDownLatch是什么"></a>CountDownLatch是什么</h2><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210804172448596.png" alt="image-20210804172448596" style="zoom:50%;" />

<p>按照官方API文档上的介绍呢，CountDownLatch就是一个同步机制，用来实现一个或多个线程一直wait知道另一个线程完成一系列动作。</p>
<h2 id="CountDownLatch使用"><a href="#CountDownLatch使用" class="headerlink" title="CountDownLatch使用"></a>CountDownLatch使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute 111&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute 222&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread invoke await&quot;</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;subThread execute end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main thread invoke await</span><br><span class="line">Thread-0 execute 111</span><br><span class="line">Thread-1 execute 222</span><br><span class="line">subThread execute end</span><br></pre></td></tr></table></figure>

<p>下面我们就从countDown和await两个方法解析CountDownLatch的运行机制吧</p>
<h2 id="CountDownLatch实现原理"><a href="#CountDownLatch实现原理" class="headerlink" title="CountDownLatch实现原理"></a>CountDownLatch实现原理</h2><p>和ReentrantLock实现独占锁不同的是，CountDownLatch是典型的共享锁。</p>
<p>值得注意的是，CountDownLatch的静态内部类Sync继承了AbstractQueuedSynchronizer并实现了tryAcquireShared方法和tryReleaseShared方法。</p>
<p>下面先从构造方法入手开始学习 👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化count字段，其值是设置在AQS的state字段上面的，当每个线程执行了countDown()之后，<code>state = state - 1</code></p>
<p>当state = 0 时，唤醒之前await的线程。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p><strong>下面是await方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AQS#acquireSharedInterruptibly(int arg)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">          	<span class="comment">// 获取中断标志，把中断标志复位，然后把中断异常往上层抛</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquireShared(arg)这个方法和之前学习ReentrantLock时是一样的，这是AQS提供的模版方法。</p>
<p>AQS提供模版方法，有每个子类自己去实现逻辑，然后再由AQS本身调用。</p>
<p><strong>CountDownLatch#tryAcquireShared(int acquires)</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getState()返回的是AQS的state值，第一个线程获取是肯定不是0</p>
<p>如果getState()方法返回-1的话，会执行下面的方法：</p>
<p><strong>AQS#doAcquireSharedInterruptibly</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 表示aqs state = 0</span></span><br><span class="line">                  	<span class="comment">// 需要把当前线程设置成头节点，并向下传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 避免一直空转，将前一个节点状态设置成SIGNAL,然后挂起当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">              	<span class="comment">// 如果线程中断，则直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当countDownLatch的count变成0的时候，主线程await完成，然后被唤醒，继续执行。</p>
<p><strong>setHeadAndPropagate(Node node, int propagate)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">          	<span class="comment">// 如果后续节点是shard节点，释放</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS#releaseShared(int arg) 释放共享锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 有子类实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch#tryReleaseShared(int releases)</strong></p>
<p>这个方法比较简单，每执行一次countDown(), state = state - 1</p>
<p>最后返回state是否等于0 如果不等于0 说明共享锁不能释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>doReleaseShared() 释放共享锁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">              <span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                  	 <span class="comment">// 释放后继结点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>unparkSuccessor()执行线程唤醒的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/128476015902">https://www.jianshu.com/p/128476015902</a></p>
<p><a href="https://segmentfault.com/a/1190000015807573">https://segmentfault.com/a/1190000015807573</a></p>
<p><a href="http://localhost:4000/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCountDownLatch%E5%B7%A5%E5%85%B7/">http://localhost:4000/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCountDownLatch%E5%B7%A5%E5%85%B7/</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之搞懂线程池</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E6%B1%A0-1/</url>
    <content><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h2 id="1-为什么存在线程池"><a href="#1-为什么存在线程池" class="headerlink" title="1. 为什么存在线程池"></a>1. 为什么存在线程池</h2><h3 id="1-1-降低资源消耗"><a href="#1-1-降低资源消耗" class="headerlink" title="1.1 降低资源消耗"></a>1.1 <strong>降低资源消耗</strong></h3><p>通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；（享元模式）</p>
<h3 id="1-2-提升系统响应速度"><a href="#1-2-提升系统响应速度" class="headerlink" title="1.2 提升系统响应速度"></a>1.2 <strong>提升系统响应速度</strong></h3><p>通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；</p>
<h3 id="1-3-提高线程的可管理性"><a href="#1-3-提高线程的可管理性" class="headerlink" title="1.3 提高线程的可管理性"></a>1.3 <strong>提高线程的可管理性</strong></h3><p>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</p>
<p>至于为什么不允许手动创建线程池，请参见<a href="https://dayarch.top/p/why-we-need-to-use-threadpool.html">https://dayarch.top/p/why-we-need-to-use-threadpool.html</a></p>
<h2 id="2-线程池的工作流程"><a href="#2-线程池的工作流程" class="headerlink" title="2. 线程池的工作流程"></a>2. 线程池的工作流程</h2><p>线程池顾名思义，就是由很多线程构成的池子，来一个任务，就从池子中取一个线程，处理这个任务。这是一个简单的理解，实际上线程池的实现和运转是一个非常复杂的过程。</p>
<p>例如线程池肯定不会无限扩大的，否则资源会耗尽；当线程数到达一个阶段，提交的任务会被暂时存储在一个队列中，如果队列内容可以不断扩大，极端下也会耗尽资源，那选择什么类型的队列，当队列满如何处理任务，都有涉及很多内容。线程池总体的工作过程如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210804144852252.png" alt="image-20210804144852252" style="zoom: 50%;" />


<p>线程池内的线程数的大小相关的概念有两个，一个是核心池大小，还有最大池大小。如果当前的线程个数比核心池个数小，当任务到来，会优先创建一个新的线程并执行任务。当已经到达核心池大小，则把任务放入队列，为了资源不被耗尽，队列的最大容量可能也是有上限的，如果达到队列上限则考虑继续创建新线程执行任务，如果此刻线程的个数已经到达最大池上限，则考虑把任务丢弃。</p>
<p>在 java.util.concurrent 包中，提供了 ThreadPoolExecutor 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="3-线程池参数"><a href="#3-线程池参数" class="headerlink" title="3. 线程池参数"></a>3. 线程池参数</h2><p>既然有了刚刚对线程池工作原理对概述，这些参数就很容易理解了：</p>
<h3 id="3-1-corePoolSize"><a href="#3-1-corePoolSize" class="headerlink" title="3.1 corePoolSize"></a>3.1 corePoolSize</h3><p> 核心池大小，既然如前原理部分所述。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用prestartAllCoreThreads方法。</p>
<h3 id="3-2-maximumPoolSize"><a href="#3-2-maximumPoolSize" class="headerlink" title="3.2 maximumPoolSize"></a>3.2 maximumPoolSize</h3><p>池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</p>
<h3 id="3-3-keepAliveTime"><a href="#3-3-keepAliveTime" class="headerlink" title="3.3 keepAliveTime"></a>3.3 keepAliveTime</h3><p>当线程数大于核心时，多于的空闲线程最多存活时间</p>
<h3 id="3-4-unit"><a href="#3-4-unit" class="headerlink" title="3.4 unit"></a>3.4 unit</h3><p>keepAliveTime 参数的时间单位。</p>
<h3 id="3-5-workQueue"><a href="#3-5-workQueue" class="headerlink" title="3.5 workQueue"></a>3.5 workQueue</h3><p>当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现Runnable接口的任务。 别看这个参数位置很靠后，但是真的很重要，因为楼主的坑就因这个参数而起，这些细节有必要仔细了解清楚。</p>
<h3 id="3-6-threadFactory"><a href="#3-6-threadFactory" class="headerlink" title="3.6 threadFactory"></a>3.6 threadFactory</h3><p>执行程序创建新线程时使用的工厂。</p>
<h3 id="3-7-handler"><a href="#3-7-handler" class="headerlink" title="3.7 handler"></a>3.7 handler</h3><p>阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。</p>
<h2 id="4-可选择的阻塞队列BlockingQueue详解"><a href="#4-可选择的阻塞队列BlockingQueue详解" class="headerlink" title="4. 可选择的阻塞队列BlockingQueue详解"></a>4. 可选择的阻塞队列BlockingQueue详解</h2><p>再重复一下新任务进入时线程池的执行策略：<br>1、如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）</p>
<p>2、如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。<br>主要有3种类型的BlockingQueue：</p>
<h3 id="4-1-无界队列"><a href="#4-1-无界队列" class="headerlink" title="4.1 无界队列"></a>4.1 无界队列</h3><p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p>
<h3 id="4-2-有界队列"><a href="#4-2-有界队列" class="headerlink" title="4.2 有界队列"></a>4.2 有界队列</h3><p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p>
<h3 id="4-3-同步移交队列"><a href="#4-3-同步移交队列" class="headerlink" title="4.3 同步移交队列"></a>4.3 同步移交队列</h3><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h2 id="5-可选择的饱和策略RejectedExecutionHandler详解"><a href="#5-可选择的饱和策略RejectedExecutionHandler详解" class="headerlink" title="5. 可选择的饱和策略RejectedExecutionHandler详解"></a>5. 可选择的饱和策略RejectedExecutionHandler详解</h2><p>JDK主要提供了4种饱和策略供选择。4种策略都做为静态内部类在ThreadPoolExcutor中进行实现。</p>
<h3 id="5-1-AbortPolicy中止策略"><a href="#5-1-AbortPolicy中止策略" class="headerlink" title="5.1 AbortPolicy中止策略"></a>5.1 AbortPolicy中止策略</h3><p>该策略是默认饱和策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p>
<h3 id="5-2-DiscardPolicy抛弃策略"><a href="#5-2-DiscardPolicy抛弃策略" class="headerlink" title="5.2 DiscardPolicy抛弃策略"></a>5.2 DiscardPolicy抛弃策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，什么都不做。</p>
<h3 id="5-3-DiscardOldestPolicy抛弃旧任务策略"><a href="#5-3-DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="5.3 DiscardOldestPolicy抛弃旧任务策略"></a>5.3 DiscardOldestPolicy抛弃旧任务策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h3 id="5-4-CallerRunsPolicy调用者运行"><a href="#5-4-CallerRunsPolicy调用者运行" class="headerlink" title="5.4 CallerRunsPolicy调用者运行"></a>5.4 CallerRunsPolicy调用者运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>
<h2 id="6-Java提供的四种常用线程池解析"><a href="#6-Java提供的四种常用线程池解析" class="headerlink" title="6. Java提供的四种常用线程池解析"></a>6. Java提供的四种常用线程池解析</h2><p>既然楼主踩坑就是使用了 JDK 的默认实现，那么再来看看这些默认实现到底干了什么，封装了哪些参数。简而言之 Executors 工厂方法Executors.newCachedThreadPool() 提供了无界线程池，可以进行自动线程回收；Executors.newFixedThreadPool(int) 提供了固定大小线程池，内部使用无界队列；Executors.newSingleThreadExecutor() 提供了单个后台线程。</p>
<p>详细介绍一下上述四种线程池。</p>
<h3 id="6-1-newCachedThreadPool"><a href="#6-1-newCachedThreadPool" class="headerlink" title="6.1 newCachedThreadPool"></a>6.1 newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在newCachedThreadPool中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为0，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 SynchronousQueue中进行等待，而SynchronousQueue的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲SynchronousQueue时其实已经给出了，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。因此即便SynchronousQueue一开始为空且大小为1，第一个任务也无法放入其中，因为没有线程在等待从SynchronousQueue中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。</p>
<h3 id="6-2-newFixedThreadPool"><a href="#6-2-newFixedThreadPool" class="headerlink" title="6.2 newFixedThreadPool"></a>6.2 newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码一目了然了，线程数量固定，使用无限大的队列。</p>
<h3 id="6-3-newScheduledThreadPool"><a href="#6-3-newScheduledThreadPool" class="headerlink" title="6.3 newScheduledThreadPool"></a>6.3 newScheduledThreadPool</h3><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在来看看ScheduledThreadPoolExecutor（）的构造函数</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor的父类即ThreadPoolExecutor，因此这里各参数含义和上面一样。值得关心的是DelayedWorkQueue这个阻塞对列，在上面没有介绍，它作为静态内部类就在ScheduledThreadPoolExecutor中进行了实现。简单的说，DelayedWorkQueue是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。</p>
<h3 id="6-4-newSingleThreadExecutor"><a href="#6-4-newSingleThreadExecutor" class="headerlink" title="6.4 newSingleThreadExecutor"></a>6.4 newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>首先new了一个线程数目为 1 的ScheduledThreadPoolExecutor，再把该对象传入DelegatedScheduledExecutorService中，看看DelegatedScheduledExecutorService的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor);</span><br><span class="line">            e = executor;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在看看它的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; </span><br><span class="line">           e = executor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是使用装饰模式增强了ScheduledExecutorService（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。</p>
<h2 id="7-为什么禁止使用-Executors-创建线程池"><a href="#7-为什么禁止使用-Executors-创建线程池" class="headerlink" title="7. 为什么禁止使用 Executors 创建线程池?"></a>7. 为什么禁止使用 Executors 创建线程池?</h2><img src='https://oscimg.oschina.net/oscnet/up-9d0200e116259f64c5485a1bbf0d4265c31.png'>

<h3 id="7-1-实验证明Executors缺陷"><a href="#7-1-实验证明Executors缺陷" class="headerlink" title="7.1 实验证明Executors缺陷"></a>7.1 实验证明Executors缺陷</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">               executor.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       <span class="comment">//do nothing &#125;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过指定JVM参数:-Xmx8m -Xms8m运行以上代码，会抛出OOM:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue. java:<span class="number">416</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor. java:<span class="number">1371</span>)</span><br><span class="line">at com.hollis.ExecutorsDemo.main(ExecutorsDemo.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码指出，ExecutorsDemo.java 的第 16 行，就是代码中的 execu- tor.execute(new SubThread());。</p>
<h3 id="7-2-Executors-为什么存在缺陷"><a href="#7-2-Executors-为什么存在缺陷" class="headerlink" title="7.2 Executors 为什么存在缺陷"></a>7.2 Executors 为什么存在缺陷</h3><p>通过上面的例子，我们知道了 Executors 创建的线程池存在 OOM 的风险，那 么到底是什么原因导致的呢?我们需要深入 Executors 的源码来分析一下。</p>
<p>其实，在上面的报错信息中，我们是可以看出蛛丝马迹的，在以上的代码中其实 已经说了，真正的导致 OOM 的其实是 LinkedBlockingQueue.offer 方法。</p>
<p>如果读者翻看代码的话，也可以发现，其实底层确实是通过 LinkedBlock- ingQueue 实现的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>如果读者对 Java 中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。</p>
<p>Java 中 的 BlockingQueue 主 要 有 两 种 实 现， 分 别 是 ArrayBlockingQ- ueue 和 LinkedBlockingQueue。</p>
<ul>
<li>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，必须设置容量。</li>
<li>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列，容量可以选择 进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为 Integer.MAX_ VALUE。  </li>
</ul>
<p>这里的问题就出在:不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置 LinkedBlockingQueue 的 容量的话，其默认容量将会是 Integer.MAX_VALUE。</p>
<p>而 newFixedThreadPool 中创建 LinkedBlockingQueue 时，并未指定容 量。此时，LinkedBlockingQueue 就是一个无边界队列，对于一个无边界队列 来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导 致内存溢出问题。</p>
<p>上面提到的问题主要体现在newFixedThreadPool 和 newSingleThreadExecutor 两个工厂方法上，并不是说 newCachedThreadPool 和 newScheduledThreadPool 这两个方法就安全了，这两种方式创建的最大线程数可能是 Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致 OOM。</p>
<h3 id="7-3-创建线程池的正确姿势"><a href="#7-3-创建线程池的正确姿势" class="headerlink" title="7.3 创建线程池的正确姿势"></a>7.3 创建线程池的正确姿势</h3><p>避免使用 Executors 创建线程池，主要是避免使用其中的默认实现，那么我们 可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的 同时，给 BlockQueue 指定容量就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util. concurrent.RejectedExecutionException，这是因为当前线程池使用的队列 是有边界队列，队列已经满了便无法继续处理新的请求。但是异常(Exception)总比 发生错误(Error)要好。</p>
<p>除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间 就应该想到开源类库，如 apache 和 guava 等。</p>
<p>作者推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">            ThreadPoolExecutor. AbortPolicy());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123; pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名 称，更加方便的出错的时候溯源。</p>
<h2 id="8、ThreadPoolExecutor源码解析"><a href="#8、ThreadPoolExecutor源码解析" class="headerlink" title="8、ThreadPoolExecutor源码解析"></a>8、ThreadPoolExecutor源码解析</h2><h3 id="8-1-ThreadPoolExecutor类重要属性"><a href="#8-1-ThreadPoolExecutor类重要属性" class="headerlink" title="8.1 ThreadPoolExecutor类重要属性"></a>8.1 ThreadPoolExecutor类重要属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个属性是用来存放 当前运行的worker数量以及线程池状态的</span></span><br><span class="line"><span class="comment">//int是32位的，这里把int的高3位拿来记录线程池状态的标志位,后29位拿来记录当前运行worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//worker的集合,用set来存放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//超出coreSize的worker的生存时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//常驻worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-ThreadPoolExecutor定义的内部状态"><a href="#8-2-ThreadPoolExecutor定义的内部状态" class="headerlink" title="8.2 ThreadPoolExecutor定义的内部状态"></a>8.2 ThreadPoolExecutor定义的内部状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中AtomicInteger变量ctl的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:</p>
<ul>
<li>RUNNING: -1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li>
<li>SHUTDOWN:  0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>STOP :  1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>TIDYING :  2 &lt;&lt; COUNT_BITS，即高3位为010, 所有的任务都已经终止；</li>
<li>TERMINATED:  3 &lt;&lt; COUNT_BITS，即高3位为011, terminated()方法已经执行完成</li>
</ul>
<h3 id="8-3-execute源码解析"><a href="#8-3-execute源码解析" class="headerlink" title="8.3 execute源码解析"></a>8.3 execute源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    		<span class="comment">// 添加任务队列并创建核心线程，然后在执行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 线程池是运行状态并且任务成功添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">				<span class="comment">// recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)</span></span><br><span class="line">        <span class="comment">//如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        		<span class="comment">// 使用普通线程运行任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	   <span class="comment">// 往线程池中创建新的线程失败，则reject任务</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考🤔</strong>      <strong>为什么需要double check线程池的状态?</strong></p>
<p>在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。</p>
<p><strong>addWorker方法</strong></p>
<p>先看看addWorker方法的注释，方便我们理解源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Checks <span class="keyword">if</span> a <span class="keyword">new</span> worker can be added with respect to current</span><br><span class="line">     * <span class="function">pool state and the given <span class="title">bound</span> <span class="params">(either core or maximum)</span>. If so,</span></span><br><span class="line"><span class="function">     * the worker count is adjusted accordingly, and, <span class="keyword">if</span> possible, a</span></span><br><span class="line"><span class="function">     * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="function">     * first task. This method returns <span class="keyword">false</span> <span class="keyword">if</span> the pool is stopped or</span></span><br><span class="line"><span class="function">     * eligible to shut down. It also returns <span class="keyword">false</span> <span class="keyword">if</span> the thread</span></span><br><span class="line"><span class="function">     * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="function">     * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="function">     * <span class="keyword">null</span>, or due to an <span class="title">exception</span> <span class="params">(typically OutOfMemoryError in</span></span></span><br><span class="line"><span class="params"><span class="function">     * Thread.start()</span>), we roll back cleanly.</span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">     <span class="comment">// 大概翻译如下：</span></span></span><br><span class="line"><span class="function">     <span class="comment">//1、首先先检查线程池的状态和线程数量是否超过界限</span></span></span><br><span class="line"><span class="function">		 <span class="comment">//2、如果可以创建的话，需要更新任务的数量，然后运行任务</span></span></span><br><span class="line"><span class="function">		 <span class="comment">//3、有两种情况这个方法会返回false，线程池stop状态或者shut down状态 </span></span></span><br><span class="line"><span class="function">		 <span class="comment">//还有一种情况是共创创建线程失败</span></span></span><br><span class="line"><span class="function">     4、不管是发生什么异常，例如线程工厂返回<span class="keyword">null</span>或者是发生了OOM,直接回滚</span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">     * @param firstTask the task the new thread should run <span class="title">first</span> <span class="params">(or</span></span></span><br><span class="line"><span class="params"><span class="function">     * <span class="keyword">null</span> <span class="keyword">if</span> none)</span>. Workers are created with an initial first task</span></span><br><span class="line"><span class="function">     * <span class="params">(in method execute()</span>) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="function">     * than corePoolSize <span class="title">threads</span> <span class="params">(in which <span class="keyword">case</span> we always start one)</span>,</span></span><br><span class="line"><span class="function">     * or when the queue is <span class="title">full</span> <span class="params">(in which <span class="keyword">case</span> we must bypass queue)</span>.</span></span><br><span class="line"><span class="function">     * Initially idle threads are usually created via</span></span><br><span class="line"><span class="function">     * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     * @param core <span class="keyword">if</span> <span class="keyword">true</span> use corePoolSize as bound, <span class="keyword">else</span></span></span><br><span class="line"><span class="function">     * maximumPoolSize. <span class="params">(A <span class="keyword">boolean</span> indicator is used here rather than a</span></span></span><br><span class="line"><span class="params"><span class="function">     * value to ensure reads of fresh values after checking other pool</span></span></span><br><span class="line"><span class="params"><span class="function">     * state)</span>.</span></span><br><span class="line"><span class="function">     * @return <span class="keyword">true</span> <span class="keyword">if</span> successful</span></span><br></pre></td></tr></table></figure>

<p><strong>下面是源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          	<span class="comment">// cas修改c的值</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  	<span class="comment">// largestPoolSize记录的最大workers长度</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">               <span class="comment">// 线程启动，执行任务(Worker.thread(firstTask).start());</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程start之后会执行如下run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面是runWorker方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</strong></p>
<p><strong>getTask()方法源码如下</strong></p>
<p>下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出先吃池是怎么让超过corePoolSize的那部分worker销毁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。</p>
<p>如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务:</p>
<p>如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</p>
<p>如果线程不允许无休止空闲timed == true, workQueue.poll任务: </p>
<p>如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ConcurrentHashMap实现原理</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>Map应该是我们平时开发过程中除了List使用的第二频繁的数据结构了吧，我们都知道HashMap无法在多线程环境下保证安全，那我们可以使用什么来代替HashMap呢，有两个选择，HashTable和ConcurrentHashMap,由于HashTable的性能相对比较低，我们一般都使用ConcurrentHashMap来代替HashMap。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="HashTable-amp-HashMap"><a href="#HashTable-amp-HashMap" class="headerlink" title="HashTable&amp;HashMap"></a>HashTable&amp;HashMap</h3><p><code>HashTable</code>的<code>put</code>, <code>get</code>,<code>remove</code>等方法是通过<code>synchronized</code>来修饰保证其线程安全性的。</p>
<p><code>HashTable</code>是 不允许key跟value为null的。</p>
<p>问题是<code>synchronized</code>是个关键字级别的==重量锁==，在get数据的时候任何写入操作都不允许。相对来说性能不好。</p>
<h3 id="ConcurrentHashMap概述"><a href="#ConcurrentHashMap概述" class="headerlink" title="ConcurrentHashMap概述"></a>ConcurrentHashMap概述</h3><p>在ConcurrentHashMap中通过一个Node&lt;K,V&gt;[]数组来保存添加到map中的键值对，而在同一个数组位置是通过链表和红黑树的形式来保存的。但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容，后面会详细解释。</p>
<p>第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取与来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个以上，如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64了的话，在会将该节点的链表转换成树。</p>
<p>通过扩容数组的方式来把这些节点给分散开。然后将这些元素复制到扩容后的新的数组中，同一个链表中的元素通过hash值的数组长度位来区分，是还是放在原来的位置还是放到扩容的长度的相同位置去 。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p>
<p>取元素的时候，相对来说比较简单，通过计算hash来确定该元素在数组的哪个位置，然后在通过遍历链表或树来判断key和key的hash，取出value值。</p>
<h2 id="ConcurrentHashMap-原理解析"><a href="#ConcurrentHashMap-原理解析" class="headerlink" title="ConcurrentHashMap 原理解析"></a>ConcurrentHashMap 原理解析</h2><h3 id="ConcurrentHashMap属性"><a href="#ConcurrentHashMap属性" class="headerlink" title="ConcurrentHashMap属性"></a>ConcurrentHashMap属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<h4 id="Node-lt-K-V-gt-这是构成每个元素的基本类。"><a href="#Node-lt-K-V-gt-这是构成每个元素的基本类。" class="headerlink" title="Node&lt;K,V&gt;,这是构成每个元素的基本类。"></a><strong>Node&lt;K,V&gt;,这是构成每个元素的基本类。</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//key的hash值</span></span><br><span class="line">  <span class="keyword">final</span> K key;       <span class="comment">//key</span></span><br><span class="line">  <span class="keyword">volatile</span> V val;    <span class="comment">//value</span></span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next; <span class="comment">//表示链表中的下一个节点</span></span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeNode，构造树的节点"><a href="#TreeNode，构造树的节点" class="headerlink" title="TreeNode，构造树的节点"></a><strong>TreeNode，构造树的节点</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">  TreeNode&lt;K,V&gt; left;</span><br><span class="line">  TreeNode&lt;K,V&gt; right;</span><br><span class="line">  TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">  <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">  TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">           TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeBin-用作树的头结点"><a href="#TreeBin-用作树的头结点" class="headerlink" title="TreeBin 用作树的头结点"></a><strong>TreeBin 用作树的头结点</strong></h4><p><strong>只存储root和first节点，不存储节点的key、value值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; root;</span><br><span class="line">  <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">  <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">  <span class="comment">// values for lockState</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><strong>ForwardingNode</strong></h4><p><strong>在转移的时候放在头部的节点，是一个空节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">    <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap几个重要方法"><a href="#ConcurrentHashMap几个重要方法" class="headerlink" title="ConcurrentHashMap几个重要方法"></a><strong>ConcurrentHashMap几个重要方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">  U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a><strong>ConcurrentHashMap的初始化</strong></h3><p>先看一下ConcurrentHashMap的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">             MAXIMUM_CAPACITY :</span><br><span class="line">             tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">  putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在任何一个构造方法中，都没有对存储Map元素Node的table变量进行初始化。而是在第一次put操作的时候在进行初始化。</p>
<p>下面来看看数组的初始化方法initTable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数组table，</span></span><br><span class="line"><span class="comment">     * 如果sizeCtl小于0，说明别的数组正在进行初始化，则让出执行权</span></span><br><span class="line"><span class="comment">     * 如果sizeCtl大于0的话，则初始化一个大小为sizeCtl的数组</span></span><br><span class="line"><span class="comment">     * 否则的话初始化一个默认大小(16)的数组</span></span><br><span class="line"><span class="comment">     * 然后设置sizeCtl的值为数组长度的3/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;    <span class="comment">//第一次put的时候，table还没被初始化，进入while</span></span><br><span class="line">    <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)                            <span class="comment">//sizeCtl初始值为0，当小于0的时候表示在别的线程在初始化表或扩展表</span></span><br><span class="line">      Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;    <span class="comment">//SIZECTL：表示当前对象的内存偏移量，sc表示期望值，-1表示要替换的值，设定为-1表示要初始化表了</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;        <span class="comment">//指定了大小的时候就创建指定大小的Node数组，否则创建指定大小(16)的Node数组</span></span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">          table = tab = nt;</span><br><span class="line">          sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sizeCtl = sc;            <span class="comment">//初始化后，sizeCtl长度为数组长度的3/4</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的put操作详解"><a href="#ConcurrentHashMap的put操作详解" class="headerlink" title="ConcurrentHashMap的put操作详解"></a>ConcurrentHashMap的put操作详解</h3><p>👇下面是put方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  单纯的额调用putVal方法，并且putVal的第三个参数设置为false</span></span><br><span class="line"><span class="comment">     *  当设置为false的时候表示这个value一定会设置</span></span><br><span class="line"><span class="comment">     *  true的时候，只有当这个key的value为空的时候才会设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面看一下putVal方法实现：</strong></p>
<p>当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，如果没有的话就初始化数组, 然后通过计算hash值来确定放在数组的哪个位置。</p>
<p>如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来，取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制。</p>
<p>如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作。</p>
<p>然后判断当前取出的节点位置存放的是链表还是树，如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾。如果是树的话，则调用putTreeVal方法把这个元素添加到树中去。</p>
<p>最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span> <span class="params">(K key, V value,<span class="keyword">boolean</span> onlyIfAbsent)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">//取得key的hash值</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">  <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">  <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">    Node&lt;K, V&gt; f;</span><br><span class="line">    <span class="keyword">int</span> n, i, fh;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//第一次put的时候table没有初始化，则初始化table</span></span><br><span class="line">      tab = initTable();</span><br><span class="line">    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的</span></span><br><span class="line">      <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                   <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                   <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">                 * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      tab = helpTransfer(tab, f);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                     *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                     *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                     *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                     *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                     *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">      V oldVal = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span></span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//遍历这个链表</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">              K ek;</span><br><span class="line">              <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key ||</span><br><span class="line">                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                oldVal = e.val;</span><br><span class="line">                <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  e.val = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Node&lt;K, V&gt; pred = e;</span><br><span class="line">              <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                           value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K, V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,</span><br><span class="line">                                                    value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              oldVal = p.val;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">          treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的扩容详解"><a href="#ConcurrentHashMap的扩容详解" class="headerlink" title="ConcurrentHashMap的扩容详解"></a><strong>ConcurrentHashMap的扩容详解</strong></h3><p>在put方法的详解中，我们可以看到，在同一个节点的个数超过8个的时候，会调用treeifyBin方法来看看是扩容还是转化为一棵树，同时在每次添加完元素的addCount方法中，也会判断当前数组中的元素是否达到了sizeCtl的量，如果达到了的话，则会进入transfer方法去扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment">     * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;treeifyBin方\t==&gt;数组长：&quot;</span>+tab.length);</span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p =</span><br><span class="line">              <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">              hd = p;    <span class="comment">//设置head</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">          &#125;</span><br><span class="line">          setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当需要扩容的时候，调用的时候tryPresize方法，看看trePresize的源码</p>
<h3 id="trePresize的源码"><a href="#trePresize的源码" class="headerlink" title="trePresize的源码"></a>trePresize的源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容表为指可以容纳指定个数的大小（总是2的N次方）</span></span><br><span class="line"><span class="comment">     * 假设原来的数组长度为16，则在调用tryPresize的时候，size参数的值为16&lt;&lt;1(32)，此时sizeCtl的值为12</span></span><br><span class="line"><span class="comment">     * 计算出来c的值为64,则要扩容到sizeCtl≥为止</span></span><br><span class="line"><span class="comment">     *  第一次扩容之后 数组长：32 sizeCtl：24</span></span><br><span class="line"><span class="comment">     *  第二次扩容之后 数组长：64 sizeCtl：48</span></span><br><span class="line"><span class="comment">     *  第二次扩容之后 数组长：128 sizeCtl：94 --&gt; 这个时候才会退出扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * MAXIMUM_CAPACITY = 1 &lt;&lt; 30</span></span><br><span class="line"><span class="comment">             * 如果给定的大小大于等于数组容量的一半，则直接使用最大容量，</span></span><br><span class="line"><span class="comment">             * 否则使用tableSizeFor算出来</span></span><br><span class="line"><span class="comment">             * 后面table一直要扩容到这个值小于等于sizeCtrl(数组长度的3/4)才退出扩容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">  <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">  tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//            printTable(tab);    调试用的</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果数组table还没有被初始化，则初始化一个大小为sizeCtrl和刚刚算出来的c中较大的一个大小的数组</span></span><br><span class="line"><span class="comment">             * 初始化的时候，设置sizeCtrl为-1，初始化完成之后把sizeCtrl设置为数组长度的3/4</span></span><br><span class="line"><span class="comment">             * 为什么要在扩张的地方来初始化数组呢？这是因为如果第一次put的时候不是put单个元素，</span></span><br><span class="line"><span class="comment">             * 而是调用putAll方法直接put一个map的话，在putALl方法中没有调用initTable方法去初始化table，</span></span><br><span class="line"><span class="comment">             * 而是直接调用了tryPresize方法，所以这里需要做一个是不是需要初始化table的判断</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">      n = (sc &gt; c) ? sc : c;</span><br><span class="line">      <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;    <span class="comment">//初始化tab的时候，把sizeCtl设为-1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">            table = nt;</span><br><span class="line">            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          sizeCtl = sc;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 一直扩容到的c小于等于sizeCtl或者数组长度大于最大长度的时候，则退出</span></span><br><span class="line"><span class="comment">             * 所以在一次扩容之后，不是原来长度的两倍，而是2的n次方倍</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      <span class="keyword">break</span>;    <span class="comment">//退出扩张</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">      <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果正在扩容Table的话，则帮助扩容</span></span><br><span class="line"><span class="comment">                 * 否则的话，开始新的扩容</span></span><br><span class="line"><span class="comment">                 * 在transfer操作，将第一个参数的table中的元素，移动到第二个元素的table中去，</span></span><br><span class="line"><span class="comment">                 * 虽然此时第二个参数设置的是null，但是，在transfer方法中，当第二个参数为null的时候，</span></span><br><span class="line"><span class="comment">                 * 会创建一个两倍大小的table</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">      <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nt;</span><br><span class="line">        <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">            sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">            transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * transfer的线程数加一,该线程将进行transfer的帮忙</span></span><br><span class="line"><span class="comment">                     * 在transfer的时候，sc表示在transfer工作的线程数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">          transfer(tab, nt);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 没有在初始化或扩容，则开始扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>)) &#123;</span><br><span class="line">        transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryPresize方法中，并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容。</p>
<h3 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h3><p>数组扩容的主要方法就是transfer方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">  <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">    stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">      nextTab = nt;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">      sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextTable = nextTab;</span><br><span class="line">    transferIndex = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">  <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">  <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">    <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">      <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">        advance = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        i = -<span class="number">1</span>;</span><br><span class="line">        advance = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">               (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                             nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">        bound = nextBound;</span><br><span class="line">        i = nextIndex - <span class="number">1</span>;</span><br><span class="line">        advance = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">      <span class="keyword">int</span> sc;</span><br><span class="line">      <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">        nextTable = <span class="keyword">null</span>;</span><br><span class="line">        table = nextTab;</span><br><span class="line">        sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">        i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">      advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          Node&lt;K,V&gt; ln, hn;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">              <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">              <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                runBit = b;</span><br><span class="line">                lastRun = p;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">              ln = lastRun;</span><br><span class="line">              hn = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              hn = lastRun;</span><br><span class="line">              ln = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">              <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">              <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">            &#125;</span><br><span class="line">            setTabAt(nextTab, i, ln);    </span><br><span class="line">            setTabAt(nextTab, i + n, hn);</span><br><span class="line">            setTabAt(tab, i, fwd);</span><br><span class="line">            advance = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">              <span class="keyword">int</span> h = e.hash;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                  lo = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  loTail.next = p;</span><br><span class="line">                loTail = p;</span><br><span class="line">                ++lc;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                  hi = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  hiTail.next = p;</span><br><span class="line">                hiTail = p;</span><br><span class="line">                ++hc;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">            setTabAt(nextTab, i, ln);</span><br><span class="line">            setTabAt(nextTab, i + n, hn);</span><br><span class="line">            setTabAt(tab, i, fwd);</span><br><span class="line">            advance = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，ConcurrentHashMap的put操作和扩容都介绍的差不多了，</p>
<p>下面的两点一定要注意：</p>
<p>1、复制之后的新链表不是旧链表的绝对倒序</p>
<p>2、在扩容的时候每个线程都有处理的步长，最少为16，在这个步长范围内的数组节点只有自己一个线程来处理</p>
<h3 id="ConcurrentHashMap的get操作详解"><a href="#ConcurrentHashMap的get操作详解" class="headerlink" title="ConcurrentHashMap的get操作详解"></a><strong>ConcurrentHashMap的get操作详解</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">  <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">          ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表转为红黑树的过程"><a href="#链表转为红黑树的过程" class="headerlink" title="链表转为红黑树的过程"></a><strong>链表转为红黑树的过程</strong></h3><p>前面在讲解tryifyBin的源码的时候讲到过，如果在当个bin上的元素超过了8个的时候，就会尝试去扩容数组或者是将链表转为红黑树。</p>
<p>源码：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p =</span><br><span class="line">              <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        </span><br><span class="line">              hd = p;    <span class="comment">//设置head</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//把TreeNode的链表放入容器TreeBin</span></span><br><span class="line">          setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));中</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将Node的链表转化为一个TreeNode的链表，然后将TreeNode链表的头结点来构造一个TreeBin。下面是TreeBin构造方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">  <span class="comment">//创建的TreeBin是一个空节点，hash值为TREEBIN（-2）</span></span><br><span class="line">  <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);    </span><br><span class="line">  <span class="keyword">this</span>.first = b;</span><br><span class="line">  TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="keyword">null</span>;</span><br><span class="line">      x.red = <span class="keyword">false</span>;</span><br><span class="line">      r = x;</span><br><span class="line">    &#125;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      K k = x.key;</span><br><span class="line">      <span class="keyword">int</span> h = x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//x代表的是转换为树之前的顺序遍历到链表的位置的节点，r代表的是根节点</span></span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk = p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)    <span class="comment">//</span></span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//当key不可以比较，或者相等的时候采取的一种排序措施</span></span><br><span class="line">          dir = tieBreakOrder(k, pk);   </span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">//在这里判断要放的left/right是否为空，不为空继续用left/right节点来判断</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          <span class="comment">//每次插入一个元素的时候都调用balanceInsertion来保持红黑树的平衡</span></span><br><span class="line">          r = balanceInsertion(r, x); </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.root = r;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap的同步机制"><a href="#ConcurrentHashMap的同步机制" class="headerlink" title="ConcurrentHashMap的同步机制"></a>ConcurrentHashMap的同步机制</h2><p>前面分析了下ConcurrentHashMap的源码，那么，对于一个映射集合来说，ConcurrentHashMap是如果来做到并发安全，又是如何做到高效的并发的呢？</p>
<p>首先是读操作，从源码中可以看出来，在get操作中，根本没有使用同步机制，也没有使用unsafe方法，所以读操作是支持并发操作的。那么写操作呢？</p>
<p>分析这个之前，先看看什么情况下会引起数组的扩容，扩容是通过transfer方法来进行的。而调用transfer方法的只有<code>trePresize</code>、<code>helpTransfer</code>和<code>addCount</code>三个方法。</p>
<p>这三个方法又是分别在什么情况下进行调用的呢？</p>
<p>tryPresize是在treeIfybin和putAll方法中调用，treeIfybin主要是在put添加元素完之后，判断该数组节点相关元素是不是已经超过8个的时候，如果超过则会调用这个方法来扩容数组或者把链表转为树。</p>
<p>helpTransfer是在当一个线程要对table中元素进行操作的时候，如果检测到节点的HASH值为MOVED的时候，就会调用helpTransfer方法，在helpTransfer中再调用transfer方法来帮助完成数组的扩容</p>
<p>addCount是在当对数组进行操作，使得数组中存储的元素个数发生了变化的时候会调用的方法。</p>
<p><strong>所以引起数组扩容的情况如下</strong>：</p>
<p>1、只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，同时数组的长度又小于64的时候，才会触发数组的扩容。</p>
<p>2、当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容</p>
<p><strong>那么在扩容的时候，可以不可以对数组进行读写操作呢？</strong></p>
<p>事实上是可以的。当在进行数组扩容的时候，如果当前节点还没有被处理（也就是说还没有设置为fwd节点），那就可以进行设置操作。如果该节点已经被处理了，则当前线程也会加入到扩容的操作中去。</p>
<p><strong>那么，多个线程又是如何同步处理的呢？</strong></p>
<p>在ConcurrentHashMap中，同步处理主要是通过Synchronized和unsafe两种方式来完成的。</p>
<p>1、在取得sizeCtl、某个位置的Node的时候，使用的都是unsafe的方法，来达到并发安全的目的</p>
<p>2、当需要在某个位置设置节点的时候，则会通过Synchronized的同步机制来锁定该位置的节点。</p>
<p>3、在数组扩容的时候，则通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED</p>
<p>4、当把某个位置的节点复制到扩张后的table的时候，也通过Synchronized的同步机制来保证线程安全</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/search?query=concurrenthashmap&amp;utm_source=gold_browser_extension&amp;utm_medium=search">https://juejin.cn/search?query=concurrenthashmap&amp;utm_source=gold_browser_extension&amp;utm_medium=search</a></p>
<p><a href="https://juejin.cn/post/6844904136937308168">https://juejin.cn/post/6844904136937308168</a></p>
<p><a href="https://www.cnblogs.com/zerotomax/p/8687425.html#go0">https://www.cnblogs.com/zerotomax/p/8687425.html#go0</a></p>
<p><a href="https://processon.com/view/6049998ae401fd39d6fffbaa?fromnew=1">https://processon.com/view/6049998ae401fd39d6fffbaa?fromnew=1</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
