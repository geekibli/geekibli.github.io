<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Http状态码及含义</title>
    <url>/wiki/Http%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<blockquote>
<p>http状态码由3个十进制数字组成。第一个数字表示状态码的分类，后面的两位表示该分类下不同的状态。<br>分为5个大类。</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>1**    信息。服务器收到请求，请继续执行请求</li>
<li>2**    成功。请求被成功接收并处理</li>
<li>3**    重定向。需要进一步操作来完成请求</li>
<li>4**    客户端错误。无法完成请求，或请求包含语法错误</li>
<li>5**    服务器错误。服务器在处理请求的过程中发成错误</li>
</ul>
<h2 id="各个状态说明"><a href="#各个状态说明" class="headerlink" title="各个状态说明"></a>各个状态说明</h2><ul>
<li>100： 继续请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分。</li>
<li>101： 切换协议请求者已要求服务器切换协议，服务器已确认并准备切换。</li>
<li>200： 成功服务器已成功处理了请求。</li>
<li>201： 已创建请求成功并且服务器创建了新的资源。</li>
<li>202： 已接受服务器已接受请求，但尚未处理。</li>
<li>203： 非授权信息服务器已成功处理了请求，但返回的信息可能来自另一来源。</li>
<li>204： 无内容服务器成功处理了请求，但没有返回任何内容。</li>
<li>205： 重置内容服务器成功处理了请求，内容被重置。</li>
<li>206： 部分内容服务器成功处理了部分请求。</li>
<li>300： 多种选择针对请求，服务器可执行多种操作。</li>
<li>301： 永久移动请求的网页已永久移动到新位置，即永久重定向。</li>
<li>302： 临时移动请求的网页暂时跳转到其他页面，即暂时重定向。</li>
<li>303： 查看其他位置如果原来的请求是 POST，重定向目标文档应该通过 GET 提取。</li>
<li>304： 未修改此次请求返回的网页未修改，继续使用上次的资源。</li>
<li>305： 使用代理请求者应该使用代理访问该网页。</li>
<li>307： 临时重定向请求的资源临时从其他位置响应。</li>
<li>400： 错误请求服务器无法解析该请求。</li>
<li>401： 未授权请求没有进行身份验证或验证未通过。</li>
<li>403： 禁止访问服务器拒绝此请求。</li>
<li>404： 未找到服务器找不到请求的网页。</li>
<li>405： 方法禁用服务器禁用了请求中指定的方法。</li>
<li>406： 不接受无法使用请求的内容响应请求的网页。</li>
<li>407： 需要代理授权请求者需要使用代理授权。</li>
<li>408： 请求超时服务器请求超时。</li>
<li>409： 冲突服务器在完成请求时发生冲突。</li>
<li>410： 已删除请求的资源已永久删除。</li>
<li>411： 需要有效长度服务器不接受不含有效内容长度标头字段的请求。</li>
<li>412： 未满足前提条件服务器未满足请求者在请求中设置的其中一个前提条件。</li>
<li>413： 请求实体过大请求实体过大，超出服务器的处理能力。</li>
<li>414： 请求 URI 过长请求网址过长，服务器无法处理。</li>
<li>415： 不支持类型请求的格式不受请求页面的支持。</li>
<li>416： 请求范围不符页面无法提供请求的范围。</li>
<li>417： 未满足期望值服务器未满足期望请求标头字段的要求。</li>
<li>500： 服务器内部错误服务器遇到错误，无法完成请求。</li>
<li>501： 未实现服务器不具备完成请求的功能。</li>
<li>502： 错误网关服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li>503： 服务不可用服务器目前无法使用。</li>
<li>504： 网关超时服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li>
<li>505： HTTP 版本不支持服务器不支持请求中所用的 HTTP 协议版本。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jmap</title>
    <url>/wiki/JVM-jmap/</url>
    <content><![CDATA[<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<h2 id="jmap-heap-pid"><a href="#jmap-heap-pid" class="headerlink" title="jmap -heap pid"></a>jmap -heap pid</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Attaching to process ID <span class="number">7183</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.242</span>-b08</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">4</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2051014656</span> (<span class="number">1956.</span>0MB)</span><br><span class="line">   NewSize                  = <span class="number">42991616</span> (<span class="number">41.</span>0MB)</span><br><span class="line">   MaxNewSize               = <span class="number">683671552</span> (<span class="number">652.</span>0MB)</span><br><span class="line">   OldSize                  = <span class="number">87031808</span> (<span class="number">83.</span>0MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">233308160</span> (<span class="number">222.</span>5MB)</span><br><span class="line">   used     = <span class="number">161611280</span> (<span class="number">154.</span>12452697753906MB)</span><br><span class="line">   free     = <span class="number">71696880</span> (<span class="number">68.</span>37547302246094MB)</span><br><span class="line">   <span class="number">69.26945032698384</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   used     = <span class="number">899896</span> (<span class="number">0.</span>8582077026367188MB)</span><br><span class="line">   free     = <span class="number">672968</span> (<span class="number">0.</span>6417922973632812MB)</span><br><span class="line">   <span class="number">57.213846842447914</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">1572864</span> (<span class="number">1.</span>5MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">223346688</span> (<span class="number">213.</span>0MB)</span><br><span class="line">   used     = <span class="number">115841432</span> (<span class="number">110.</span>4749984741211MB)</span><br><span class="line">   free     = <span class="number">107505256</span> (<span class="number">102.</span>5250015258789MB)</span><br><span class="line">   <span class="number">51.866196466723515</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">41772</span> interned Strings occupying <span class="number">4324472</span> bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/a4ad53179df3">jvm 性能调优工具之 jmap</a><br><a href="https://pandora.blog.csdn.net/article/details/108705081">JVM调试工具-jmap</a><br><a href="https://blog.csdn.net/lengyue309/article/details/80590119">通过jstack与jmap分析一次线上故障</a>                 
  </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-Xms,Xmx和Xss</title>
    <url>/wiki/JVM-Xms-Xmx%E5%92%8CXss/</url>
    <content><![CDATA[<h1 id="性能调优参数Xms，Xmx，Xss的含义"><a href="#性能调优参数Xms，Xmx，Xss的含义" class="headerlink" title="性能调优参数Xms，Xmx，Xss的含义"></a>性能调优参数Xms，Xmx，Xss的含义</h1><blockquote>
<p>-Xss</p>
</blockquote>
<p>规定了每个线程虚拟机栈及堆栈的大小，一般情况下，256k是足够的，此配置将会影响此进程中并发线程数的大小。</p>
<blockquote>
<p>-Xms</p>
</blockquote>
<p>表示初始化JAVA堆的大小及该进程刚创建出来的时候，他的专属JAVA堆的大小，一旦对象容量超过了JAVA堆的初始容量，JAVA堆将会自动扩容到-Xmx大小。</p>
<blockquote>
<p>-Xmx</p>
</blockquote>
<p>表示java堆可以扩展到的最大值，在很多情况下，通常将-Xms和-Xmx设置成一样的，因为当堆不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性。</p>
<blockquote>
<p>堆内存分配：</p>
</blockquote>
<p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/a1439775520/article/details/97787160">类似-Xms、-Xmn这些参数的含义：</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1671253445384660292&wfr=spider&for=pc">JVM三大性能调优参数Xms，Xmx，Xss的含义，你又知道多少呢</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jstack</title>
    <url>/wiki/JVM-jstack/</url>
    <content><![CDATA[<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><h2 id="jstack-功能"><a href="#jstack-功能" class="headerlink" title="jstack 功能"></a>jstack 功能</h2><p>主要分为两个功能：</p>
<p>a．  针对活着的进程做本地的或远程的线程dump；</p>
<p>b．  针对core文件做线程dump。</p>
<p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<h2 id="jstack-操作方式"><a href="#jstack-操作方式" class="headerlink" title="jstack 操作方式"></a>jstack 操作方式</h2><blockquote>
<p>jps -l | grep keyword -&gt; pid<br>jstack pid</p>
</blockquote>
<p>jstack结果如下；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;lettuce-nioEventLoop-4-1&quot; #639 daemon prio=5 os_prio=0 tid=0x00007ff27025d800 nid=0x258f runnable [0x00007ff262af7000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">	- locked &lt;0x000000008988d6a8&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">	- locked &lt;0x000000008988d770&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">	- locked &lt;0x000000008988d600&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)</span><br><span class="line">	at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:68)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:803)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:457)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/weixin_30013175/article/details/113901522">https://blog.csdn.net/weixin_30013175/article/details/113901522</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-jstat</title>
    <url>/wiki/JVM-jstat/</url>
    <content><![CDATA[<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>jstat是一个简单的实用工具，在JDK中存在，用于提供与JVM性能相关的统计信息，例如垃圾收集，编译活动。 jstat的主要优势在于，它可以在运行JVM且无需任何先决条件的情况下动态捕获这些指标。 这是什么意思？ 例如，如果要捕获与垃圾回收相关的统计信息，则需要在启动JVM之前传递以下参数：</p>
<blockquote>
<p> -Xlog:gc*:file={file-path} </p>
</blockquote>
<p>此参数将启用GC日志并将其打印在指定的文件路径中。 假设您尚未传递此参数，那么将不会生成与GC相关的统计信息。 这是jstat可以派上用场的地方。 您可以动态地连接到JVM并捕获GC，编译相关的统计信息如下所示。</p>
<h2 id="jstat操作"><a href="#jstat操作" class="headerlink" title="jstat操作"></a>jstat操作</h2><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat -gc -t 11656 10000 30 </span><br></pre></td></tr></table></figure>
<p>-gc ：将显示与垃圾收集相关的统计信息</p>
<p>自JVM启动以来的-t时间戳将被打印</p>
<p>11656：目标JVM进程ID</p>
<p>10000：每10,000毫秒（即10秒）将打印一次统计信息。</p>
<p>30 ：将打印30次迭代的统计信息。 因此，以上选项将导致JVM打印指标300秒（即10秒x 30次迭代）。</p>
<p>（请注意，除了-gc之外，您还可以传递其他各种选项来生成不同的数据集。有关不同选项的更多详细信息，请参见此处 。）<br>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">        34486.1 1536.0 1536.0  0.0   878.8  226816.0 132809.2  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br><span class="line">        34496.3 1536.0 1536.0  0.0   878.8  226816.0 138030.9  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br><span class="line">        34506.3 1536.0 1536.0  0.0   878.8  226816.0 195648.1  218112.0   113086.4  120664.0 111284.9 14464.0 12928.3    355    3.523   6      1.126    4.649</span><br></pre></td></tr></table></figure>

<h3 id="字段解读"><a href="#字段解读" class="headerlink" title="字段解读"></a>字段解读</h3><p>S0C –幸存者0区域的容量，以KB为单位</p>
<p>S1C –幸存者1区域的容量，以KB为单位</p>
<p>S0U –幸存者0区域使用的空间以KB为单位</p>
<p>S1U –幸存者1区域以KB为单位使用空间</p>
<p>EC –伊甸园地区容量（KB）</p>
<p>欧盟–伊甸园地区的已利用空间（以KB为单位）</p>
<p>OC –旧区域容量（KB）</p>
<p>OU –旧区域的已利用空间，以KB为单位</p>
<p>MC –元空间区域容量，以KB为单位</p>
<p>MU –元空间区域使用的空间以KB为单位</p>
<p>CCSC –压缩类空间区域的容量，以KB为单位</p>
<p>CCSU –压缩类空间区域以KB为单位使用空间</p>
<p>YGC –迄今为止发生的年轻GC事件的数量</p>
<p>YGCT –到目前为止，年轻GC花费的时间</p>
<p>FGC –迄今为止已发生的完全GC事件的数量</p>
<p>FGCT –到目前为止已花费的完整GC时间</p>
<p>GCT –到目前为止所花费的GC时间总量（基本上是YGCT + FGCT）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dnc8371/article/details/107255359">jstat分析_jstat –分析</a> </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-strace</title>
    <url>/wiki/JVM-strace/</url>
    <content><![CDATA[<h1 id="strace-命令查看操作系统日志"><a href="#strace-命令查看操作系统日志" class="headerlink" title="strace 命令查看操作系统日志"></a>strace 命令查看操作系统日志</h1><p><code>strace -ff -o out java ***.class</code></p>
<p>-ff : 跟踪进程下所有线程用到的系统命令<br>-o : 将跟踪的操作系统日志输出</p>
<blockquote>
<p>下面查看JDK1.8下，BIO模式都有哪些系统命令的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.io.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 2:55 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SockerIo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        Socket client = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = client.getInputStream();</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        <span class="comment">// 读阻塞</span></span><br><span class="line">        System.err.println(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务端</p>
</blockquote>
<p>1、<code>javac SockerIo.java</code> 得到SockerIo.class<br>然后，使用strace启动java程序👇：<br>2、<code>strace -ff -0 out java SockerIo</code><br>得到如下日志：<br><img src="https://oscimg.oschina.net/oscnet/up-924f13a6df8c2ce97e13019329008fb4a84.png"></p>
<blockquote>
<p>客户端使用nc连接9090端口，然后请求数据</p>
</blockquote>
<p><code>nc 127.0.0.1 9090</code>  发送如下数据</p>
<img src="https://oscimg.oschina.net/oscnet/up-4b7b364f021786bd9bdf4f40135da3b4a8d.png">

<blockquote>
<p>strace查看日志</p>
</blockquote>
<p>查看主线程日志：<br><img src="https://oscimg.oschina.net/oscnet/up-291f9a1018a2d288b88a5c2e43666d5d47e.png"><br>如上图，👆文件最大的是主线程日志：</p>
<img src="https://oscimg.oschina.net/oscnet/up-c306b9f94e3d0a3582b049d3c4769b4f5ec.png">

<p>根据上面👆strace命令跟踪的日志可以看到，JDK1.8下的BIO的多路复用器是使用的「poll」</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载机制</title>
    <url>/wiki/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载机制具体流程"><a href="#类加载机制具体流程" class="headerlink" title="类加载机制具体流程"></a>类加载机制具体流程</h2><p>Java 的类加载过程可以分为 5 个阶段：载入、验证、准备、解析和初始化。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。</p>
<p>1）Loading（载入）</p>
<p>JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象。</p>
<p>2）Verification（验证）</p>
<p>JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。</p>
<p>确保二进制字节流格式符合预期（比如说是否以 cafe bene 开头）。<br>是否所有方法都遵守访问控制关键字的限定。<br>方法调用的参数个数和类型是否正确。<br>确保变量在使用之前被正确初始化了。<br>检查变量是否被赋予恰当类型的值。<br>3）Preparation（准备）</p>
<p>JVM 会在该阶段对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p>
<p>也就是说，假如有这样一段代码：</p>
<p>public String chenmo = “沉默”;<br>public static String wanger = “王二”;<br>public static final String cmower = “沉默王二”;<br>chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 null。</p>
<p>需要注意的是，static final 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 null。</p>
<p>4）Resolution（解析）</p>
<p>该阶段将常量池中的符号引用转化为直接引用。</p>
<p>what？符号引用，直接引用？</p>
<p>符号引用以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。</p>
<p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。</p>
<p>直接引用通过对符号引用进行解析，找到引用的实际内存地址。</p>
<p>5）Initialization（初始化）</p>
<p>该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。</p>
<p>oh，no，上面这段话说得很抽象，不好理解，对不对，我来举个例子。</p>
<p>String cmower = new String(“沉默王二”);<br>上面这段代码使用了 new 关键字来实例化一个字符串对象，那么这时候，就会调用 String 类的构造方法对 cmower 进行实例化。</p>
<h2 id="什么是双亲委派"><a href="#什么是双亲委派" class="headerlink" title="什么是双亲委派"></a>什么是双亲委派</h2><p>聊完类加载过程，就不得不聊聊类加载器。</p>
<p>一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试<br>ClassNotFoundException 和 NoClassDefFoundError 等异常。</p>
<p>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 Class 对象不 equals）。</p>
<p>站在程序员的角度来看，Java 类加载器可以分为三种。</p>
<p>1）启动类加载器（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。</p>
<p>2）扩展类加载器（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件。</p>
<p>3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。</p>
<p>来来来，通过一段简单的代码了解下。</p>
<pre><code class="java">public class Test &#123;

    public static void main(String[] args) &#123;
        ClassLoader loader = Test.class.getClassLoader();
        while (loader != null) &#123;
            System.out.println(loader.toString());
            loader = loader.getParent();
        &#125;
    &#125;

&#125;
</code></pre>
<p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 类名.class.getClassLoader() 可以获取到此引用；然后通过 loader.getParent() 可以获取类加载器的上层类加载器。</p>
<p>这段代码的输出结果如下：</p>
<p>sun.misc.Launcher$AppClassLoader@73d16e93<br>sun.misc.Launcher$ExtClassLoader@15db9742<br>第一行输出为 Test 的类加载器，即应用类加载器，它是 sun.misc.Launcher$AppClassLoader 类的实例；第二行输出为扩展类加载器，是 sun.misc.Launcher$ExtClassLoader 类的实例。那启动类加载器呢？</p>
<p>按理说，扩展类加载器的上层类加载器是启动类加载器，但在我这个版本的 JDK 中， 扩展类加载器的 getParent() 返回 null。所以没有输出。</p>
<hr>
<p>双亲委派机制：<br><img src="https://oscimg.oschina.net/oscnet/up-5314cbdba627f795c147f27e03270d392c7.png" width=400 height=450></p>
<h2 id="双亲委派如何破坏"><a href="#双亲委派如何破坏" class="headerlink" title="双亲委派如何破坏"></a>双亲委派如何破坏</h2><p>线程上下文加载器</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/weixin_40236948/article/details/88072698">Java类加载机制</a><br>2、<a href="https://blog.csdn.net/codeyanbao/article/details/82875064">通俗易懂的双亲委派机制</a>  </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-自定义类加载器</title>
    <url>/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p>为什么要自定义加载器</p>
<p>原因：<br>1、存放在自定义路径上的类，需要通过自定义类加载器去加载。【注意：AppClassLoader加载classpath下的类】<br>2、类不一定从文件中加载，也可能从网络中的流中加载，这就需要自定义加载器去实现加密解密。<br>3、可以定义类的实现机制，实现类的热部署,<br>如OSGi中的bundle模块就是通过实现自己的ClassLoader实现的，<br>如tomcat实现的自定义类加载模型。</p>
<p>如何实现自定义加载器</p>
<blockquote>
<p>实现自定义类加载有以下两步：<br>1、继承ClassLoader<br>2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。<br>注意：如果要打破双亲委派机制，需要重写loadClass方法。<br>如下：是一个自定义 的类加载器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span>  <span class="keyword">extends</span>  <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 data= loadByte(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/admin/test/&quot;</span>+name);</span><br><span class="line">            FileInputStream fi = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> len = fi.available();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fi.read(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>下面是要加载的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类编译后的class 文件放置在/Users/admin/test/下,然后执行如下代码去加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;Demo.class&quot;</span>);</span><br><span class="line">        Object o=clazz.newInstance();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">输出:hello</span><br></pre></td></tr></table></figure>

<p>能不能自己写一个java.lang.String</p>
<p>1、代码书写后可以编译不会报错<br>2、在另一个类中加载java.lang.String，通过反射调用自己写的String类里的方法，得到结果NoSuchMethod，说明加载的还是原来的String，因为通过双亲委派机制，会把java.lang.String一直提交给启动类加载器去加载，通过他加载，加载到的永远是/lib下面的java.lang.String<br>3、在这个自己写的类中写上main方法<br>public static void main(String[] args)<br>执行main方法报错，因为这个String并不是系统的java.lang.String，所以JVM找不到main方法的签名</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_28605513/article/details/85014451">JVM:如何实现一个自定义类加载器？</a><br>原文链接：<a href="https://blog.csdn.net/qq_28605513/article/details/85014451">https://blog.csdn.net/qq_28605513/article/details/85014451</a></p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-CAS原理和底层实现</title>
    <url>/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="CAS原理和底层实现"><a href="#CAS原理和底层实现" class="headerlink" title="CAS原理和底层实现"></a>CAS原理和底层实现</h1><img src="https://oscimg.oschina.net/oscnet/up-0ed0dcb929342035287eb09818f33416baa.png" width=550 height=400>

<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是（compare and swap） 的缩写，它能在不加锁的情况下，在多线程的环境下，保证多线程一致性的改动某一值；</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题是一个线程在CAS比较值和原来是否相等的过程中，别的线程修改过这个值，但是又改回去了，倒置当前线程比较的时候，发现是相等的，但是，中间是被修改过的；  </p>
<p>添加版本号，比较值的时候同时比较版本号</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger:"></a>AtomicInteger:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe:"></a>Unsafe:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>运用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h3 id="jdk8u-atomic-linux-x86-inline-hpp-93行"><a href="#jdk8u-atomic-linux-x86-inline-hpp-93行" class="headerlink" title="jdk8u: atomic_linux_x86.inline.hpp 93行"></a>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></h3><p>is_MP = Multi Processor  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">&quot;cmp $0, &quot;</span> #mp <span class="meta-string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="最终实现："><a href="#最终实现：" class="headerlink" title="最终实现："></a>最终实现：</h3><p>底层对应一个汇编指令「lock comxchg」，但是comxchg这条指令不是原子性的，他不能保证在比较的时候，别的线程会不会改变值；而保证线程安全的则是lock这条指令，lock这条指令在执行后面执行的时候锁定一个「北桥信号」，而不是采用纵线锁的方式；</p>
<h2 id="CAS在JDK中的实现"><a href="#CAS在JDK中的实现" class="headerlink" title="CAS在JDK中的实现"></a>CAS在JDK中的实现</h2><p>1、AtomitInteger<br>2、ConcurrentHashMap</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-FutureTask原理</title>
    <url>/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><h3 id="Future方法介绍"><a href="#Future方法介绍" class="headerlink" title="Future方法介绍"></a>Future方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务 可中断的方式取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断任务是否处于取消状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断异步任务是否执行完成      ==这里使用轮训的方式监听==</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到有结果返回；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到设置的时间，有结果返回，没有结果则抛出异常；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单示范Callable-amp-Future"><a href="#简单示范Callable-amp-Future" class="headerlink" title="简单示范Callable&amp;Future"></a>简单示范Callable&amp;Future</h3><p>（1）向线程池中提交任务的submit方法不是阻塞方法，而Future.get方法是一个阻塞方法<br>（2）submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果，所以一般需要使用future.isDone先判断任务是否全部执行完成，完成后再使用future.get得到结果。（也可以用get (long timeout, TimeUnit unit)方法可以设置超时时间，防止无限时间的等待）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;start call method...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main method start....&quot;</span>);</span><br><span class="line">        FutureTest futureTest = <span class="keyword">new</span> FutureTest();</span><br><span class="line">        Future1Test future1Test = <span class="keyword">new</span> Future1Test();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(future1Test);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;future not done !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(futureTest);</span><br><span class="line">        <span class="comment">// submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果</span></span><br><span class="line">        <span class="comment">// 这里先提交了future1Test，休眠了4s, futureTest休眠了3s，但是等我们get到结果的时候，是消耗的4s时间的；</span></span><br><span class="line">        System.err.println(<span class="string">&quot;cost time: &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">        System.err.println(<span class="string">&quot;future: &quot;</span> + future.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;future1: &quot;</span> + future1.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;main method end....&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main method start....</span><br><span class="line">future not done !</span><br><span class="line"><span class="comment">// 说明了第一 get()方法是阻塞，第二线程池任务都执行完成之后，按提交任务顺序get结果返回值</span></span><br><span class="line">cost time: <span class="number">4</span></span><br><span class="line">start call method...</span><br><span class="line">future: future <span class="number">2</span> test</span><br><span class="line">future1: <span class="number">1111</span></span><br><span class="line">main method end....</span><br></pre></td></tr></table></figure>

<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul>
<li>线程池执行任务有两种方式execute和submit，execute是不带返回值的，submit是有返回值的;</li>
<li>main方法中可以不使用线程池，可以直接创建线程，调用start方法就可以，切记只有在演示代码的时候后。手动直接创建线程的方式还是不要用，因为一旦请求变多，则会创建无数的线程，线程数大于CPU核数，进而导致CPU频繁切换上下分进行调度，性能严重下降。</li>
<li>而且线程的数据是存放在内存中的，会占用大量的内存，增加垃圾回收的压力。严重的会发生OOM;</li>
<li>异常main方法中我们使用的是Future<String> future接收异步任务执行的放回结果，但实际上Future其实是一个interface，并不能接收返回结果的，那实际我们调用future.get()是，是实例了一个FutureTask对象来接受的；</li>
</ul>
<h3 id="FutureTask讲解"><a href="#FutureTask讲解" class="headerlink" title="FutureTask讲解"></a>FutureTask讲解</h3><p>下面主要针对Future的实现类FutureTask的几个重要方法展开</p>
<h4 id="FutureTask继承关系"><a href="#FutureTask继承关系" class="headerlink" title="FutureTask继承关系"></a>FutureTask继承关系</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 下面是RunnableFuture接口的继承关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>FutureTask 重要的成员变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="comment">//任务执行结果或者任务异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="comment">//执行任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="comment">//等待节点，关联等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//state字段的内存偏移量     这个在线程池执行任务的时候进行状态判断的时候会用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="comment">//runner字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line"><span class="comment">//waiters字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义任务的生命周期</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NORMAL:指的是任务能够正常执行状态  </li>
<li>EXCEPTIONAL：表示任务执行异常  </li>
<li>CANCELLED：取消状态，之后的状态都表示任务取消或终端  </li>
</ul>
<p>下面看一下FutureTask中几个重要的方法</p>
<h4 id="执行结果-report方法"><a href="#执行结果-report方法" class="headerlink" title="执行结果 | report方法"></a>执行结果 | report方法</h4><blockquote>
<p>Returns result or throws exception for completed task.<br>主要是上报异步任务执行的结果或返回任务执行发生的异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>判断逻辑就是根据参数，也是是任务状态，根据不同的状态处理相应的逻辑。比如NORNAL状态，表示任务正常执行，直接返回结果就可以。如果状态大于CANCELLED，说明任务被取消或终端，会抛出CancellationException()；如果不是异常状态，则抛出ExecutionException；</p>
<h4 id="任务执行-run"><a href="#任务执行-run" class="headerlink" title="任务执行 |   run()"></a>任务执行 |   run()</h4><blockquote>
<p>执行异步任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果状态 state 不是 NEW，或者设置 runner 值失败</span></span><br><span class="line">     <span class="comment">// 表示有别的线程在此之前调用 run 方法，并成功设置了 runner 值</span></span><br><span class="line">     <span class="comment">// 保证了只有一个线程可以运行 try 代码块中的代码。</span></span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">             !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//以上state值变更的由CAS操作保证原子性</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="comment">//只有c不为null且状态state为NEW的情况</span></span><br><span class="line">         <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="keyword">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//调用callable的call方法，并获得返回结果</span></span><br><span class="line">                 result = c.call();</span><br><span class="line">                 <span class="comment">//运行成功</span></span><br><span class="line">                 ran = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="keyword">null</span>;</span><br><span class="line">                 ran = <span class="keyword">false</span>;</span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 <span class="comment">//设置结果</span></span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">         <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">         runner = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">         <span class="comment">// leaked interrupts</span></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">             handlePossibleCancellationInterrupt(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑就是调用Callable的call方法，==result=c.call();== 并且对任务执行的结果或异常信息进行处理；</p>
<h4 id="获取结果-get-throws-InterruptedException-ExecutionException"><a href="#获取结果-get-throws-InterruptedException-ExecutionException" class="headerlink" title="获取结果 | get() throws InterruptedException, ExecutionException"></a>获取结果 | get() throws InterruptedException, ExecutionException</h4><blockquote>
<p>获取异步任务执行的结果或异常信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法执行两个操作：  </p>
<ul>
<li>判断任务的状态,如果没有执行完成，调用awaitDone方法</li>
<li>任务完成，调用我们上面说的report方法，返回任务执行结果</li>
</ul>
<h4 id="任务阻塞-awaitDone-boolean-timed-long-nanos"><a href="#任务阻塞-awaitDone-boolean-timed-long-nanos" class="headerlink" title="任务阻塞 | awaitDone(boolean timed, long nanos)"></a>任务阻塞 | awaitDone(boolean timed, long nanos)</h4><blockquote>
<p>等到任务执行完成 也是get方法阻塞特性的关键所在</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// CPU轮转</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果线程中断了，将线程移除等待队列，抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 如果任务状态大于完成，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务完成，但是返回值outcome还没有设置，可以先让出线程执行权，让其他线程执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">// 下面是任务还没有执行完成的状态，将线程添加到等待队列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="comment">// 判断get方法是否设置了超时时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 如果超出设置的时间，线程移除等到队列</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有设置超时时间，线程直接阻塞，直到任务完成</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>主要执行步骤：</p>
<ul>
<li>判断线程是否被中断，如果被中断了，就从等待的线程栈中移除该等待节点，然后抛出中断异常 </li>
<li>读取state,判断任务是否已经完成，如果已经完成或者任务已经取消，此时调用get方法的线程不会阻塞，会直接获取到结果或者拿到异常信息；  </li>
<li>如果s == COMPLETING，说明任务已经结束，但是结果还没有保存到outcome中，==此时线程让出执行权，给其他线程先执行；==   </li>
<li>如果任务没有执行完成，则需要创建等待节点，等待插入到阻塞队列  </li>
<li>判断queued，这里是将c中创建节点q加入队列头。使用Unsafe的CAS方法，对waiters进行赋值，waiters也是一个WaitNode节点，相当于队列头，或者理解为队列的头指针。通过WaitNode可以遍历整个阻塞队列  </li>
<li>然后判断超时时间，时间是在调用get方法的时候传输进来的，如果有超时时间，则设置超时时间，如果超出时间，则将线程移除等待队列；如果没有设置时间，则直接阻塞线程；  </li>
</ul>
<h4 id="取消任务-cancel-boolean-mayInterruptIfRunning"><a href="#取消任务-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="取消任务 |  cancel(boolean mayInterruptIfRunning)"></a>取消任务 |  cancel(boolean mayInterruptIfRunning)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Param</span> mayInterruptIfRunning 是否中断</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在状态还为NEW的时候，根据参数中的是否允许传递，</span></span><br><span class="line"><span class="comment">     * 将状态流转到INTERRUPTING或者CANCELLED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 必须将栈顶CAS为null，否则重读栈顶并重试。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历并唤醒栈中节点对应的线程。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将next域置为null，这样对GC友好。</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; </span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * done方法是暴露给子类的一个钩子方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个方法在ExecutorCompletionService.QueueingFuture中的override实现是把结果加到阻塞队列里。</span></span><br><span class="line"><span class="comment">     * CompletionService谁用谁知道，奥秘全在这。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * callable置为null主要为了减少内存开销,</span></span><br><span class="line"><span class="comment">     * 更多可以了解JVM memory footprint相关资料。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    callable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Callable-amp-Future使用场景"><a href="#Callable-amp-Future使用场景" class="headerlink" title="Callable&amp;Future使用场景"></a>Callable&amp;Future使用场景</h3><ul>
<li>异步任务需要拿到返回值</li>
<li>多线程并发调用，顺序组装返回值，一些并发框架中会看到相应体现</li>
<li>还有一些分布式任务调度的场景，远程调用需要回填执行结果</li>
<li>还有很多通信框架中都有体现</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p>(1) <a href="https://blog.csdn.net/qq_34562093/article/details/90209520">future.get方法阻塞问题的解决，实现按照任务完成的先后顺序获取任务的结果</a><br>(2) <a href="https://blog.csdn.net/luofenghan/article/details/78596950#%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java多线程引发的性能问题以及调优策略</a><br>(3) <a href="https://www.jianshu.com/p/55221d045f39">可取消的异步任务——FutureTask用法及解析</a><br>(4) <a href="https://www.cnblogs.com/micrari/p/7374513.html">FutureTask源码解读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO</title>
    <url>/wiki/Java-NIO/</url>
    <content><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><blockquote>
<p>Java NIO 对于Java BIO的优化</p>
</blockquote>
<h2 id="Java-非阻塞IO"><a href="#Java-非阻塞IO" class="headerlink" title="Java 非阻塞IO"></a>Java 非阻塞IO</h2><blockquote>
<p>及时不使用线程池，也可以处理多个客户端请求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ServerSocketChannel ss = ServerSocketChannel.open();</span><br><span class="line">    ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">    ss.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        SocketChannel client = ss.accept();</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;client is null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">            System.err.println(<span class="string">&quot;client port &quot;</span> + port);</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 串型话</span></span><br><span class="line">        <span class="comment">// 真实场景下 每一个client一个独自的buffer</span></span><br><span class="line">        <span class="keyword">for</span> (SocketChannel c : clients) &#123;</span><br><span class="line">            <span class="comment">// -1 出现空轮训 </span></span><br><span class="line">            <span class="keyword">int</span> num = c.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">                byteBuffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                System.err.println(c.socket().getPort() + <span class="string">&quot; :   &quot;</span> + b);</span><br><span class="line">                <span class="comment">// 清空 循环下一次client在使用</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上可以实现，一个线程可以处理多个客户端链接，服务端非阻塞接收，接收之后，读取数据也是非阻塞的；</p>
</blockquote>
<blockquote>
<p>NIO的非阻塞是操作系统内部实现的，底层调用了linux内核的accept函数</p>
</blockquote>
<blockquote>
<p>d Java的NIO有什么弊端</p>
</blockquote>
<ul>
<li>服务端还是会进行空转</li>
<li>不管有没有客户端连接建立，服务端都要不断执行accept方法</li>
<li>不管客户端连接有没有传输数据，都会执行一遍read操作</li>
</ul>
<blockquote>
<p>资源浪费问题</p>
</blockquote>
<p>还是会存在C10k的问题</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--buffer</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-buffer/</url>
    <content><![CDATA[<h1 id="Buffer-读写"><a href="#Buffer-读写" class="headerlink" title="Buffer 读写"></a>Buffer 读写</h1><h2 id="NIO之Buffer"><a href="#NIO之Buffer" class="headerlink" title="NIO之Buffer"></a>NIO之Buffer</h2><p>Buffer作为NIO三大核心组件之一，本质上是一块可以写入数据，以及从中读取数据的内存，实际上也是一个byte[]数据,只是在NIO中被封装成了NIO Buffer对象<br>并提供了一组方法来访问这个内存块。</p>
<h3 id="下面是一个简单的Demo"><a href="#下面是一个简单的Demo" class="headerlink" title="下面是一个简单的Demo"></a>下面是一个简单的Demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一个text.txt文件，生成一个新的text1.txt文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNioDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">        FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">// 声明缓冲区大小为1024字节</span></span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 从通道中读取数据</span></span><br><span class="line">        inChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">// 读模式切换为写模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//把缓冲区的数据写到通道</span></span><br><span class="line">        outChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 数据写完之后清空全部缓冲区</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="comment">//关闭文件流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; 执行结果：生成/Users/gaolei/Desktop/text1.txt文件  </span><br><span class="line"></span><br><span class="line">**Buffer进行数据读写操作的一般步骤**  </span><br><span class="line"><span class="number">1</span>、写入数据到Buffer  </span><br><span class="line"><span class="number">2</span>、调用flip()方法  </span><br><span class="line"><span class="number">3</span>、从Buffer中读取数据  </span><br><span class="line"><span class="number">4</span>、调用clear()方法或者compact()方法  </span><br><span class="line"></span><br><span class="line">&gt; clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### Buffer三个核心的属性  </span><br><span class="line">- capacity 容量 与buffer处在什么模式无关</span><br><span class="line">- position 游标位置 指向下一个存放/读取数据的位置 范围（<span class="number">0</span> ～ capacity–<span class="number">1</span>）</span><br><span class="line">- limit </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 读写操作中Buffer三大属性的变化</span><br><span class="line">初始状态  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;    </span><br><span class="line">第一次读取数据  </span><br><span class="line">position处于起始位置，limit和capacity都处于结尾  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-41b47d9e54d58c7b39caf9e514fc9b5261f.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">第二次读取数据  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-07f3d1aa1f886b592b386cd4d846810911d.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">当写数据的时候，需要调用flip方法： </span><br><span class="line">当将Buffer从写模式切换到读模式，position会被重置为<span class="number">0.</span> 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。  </span><br><span class="line">当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）     </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-b9323701bbb34a6c12f61d5ac2652ab7eeb.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">Clear方法  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JAVA NIO下的Buffer分类</span><br><span class="line">- ByteBuffer</span><br><span class="line">- MappedByteBuffer</span><br><span class="line">- CharBuffer</span><br><span class="line">- DoubleBuffer</span><br><span class="line">- FloatBuffer</span><br><span class="line">- IntBuffer</span><br><span class="line">- LongBuffer</span><br><span class="line">- ShortBuffer</span><br><span class="line">&gt; Java基本类型除了布尔类型，都有其对应的Buffer </span><br><span class="line"></span><br><span class="line">### ByteBuffer使用</span><br><span class="line">&gt; 下面以ByteBuffer为例子看一下Buffer如何使用</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 创建一个byteBuffer，设置容量为1024字节</span></span><br><span class="line">ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>1、如下代码，其实调用了new HeapByteBuffer(capacity, capacity)来创建一个buffer  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>2、创建了buffer之后要往里面写数据，除了上面从channel中读取数据之外，还可以调用put方法,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>3、如果写将buffer中的数据写出去，必须先调用flap方法</p>
<blockquote>
<p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
</blockquote>
<p>4、将数据写到通道中 inChannel.write(buf);</p>
<p>5、数据写出到通道之后，要将缓存清空，一般调用clear方法<br><strong>clear方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//position将被设回0</span></span><br><span class="line">       position = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//limit被设置成 capacity的值</span></span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。<br><strong>compact方法</strong><br>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//compact()方法将所有未读的数据拷贝到Buffer起始处。</span></span><br><span class="line">        System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">        <span class="comment">//position设到最后一个未读元素正后面</span></span><br><span class="line">        position(remaining());</span><br><span class="line">        <span class="comment">//limit属性设置成capacity</span></span><br><span class="line">        limit(capacity());</span><br><span class="line">        discardMark();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">现在Buffer准备好写数据了，但是不会覆盖未读的数据 </span><br></pre></td></tr></table></figure>
<h3 id="零拷贝原理"><a href="#零拷贝原理" class="headerlink" title="零拷贝原理"></a>零拷贝原理</h3><p>– 零拷贝，第一次接触零拷贝是在kafka的数据存储部分–<br>IO流程：<br><img src="https://oscimg.oschina.net/oscnet/up-f5a9accbd021cfe41414ca72391b3889049.png"  height="230" width="395"><br>内存映射缓冲区<br><img src="https://oscimg.oschina.net/oscnet/up-a7a80d3426d1497bcaa69f30789718db0ee.png"  height="230" width="395"><br>比普通IO操作文件快很多，甚至比channel还要快很多。<br>因为避免了很多系统调用（System.read System.write）。减少了内核缓冲区的数据拷贝到用户缓冲区。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      FileChannel in = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">      FileChannel out = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>), StandardOpenOption.READ, StandardOpenOption.CREATE, StandardOpenOption.WRITE);</span><br><span class="line">      MappedByteBuffer inBuffer = in.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, in.size());</span><br><span class="line">      MappedByteBuffer outBuffer = out.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, in.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inBuffer.limit()];</span><br><span class="line">      inBuffer.get(bytes);</span><br><span class="line">      outBuffer.put(bytes);</span><br><span class="line">      in.close();</span><br><span class="line">      out.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-ec7269566091c2f389749849ad734972de6.png"><br>普通的网络IO拷贝流程<br>1、首先系统从磁盘上拷贝文件到内核空间缓冲区<br>2、然后在内核空间拷贝数据到用户空间<br>3、第三次，用户缓冲区再将数据拷贝到内核部分的socket缓冲<br>4、内核在将存储在socket缓冲区的数据拷贝并发送到网卡缓冲区<br>以上一个常规的网络IO经历了4次数据拷贝；  </p>
<p>设置缓冲区的意义在于提升性能，当用户空间仅仅需要一小部分数据的时候，操作系统会在磁盘上读取一块数据方法内核缓冲区，这个叫做局部性原理。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6209218a39ae427544247f1b3937b4043cc.png"><br>零拷贝减去了内核空间数据到用户空间数据的拷贝，从而提升IO性能。假设读取的文件很大，操作系统需要读取磁盘大量数据到内核空间，<br>这时候内核缓冲区的作用是很难体现的。因为如果用户空间需要少量数据的时候是可以直接在内核空间获取的（局部性原理）。正式因为有了零拷贝，<br>操作系统在磁盘读取数据之后，可以直接发送到网卡缓冲区，从而大大提升IO性能。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--channel</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-channel/</url>
    <content><![CDATA[<h1 id="NIO核心组件-Channel"><a href="#NIO核心组件-Channel" class="headerlink" title="NIO核心组件 - Channel"></a>NIO核心组件 - Channel</h1><h2 id="SocketChannel-和-ServerSocketChannel"><a href="#SocketChannel-和-ServerSocketChannel" class="headerlink" title="SocketChannel 和 ServerSocketChannel"></a>SocketChannel 和 ServerSocketChannel</h2><p>学习此部分可以对比Socket和ServerSocket</p>
<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketServer01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocketChannel 支持阻塞/非阻塞</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 设置成非阻塞。默认阻塞true</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 循环监听客户端连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有客户端连接，则返回一个socketChannel实例，否则socketChannel=null</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                <span class="comment">// 代码执行到此处，说明有客户端链接</span></span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 读取客户端发送的数据，并输出</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.err.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                    <span class="comment">// 将数据在写会客户端</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    socketChannel.write(buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//验证客户端 socketChannel设置成false时，从服务端read数据的操作变成非阻塞的</span></span><br><span class="line">                    <span class="comment">//ByteBuffer buffer = ByteBuffer.allocate(1024);</span></span><br><span class="line">                    <span class="comment">//buffer.put(&quot;this is server!&quot;);</span></span><br><span class="line">                    <span class="comment">//buffer.flip();</span></span><br><span class="line">                    <span class="comment">//socketChannel.write(buffer);</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    System.err.println(<span class="string">&quot;no client&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 默认阻塞IO true</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// finishConnect的主要作用就是确认通道连接已建立，方便后续IO操作（读写）不会因连接没建立而导致NotYetConnectedException异常。</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel.isConnectionPending()) &#123;</span><br><span class="line">                <span class="comment">// finishConnect一直阻塞到connect建立完成</span></span><br><span class="line">                socketChannel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            </span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">int</span> r = socketChannel.read(byteBuffer); <span class="comment">// 非阻塞方法 byteBuffer的数据还是上面put的</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;get msg:&#123;&#125;&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server no back&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO核心组件--selector</title>
    <url>/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-selector/</url>
    <content><![CDATA[<h1 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>1、select选择器会告诉客户端哪些连接有数据要读取，但是读取的操作还是用户自己触发的，这种叫做「同步」</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 4:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMultiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.err.println(<span class="string">&quot;server started ....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// selector.select() 调用系统内核的select</span></span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 从多路复用器中选择有效的key</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        acceptHandle(key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        readHandle(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel client = ssc.accept();</span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class="line">        System.err.println(<span class="string">&quot;client arrived &quot;</span> + client.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            read = client.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务端读到的数据，再写一遍给到客户端</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// client 发生错误 或者断开 read == -1</span></span><br><span class="line">                <span class="comment">// 导致空转 最终CPU达到100%</span></span><br><span class="line">                client.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的写法是一个selector既担任boss又担任worker </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-join方法原理解析</title>
    <url>/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">join重载方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> join()</span><br><span class="line"><span class="number">2</span> join(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line"><span class="number">3</span> join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br></pre></td></tr></table></figure>
<h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//        t.join();</span></span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上将t.join();注释掉，执行的一种可能结果如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">main thread end... </span><br><span class="line">join thread demo</span><br><span class="line"></span><br><span class="line">还有可能是这种结果：</span><br><span class="line">main thread start... </span><br><span class="line">join thread demo</span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure>
<p>但是把注释去掉，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的demo,效果是显而易见的。当main线程去调用t.join()是，会将自己当前线程阻塞，等到t线程执行完成到达完结状态，main线程才可以继续执行。  </p>
<p>我们看一下join()设置超时时间的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程睡眠4s</span></span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">null</span>;</span><br><span class="line">        System.err.println(strings.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 但是主线程join的超时时间是1s</span></span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br><span class="line">Exception in thread <span class="string">&quot;ibli joinTest ...&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at com.ibli.threadTest.api.JoinDemo.run(JoinDemo.java:<span class="number">14</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的执行结果可以看到，子线程设置了4s的超时时间，但是主线程在1秒超时后，并没有等待子线程执行完毕，就被唤醒执行后续操作了；这样的预期是否符合你的预期呢？<br>下面我们按照join的源码去分析吧！</p>
</blockquote>
<h3 id="join方法原理"><a href="#join方法原理" class="headerlink" title="join方法原理"></a>join方法原理</h3><p>下面是join的原理图</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5386b2aaabd43cab4b0f042e0270118~tplv-k3u1fbpfcp-zoom-1.image?imageView2/2/w/480/h/480/q/85/interlace/1" width = "400" height = "500" div align=right />




<blockquote>
<p>join()源码</p>
</blockquote>
<p>首先会调用join(0)方法，其实是join的重载方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是join的核心实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先校验参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果join方法没有参数，则相当于直接调用wait方法</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面是isAlive方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法，作用是判断当前的线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。</p>
<ul>
<li><p>这里有一个点要注意，join为什么阻塞的是主线程，而不是子线程呢？  </p>
</li>
<li><p>不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p>
</li>
<li><p>其实join()方法的核心在于wait(),在主线程中调用t.join()相当于在main方法中添加 new JoinDemo().wait();是一样的效果；在这里只不过是wait方法写在了子线程的方法中。  </p>
</li>
<li><p>再次重申一遍，join方法的作用是在主线程阻塞，等在子线程执行完之后，由子线程唤醒主线程，再继续执行主线程调用t.join()方法之后的逻辑。</p>
</li>
</ul>
<blockquote>
<p>那么主线程是在什么情况下知道要继续执行呢？就是上面说的，主线程其实是由join的子线程在执行完成之后调用的notifyAll()方法，来唤醒等待的线程。怎么证明呢？</p>
</blockquote>
<p>其实大家可以去翻看JVM的源码实现，Thread.cpp文件中，有一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">  <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">  <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中调用ensure_join方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">  <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">&quot;java thread object must exist&quot;</span>);</span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">  <span class="comment">// to complete once we&#x27;ve done the notify_all below</span></span><br><span class="line">  <span class="comment">//这里是清除native线程，这个操作会导致isAlive()方法返回false</span></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  <span class="comment">// 在这里唤醒等待的线程</span></span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JVM的代码中，线程执行结束的最终调用了lock.notify_all(thread)方法来唤醒所有处于等到的线程</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>比如我们使用Callable执行异步任务，需要在主线程处理任务的返回值时，可以调用join方法；</li>
<li>还有一些场景希望线程之间顺序执行的；</li>
</ul>
<h2 id="join-方法与sleep-的比较"><a href="#join-方法与sleep-的比较" class="headerlink" title="join()方法与sleep()的比较"></a>join()方法与sleep()的比较</h2><p>我们先说一下sleep方法：</p>
<ul>
<li>让当前线程休眠指定时间。</li>
<li>休眠时间的准确性依赖于系统时钟和CPU调度机制。</li>
<li>不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进- 入到当前同步块或者同步方法中的。</li>
<li>可通过调用interrupt()方法来唤醒休眠线程。</li>
<li>sleep是静态方法，可以在任何地方调用</li>
</ul>
<p>相比与sleep方法<br>sleep是静态方法，而且sleep的线程不是放锁资源，而join方法是对象方法，并且在等待的过程中会释放掉对象锁；</p>
<blockquote>
<p>关于join方法会释放对象锁，那到底是释放的那个对象的锁呢，可以参照 <a href="https://www.cnblogs.com/lwmp/p/11805440.html">关于join() 是否会释放锁的一些思考</a> </p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.iteye.com/blog/uule-1101994">1、Java多线程中join方法的理解</a><br><a href="https://blog.csdn.net/weichi7549/article/details/108449618">2、Thread.join的作用和原理</a><br><a href="https://www.jianshu.com/p/fc51be7e5bc0">3、Thread.join的作用和原理</a></p>
</blockquote>
<blockquote>
<p>d <p align="middle">山脚太拥挤 我们更高处见。</p></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-synchronzied底层原理</title>
    <url>/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="synchronzied底层原理"><a href="#synchronzied底层原理" class="headerlink" title="synchronzied底层原理"></a>synchronzied底层原理</h1><h2 id="synchronzied四个层级实现"><a href="#synchronzied四个层级实现" class="headerlink" title="synchronzied四个层级实现"></a>synchronzied四个层级实现</h2><ul>
<li>Java代码 通过添加synchronzied给对象或者方法或者代码块</li>
<li>字节码层级通过一组 MONITORENTER/MONITOREXIT指令</li>
<li>JVM层级：锁升级过程</li>
<li>汇编执行通过 lock comxchg指令保证原子操作</li>
</ul>
<p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db <span class="string">&quot;Hello&quot;</span>, <span class="number">0xA</span></span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, <span class="number">1</span> ;文件描述符<span class="number">1</span> std_out</span><br><span class="line">    mov eax, <span class="number">4</span> ;write函数系统调用号 <span class="number">4</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">    mov ebx, <span class="number">0</span></span><br><span class="line">    mov eax, <span class="number">1</span> ;exit函数系统调用号</span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure>

<p>优化后的synchronized如下👇：</p>
<h2 id="Java层级"><a href="#Java层级" class="headerlink" title="Java层级"></a>Java层级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Object object = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">          System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">    <span class="comment">// parameter  args</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L2 L3 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 13 L4</span></span><br><span class="line"><span class="function">    NEW java/lang/Object</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/lang/Object.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L5</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">16</span> L6</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    DUP</span><br><span class="line">    ASTORE <span class="number">2</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">17</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">18</span> L7</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L8</span><br><span class="line">   L2</span><br><span class="line">   FRAME FULL [[Ljava/lang/String; java/lang/Object java/lang/Object] [java/lang/Throwable]</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">    ALOAD <span class="number">3</span></span><br><span class="line">    ATHROW</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">19</span> L8</span><br><span class="line">   FRAME CHOP <span class="number">1</span></span><br><span class="line">    RETURN</span><br><span class="line">   L9</span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L4 L9 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE object Ljava/lang/Object; L5 L9 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要通过MONITORENTER 和 MONITOREXIT 两个字节码指令控制加锁过程</p>
</blockquote>
<h2 id="JVM层级"><a href="#JVM层级" class="headerlink" title="JVM层级"></a>JVM层级</h2><p>通过锁升级过程实现加锁；<br>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁 自适应锁）-&gt; 重量级锁<br>锁升级过程可以查看 <a href="doc:rjG4EIhi">锁升级过程</a>  复制理解</p>
<h2 id="汇编指令级别"><a href="#汇编指令级别" class="headerlink" title="汇编指令级别"></a>汇编指令级别</h2><p>linux操作系统安装hsdis插件，查看java代码的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    static volatile int i = 0;</span><br><span class="line">    </span><br><span class="line">    public static void n() &#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void m() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    publics static void main(String[] args) &#123;</span><br><span class="line">        for(int j=0; j&lt;1000_000; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</span><br></pre></td></tr></table></figure>
<ul>
<li>C1 Compile Level 1 (一级优化)</li>
<li>C2 Compile Level 2 (二级优化)</li>
</ul>
<blockquote>
<p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-为什么禁止把SimpleDateFormat定义成static变量?</title>
    <url>/wiki/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E6%88%90static%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文参照 《Java技术灵魂15问》</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在日常开发中，我们经常会用到时间，我们有很多办法在 Java 代码中获取时 间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工 具，把时间显示成我们需要的格式。</p>
<p>最常用的方法就是使用 SimpleDateFormat 类。这是一个看上去功能比较简单 的类，但是，一旦使用不当也有可能导致很大的问题。<br>在 Java 开发手册中，有如下明确规定:</p>
<img src="https://oscimg.oschina.net/oscnet/up-8b016ecefbdfc6ea675aaf7f2a0511bbc6a.png">

<p>那么，本文就围绕 SimpleDateFormat 的用法、原理等来深入分析下如何以正 确的姿势使用它。</p>
<p>SimpleDateFormat 是 Java 提供的一个格式化和解析日期的工具类。它允许进 行格式化(日期 -&gt; 文本)、解析(文本 -&gt; 日期)和规范化。SimpleDateFormat 使 得可以选择任何用户定义的日期 - 时间格式的模式。</p>
<p>在 Java 中，可以使用 SimpleDateFormat 的 format 方法，将一个 Date 类型 转化成 String 类型，并且可以指定输出格式。</p>
<h2 id="SimpleDateFormat-用法"><a href="#SimpleDateFormat-用法" class="headerlink" title="SimpleDateFormat 用法"></a>SimpleDateFormat 用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Date转String</span></span><br><span class="line">Date data = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String dataStr = sdf.format(data);</span><br><span class="line">System.out.println(dataStr);</span><br></pre></td></tr></table></figure>

<p>以上代码，转换的结果是:2018-11-25 13:00:00，日期和时间格式由”日期 和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就 行了。</p>
<p>在 Java 中，可以使用 SimpleDateFormat 的 parse 方法，将一个 String 类型 转化成 Date 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String转Data </span></span><br><span class="line">System.out.println(sdf.parse(dataStr));</span><br></pre></td></tr></table></figure>


<h2 id="日期和时间模式表达方法"><a href="#日期和时间模式表达方法" class="headerlink" title="日期和时间模式表达方法"></a>日期和时间模式表达方法</h2><p>在使用 SimpleDateFormat 的时候，需要通过字母来描述时间元素，并组装成 想要的日期和时间模式。常用的时间元素和字母的对应表如下:</p>
<img src='https://oscimg.oschina.net/oscnet/up-80bd4dd81e9c6fb2f0fe9c3b5eae1cef2b8.png'>

<p>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表 示方法。</p>
<img src="https://oscimg.oschina.net/oscnet/up-0c95fadb15ae4ca6aedb2e8cb68ce7ec50b.png">


<h2 id="输出不同时区的时间"><a href="#输出不同时区的时间" class="headerlink" title="输出不同时区的时间"></a>输出不同时区的时间</h2><p>时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置(时 角)决定时间，这就使得不同经度的地方的时间有所不同(地方时)。1863 年，首次 使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p>
<p>世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日 出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p>
<p>现今全球共分为 24 个时区。由于实用上常常 1 个国家，或 1 个省份同时跨着 2 个或更多时区，为了照顾到行政上的方便，常将 1 个国家或 1 个省份划在一起。所以 时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差 不多跨 5 个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间 为准。</p>
<p>由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一 样，所以，在 Java 中想要获取时间的时候，要重点关注一下时区问题。<br>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获取中国的当前 时间的原因。</p>
<p>那么，如何在 Java 代码中获取不同时区的时间呢? SimpleDateFormat 可以 实现这个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>)); </span><br><span class="line">System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br></pre></td></tr></table></figure>

<p>以上代码，转换的结果是:2018-11-24 21:00:00 。既中国的时间是 11 月 25 日的 13 点，而美国洛杉矶时间比中国北京时间慢了 16 个小时(这还和冬夏令时有关 系，就不详细展开了)。</p>
<p>如果你感兴趣，你还可以尝试打印一下美国纽约时间(America/New_York)。 纽约时间是 2018-11-25 00:00:00。纽约时间比中国北京时间早了 13 个小时。</p>
<p>当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍 SimpleDate-Format，其他方法暂不介绍了。</p>
<h2 id="SimpleDateFormat-线程安全性"><a href="#SimpleDateFormat-线程安全性" class="headerlink" title="SimpleDateFormat 线程安全性"></a>SimpleDateFormat 线程安全性</h2><p>由于 SimpleDateFormat 比较常用，而且在一般情况下，一个应用中的时间显 示模式都是一样的，所以很多人愿意使用如下方式定义 SimpleDateFormat:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            simpleDateFormat.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">            System.out.println(simpleDateFormat.format(Calendar.getInstance().</span><br><span class="line">                    getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ 这种定义方式，存在很大的安全隐患。</p>
<p>我们来看一段代码，以下代码使用线程池来执行时间输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个全局的SimpleDateFormat</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用ThreadFactoryBuilder定义一个线程池</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">                ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个线程安全的 HashSet</span></span><br><span class="line">            Set&lt;String&gt; dates = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取当前时间</span></span><br><span class="line">                Calendar calendar = Calendar.getInstance();</span><br><span class="line">                <span class="keyword">int</span> finalI = i;</span><br><span class="line">                pool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 时间增加</span></span><br><span class="line">                    calendar.add(Calendar.DATE, finalI);</span><br><span class="line">        <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                    String dateString = simpleDateFormat.format(calendar.</span><br><span class="line">                            getTime());</span><br><span class="line">                    <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                    dates.add(dateString); </span><br><span class="line">                    <span class="comment">//countDown countDownLatch.countDown();</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞，直到 countDown 数量为 0 countDownLatch.await();</span></span><br><span class="line">        <span class="comment">// 输出去重后的时间个数 System.out.println(dates.size());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>以上代码，其实比较简单，很容易理解。就是循环一百次，每次循环的时候都在 当前时间基础上增加一个天数(这个天数随着循环次数而变化)，然后把所有日期放入 一个线程安全的、带有去重功能的 Set 中，然后输出 Set 中元素个数。</p>
<p>正常情况下，以上代码输出结果应该是 100。但是实际执行结果是一个小于 100 的数字。</p>
<p>原因就是因为 SimpleDateFormat 作为一个非线程安全的类，被当做了共享变 量在多个线程中进行使用，这就出现了线程安全问题。</p>
<h2 id="线程不安全原因"><a href="#线程不安全原因" class="headerlink" title="线程不安全原因"></a>线程不安全原因</h2><p>通过以上代码，我们发现了在并发场景中使用 SimpleDateFormat 会有线程安 全问题。其实，JDK 文档中已经明确表明了 SimpleDateFormat 不应该用在多线程 场景中:</p>
<blockquote>
<p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</blockquote>
<p>那么接下来分析下为什么会出现这种问题，SimpleDateFormat 底层到底是怎 么实现的?<br>我们跟一下 SimpleDateFormat 类中 format 方法的实现其实就能发现端倪。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from Format after creating a FieldDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="params"><span class="function">                                FieldDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Convert input date to time field list</span></span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = compiledPattern[i] &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> count = compiledPattern[i++] &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">255</span>) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                toAppendTo.append((<span class="keyword">char</span>)count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_CHARS:</span><br><span class="line">                toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">                i += count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SimpleDateFormat 中的 format 方法在执行过程中，会使用一个成员变量 calendar 来保存时间。这其实就是问题的关键。</p>
<p>由于我们在声明 SimpleDateFormat 的时候，使用的是 static 定义的。那么 这 个 SimpleDateFormat就是一个共享变量， 随 之，SimpleDateFormat 中 的 calendar 也就可以被多个线程访问到。</p>
<p>假设线程 1 刚刚执行完 calendar.setTime 把时间设置成 2018-11-11，还 没等执行完，线程 2 又执行了 calendar.setTime 把时间改成了 2018-12-12。 这时候线程 1 继续往下执行，拿到的 calendar.getTime 得到的时间就是线程 2 改 过之后的。</p>
<p>除了 format 方法以外，SimpleDateFormat 的 parse 方法也有同样的问题。 所以，不要把 SimpleDateFormat 作为一个共享变量使用。</p>
<h2 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="headerlink" title="如何解决线程安全问题"></a>如何解决线程安全问题</h2><ul>
<li>使用局部变量<br> 不要使用static</li>
<li>加同步锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// 获取当前时间</span></span><br><span class="line">           Calendar calendar = Calendar.getInstance();</span><br><span class="line">           <span class="keyword">int</span> finalI = i;</span><br><span class="line">           pool.execute(() -&gt; &#123;</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                   <span class="comment">// 时间增加</span></span><br><span class="line">                   calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                   <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                   String dateString = simpleDateFormat.format(calendar.getTime()); <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                   dates.add(dateString);</span><br><span class="line">                   <span class="comment">//countDown</span></span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以 只对 simpleDateFormat.format 这一行加锁，这样效率更高一些。</p>
<ul>
<li>使用 ThreadLocal<br> 第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以 得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 使用ThreadLocal定义一个全局的SimpleDateFormat */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 用法</span></span><br><span class="line">       String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure>

<p>用 ThreadLocal 来实现其实是有点类似于缓存的思路，每个线程都有一个独享 的对象，避免了频繁创建对象，也避免了多线程的竞争。</p>
<p>当然，以上代码也有改进空间，就是，其实 SimpleDateFormat 的创建过程可 以改为延迟加载。这里就不详细介绍了。</p>
<h2 id="使用-DateTimeFormatter"><a href="#使用-DateTimeFormatter" class="headerlink" title="使用 DateTimeFormatter"></a>使用 DateTimeFormatter</h2><p>如果是 Java8 应用，可以使用 DateTimeFormatter 代替 SimpleDateFormat， 这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析日期</span></span><br><span class="line">String dateStr = <span class="string">&quot;2016年10月25日&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">LocalDate date = LocalDate.parse(dateStr, formatter);</span><br><span class="line"><span class="comment">// 日期转换为字符串</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 hh:mm a&quot;</span>);</span><br><span class="line">String nowStr = now.format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本 文 介 绍 了 SimpleDateFormat 的 用 法，SimpleDateFormat 主 要 可 以 在 String 和 Date 之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场 景中 SimpleDateFormat 是不能保证线程安全的，需要开发者自己来保证其安全性。</p>
<p>主要的几个手段有改为局部变量、使用 synchronized 加锁、使用 Threadlocal 为每一个线程单独创建一个等。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-传统的BIO</title>
    <url>/wiki/Java-%E4%BC%A0%E7%BB%9F%E7%9A%84BIO/</url>
    <content><![CDATA[<h1 id="传统的BIO"><a href="#传统的BIO" class="headerlink" title="传统的BIO"></a>传统的BIO</h1><h2 id="Socket-和-ServerSocket"><a href="#Socket-和-ServerSocket" class="headerlink" title="Socket 和 ServerSocket"></a>Socket 和 ServerSocket</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">       <span class="comment">// 阻塞</span></span><br><span class="line">       Socket client = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">       InputStream inputStream = client.getInputStream();</span><br><span class="line"></span><br><span class="line">       BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">       <span class="comment">// 读阻塞</span></span><br><span class="line">       System.err.println(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>new ServerSocket(9090);</p>
</blockquote>
<p>这个java程序创建new ServerSocket(9090);会调用操作系统内核，也就是系统调用，<br>比如linux操作系统，应用进程也就是我们的java进程，会调用linux的内核方法，创建一个socket，在linux系统中就是一个文件描述符fd，最终对得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket() = XXfd</span><br><span class="line">bind(XXfd,9090)</span><br><span class="line">listen(XXfd)</span><br></pre></td></tr></table></figure>

<p><img src="https://sjwx.easydoc.xyz/47754217/files/kn1ecf3d.png" alt="image.png"></p>
<ul>
<li>socket 的read方法 ，读取客户端发送的数据，如果没有，则一直阻塞</li>
<li>serverSocket的accept方法，等待客户端的链接，如果没有链接，则一直阻塞等待</li>
<li>serverSocket 一次只能处理一个客户端请求</li>
</ul>
<h2 id="BIO程序有哪些弊端？"><a href="#BIO程序有哪些弊端？" class="headerlink" title="BIO程序有哪些弊端？"></a>BIO程序有哪些弊端？</h2><ul>
<li>服务端一次处理一个请求，并发非常低</li>
<li>没有客户端请求，服务端一直阻塞，占用资源</li>
</ul>
<h2 id="如果在bio的基础上，利用多线程处理客户端请求？"><a href="#如果在bio的基础上，利用多线程处理客户端请求？" class="headerlink" title="如果在bio的基础上，利用多线程处理客户端请求？"></a>如果在bio的基础上，利用多线程处理客户端请求？</h2><blockquote>
<p>d C10K问题 </p>
</blockquote>
<p><font color=red>来一个链接，服务端创建一个线程</font> ，去处理请求，服务端继续监听客户端，是不是可以增加并发？<br>有什么问题？</p>
<ul>
<li>线程消耗内存资源</li>
</ul>
<p>如果一下子过来10万个请求呢？<br>服务器要创建10万个线程，内存就崩了。</p>
<p>如果搞一个线程池呢？ 并发度最大为最大线程数？ 并发度已经定死了？</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-锁升级过程</title>
    <url>/wiki/Java-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><h2 id="使用JOL查看加锁之后的对象信息"><a href="#使用JOL查看加锁之后的对象信息" class="headerlink" title="使用JOL查看加锁之后的对象信息"></a>使用JOL查看加锁之后的对象信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           f0 b8 d0 <span class="number">0f</span> (<span class="number">11110000</span> <span class="number">10111000</span> <span class="number">11010000</span> <span class="number">00001111</span>) (<span class="number">265337072</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">70</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">01110000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">28672</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>


<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><blockquote>
<p>锁升级过程： new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-2f555289640d34755ca4288ab080906554b.png" width=750 height=450> 

<p><strong>自旋锁什么时候升级为重量级锁？</strong></p>
<p><strong>为什么有自旋锁还需要重量级锁？</strong></p>
<blockquote>
<p>自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗<br>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p>
</blockquote>
<p><strong>偏向锁是否一定比自旋锁效率高？</strong></p>
<blockquote>
<p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁<br>JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开</p>
</blockquote>
<h3 id="synchronized优化的过程和markword息息相关"><a href="#synchronized优化的过程和markword息息相关" class="headerlink" title="synchronized优化的过程和markword息息相关"></a>synchronized优化的过程和markword息息相关</h3><p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p>
<ol>
<li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p>
</li>
<li><p>o.hashCode()<br>001 + hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>little endian big endian </p>
<p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p>
</li>
<li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure></li>
<li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p>
</li>
<li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p>
</li>
<li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p>
</li>
<li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
</li>
</ol>
<p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)<br>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p>
<p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p>
<blockquote>
<p><strong>轻量级锁重量级锁的hashCode存在与什么地方？</strong><br>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
</blockquote>
<p>关于epoch: (不重要)</p>
<blockquote>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
</blockquote>
<p>没错，我就是厕所所长</p>
<p>加锁，指的是锁定对象</p>
<p>锁升级的过程</p>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
<p>现代版本进行了优化</p>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
<p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-锁消除和锁膨胀</title>
    <url>/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/</url>
    <content><![CDATA[<h1 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h1><h2 id="锁消除-（lock-eliminate）"><a href="#锁消除-（lock-eliminate）" class="headerlink" title="锁消除 （lock eliminate）"></a>锁消除 （lock eliminate）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h2 id="锁粗化-（lock-coarsening）"><a href="#锁粗化-（lock-coarsening）" class="headerlink" title="锁粗化 （lock coarsening）"></a>锁粗化 （lock coarsening）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p><a href="https://www.zhihu.com/question/63859501">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="首先需要思考什么是JMM，以及为什么会有JMM。"><a href="#首先需要思考什么是JMM，以及为什么会有JMM。" class="headerlink" title="首先需要思考什么是JMM，以及为什么会有JMM。"></a>首先需要思考什么是JMM，以及为什么会有JMM。</h2><blockquote>
<p>Java Memory Model简称JMM, 是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。(可能在术语上与Java运行时内存分布有歧义，后者指堆、方法区、线程栈等内存区域)。</p>
</blockquote>
<p> <strong>JMM规范的内容</strong>  </p>
<ul>
<li>1.所有变量存储在主内存  </li>
<li>2.主内存是虚拟机内存的一部分</li>
<li>3.每条线程有自己的工作内存</li>
<li>4.线程的工作内存保存变量的主内存副本</li>
<li>5.线程对变量的操作必须在工作内存中进行</li>
<li>6.不同线程之间无法直接访问对方工作内存中的变量</li>
<li>7.线程间变量值的传递均需要通过主内存来完成</li>
</ul>
<p>JMM并不是一个客观存在的东西，它实际是为了规范Java虚拟机制定到一套标准。那为什么需要这套标准呢？ </p>
<p> 其实我们都知道JVM是运行在操作系统之上的。而目前的操作系统都是基于冯诺伊曼设置的计算机系统体系来的。CPU是计算机中用来执行控制和计算的核心组建，<br>所有的计算任务全部在CPU中完成，但是我们的所有变量的数据全部存储在主内存中。CPU在执行计算时，需要去主内存加载数据，CPU执行运算的速度极快，<br>这就设计一个CPU执行速度和数据加载速度不一致的问题。   </p>
<img src= "https://user-gold-cdn.xitu.io/2018/2/7/1616dcd4cfc4f98c?imageView2/0/w/1280/h/960/ignore-error/1" width = "400" height = "500" />      

<p> 在操作系统级别解决这个问题的办法是引入了CPU缓存。每个CPU都有自己私有的L1缓存和L2缓存，当执行计算时，会优先去CPU自己的缓存中寻找数据，<br>没有的话才会重新加载内存数据。这种方式一定程度上解决了CPU计算和数据加载不一致的问题。    </p>
<p><strong>但是也会引入一个新的问题，就是数据一致性问题。</strong>  </p>
<h2 id="缓存一致性与MESI协议"><a href="#缓存一致性与MESI协议" class="headerlink" title="缓存一致性与MESI协议"></a>缓存一致性与MESI协议</h2><p><strong>首先看一下什么是MESI协议</strong>  </p>
<blockquote>
<p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），<br>用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p>
</blockquote>
<ul>
<li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li>
<li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li>
<li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li>
<li>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。</li>
</ul>
<p>如何解决缓存一致性问题呢？<br><img src="http://www.wowotech.net/content/uploadfile/201411/e35f2f4793d734a566d1d230d1b83b4620141114112002.gif">  </p>
<p>如上图所示，共享变量是存储在主内存Memory中，在CPU计算时，每一个CPU都有改变量的独立拷贝，每个CPU可以去读取甚至修改共享变量的值，<br>但是为了保证数据的一致性，一个CPU modify了变量的值，需要通知其他的CPU这个变量的最新值是什么。那么可以怎么做呢。</p>
<ul>
<li><p>在初始状态，每个CPU还没有加载共享变量，所有每一个CPU的缓存行的状态都是invalid；  </p>
</li>
<li><p>当CPU0去使用这个共享变量的时候，首先去自己的缓存中查找，肯定是缓存不命中的，也就是cache miss,这个时候去主内存Memory中去加载，<br>当共享变量的值加载到CPU0的缓存后，CPU缓存行状态变成shared,也就是共享状态；  </p>
</li>
<li><p>如果这个时候有其他的CPU也读取了共享变量的值，它们的cache line 的状态同样也是shared共享状态；此时一个CPU如果修改共享变量的值，<br>而没有通知其他的CPU,就会造成缓存一致性问题；</p>
</li>
<li><p>当CPU0尝试去修改共享变量的值时，它会发出一个read invalidate命令，同时CPU0的缓存行状态设置为exclusive(独占),<br>同时将其他加载了这个共享变量的cacheline的状态设置为invalid。通俗一点就是CPU0独占的这个变量的缓存行，其他的CPU缓存的共享变量都失效了； </p>
</li>
<li><p>CPU0接下来修改共享变量的值，它会将cacheline的状态修改为modified,其实也是独占共享变量的cacheline，<br>只不过是此时缓存行的数据和主内存Memory的数据不一致的，而exclusive虽然也是独占状态，但是共享变量的值是一样的，<br>modified的值需要write back到Memory中去的，而exclusive是不需要的； </p>
</li>
<li><p>在cacheline没有替换出CPU0的cache之前，当有其他CPU来读取共享变量，此时肯定是cache miss ,因为CPU0的modify操作已经将它的缓存失效了。<br>如果CPU0的状态是modified状态，它必须响应其他CPU的读操作，会告知其他CPU主内存的数据是dirty data。所以其他的CPU的状态可能会变成shared。<br>如果CPU0还没有write back操作，其他的CPU状态还是invalid状态。</p>
</li>
</ul>
<h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>正如上面所描述的，在CPU0进行共享变量的修改，会同步修改其他CPU的cacheline状态为invalid，这个操作是和共享变量的写操作同步进行的，因此共享变量的写操作的性能是非常差的。在修改其他的CPU cacheline状态时，CPU0其实是处于阻塞状态的。所以为了优化这个问题，提出了Store Buffer的解决方案。</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201411/a872a1863fec02585bb786a5c382d3eb20141114112005.gif"></p>
<p>这样的话，写操作不必等到cacheline被加载，而是直接写到store buffer中，然后去执行后续的操作。由于是store buffer相当于是异步处理，<br>在这里可能会出现因为并发执行导致的执行执行交叉问题，具体解决方法是依赖于内存屏障。<br>具体可以参考这篇文章：<a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html">Linux内核同步机制之（三）：memory barrier</a>  </p>
<h3 id="Invalidate-Queue"><a href="#Invalidate-Queue" class="headerlink" title="Invalidate Queue"></a>Invalidate Queue</h3><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。<br>为了解决上面两个问题，引进了失效队列（invalidate queue）。处理失效的工作如下：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201411/46e1bbd0ba094941caf23050e1db2d2d20141114112008.gif"></p>
<ul>
<li>收到失效消息时，放到失效队列中去。</li>
<li>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。</li>
<li>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</li>
</ul>
<h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens- before原则"></a>happens- before原则</h2><blockquote>
<p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：    </p>
</blockquote>
<p>1、单线程每个操作，happen-before于该线程中任意后续操作；<br>2、volatile写happen-before与后续对这个变量的读；<br>3、synchronized解锁happen-before后续对这个锁的加锁；<br>4、final变量的写happen-before于final域对象的读，happen-before后续对final变量的读；<br>5、传递性规则，A先于B，B先于C，那么A一定先于C发生；  </p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/wiki/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><blockquote>
<p>反向探知，在程序运行是动态的获取类的相关属性<br>这种动态获取类的内容以及动态调用对象的方法和获取属性的机制，叫做java反射机制；</p>
</blockquote>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><blockquote>
<p>优点<br>增加了程序的灵活性，避免的固有逻辑写死到程序中<br>代码简介，提高程序的复用性</p>
</blockquote>
<blockquote>
<p>缺点<br>相比于直接调用，反射有比较大的性能消耗<br>内部暴露和安全隐患  （因为反射可以操作private成员变量和调用private成员方法）</p>
</blockquote>
<h3 id="反射的基本操作"><a href="#反射的基本操作" class="headerlink" title="反射的基本操作"></a>反射的基本操作</h3><h4 id="获取类对象的4种方式"><a href="#获取类对象的4种方式" class="headerlink" title="获取类对象的4种方式"></a>获取类对象的4种方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用forName方法得到一个对象，这也是最容易想到的方式</span><br><span class="line">Class&lt;?&gt; object = Class.forName(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">// 通过实例对象调用getClass方法</span><br><span class="line">Teacher teacher = new Teacher();</span><br><span class="line">Class&lt;?&gt; objectT = teacher.getClass();</span><br><span class="line"></span><br><span class="line">// 通过类加载器的方式</span><br><span class="line">Class&lt;?&gt; loader = ClassLoader.getSystemClassLoader().loadClass(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">//通过一个类.class</span><br><span class="line">Class&lt;?&gt; tt = Teacher.class;</span><br></pre></td></tr></table></figure>

<h4 id="基本信息操作"><a href="#基本信息操作" class="headerlink" title="基本信息操作"></a>基本信息操作</h4><table>
<thead>
<tr>
<th align="center">类修饰符</th>
<th align="center">PUBLIC</th>
<th align="center">PRIVATE</th>
<th align="center">PROTECTED</th>
<th align="center">STATIC</th>
<th align="center">FINAL</th>
<th align="center">SYNCHRONIZED</th>
<th align="center">VOLATILE</th>
<th align="center">TRANSIENT</th>
<th align="center">NATIVE</th>
<th align="center">INTERFACE</th>
<th align="center">ABSTRACT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">modifiers</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">128</td>
<td align="center">256</td>
<td align="center">512</td>
<td align="center">1024</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类的修饰符 具体的值可以参考JDK API文档中的定义 返回值是int类型  public：1</span><br><span class="line">System.err.println(tt.getModifiers());</span><br><span class="line">// 包名</span><br><span class="line">System.err.println(tt.getPackage());</span><br><span class="line">// 类的名称</span><br><span class="line">System.err.println(tt.getName());</span><br><span class="line">// 父类</span><br><span class="line">System.err.println(tt.getSuperclass());</span><br><span class="line">// 类加载器</span><br><span class="line">System.err.println(tt.getClassLoader());</span><br><span class="line">// 简称</span><br><span class="line">System.err.println(tt.getSimpleName());</span><br><span class="line">// 类实现的所有的接口</span><br><span class="line">System.err.println(tt.getInterfaces().length);</span><br><span class="line">// 所有的注解类型</span><br><span class="line">System.err.println(tt.getAnnotations().length);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">package com.ibli.javaBase.reflection</span><br><span class="line">com.ibli.javaBase.reflection.Teacher</span><br><span class="line">class java.lang.Object</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Teacher</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h4 id="查看类的变量"><a href="#查看类的变量" class="headerlink" title="查看类的变量"></a>查看类的变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// User extend Person(aa,bb)</span><br><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 能够拿到类的所有的变量</span><br><span class="line">Field[] fields = obj.getDeclaredFields();</span><br><span class="line">for (Field field : fields)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;    &quot;);</span><br><span class="line"></span><br><span class="line">// 只能够拿到类的public的变量</span><br><span class="line">Field[] fields1 = obj.getFields();</span><br><span class="line">for (Field field : fields1)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;     &quot;);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 age</span><br><span class="line">2 name</span><br><span class="line">1 sex</span><br><span class="line">10 height</span><br><span class="line">    </span><br><span class="line">1 sex</span><br><span class="line">1 aa</span><br><span class="line">1 bb</span><br></pre></td></tr></table></figure>
<p>结论：  </p>
<ul>
<li>getDeclaredFields<br>（1）getDeclaredFields能够获取本类的所有成员变量，无论是public还是private;<br>（2）但是不能获取父类的任何属性；<br>（3）可以获取static类型的属性；</li>
<li>getFields<br>（1）只能够获取本类的public属性；<br>（2）能够获取父类的public属性；<br>（3）可以获取static类型的属性；  </li>
</ul>
<h4 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置Person中的变量aa</span><br><span class="line">Field aaField = obj.getField(&quot;aa&quot;);</span><br><span class="line">aaField.setInt(user,111);</span><br><span class="line">System.err.println(user.getAa());</span><br><span class="line"></span><br><span class="line">// 设置User私有成员变量</span><br><span class="line">Field ageField = obj.getDeclaredField(&quot;age&quot;);</span><br><span class="line">// 设置访问权限</span><br><span class="line">ageField.setAccessible(true);</span><br><span class="line">ageField.set(user,333);</span><br><span class="line">System.err.println(user.getAge());</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111</span><br><span class="line">333</span><br></pre></td></tr></table></figure>


<h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line"></span><br><span class="line">// 可以获取父类的方法</span><br><span class="line">Method[] methods = obj.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; -----  &quot;);</span><br><span class="line"></span><br><span class="line">// 获取本类中的所有方法</span><br><span class="line">Method[] methods1 = obj.getDeclaredMethods();</span><br><span class="line">for (Method method : methods1) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; 。。。。。。 &quot;);</span><br><span class="line">// 执行结果就不展示了</span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li>getDeclaredMethods<br>（1）可以获取本类中的所有方法；<br>（2）可以获取本类的静态方法</li>
<li>getMethods<br>（1）可以获取本类中的所有==公有==方法；<br>（2）可以获取父类中的所有==公有==方法；<br>（3）可以获取本类和父类的公有静态方法；</li>
</ul>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 访问私有方法</span><br><span class="line">Method sleep = obj.getDeclaredMethod(&quot;sleep&quot;);</span><br><span class="line">sleep.setAccessible(true);</span><br><span class="line">sleep.invoke(user);</span><br><span class="line"></span><br><span class="line">// 如果是静态方法，invoke第一个参数传null即可</span><br><span class="line">Method say = obj.getDeclaredMethod(&quot;say&quot;,String.class);</span><br><span class="line">say.setAccessible(true);</span><br><span class="line">say.invoke(null,&quot;hello java&quot;);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Im sleeping!</span><br><span class="line">say hello java</span><br></pre></td></tr></table></figure>


<h4 id="构造器的使用"><a href="#构造器的使用" class="headerlink" title="构造器的使用"></a>构造器的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">// 查询共有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors = obj.getConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors)&#123;</span><br><span class="line">    System.out.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以获取私有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors1 = obj.getDeclaredConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors1)&#123;</span><br><span class="line">    System.err.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line"></span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">2   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>getConstructors<br>（1）获得本类所有的公有构造器  </li>
<li>getDeclaredConstructors<br>（1）获得本类所有的构造器（public&amp;private）  </li>
</ul>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用newInstance创建对象 调用无参构造器</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 获取构造器来实例化对象</span><br><span class="line">Constructor&lt;User&gt; constructor = obj.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">User temp = constructor.newInstance(22, &quot;java&quot;);</span><br><span class="line">System.err.println(temp.getAge() + &quot; &quot; + temp.getName());</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>22 java</p>
</blockquote>
<h3 id="反射性能为什么差"><a href="#反射性能为什么差" class="headerlink" title="反射性能为什么差"></a>反射性能为什么差</h3><blockquote>
<p>可以从两方面考虑，第一个是反射生成Class对象时性能差，第二是通过反射调用对象方式是的性能差；</p>
</blockquote>
<p>（1） 调用forName 本地方法<br>（2）每次newInstance 都会进行一次安全检查<br>（3）在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p>
<p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的Object数组   </li>
<li>基本类型的自动装箱、拆箱  (参考资料2)</li>
<li>还有最重要的方法内联。</li>
</ul>
<blockquote>
<p>参考资料<br>(1)<a href="https://blog.csdn.net/xqlovetyj/article/details/82798864">反射为什么慢</a><br>(2)<a href="https://blog.csdn.net/Admin_Jhon/article/details/52873468?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf">关于装箱拆箱为什么会影响效率</a><br>(3)<a href="https://zhuanlan.zhihu.com/p/55630861">jvm之方法内联优化</a></p>
</blockquote>
<h3 id="反射使用的场景"><a href="#反射使用的场景" class="headerlink" title="反射使用的场景"></a>反射使用的场景</h3><ul>
<li>JDBC封装    </li>
<li>Spring IOC</li>
<li>jdbcTemplate</li>
<li>Mybatis使用大量反射</li>
</ul>
<h3 id="使用反射注意点"><a href="#使用反射注意点" class="headerlink" title="使用反射注意点"></a>使用反射注意点</h3><ul>
<li>在获取Field,method,construtor的时候，应尽量避免是用getDelcaredXXX(),应该传进参数获取指定的字段，方法和构造器；</li>
<li>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的</li>
</ul>
<blockquote>
<p align="middle"> ---------------------   前途浩浩荡荡 万事尽可期待。-----------------------  </p>
</blockquote>
<h3 id="反射在IOC中的应用"><a href="#反射在IOC中的应用" class="headerlink" title="反射在IOC中的应用"></a>反射在IOC中的应用</h3>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <url>/wiki/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<h2 id="ThreadLocalMap结构"><a href="#ThreadLocalMap结构" class="headerlink" title="ThreadLocalMap结构"></a>ThreadLocalMap结构</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b45487065b90?imageView2/0/w/1280/h/960/ignore-error/1'>




<h2 id="ThreadLocal-set流程"><a href="#ThreadLocal-set流程" class="headerlink" title="ThreadLocal set流程"></a>ThreadLocal set流程</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b454879fe57d?imageView2/0/w/1280/h/960/ignore-error/1'>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://juejin.cn/post/6854573219916021767">Java面试必问：ThreadLocal终极篇 </a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-多线程的发展和意义</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<h1 id="线程基础概念"><a href="#线程基础概念" class="headerlink" title="线程基础概念"></a>线程基础概念</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是CPU执行任务的基本单位，一个进程中包含一个或者多个线程，一个进程内的多个线程共享进程的资源，每一个线程有自己的独立内存，是线程不共享的。</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><ul>
<li>并行<br> 同一时刻，横向有多少个线程可以运行</li>
<li>并发<br> 系统和服务器同一时刻能够承受的并发线程</li>
</ul>
<h2 id="线程的特征"><a href="#线程的特征" class="headerlink" title="线程的特征"></a>线程的特征</h2><ul>
<li>异步（不需要等待）<br> 比如说注册之后发送验证码，验证码的过程可以异步去做不需要客户去在注册接口等待这个时间；</li>
<li>并行（CPU核数）   </li>
</ul>
<h2 id="Java中线程的使用"><a href="#Java中线程的使用" class="headerlink" title="Java中线程的使用"></a>Java中线程的使用</h2><ul>
<li>继承Thread</li>
<li>实现Runnalbe</li>
<li>实现Callable/Future</li>
</ul>
<h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="title">extend</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">      b = a + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行start方法，其实是调用JVM相关的指令， thread.cpp</p>
<blockquote>
<p>java thread.start() -&gt; cpp thread.start() -&gt; os指令:create.thread    start.thread<br>操作系统层面会创建线程，线程创建之后，线程可以启动，（线程启动之后并不一定马上执行）这些线程统一有CPU调度算法来处理；决定那个线程分配给那个执行CPU；<br>CPU执行线程任务的时候，会调用run方法 -&gt; cpp run方法  -&gt; java  thread.run()</p>
</blockquote>
<img src='https://oscimg.oschina.net/oscnet/up-9147a0440e839bc9946fc87147e97b7c793.png' whith=600 height=380>

<p>⚠️ CompletableFuture 异步回调通知，基于Future的优化 </p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程创建，当线程中的指令执行完成之后，run（）结束 线程销毁<br>其他线程状态</p>
<ul>
<li>等待状态 （sleep join wait）</li>
<li>锁阻塞状态 （blocked 竞争锁失败 park）</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-dc87c94066283689df31680050c67edd7b1.png" width=500 height=450>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStatusDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;time waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStatusDemo.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ThreadStatusDemo.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BlockDemo.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>查看线程状态</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<h2 id="线程如何停止"><a href="#线程如何停止" class="headerlink" title="线程如何停止"></a>线程如何停止</h2><p>interrupt() 停止线程<br>主动停止方式 -&gt; run方法执行结束<br>被动停止方式</p>
<p>一般中断线程是在无法控制线程的情况下，比如线程wait ， 线程sleep ， 线程while(true)<br><code>Thread.currnetThread().isInterrupted()</code></p>
<blockquote>
<p>stop方法停止线程 禁止使用 相当于kill线程 不友好</p>
</blockquote>
<p>interrupt 功能</p>
<ul>
<li>唤醒阻塞状态的线程</li>
<li>修改中断标志，false -&gt; true</li>
</ul>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象头</title>
    <url>/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><h2 id="JOL查看对象头信息"><a href="#JOL查看对象头信息" class="headerlink" title="JOL查看对象头信息"></a>JOL查看对象头信息</h2><p>在项目中引入以下依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>写一个main方法，创建一个Object，然后打印对象信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>由此可知，new Object()在内存中占16个字节，组成部分8字节的markword+4字节的class point+4字节的对齐；</p>
<h2 id="Java对象在内存中的布局"><a href="#Java对象在内存中的布局" class="headerlink" title="Java对象在内存中的布局"></a>Java对象在内存中的布局</h2><image src="https://oscimg.oschina.net/oscnet/up-056ef14e62f5dfde1a5af579dabeb6e4c2a.png" width=250 height=420>

<ul>
<li>markword<blockquote>
<p>存储sync锁标志，分代年龄等一些关键信息 8字节</p>
</blockquote>
</li>
<li>class pointer<blockquote>
<p>指向当前对象所属类类型 4字节</p>
</blockquote>
</li>
</ul>
<p><strong>查看java命令默认带的参数命令：</strong> java -XX:+PrintCommandLineFlags -version </p>
<blockquote>
<p>-XX:InitialHeapSize=134217728<br>-XX:MaxHeapSize=2147483648<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers 压缩类指针 4字节<br>-XX:+UseCompressedOops 普通对象指针压缩 4字节<br>-XX:+UseParallelGC</p>
</blockquote>
<ul>
<li>instance data<blockquote>
<p>寸尺当前对象的实例数据</p>
</blockquote>
</li>
<li>padding<blockquote>
<p>对齐填充，当对象所占字节数不能被8整除之后，进行填充对齐。 目前的操作系统基本上都是64位的；</p>
</blockquote>
</li>
</ul>
<h2 id="顺丰面试题，new-Object-在内存中占多少个字节"><a href="#顺丰面试题，new-Object-在内存中占多少个字节" class="headerlink" title="顺丰面试题，new Object()在内存中占多少个字节"></a>顺丰面试题，new Object()在内存中占多少个字节</h2><p>1、如果创建的是空对象，没有实例数据</p>
<ul>
<li>默认开启了class pointer指针压缩<blockquote>
<p>8字节markword + 4字节class pointer + 4字节 padding</p>
</blockquote>
</li>
<li>如果关闭了类指针压缩<blockquote>
<p>8字节markword + 8字节class pointer</p>
</blockquote>
</li>
</ul>
<p>2、如果创建的对象有实力数据，如下对象：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person（int age , String name）</span><br></pre></td></tr></table></figure></p>
<ul>
<li>默认开启了class pointer指针压缩<blockquote>
<p>8字节markword + 4字节class pointer + 4字节int + 4字节String + 4字节padding对齐</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之同步锁</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-Overview</title>
    <url>/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Overview/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/wiki/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h2 id="1、泛型定义"><a href="#1、泛型定义" class="headerlink" title="1、泛型定义"></a>1、泛型定义</h2><blockquote>
<p>使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后在进行强制类型转换的代码具有更好的安全性和可读性。  –《Java核心技术》  </p>
</blockquote>
<p>泛型是在编译时期作用的；</p>
<p>泛型变量使用大写形式，在Java库中，一般使用变量E表示集合的元素类型，K和V表示表的关键字与值的类型。</p>
<h2 id="2、通配符"><a href="#2、通配符" class="headerlink" title="2、通配符"></a>2、通配符</h2><h3 id="2-1-无边界通配符"><a href="#2-1-无边界通配符" class="headerlink" title="2.1 无边界通配符"></a>2.1 无边界通配符</h3><p>无边界通配符又成为非限定通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-上边界通配符"><a href="#2-2-上边界通配符" class="headerlink" title="2.2 上边界通配符"></a>2.2 上边界通配符</h3><p>上边界通配符和下边界通配符都属于限定通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List中的类型必须是Number的子类，不然会报编译错误</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传进来的list的类型必须是Number或Number的子类才可以</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>? extends Number<br>如果限定的类型有多个，之间使用 &amp; 进行分割</p>
</blockquote>
<h3 id="2-3-下边界通配符"><a href="#2-3-下边界通配符" class="headerlink" title="2.3 下边界通配符"></a>2.3 下边界通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List的泛型是Number 添加的元素只要是Number下的类型就可以</span></span><br><span class="line">        List&lt;Number&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2L</span>);</span><br><span class="line">        list1.add(<span class="keyword">new</span> BigDecimal(<span class="number">22</span>));</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用类型必须是Number到Object之间的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、泛型的使用"><a href="#3、泛型的使用" class="headerlink" title="3、泛型的使用"></a>3、泛型的使用</h2><blockquote>
<p>泛型必须先声明，再使用，不然会有编译错误；<br>泛型的声明是用过一对&lt;&gt;来完成，约定使用一个大写的字母来表示;<br>通配符不能用作返回值;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testA</span><span class="params">(T t, Test1&lt;T&gt; test1)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是传入的T:&quot;</span> + t);</span><br><span class="line">    t = test1.t;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是赋值后的T:&quot;</span> + t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要从泛型类取数据时，用extends；</li>
<li>要往泛型类写数据时，用super；</li>
<li>既要取又要写，就不用通配符（即extends与super都不用）。</li>
</ul>
<h3 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;K&gt; <span class="function">K <span class="title">test</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-泛型方法"><a href="#3-2-泛型方法" class="headerlink" title="3.2 泛型方法"></a>3.2 泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest4</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;T&gt; 代表泛型的声明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t   本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的泛型方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k   类中定义的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;X&gt; 本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X&gt; <span class="function">X <span class="title">aa</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (X) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法中是无法使用类中声明的泛型类型的</span></span><br><span class="line"><span class="comment">     * 可以使用在本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;X&gt; <span class="function">X <span class="title">bb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-泛型接口"><a href="#3-3-泛型接口" class="headerlink" title="3.3 泛型接口"></a>3.3 泛型接口</h3><p>首先看一下不使用泛型接口的Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先定义接口，声明两个方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">aa</span><span class="params">(Integer a)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Integer <span class="title">bb</span><span class="params">(Integer b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后创建一个类来实现方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo</span> <span class="keyword">implements</span> <span class="title">IGeneric</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是没有使用泛型的接口设计，但是aa方法的操作类型相当于在接口中写死了，如果此时我们需要一个String类型的aa方法，那是不是还要在声明一个String类型的接口，然后再去实现呢，这样是不是显得代码很臃肿，代码重复；<br>所以我们可以看一下使用泛型之后是怎么样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义泛型接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面是根据不同类型的实现类</span><br><span class="line">泛型传如Integer类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericInteger</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型传入String类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericString</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aa</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bb</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4、泛型擦除"><a href="#4、泛型擦除" class="headerlink" title="4、泛型擦除"></a>4、泛型擦除</h2><p>在虚拟机上没有泛型类型对象，所有的对象都属于普通类。Java在处理泛型类型的时候，会处理成一个相应的原始类型。  擦除类型变量，并替换为限定类型，如果没有限定类型，默认使用Object替代。如果有限定类型，并且是多个，会使用第一个限定的类型来替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这个T是一个无限定的变量，泛型擦除之后会直接使用Object替换。<br>当然调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ....</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>
<p>擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换，也就是说，编译器调用方法是其实是执行了一下两个虚拟机指令：</p>
<ul>
<li>对原始方法Pair.getFirst()方法的调用</li>
<li>将返回的Object类型强制转换为Employee类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">foo</span><span class="params">(T [] args)</span></span></span><br></pre></td></tr></table></figure>
<p>在擦除类型之后变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable T <span class="title">foo</span><span class="params">(Comparable [] args)</span></span></span><br></pre></td></tr></table></figure>
<p>参数类型T已经被擦除，只留下限定类型Comparable;</p>
<blockquote>
<p>总之有关Java泛型转换的事实：</p>
<ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都用它们的限定类型替换</li>
<li>==桥方法被合成来保证多态==</li>
<li>为了保持类型安全型，必要时插入强制类型转换</li>
</ul>
</blockquote>
<p>第一条应该很好理解，这也是为什么会有泛型擦除这个概念，是因为JVM不能操作泛型；<br>第二条就是解释泛型如何进行类型的擦除；<br>第三条是泛型方法可能与多态的理念矛盾，所以使用桥方法来过渡或兼容；<br>第四条上面也有提到，会出现强制类型转换的情况；  </p>
<h2 id="5、泛型的约束与局限性"><a href="#5、泛型的约束与局限性" class="headerlink" title="5、泛型的约束与局限性"></a>5、泛型的约束与局限性</h2><p>当然泛型的设计在java中并没有那么完美，它确实可以解决代码结构重用等问题，但是也是有一些局限性，下面是我根据《Java核心技术》进行的总结：</p>
<h3 id="5-1-不能使用基础数据类型实例化类型参数"><a href="#5-1-不能使用基础数据类型实例化类型参数" class="headerlink" title="5.1 不能使用基础数据类型实例化类型参数"></a>5.1 不能使用基础数据类型实例化类型参数</h3><p>原因是类型擦除之后，如果使用Object原始类型，Object是无法存储基本数据类型的值。所以只能通过其包装类型声明；</p>
<h3 id="5-2-运行时查询类型只适用与原始类型"><a href="#5-2-运行时查询类型只适用与原始类型" class="headerlink" title="5.2 运行时查询类型只适用与原始类型"></a>5.2 运行时查询类型只适用与原始类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest5</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoTest5&lt;String&gt; demoTest5 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        DemoTest5&lt;Integer&gt; demoTest4 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        System.err.println(demoTest4.getClass().equals(demoTest5.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demoTest4.getClass().equals(demoTest5.getClass())其实比较的是DemoTest5这个类类型，我们输出一下demoTest4.getClass()的结果看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class com.ibli.javaBase.generics.DemoTest5</span><br></pre></td></tr></table></figure>
<p>所以这里有一道非常经典的面试题，<a href="https://blog.csdn.net/IBLiplus/article/details/108672223">如何判断一个泛型他的具体类型是什么，这里我们可以使用反射去拿到泛型的具体类型；</a></p>
<h3 id="5-3-不能创造参数化类型的数组"><a href="#5-3-不能创造参数化类型的数组" class="headerlink" title="5.3 不能创造参数化类型的数组"></a>5.3 不能创造参数化类型的数组</h3><p>对于参数化类型的数组，在类型擦除之后，会变成Object[]类型，如果此时试图存储一个String类型的元素，就会抛出一个Array-StoreException异常；<br>主要目的还是处于到数组安全的保护，可以参考几篇文章:  </p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/ask/195960">1、如果Java不支持参数化类型数组，那么Arrays.asList()如何处理它们？</a><br><a href="https://blog.csdn.net/qq_41286138/article/details/105250938">2、java不能创建参数化类型的泛型数组</a><br><a href="https://www.cnblogs.com/shuilangyizu/p/5916402.html">3、java.lang.ArrayStoreException</a></p>
</blockquote>
<h3 id="5-4-Varargs警告"><a href="#5-4-Varargs警告" class="headerlink" title="5.4 Varargs警告"></a>5.4 Varargs警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例的场景，编译器会发出警告！<br>抑制这种警告的方式有两种：</p>
<ul>
<li>在调用方法上增加注解@SuppressWarnings(“unchecked”)</li>
<li>还可以使用@SafeVarargs注解直接标注方法<blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_41286138/article/details/105250938">java不能创建参数化类型的泛型数组</a>  </p>
</blockquote>
</li>
</ul>
<h3 id="5-5-不能实例化类型变量"><a href="#5-5-不能实例化类型变量" class="headerlink" title="5.5 不能实例化类型变量"></a>5.5 不能实例化类型变量</h3><p>不能使用new T(..) 或则new T[…]和T.class这样的表达式的类型变量；因为类型擦除后，T变成Object，显然我们在这里并不是想要创建一个Object实例。解决办法是在调用者提供一个构造器表达式，下面是用Supplier函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T first;</span><br><span class="line">        <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cannot infer type arguments for Pair2&lt;&gt;</span></span><br><span class="line"><span class="comment">         * 当函数头返回值为Pair时,无法推断,改为Pair2后可以推断.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> c1</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Class&lt;T&gt; c1)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c1.newInstance(),c1.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Supplier是一个函数接口，返回一个无参数并且返回类型为T的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMakePair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.接受Supplier&lt;T&gt;--它是一个函数式接口。表示无参数且返回类型为T的函数。</span></span><br><span class="line"><span class="comment">         * 因为不能实例化类型变量，如：</span></span><br><span class="line"><span class="comment">         * public Pair() &#123;first = new T();second = new T();&#125;</span></span><br><span class="line"><span class="comment">         * 所以最好的方式是让调用者提供一个构造器表达式.形式如下:</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> constr</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair = Pair.build(String::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(pair.getFirst().length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public void buildT()&#123;</span></span><br><span class="line"><span class="comment">         2.传统的方式是通过Class.newInstance方法来构造泛型对象.</span></span><br><span class="line"><span class="comment">         但由于细节过于复杂,T.class是不合法的.它会被擦除为Object.class.如下:</span></span><br><span class="line"><span class="comment">         Illegal class literal for the type parameter T</span></span><br><span class="line"><span class="comment">         T.class.newInstance();</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         * 3.</span></span><br><span class="line"><span class="comment">         * T.class是不合法的,但若API涉及如下</span></span><br><span class="line"><span class="comment">         * reason:因为String.class是Class&lt;String&gt;的一个实例.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair1 = Pair.build(String.class);</span><br><span class="line">        System.out.println(pair1.getFirst().length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="5-6-不能构造泛型数组"><a href="#5-6-不能构造泛型数组" class="headerlink" title="5.6 不能构造泛型数组"></a>5.6 不能构造泛型数组</h3><p>就像不能实例化一个泛型实例一样，也不能实例化数组。数组本身也有类型，用来监控存储在JVM中的数组，这个类型会被擦除，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] foo(T[] a)&#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除，会让这个方法永远构造Comparabel[2]数组；</p>
<h3 id="5-7-泛型类的静态上下文中类型变量无效"><a href="#5-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="5.7 泛型类的静态上下文中类型变量无效"></a>5.7 泛型类的静态上下文中类型变量无效</h3><p>这个应该是比较好理解的，上文也提到过了，泛型类型是作用在泛型类上的，一些静态的方法或这静态的属性不能够使用泛型类的变量类型，编译器会直接报错；</p>
<h3 id="5-8-不能抛出或者捕获泛型类的实例"><a href="#5-8-不能抛出或者捕获泛型类的实例" class="headerlink" title="5.8 不能抛出或者捕获泛型类的实例"></a>5.8 不能抛出或者捕获泛型类的实例</h3><p>Java既不能抛出也不能捕获泛型类对象，实际上，甚至泛型类扩展Throwable都是不合法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (T ex)&#123;  此处无法捕获    <span class="keyword">catch</span>必须捕获具体的异常</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在异常规范中使用类型变量是允许的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex)&#123;  </span><br><span class="line">        t.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-9-可以消除对受查异常的检查"><a href="#5-9-可以消除对受查异常的检查" class="headerlink" title="5.9 可以消除对受查异常的检查"></a>5.9 可以消除对受查异常的检查</h3><p>Java异常处理要求必须为所有的受查异常提供一个处理器，但是使用泛型，可以规避这一点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的方法，编译器会认为t是一个非受查异常;</p>
<h3 id="5-10-注意擦除后的冲突"><a href="#5-10-注意擦除后的冲突" class="headerlink" title="5.10 注意擦除后的冲突"></a>5.10 注意擦除后的冲突</h3><p>比如一个泛型类的equals方法，擦除之后，和Object的equals冲突；解决办法是重新命名引发错误的方法；</p>
<h2 id="6、泛型的继承关系"><a href="#6、泛型的继承关系" class="headerlink" title="6、泛型的继承关系"></a>6、泛型的继承关系</h2><p>如果Manage extends Employee,那么Pair&lt; Manage &gt;是Pair&lt; Employee &gt;的子类吗？ 不是的！<br>但是泛型类可以扩展或实现其他的泛型类，很典型的一个例子ArrayList:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList[E]继承了AbstractList[E];</p>
<h2 id="对于Java泛型的一些思考"><a href="#对于Java泛型的一些思考" class="headerlink" title="对于Java泛型的一些思考"></a>对于Java泛型的一些思考</h2><blockquote>
<p>编译器如何推断出具体的类型？ 参考资料：<a href="https://blog.csdn.net/u011240877/article/details/53545041#%E6%93%A6%E9%99%A4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">深入理解 Java 泛型</a></p>
</blockquote>
<blockquote>
<p align="middle"> -------------------   他日若遂凌云志 敢笑黄巢不丈夫 ------------------- </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/wiki/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java基础之注解机制详解"><a href="#Java基础之注解机制详解" class="headerlink" title="Java基础之注解机制详解"></a>Java基础之注解机制详解</h1><blockquote>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、<br>局部变量等进行注解。它是框架学习和设计者必须掌握的基础。</p>
</blockquote>
<h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：<br>— 生成文档，通过代码里标识的元数据生成javadoc文档。<br>— 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。<br>— 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 </p>
<ul>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理， 例如使用反射注入实例。<br>这么来说是比较抽象的，我们具体看下注解的常见分类： <ul>
<li><strong>Java自带的标准注解</strong>， 包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，<br>用这些注解标明后编译器就会进行检查。   </li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，<br>@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，<br>@Documented用于标明是否生成javadoc文档。 </li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。<br>接下来我们通过这个分类角度来理解注解。  </li>
</ul>
</li>
</ul>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    /**</span><br><span class="line">        * 重载父类的test方法</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 被弃用的方法</span><br><span class="line">        */</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void oldMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 忽略告警</span><br><span class="line">        * </span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    public List processList() &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：   </p>
<ul>
<li>@Override：表示当前的方法定义将覆盖父类中的方法  </li>
<li>@Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告  </li>
<li>@SuppressWarnings：表示关闭编译器警告信息 我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。  </li>
</ul>
<h3 id="内置注解-Override"><a href="#内置注解-Override" class="headerlink" title="内置注解 - @Override"></a>内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。<br>这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，<br>若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。    </p>
<h3 id="内置注解-Deprecated"><a href="#内置注解-Deprecated" class="headerlink" title="内置注解 - @Deprecated"></a>内置注解 - @Deprecated</h3><p>这个注解的定义如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。  </p>
<h3 id="内置注解-SuppressWarnings"><a href="#内置注解-SuppressWarnings" class="headerlink" title="内置注解 - @SuppressWarnings"></a>内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。<br>它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<p>// TODO</p>
<blockquote>
<p>参考资料<br><a href="https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html">https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-MVCC多版本并发控制</title>
    <url>/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>MVCC在MySQL InnoDB中的实现主要是为了 「<font color=red> 提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 </font>」</p>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><blockquote>
<p>当前读</p>
</blockquote>
<p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<blockquote>
<p>快照读</p>
</blockquote>
<p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p>
<p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p>
<p><font color=red >MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</font></p>
<h2 id="MVCC有什么好处，解决了什么问题"><a href="#MVCC有什么好处，解决了什么问题" class="headerlink" title="MVCC有什么好处，解决了什么问题"></a>MVCC有什么好处，解决了什么问题</h2><p>多版本并发控制（MVCC）是一种用来「 <font color=green>解决读-写冲突的无锁并发控制</font> 」，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的  <font color=red>3个隐式字段</font>，<font color=red>undo日志</font> ，<font color=red>Read View</font> 来实现的。所以我们先来看看这个三个point的概念</p>
<h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<blockquote>
<p>DB_TRX_ID</p>
</blockquote>
<p>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p>
<blockquote>
<p>DB_ROLL_PTR</p>
</blockquote>
<p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p>
<blockquote>
<p>DB_ROW_ID</p>
</blockquote>
<p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p>
<blockquote>
<p>insert undo log</p>
</blockquote>
<p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
<blockquote>
<p>update undo log</p>
</blockquote>
<p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，<font color=red>主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护）</font>，如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本;</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/8845ddca3b23">1、MVCC多版本并发控制</a><br><a href="https://blog.csdn.net/chosen0ne/article/details/18093187">2、MVCC浅析</a><br><a href="https://database.51cto.com/art/202010/629317.htm">3、乐观锁、悲观锁和MVCC，今天让你一次搞懂</a><br><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc">4、面试官：谈谈你对Mysql的MVCC的理解？</a><br><a href="https://www.cnblogs.com/shujiying/p/11347632.html">5、Mysql中MVCC的使用及原理详解</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/wiki/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><ul>
<li><p>linux 在文档中查找关键字个数<br><code>grep -o “关键字” 文档名 | wc -l </code><br><code>grep -o “关键字” 文档名 | sort | uniq -c</code></p>
</li>
<li><p>清除history记录<br><code>vim .bash_history</code><br>命令模式下（Esc之后输入:） 输入 set nu 每行数据前面显示行号<br><code>11,20d</code> 回车 11～20行的记录就被删除了<br>然后命令模式下 wq 保存退出就可以了<br>如果在此查看还是有记录，可以退出当前回话之后，再进去查看，就会不再显示删除的记录了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Common commands</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务特性与实现原理</title>
    <url>/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务特性与实现原理"><a href="#事务特性与实现原理" class="headerlink" title="事务特性与实现原理"></a>事务特性与实现原理</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote>
<p>原子性(Atomicity)</p>
</blockquote>
<p>事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。</p>
<blockquote>
<p>一致性(Consistency)</p>
</blockquote>
<p>事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p>
<blockquote>
<p>隔离性(Isolation)</p>
</blockquote>
<p>并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。</p>
<blockquote>
<p>持久性(Durability)</p>
</blockquote>
<p>事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p>
<p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面<br>1.事务的并发执行<br>2.事务故障或系统故障</p>
<h2 id="事务实现原理"><a href="#事务实现原理" class="headerlink" title="事务实现原理"></a>事务实现原理</h2><img src="https://oscimg.oschina.net/oscnet/up-7b54f7847cee22930ec53a4058179a2b531.png" width=460 height=300>

<ul>
<li>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。</li>
<li>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</li>
</ul>
<h3 id="回滚日志（undo）"><a href="#回滚日志（undo）" class="headerlink" title="回滚日志（undo）"></a>回滚日志（undo）</h3><p>undo log属于 「 逻辑日志 」，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<p>undo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。</p>
<p>因此，undo log有两个作用：提供回滚和多个行版本控制(MVCC)。</p>
<h3 id="重做日志（redo）"><a href="#重做日志（redo）" class="headerlink" title="重做日志（redo）"></a>重做日志（redo）</h3><p>redo log重做日志记录的是新数据的备份，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据恢复到最新的状态。</p>
<p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p>
<p>MySQL中redo log刷新规则采用一种称为Checkpoint的机制（利用LSN实现），为了确保安全性，又引入double write机制。</p>
<h2 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h2><p>开启事务：start transaction<br>回滚事务：rollback<br>提交事务：commit</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">1、详细分析MySQL事务日志(redo log和undo log)</a><br><a href="https://www.cnblogs.com/takumicx/p/9998844.html">2、数据库事务的概念及其实现原理</a><br><a href="https://zhuanlan.zhihu.com/p/281927963">3、数据库事务实现原理</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter index out of range (1 &gt; number of parameters, which is 0).</title>
    <url>/wiki/Parameter-index-out-of-range-1-number-of-parameters-which-is-0/</url>
    <content><![CDATA[<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 12:39:31.179 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:39:31.186 [http-nio-8081-exec-2] ERROR com.alibaba.otter.canal.client.adapter.support.Util - sqlRs has error, sql: SELECT COUNT(1) FROM ( select t.redtom_id as id, t.username, t.nickname, t.avatar, t.status, t.mobile, t.mobile_region_no, t.email, t.gender, t.password,t.salt,t.birthday,t.introduce,t.country,t.region,t.level,t.is_vip,t.follows    ,t.fans,t.likes_num, t.collects_num, t.instagram_account, t.youtube_account, t.facebook_account, t.twitter_account,t.create_ip, t.create_time,t.update_time from rd_member r where t.create_time&gt;=&#x27;&#123;0&#125;&#x27;) _CNT</span><br><span class="line">2021-07-06 12:39:31.188 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">java.lang.RuntimeException: java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:65) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:62) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br></pre></td></tr></table></figure>

<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我执行的操作如下：👇<br><code>curl http://127.0.0.1:8081/etl/es7/customer.yml -X POST -d &quot;params=2019-08-31 00:00:00&quot;</code></p>
<p>但是我的 es7/rd_member.yml的配置文件如下：</p>
<p><code>etlCondition:&quot;where a.c_time&gt;=&#39;&#123;0&#125;&#39;&quot; # etl 的条件参数</code></p>
<p>应该改成：<br><code>etlCondition:&quot;where a.c_time&gt;=&#123;&#125;&quot; # etl 的条件参数</code></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Other Question</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务隔离级别</title>
    <url>/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。另外，这篇分布式事务不理解？一次给你讲清楚！推荐大家阅读。</p>
<blockquote>
<p>Read Uncommitted（读取未提交内容）</p>
</blockquote>
<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<blockquote>
<p>Read Committed（读取提交内容）</p>
</blockquote>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<blockquote>
<p>Repeatable Read（可重读）</p>
</blockquote>
<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<blockquote>
<p>Serializable（可串行化）</p>
</blockquote>
<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<h2 id="事务隔离级别产生的问题"><a href="#事务隔离级别产生的问题" class="headerlink" title="事务隔离级别产生的问题"></a>事务隔离级别产生的问题</h2><img src="https://oscimg.oschina.net/oscnet/up-ee3cb778a32220ff81103f9163d22f774b2.png"> 


<blockquote>
<p>脏读(Drity Read)</p>
</blockquote>
<p>某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，但是此时的事务B还未commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务B-&gt;rollback操作</span><br><span class="line">事务A读取到的是脏数据</span><br></pre></td></tr></table></figure>


<blockquote>
<p>不可重复读(Non-repeatable read)</p>
</blockquote>
<p>在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，并commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务A多次读取的结果不一致</span><br></pre></td></tr></table></figure>

<blockquote>
<p>幻读(Phantom Read) </p>
</blockquote>
<p><font color=red >幻读和不可重复读的区别在于，幻读主要表现在数据的删除和插入，而不可重复读表现在数据的更新。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新delete price=100 这条记录，并commit</span><br><span class="line">事务A读取的price=100</span><br><span class="line">price这条记录已经不存在，但是事务A还是可以读取到</span><br></pre></td></tr></table></figure>

<p>1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。<br>　　2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/xiewenfeng520/article/details/99407038">1、mysql数据库的隔离级别</a><br><a href="https://blog.csdn.net/sinat_15805929/article/details/91127491">2、MYSQL数据库的四种隔离级别</a><br><a href="https://www.jianshu.com/p/c53c8ab650b5">3、MySQL幻读
</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis-list底层实现</title>
    <url>/wiki/Redis-list%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Redis-List-底层实现"><a href="#Redis-List-底层实现" class="headerlink" title="Redis List 底层实现"></a>Redis List 底层实现</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">   </p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote>
<p>连锁更新问题 | quicklist | ziplist | linkedlist </p>
</blockquote>
<h2 id="List底层数据结构"><a href="#List底层数据结构" class="headerlink" title="List底层数据结构"></a>List底层数据结构</h2><p>在 3.0 版本的 Redis 中，List 类型有两种实现方式：<br>数据结构底层采用压缩列表ziplist或linkedlist两种数据结构进行存储，首先以ziplist进行存储，在不满足ziplist的存储要求后转换为linkedlist列表。<br>当列表对象同时满足以下两个条件时，列表对象使用ziplist进行存储，否则用linkedlist存储。</p>
<h3 id="ziplist转换成linkedlist的条件"><a href="#ziplist转换成linkedlist的条件" class="headerlink" title="ziplist转换成linkedlist的条件"></a>ziplist转换成linkedlist的条件</h3><p><strong>1、触发一下任意一条即进行转换：</strong></p>
<ul>
<li>列表对象保存的所有字符串元素的长度小于64字节  </li>
<li>列表对象保存的元素数量小于512个。</li>
</ul>
<p><strong>2、redis.conf配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list-max-ziplist-value 64 </span><br><span class="line">list-max-ziplist-entries 512 </span><br></pre></td></tr></table></figure>
<p><strong>3、ziplist和linkedlist底层实现</strong><br><a href="">1、使用压缩列表（ziplist）实现的列表对象。</a><br><a href="">2、使用双端链表（linkedlist）实现的列表对象。</a>  </p>
<p>在 3.2 版本后新增了 quicklist 数据结构实现了 list，现在就来分析下 quicklist 的结构。    </p>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p><img src="https://oscimg.oschina.net/oscnet/up-558f859ac71d40fd122bae2ebdb0a9eb055.png"><br>ziplist会引入频繁的内存申请和释放，而linkedlist由于指针也会造成内存的浪费，而且每个节点是单独存在的，会造成很多内存碎片，<br>所以结合两个结构的特点，设计了quickList。<br>quickList 是一个 ziplist 组成的双向链表。每个节点使用 ziplist 来保存数据。本质上来说， quicklist 里面保存着一个一个小的 ziplist。</p>
<h3 id="quicklist表头结构"><a href="#quicklist表头结构" class="headerlink" title="quicklist表头结构"></a>quicklist表头结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向头部(最左边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向尾部(最右边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ziplist中的entry节点计数器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//quicklist的quicklistNode节点计数器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存ziplist的大小，配置文件设定，占16bits</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存压缩程度值，配置文件设定，占16bits，0表示不压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<ul>
<li>head 和 tail 分别指向这个双端链表的表头和表尾, quicklist 存储的节点是一个叫做 quicklistNode 的结构, 如果这个 quicklist 是空的,<br>那么 head 和 tail 会同时成为空指针, 如果这个双端链表的大小为 1, 那么 head 和 tail 会同时指向一个相同的节点</li>
<li>count 是一个计数器, 表示当前这个 list 结构一共存储了多少个元素, 它的类型是 unsigned long, 所以一个 list 能存储的最多的元素在 字长为 64 bit 的机器上是 (1 &lt;&lt; 64) - 1, 字长为 32 bit 的机器上是 (1 &lt;&lt; 32) - 1</li>
<li>len 表示了这个双端链表的长度(quicklistNodes 的数量)</li>
<li>fill 表示了单个节点(quicklistNode)的负载比例(fill factor), 这是什么意思呢 <blockquote>
<p>Lists 结构使用了一种特殊的编码方式来节省空间, Lists 中每一个节点所能存储的东西可以通过最大长度或者一个最大存储的空间大小来限制,<br>对于想限制每个节点最大存储空间的用户, 用 -5 到 -1 来表示这个限制值  </p>
</blockquote>
</li>
<li>5: 最大存储空间: 64 Kb &lt;– 通常情况下不要设置这个值    </li>
<li>4: 最大存储空间: 32 Kb &lt;– 非常不推荐</li>
<li>3: 最大存储空间: 16 Kb &lt;– 不推荐</li>
<li>2: 最大存储空间: 8 Kb &lt;– 推荐</li>
<li>1: 最大存储空间: 4 Kb &lt;– 推荐    </li>
</ul>
<p>对于正整数则表示最多能存储到你设置的那个值, 当前的节点就装满了<br>通常在 -2 (8 Kb size) 或 -1 (4 Kb size) 时, 性能表现最好<br>但是如果你的使用场景非常独特的话, 调整到适合你的场景的值！！！！</p>
<p><strong>redis.conf, 其中有一个可配置的参数叫做 list-max-ziplist-size, 默认值为 -2, 它控制了 quicklist 中的 fill 字段的值, 负数限制 quicklistNode 中的 ziplist 的字节长度, 正数限制 quicklistNode 中的 ziplist 的最大长度</strong>  </p>
<ul>
<li>compress 则表示 quicklist 中的节点 quicklistNode, 除开最两端的 compress 个节点之后, 中间的节点都会被压缩<blockquote>
<p>Lists 在某些情况下是会被压缩的, 压缩深度是表示除开 list 两侧的这么多个节点不会被压缩, 剩下的节点都会被尝试进行压缩, 头尾两个节点一定不会被进行压缩,<br>因为要保证 push/pop 操作的性能, 有以下的值可以设置:<br>0: 关闭压缩功能</p>
</blockquote>
</li>
</ul>
<p> 1: 深度 1 表示至少在 1 个节点以后才会开始尝试压缩, 方向为从头到尾或者从尾到头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[head]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[tail]</span><br><span class="line">[head], [tail] 永远都是不会被压缩的状态; 中间的节点则会被压缩</span><br></pre></td></tr></table></figure>
<p>2 不会尝试压缩 head 或者 head-&gt;next 或者 tail-&gt;prev 或者 tail 但是会压缩这中间的所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[head]-&gt;[next]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[prev]-&gt;[tail]</span><br></pre></td></tr></table></figure>
<p>3: 以此类推，最大为2的16次方。  </p>
<h3 id="quicklistNode-节点"><a href="#quicklistNode-节点" class="headerlink" title="quicklistNode 节点"></a>quicklistNode 节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前驱节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后继节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不设置压缩数据参数recompress时指向一个ziplist结构</span></span><br><span class="line">    <span class="comment">//设置压缩数据参数recompress指向quicklistLZF结构</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩列表ziplist的总长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;                  <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ziplist中包的节点数，占16 bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;          <span class="comment">/* count of items in ziplist */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示是否采用了LZF压缩算法压缩quicklist节点，1表示压缩过，2表示没压缩，占2 bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;        <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩，默认是2，占2bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;       <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记quicklist节点的ziplist之前是否被解压缩过，占1bit长度</span></span><br><span class="line">    <span class="comment">//如果recompress为1，则等待被再次压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试时使用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//额外扩展位，占10bits长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>prev 和 next 分别指向当前 quicklistNode 的前一个和后一个节点</li>
<li>zl 指向实际的 ziplist</li>
<li>sz 存储了当前这个 ziplist 的占用空间的大小, 单位是字节</li>
<li>count 表示当前有多少个元素存储在这个节点的 ziplist 中, 它是一个 16 bit 大小的字段, 所以一个 quicklistNode 最多也只能存储 65536 个元素</li>
<li>encoding 表示当前节点中的 ziplist 的编码方式, 1(RAW) 表示默认的方式存储, 2(LZF) 表示用 LZF 算法压缩后进行的存储 </li>
<li>container 表示 quicklistNode 当前使用哪种数据结构进行存储的, 目前支持的也是默认的值为 2(ZIPLIST), 未来也许会引入更多其他的结构</li>
<li>recompress 是一个 1 bit 大小的布尔值, 它表示当前的 quicklistNode 是不是已经被解压出来作临时使用</li>
<li>attempted_compress 只在测试的时候使用</li>
<li>extra 是剩下多出来的 bit, 可以留作未来使用</li>
</ul>
<h3 id="quicklistLZF-结构定义"><a href="#quicklistLZF-结构定义" class="headerlink" title="quicklistLZF 结构定义"></a>quicklistLZF 结构定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copytypedef struct quicklistLZF &#123;</span><br><span class="line">    unsigned int sz;  //压缩后的ziplist大小</span><br><span class="line">    char compressed[];//柔性数组，存放压缩后的ziplist字节数组</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<p>当指定使用lzf压缩算法压缩ziplist的entry节点时，quicklistNode结构的zl成员指向quicklistLZF结构;   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://zhuanlan.zhihu.com/p/102422311">Redis列表list 底层原理</a><br>2、<a href="https://cloud.tencent.com/developer/article/1710612">Redis中string、list的底层数据结构原理</a><br>3、<a href="https://cloud.tencent.com/developer/article/1619920">《闲扯Redis五》List数据类型底层之quicklist</a><br>4、<a href="https://blog.csdn.net/men_wen/article/details/70229375">Redis源码剖析和注释（七）— 快速列表(quicklist)</a><br>5、<a href="https://blog.csdn.net/qq_31720329/article/details/99938219">redis 列表结构 底层实现(quicklist)</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-哈希表实现</title>
    <url>/wiki/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Redis之Hash表底层实现"><a href="#Redis之Hash表底层实现" class="headerlink" title="Redis之Hash表底层实现"></a>Redis之Hash表底层实现</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">  </p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><blockquote>
<p>字段dict | 渐进式哈希 | ziplist |  哈希表</p>
</blockquote>
<h2 id="字典底层结构"><a href="#字典底层结构" class="headerlink" title="字典底层结构"></a>字典底层结构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-95f75bf34c0a82057f05be6630b16163e42.png">  </p>
<h3 id="dict-字典结构体"><a href="#dict-字典结构体" class="headerlink" title="dict 字典结构体"></a>dict 字典结构体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dict&#123;</span><br><span class="line">    dictType *type;//类型特定函数，包括一些自定义函数，这些函数使得key和</span><br><span class="line">                   //value能够存储</span><br><span class="line">    void *private;//私有数据</span><br><span class="line">    dictht ht[2];//两张hash表 </span><br><span class="line">    int rehashidx;//rehash索引，字典没有进行rehash时，此值为-1</span><br><span class="line">    unsigned long iterators; //正在迭代的迭代器数量</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<ul>
<li>type和private这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对应的一些复制，比较函数也不一样，这两个属性配合起来可以实现多态的方法调用；</li>
<li>ht[2]，两个hash表</li>
<li>rehashidx，这是一个辅助变量，用于记录rehash过程的进度，以及是否正在进行rehash等信息，当此值为-1时，表示该dict此时没有rehash过程</li>
<li>iterators，记录此时dict有几个迭代器正在进行遍历过程</li>
</ul>
<h3 id="dictht-哈希表结构体"><a href="#dictht-哈希表结构体" class="headerlink" title="dictht 哈希表结构体"></a>dictht 哈希表结构体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dictht&#123;</span><br><span class="line">    dictEntry **table;//存储数据的数组 二维</span><br><span class="line">    unsigned long size;//数组的大小</span><br><span class="line">    unsigned long sizemask;//哈希表的大小的掩码，用于计算索引值，总是等于 </span><br><span class="line">                           //size-1</span><br><span class="line">    unsigned long used;//// 哈希表中中元素个数</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h3 id="dictEntry-哈希数组结构"><a href="#dictEntry-哈希数组结构" class="headerlink" title="dictEntry 哈希数组结构"></a>dictEntry 哈希数组结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedf struct dictEntry&#123;</span><br><span class="line">    void *key;//键</span><br><span class="line">    union&#123;</span><br><span class="line">        void val;</span><br><span class="line">        unit64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">        double d;</span><br><span class="line">    &#125;v;//值</span><br><span class="line">    struct dictEntry *next；//指向下一个节点的指针</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。<br>这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。  </p>
<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。<br>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。<br>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。  </p>
<h3 id="触发扩容的条件："><a href="#触发扩容的条件：" class="headerlink" title="触发扩容的条件："></a>触发扩容的条件：</h3><ul>
<li>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li>
<li>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。<br>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</li>
</ul>
<h3 id="为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？"><a href="#为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？" class="headerlink" title="为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？"></a>为什么扩容的时候要考虑BIGSAVE的影响，而缩容时不需要？</h3><ul>
<li>BGSAVE时，dict要是进行扩容，则此时就需要为dictht[1]分配内存，若是dictht[0]的数据量很大时，就会占用更多系统内存，造成内存页过多分离，<br>所以为了避免系统耗费更多的开销去回收内存，此时最好不要进行扩容；</li>
<li>缩容时，结合缩容的条件，此时负载因子&lt;0.1，说明此时dict中数据很少，就算为dictht[1]分配内存，也消耗不了多少资源；</li>
</ul>
<h2 id="渐进式哈希"><a href="#渐进式哈希" class="headerlink" title="渐进式哈希"></a>渐进式哈希</h2><p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，<br>但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。<br>所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，<br>第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。</p>
<ul>
<li>渐进式哈希其实就是慢慢的，一步一步的将hash表的数据迁移到另一个hash表中</li>
<li>redis会有一个定时任务去检测是否需要进行rehash</li>
<li>rehash的过程中会在字典dict中维护一个rehashidx的标志</li>
<li>在rehash的过程中，两个hash表中都会有数据，此时如果有数据新增，将会存在ht[1]也就是第二个哈希表上；</li>
<li>在rehash的过程中，如果有删改查，则优先选择第一张表，如果第一张表没有查到数据，则查找第二章哈希表；</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://www.cnblogs.com/ysocean/p/9080942.html">Redis详解（四）—— redis的底层数据结构</a><br>2、<a href="https://www.cnblogs.com/reecelin/p/13362104.html">Redis底层数据结构之hash</a><br>3、<a href="https://blog.csdn.net/mccand1234/article/details/93411326">Redis Hash数据结构的底层实现</a><br>4、<a href="https://baijiahao.baidu.com/s?id=1651767862408344160&wfr=spider&for=pc">图解redis五种数据结构底层实现(动图哦)</a><br>5、<a href="https://www.jianshu.com/p/c63d8448a7b0">redis hash底层数据结构</a><br>6、<a href="https://www.cnblogs.com/reecelin/p/13362104.html">Redis底层数据结构之hash</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-overview</title>
    <url>/wiki/Redis-overview/</url>
    <content><![CDATA[<h1 id="Redis-（Remote-Dictionary-Server）"><a href="#Redis-（Remote-Dictionary-Server）" class="headerlink" title="Redis （Remote Dictionary Server）"></a>Redis （Remote Dictionary Server）</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中<br>进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。<br>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。<br>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限<br>制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。<br>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高<br>性能的 tag 系统等等。<br>另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。<br>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因<br>此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h2 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456<br>授权密码：auth 123456  </p>
<h2 id="Redis-有哪几种数据淘汰策略？"><a href="#Redis-有哪几种数据淘汰策略？" class="headerlink" title="Redis 有哪几种数据淘汰策略？"></a>Redis 有哪几种数据淘汰策略？</h2><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但 DEL 和几个例外）<br>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>allkeys-random: 回收随机的键使得新添加的数据有空间存放。<br>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。  </p>
<h2 id="Redis-有哪些适合的场景？"><a href="#Redis-有哪些适合的场景？" class="headerlink" title="Redis 有哪些适合的场景？"></a>Redis 有哪些适合的场景？</h2><h3 id="（1）会话缓存（Session-Cache）"><a href="#（1）会话缓存（Session-Cache）" class="headerlink" title="（1）会话缓存（Session Cache）"></a>（1）会话缓存（Session Cache）</h3><p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Mem<br>cached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车<br>信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为<br>人知的商业平台 Magento 也提供 Redis 的插件。</p>
<h3 id="（2）全页缓存（FPC）"><a href="#（2）全页缓存（FPC）" class="headerlink" title="（2）全页缓存（FPC）"></a>（2）全页缓存（FPC）</h3><p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实<br>例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。<br>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。<br>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快<br>速度加载你曾浏览过的页面。  </p>
<h3 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h3><p>Redis 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队<br>列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop<br>操作。<br>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是<br>利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作<br>为 broker，你可以从这里去查看。</p>
<h3 id="（4）排行榜-计数器"><a href="#（4）排行榜-计数器" class="headerlink" title="（4）排行榜/计数器"></a>（4）排行榜/计数器</h3><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也<br>使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。<br>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下<br>面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执<br>行：<br>ZRANGE user_scores 0 10 WITHSCORESAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可<br>以在这里看到。<br>###（5）发布/订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见<br>人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建<br>立聊天系统！</p>
<h3 id="Redis-常见的性能问题和解决方案"><a href="#Redis-常见的性能问题和解决方案" class="headerlink" title="Redis 常见的性能问题和解决方案"></a>Redis 常见的性能问题和解决方案</h3><p>1、master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件<br>2、如果数据比较重要，某个 slave 开启 AOF 备份，策略设置成每秒同步一次<br>3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内<br>4、尽量避免在压力大得主库上增加从库<br>5、主从复制不要采用网状结构，尽量是线性结构，Master&lt;–Slave1&lt;—-Slave2 ….  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-字符串底层原理</title>
    <url>/wiki/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Redis底层实现及原理"><a href="#Redis底层实现及原理" class="headerlink" title="Redis底层实现及原理"></a>Redis底层实现及原理</h1><p><img src="https://oscimg.oschina.net/oscnet/up-c8da12582edb1a4320e17096efc9b9103a2.png">  </p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><blockquote>
<p>SDS embstr 二进制安全 空间预分配</p>
</blockquote>
<h2 id="String类型不同的编码方式"><a href="#String类型不同的编码方式" class="headerlink" title="String类型不同的编码方式"></a>String类型不同的编码方式</h2><ul>
<li><strong>使用整数存储：</strong> 只对长度小于或等于 21 字节，并且可以被解释为整数的字符串进行编码</li>
<li><strong>使用EMBSTR 编码：</strong> 尝试将 RAW 编码的字符串编码为 EMBSTR 编码，</li>
<li><strong>使用SDS编码:</strong> 这个对象没办法进行编码，尝试从 SDS 中移除所有空余空间 下面举个例子看一下👇</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-01a9f52dd08c514531b8701a47aa90aa029.png"  width="600" height="413" align="bottom" />

<h3 id="embstr与动态字符串"><a href="#embstr与动态字符串" class="headerlink" title="embstr与动态字符串"></a>embstr与动态字符串</h3><ul>
<li>embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为redisObject分配对象，embstr省去了第一次）。 相对地，释放内存的次数也由两次变为一次。</li>
<li>embstr的redisObject和sds放在一起，更好地利用缓存带来的优势</li>
<li>但是redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改。</li>
</ul>
<h2 id="SDS-simple-dynamic-string"><a href="#SDS-simple-dynamic-string" class="headerlink" title="SDS(simple dynamic string)"></a>SDS(simple dynamic string)</h2><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">     //记录buf数组中已使用字节的数量</span><br><span class="line">     //等于 SDS 保存字符串的长度</span><br><span class="line">     int len;</span><br><span class="line">     //记录 buf 数组中未使用字节的数量</span><br><span class="line">     int free;</span><br><span class="line">     //字节数组，用于保存字符串</span><br><span class="line">     char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDS有什么优点"><a href="#SDS有什么优点" class="headerlink" title="SDS有什么优点"></a>SDS有什么优点</h3><h4 id="1、常数复杂度获取字符串长度"><a href="#1、常数复杂度获取字符串长度" class="headerlink" title="1、常数复杂度获取字符串长度"></a><strong>1、常数复杂度获取字符串长度</strong></h4><p>sdshdr 中由于 len 属性的存在，获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)，而对于 C 语言来说， 获取字符串的长度通常是遍历字符串计数来实现的，时间复杂度为 O(n)。</p>
<h4 id="2、杜绝缓冲区溢出"><a href="#2、杜绝缓冲区溢出" class="headerlink" title="2、杜绝缓冲区溢出"></a><strong>2、杜绝缓冲区溢出</strong></h4><p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候， 会首先根据记录的 len<br>属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<h4 id="3、减少修改字符串时带来的内存重分配次数"><a href="#3、减少修改字符串时带来的内存重分配次数" class="headerlink" title="3、减少修改字符串时带来的内存重分配次数"></a><strong>3、减少修改字符串时带来的内存重分配次数</strong></h4><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，<br>字符串长度减小时会造成内存泄露。而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：</p>
<p>3.1 字符串长度增加操作时，进行空间预分配</p>
<blockquote>
<p>对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
</blockquote>
<p>3.2 字符串长度减少操作时，惰性空间释放</p>
<blockquote>
<p>对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。<br>（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。</p>
</blockquote>
<h4 id="4、二进制安全"><a href="#4、二进制安全" class="headerlink" title="4、二进制安全"></a><strong>4、二进制安全</strong></h4><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取； 而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS<br>不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<h4 id="5、兼容部分C字符串函数"><a href="#5、兼容部分C字符串函数" class="headerlink" title="5、兼容部分C字符串函数"></a><strong>5、兼容部分C字符串函数</strong></h4><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<h3 id="为什么字符串长度大于44就是用raw方式编码"><a href="#为什么字符串长度大于44就是用raw方式编码" class="headerlink" title="为什么字符串长度大于44就是用raw方式编码"></a>为什么字符串长度大于44就是用raw方式编码</h3><p>这个是因为C语言函数库分配内存的长度只能是2/4/8/16/32/64；最大分配64位的长度；<br>但是redisObj的长度加上字符串对象头的长度，占用20位，所以字符串长度最多是44位，超过这个长度，就是用raw方式进行编码；  – 《Redis深度历险-String数据结构》  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1606944">《闲扯Redis二》String数据类型之底层解析</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1660571063765620837&wfr=spider&for=pc">每个程序员都应该知道的Redis知识 - String底层原理</a><br>3、<a href="https://www.cnblogs.com/ysocean/p/9080942.html">Redis详解（四）—— redis的底层数据结构</a><br>4、<a href="https://yq.aliyun.com/articles/666402">redis string底层数据结构</a>  </p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-缓存穿透、击穿和雪崩</title>
    <url>/wiki/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="缓存击穿，穿透和雪崩"><a href="#缓存击穿，穿透和雪崩" class="headerlink" title="缓存击穿，穿透和雪崩"></a>缓存击穿，穿透和雪崩</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先说一下为什么会写这片文章，因为这个对我来说是印象非常深刻的，那是还在实习的时候，当时接了一个任务（其实就是练手的），大致需求是写一个白名单，然后有一个功能对白名单开放。因为是新功能，需要在部分地区试点，如果没有问题才会放开到全国城市运行。就是这么一个小的功能，让当时的我，呵呵。我记得那是第一次使用Redis,根本不知道什么是缓存雪崩啊，缓存击穿啊，穿透呀这些，还有更可怕的缓存一致性问题（TODO 下期再说）。          当时团队十几位大佬review我的代码，哼。这就是为什么印象会深刻一些吧，关键那是我第一个review代码，还是第一次使用redis，整个review就像是十几个大佬在面试我。真是怀疑人生了。。我是废物，别笑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大致伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermit</span><span class="params">(String cityCode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先查询缓存中是否存在</span></span><br><span class="line">    String tmpCity = getCache(cityCode);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isNotBlank(tmpCity))&#123;</span><br><span class="line">        reture Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中没有在去查数据库</span></span><br><span class="line">    <span class="function">reture <span class="title">judgeForDb</span><span class="params">(cityCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我上面的例子其实就是典型的缓存穿透的问题。因为仅仅是开放了十几个城市来试点功能，所以大部分的查询都是缓存不命中的。</p>
<p>下面引出今天我们的三个关键词：</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>要查询的数据，缓存中基本上没有，所以大概率情况下缓存是不命中的，而是去数据库中去查询数据，导致缓存相当于是一个摆设。如果Key不是热点访问还可以，如果是热点Key，而且并发量也会很大的情况下，绝大多数的请求都会打到数据库上，很容易造成数据库宕机。</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、布隆过滤器进行校验，bloom filter典型应用场景（用户名是否存在，黑名单机制，单词错误检测）<br>2、缓存空值方法，这个网上也是说的比较多的，这种方式也是可以的  </p>
<h5 id="在此我说一下我的解决方案："><a href="#在此我说一下我的解决方案：" class="headerlink" title="在此我说一下我的解决方案："></a>在此我说一下我的解决方案：</h5><p>1、校验一个城市是否是城市白名单的城市时，直接查询缓存，存储的数据结构是使用的hash；<br>2、如果没有查到这个城市，则认为这个城市不在白名单中，因为我是先查的hash，然后在查询hash中的具体城市。如果hash的值都没有查到，那说明缓存失效了；<br>3、针对缓存失效的情况，可以再查DB来更新缓存，这个时候有人要较真了，会不会出线缓存击穿的情况呀，这个看具体场景，因为我的业务是不需要的，所以这里就直接查库更新缓存了，如果需要的话，那可以上缓存击穿的解决方案，或者看看上面两种解决方案有没有合适的，哈哈哈；<br>4、因为城市是在后台进行配置的，所以我是在增删改的操作时，保证了缓存数据的一致性的前提下，才选择相信缓存的。这是我当时的解决方案。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>某个热点Key在一段时间内失效了，此时有大量请求瞬时抵达，会严重增加数据库的压力。因为我们的缓存数据一般都是要设置过期时间的，当缓存失效时，会去查询数据库同时更新缓存数据。</p>
</blockquote>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、可以加锁，来保证只有第一个请求进来时达到数据库上，然后更新缓存，第二个请求进来是就会命中缓存，当然如果是分布式服务，那就需要使用分布式锁了。<br>2、合理设置缓存时间，可以将热点Key时间设置长一些，或者根据业务将失效时间设置在业务量比较小的波段，都是可以的。有的解决方案会不设置Key的过期时间，这个，看情况吧，不建议这样。 如果大量的key不设置过期时间，则长期占用内存也是不好的。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存雪崩顾名思义，就是大量Key在一段时间或者瞬时失效，或者Redis服务重启（所有Key失效，因为是存在内存中），从而导致大量请求打到数据库上，增加数据库压力</p>
</blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、将热点key设置不同波段的过期时间，把过期时间散列开。<br>2、也可以使用分布式锁来限制高并发的请求，和缓存击穿的解决方案同理。<br>3、对于Redis重启或宕机的问题，可以考虑集群部署，并保证数据的同步和一致性；</p>
<blockquote>
 <p align="middle" > 生活远不止眼前的苟且 </p></blockquote>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/wiki/Spring-Overview/</url>
    <content><![CDATA[<hr>
<p>title: Spring-Overview<br>toc: true<br>date: 2021-07-28 17:32:41<br>tags: Spring<br>categories: [Spring Family , Spring Framework]</p>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>The Spring Framework provides a comprehensive<br> programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.</p>
<p>A key element of Spring is infrastructural support at the application level: Spring focuses on the “plumbing” of enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to specific deployment environments.</p>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul>
<li>先梳理脉络，先宏观，再细节</li>
<li>Spring源码注释很重要</li>
<li>见名知意 学习spring的命名规范</li>
<li>猜测和验证</li>
<li>坚持看 不要三分钟热度</li>
</ul>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><blockquote>
<p>Spring框架官方网站</p>
</blockquote>
<p><a href="https://spring.io/projects/spring-framework#overview">【官网】</a>可以下载Spirng源码在本地查看更舒服！ 源码请戳    👉👉 <a href="https://spring.io/projects/spring-framework#overview">【源码】</a> 👈👈</p>
<blockquote>
<p>Spring5最新完整教程IDEA版通俗易懂 </p>
</blockquote>
<p>视频教程 狂神说 （这个大佬在B站很火的）原链接请点击👉 <a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=20">【传送】</a></p>
<blockquote>
<p>24集彻底搞懂aop ioc mvc底层原理</p>
</blockquote>
<p>视频目录比较好 👉 <a href="https://www.bilibili.com/video/BV1Bt4y1S7nW?p=7">【2020年史上最新Spring源码合集，24集彻底搞懂aop ioc mvc底层原理。】</a></p>
<blockquote>
<p>手撕SpringIOC源码</p>
</blockquote>
<p>马士兵教育 <a href="https://www.bilibili.com/video/BV1CT4y1P7tK?p=1">【400分钟学完Spring源码设计及原理，手撕SpringIOC源码，从我做起】</a></p>
<blockquote>
<p>图灵学院公开课 </p>
</blockquote>
<p>课程目录还不错 5个小时 21年录制比较新 <a href="https://www.bilibili.com/video/BV1Ya411F73A?from=search&seid=11823196289005055636">【2021年新版Java-Spring底层原理，阿里P8大佬全套讲解】</a></p>
<blockquote>
<p>Mybatis + Spring 源码解读 VIP公开课<br><a href="https://www.bilibili.com/video/BV1Gv411s7hL?p=1">【终于有字节跳动技术大牛把【mybatis底层原理：spring整理mybatis】讲明白了】</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>SpringBean循环依赖</title>
    <url>/wiki/SpringBean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring-Bean-循环依赖"><a href="#Spring-Bean-循环依赖" class="headerlink" title="Spring Bean 循环依赖"></a>Spring Bean 循环依赖</h1><h2 id="为什么会存在循环依赖"><a href="#为什么会存在循环依赖" class="headerlink" title="为什么会存在循环依赖"></a>为什么会存在循环依赖</h2><img src="https://oscimg.oschina.net/oscnet/up-4ac2f1ac005d007a18a0823719edb29abf7.png" width=300 height=168>

<p>如上图👆所示，A对象的一个属性是B,B对象的一个属性是A,而Spring中的bean默认情况下都是单例的，所以这两个Bean就产生了循环依赖的问题！</p>
<blockquote>
<p>那么循环依赖的问题出现在什么情况呢</p>
</blockquote>
<p>想一下属性赋值的方式有几种呢？</p>
<ul>
<li>构造器赋值<blockquote>
<p>这种形式循环依赖问题无法解决</p>
</blockquote>
</li>
<li>GET/SET方法<blockquote>
<p>调用SET方法进行赋值的时候，可以通过三级缓存的策略来解决循环依赖的问题</p>
</blockquote>
</li>
</ul>
<p>所以，三级缓存的策略是针对于使用SET方法对属性赋值的场景下的！</p>
<h2 id="循环依赖如何解决"><a href="#循环依赖如何解决" class="headerlink" title="循环依赖如何解决"></a>循环依赖如何解决</h2><img src="https://oscimg.oschina.net/oscnet/up-eabac6749e665ea36856dce17c2119658a7.png">

<p>在实例化的过程中，将处于半成品的对象全部放到缓存中，方便后续来进行调用；<br>只要有了当前对象的引用地址，那么后续来进行赋值即可；</p>
<blockquote>
<p>d 能不能将创建好的对象也放到缓存中呢？</p>
</blockquote>
<p>不能，如果放在一起将无法区分对象是成品对象还是半成品对象了<br>所以再次引出多级缓存的概念，可以创建两个缓存对象，一个用来存放已经实例化的半成品对象，另一个存放完成实例化并且完成初始化的成品对象，这个应该比较好理解吧！</p>
<blockquote>
<p>思考一下以上的设计有没有问题呢？</p>
</blockquote>
<h3 id="为什么需要三级缓存？"><a href="#为什么需要三级缓存？" class="headerlink" title="为什么需要三级缓存？"></a>为什么需要三级缓存？</h3><p>Spring在解决对象Bean循环依赖的问题的解决方案是使用了「三级缓存」；<br>为什么需要三级缓存，也就是三个Map对象；</p>
<blockquote>
<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 三级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>







<blockquote>
<p>三级缓存中分别保存的是什么内容</p>
</blockquote>
<ul>
<li>一级缓存： 成品对象</li>
<li>二级缓存： 半成品对象</li>
<li>三级缓存； lambda表达式</li>
</ul>
<blockquote>
<p>如果只有二级缓存可不可行</p>
</blockquote>
<p>在Spring源码中，只有addSingleton方法和doCreateBean方法中向三级缓存中添加东西的；</p>
<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">           <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">           <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">           <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">       Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">       <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">               singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">               <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                   ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                   <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       singletonObject = singletonFactory.getObject();</span><br><span class="line">                       <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                       <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> singletonObject;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">       Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">           <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName, <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">               <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">boolean</span> recordSuppressedExceptions = <span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   singletonObject = singletonFactory.getObject();</span><br><span class="line">                   newSingleton = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IllegalStateException var16) &#123;</span><br><span class="line">                   singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> var16;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (BeanCreationException var17) &#123;</span><br><span class="line">                   BeanCreationException ex = var17;</span><br><span class="line">                   <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                       Iterator var8 = <span class="keyword">this</span>.suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                           Exception suppressedException = (Exception)var8.next();</span><br><span class="line">                           ex.addRelatedCause(suppressedException);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> singletonObject;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring加载配置文件原理</title>
    <url>/wiki/Spring%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Spring如何加载配置文件到应用程序"><a href="#Spring如何加载配置文件到应用程序" class="headerlink" title="Spring如何加载配置文件到应用程序"></a>Spring如何加载配置文件到应用程序</h1><h2 id="加载Xml文件配置，获取对象"><a href="#加载Xml文件配置，获取对象" class="headerlink" title="加载Xml文件配置，获取对象"></a>加载Xml文件配置，获取对象</h2><blockquote>
<p>xml文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ibli.javaBase.reflection.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gaolei&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-ioc.xml&quot;</span>);</span><br><span class="line">        User user = (User) ac.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-加载Xml文件流程"><a href="#Spring-加载Xml文件流程" class="headerlink" title="Spring 加载Xml文件流程"></a>Spring 加载Xml文件流程</h2><blockquote>
<p>首先猜想一下宏观的流程</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-6aaea943c32e32e44e672c1850975bd40ae.png">

<p>我们可以大体猜想流程是什么样的，如下👇</p>
<img src="https://oscimg.oschina.net/oscnet/up-992d3c9c618a021852b873f08b756824901.png">

<p>接下来debug源码看一下具体流程：</p>
<blockquote>
<p>ClassPathXmlApplicationContext调用refresh方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">// Spring 启动入口</span></span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   Spring 启动入口 this.refresh(); 👆</p>
<blockquote>
<p>调用AbstractRefreshableApplicationContext下的refreshBeanFactory</p>
</blockquote>
<p>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.hasBeanFactory()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">           <span class="keyword">this</span>.closeBeanFactory();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</span><br><span class="line">           beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</span><br><span class="line">           <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">// 从这里进入下一步 👇</span></span><br><span class="line">           <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">               <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + <span class="keyword">this</span>.getDisplayName(), var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=red>关键方法是this.loadBeanDefinitions(beanFactory);</font></p>
<blockquote>
<p> 找到XmlBeanDefinitionReader 这是读取配置的关键所在</p>
</blockquote>
<p>关键对象 <font color=red>XmlBeanDefinitionReader</font> 这个在 「梳理Spring启动脉络」中提到了，Spring提供的抽象接口！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">       XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">       beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">       beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">       beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">       <span class="comment">// 初始化beanDefinitionReader对象</span></span><br><span class="line">       <span class="keyword">this</span>.initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">       <span class="comment">// 加载配置文件 获得BeanDefinitions</span></span><br><span class="line">       <span class="keyword">this</span>.loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继续调用 loadBeanDefinitions 这个有很多重载方法，一直点下去就行！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        Resource[] configResources = <span class="keyword">this</span>.getConfigResources();</span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        String[] configLocations = <span class="keyword">this</span>.getConfigLocations();</span><br><span class="line">         <span class="comment">//spring-ioc.xml</span></span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>configLocations 就是我们Xml配置文件的路径</p>
<blockquote>
<p>接下来一直调用loadBeanDefinitions方法 直到这一步 👇</p>
</blockquote>
<p>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">                Throwable var4 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                    <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var6 = <span class="keyword">this</span>.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var24) &#123;</span><br><span class="line">                    var4 = var24;</span><br><span class="line">                    <span class="keyword">throw</span> var24;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                inputStream.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                                var4.addSuppressed(var23);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            inputStream.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里看到 <font color=red >nputStream</font> 很明显，这里是通过IO流读取制定位置的文件的 !</p>
<blockquote>
<p> 获取到文件输入流之后，将输入流转换成Document文件去解析</p>
</blockquote>
<p>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换成Document的关键方法</span></span><br><span class="line">Document doc = <span class="keyword">this</span>.doLoadDocument(inputSource, resource);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>调用doRegisterBeanDefinitions方法</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions<br>调用parseBeanDefinitions方法去解析数据</p>
<blockquote>
<p>调用DefaultBeanDefinitionDocumentReader的parseBeanDefinitions方法 来解析Element</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">           NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">               Node node = nl.item(i);</span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                   Element ele = (Element)node;</span><br><span class="line">                   <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       delegate.parseCustomElement(ele);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           delegate.parseCustomElement(root);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用parseDefaultElement方法</p>
</blockquote>
<p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;import&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;alias&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;bean&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;beans&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里看到<code>if (delegate.nodeNameEquals(ele, &quot;bean&quot;))</code> 会不会很兴奋呢，接下来就是解析的方法了👇 </p>
<blockquote>
<p> 跳转到 processBeanDefinition(ele, delegate);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是的 就是这个方法了 👉</span></span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> + bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>parseBeanDefinitionElement 将元素数据解析到beanDefinition</p>
</blockquote>
<p>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        String id = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String nameAttr = ele.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, <span class="string">&quot;,; &quot;</span>);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = (String)aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将element数据最终转换成一个beanDefinition对象 是不是很惊奇 哈哈哈</span></span><br><span class="line">     👉 AbstractBeanDefinition beanDefinition = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.error(var9.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring梳理启动脉络</title>
    <url>/wiki/Spring%E6%A2%B3%E7%90%86%E5%90%AF%E5%8A%A8%E8%84%89%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="Spring是如何启动的"><a href="#Spring是如何启动的" class="headerlink" title="Spring是如何启动的"></a>Spring是如何启动的</h1><p>Spring最大的核心就是Bean容器；<br>容器： 从对象创建，使用和销毁全部由容器帮我们控制，用户仅仅使用就可以。</p>
<h2 id="两大核心"><a href="#两大核心" class="headerlink" title="两大核心"></a>两大核心</h2><ul>
<li>IOC 控制反转</li>
<li>AOP 面向切面编程</li>
</ul>
<p>思考：我们是如何使用Spring的呢？</p>
<blockquote>
<p> 加入从配置文件中加载bean 我们猜想一下大致流程是怎样的</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">getPerson</span> <span class="attr">class</span>=<span class="string">com.ibli.Person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">id</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">age</span> <span class="attr">value</span>=<span class="string">20</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件如上👆，这里是伪代码！</p>
<p>先猜想大致流程：</p>
<img src="https://oscimg.oschina.net/oscnet/up-c5313f104a205f008fde4f4b729507c80e7.png">


<p>通过上面猜想创建的对象流程，创建出对象，对象已经好了，就是使用了，那么如何使用呢？</p>
<p>一般情况下我们会可以这样使用，写一下伪代码吧👇：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建一个ApplicationContext对象</span><br><span class="line">Object obj = applicationContext.getBean(<span class="string">&quot;bean name); </span></span><br></pre></td></tr></table></figure>

<p>思考，创建的对象如何存储？ 或者容器到底是什么呢？ 应该可以猜到是Map结构，具体是什么Map,先不管；</p>
<img src="https://oscimg.oschina.net/oscnet/up-baea159953c9590bba80022b251df95a255.png" >

<blockquote>
<p>1、首先容器是创建好的，容器创建好之后，才可以加载配置文件</p>
</blockquote>
<p>也就是我们猜想的Map</p>
<blockquote>
<p>2、加载配置文件</p>
</blockquote>
<p>配置文件可能会有多种方式，比如XML格式，property格式，yaml格式，注解格式，这个格式各不相同，又是如何加载的呢？<br>Spring提供了一个接口，BeanDefinitionReader,它有一个抽象实现类AbstractBeanDefinitionReader，不同配置文件的Reader来继承这个抽象类，实现它们自己的逻辑；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GroovyBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">GroovyObject</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、读取的配置文件会转换成Spring定义的格式，也就是BeanDefinition；</p>
</blockquote>
<p>BeanDefinition定义了类的所有相关的数据； 此时得到的BeanDefinition的属性值只是「符号类型」,并不是真正的属性值；</p>
<p>我们可能会见过这中加载数据源的方式👇</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">dataSource</span> <span class="attr">class</span>=<span class="string">com.alibab.durid.pool.DruidDataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">url</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.url&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">username</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.username&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">password</span> <span class="attr">value</span>=<span class="string">$&#123;jdbc.password&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>数据源的具体配置是放在配置文件中的，当通过XmlBeanDefinitionReader读取并解析到的BeanDefinition，仅仅是将Xml中的文件数据存放到BeanDefinition中，属性的值是${jdbc.url}而不是真正的我们数据源的地址；</p>
<blockquote>
<p>4、得到所有的BeanDefinition之后，通过BeanFactoryPostProcessor来处理上一步骤中，属性value不是真实数据的问题</p>
</blockquote>
<p>比如PlaceHolderConfigurerSupport(占位符处理) 经过工厂后置处理器处理之后，BeanDefinition的属性值就是真实需要的数据了；</p>
<blockquote>
<p>5、BeanDefinition数据准备完成之后，由BeanFactory来完成Bean的创建</p>
</blockquote>
<ul>
<li>实例化 对象中分配堆内存等操作<blockquote>
<p>反射调用无参构造函数 创建对象 但是属性是空的</p>
</blockquote>
</li>
<li>初始化</li>
</ul>
<blockquote>
<p>6、初始化之前需要准备的工作 </p>
</blockquote>
<p>1、准备BeanPostProcessors<br>2、观察者模式，准备监听器 事件 广播器</p>
<blockquote>
<p>7、初始化环节有很多步骤</p>
</blockquote>
<ul>
<li><p>对象的填充</p>
<blockquote>
<p>其实就是调用get/set方法对属性赋值</p>
</blockquote>
</li>
<li><p>调用aware方法</p>
<blockquote>
<p>如果我们的对象中的属性是BeanFactory 我们不用自己去完成setBeanFactory方法，只需要当前类实现BeanFactoryAware方法即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>处理before操作</p>
</li>
<li><p>调用init方法</p>
</li>
<li><p>执行after方法</p>
<blockquote>
<p>before和after此处是调用的BeanPostProcessor的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前置方法</span><br><span class="line">postProcessBeforeInitialization</span><br><span class="line">// 后置方法</span><br><span class="line">postProcessAfterInitialization</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>8、执行到此，完成对象的创建，得到一个可以使用的对象</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>Spring Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-RTO重传计数器的计算</title>
    <url>/wiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>之前的文章已经介绍了TCP超时重传的过程中使用了定时器的策略，当定时器规定时间内未收到确认报文之后，就会触发报文的重传，同时定时器复位；那么定时器超时时间（RTO Retramission Timeout）是如何计算的呢？</p>
</blockquote>
<h2 id="什么是RTT？"><a href="#什么是RTT？" class="headerlink" title="什么是RTT？"></a>什么是RTT？</h2><p>了解RTO如何计算之前，首先明确一个概念「 <strong>RTT</strong> 」；</p>
<image src="https://oscimg.oschina.net/oscnet/up-9b45623a3b0652d842ffa3eecea13e92183.png" width=550 height=400>   

<p>如上图所示，从client发送第一个「SYN」报文，到Server接受到报文，并且返回「SYN ACK」报文之后，client接受到Server的「ACK」报文之后，client所经历的时间，叫做1个RTT时间；</p>
<h2 id="如何在重传下有效测量RTT？"><a href="#如何在重传下有效测量RTT？" class="headerlink" title="如何在重传下有效测量RTT？"></a>如何在重传下有效测量RTT？</h2><p><img src="https://oscimg.oschina.net/oscnet/up-6c558bfea1825bf5d3b2da74e087cdde43a.png"></p>
<p>如上图两种情况：<br>第一种，左侧a图所示，当一端发送的数据报丢失后要进行重传，到重传之后接收到确认报文之后，这种场景下该如何计算RTT呢？开始时间是按照第一次发送数据报时间呢还是按照重传数据报的时间呢？</p>
<blockquote>
<p>按照常理来说，如右侧b图所示，RTT时间应该以RTT2为准；</p>
</blockquote>
<p>第二种，左侧b图所示，第一次发送数据报文时，由于网络时延导致RTO时间内没有收到接收段的确认报文，发送端进行重发，但是在刚刚重发之后就收到了第一次报文的确认报文，那这种情况RTT该如何计算呢？</p>
<blockquote>
<p>如右侧a图所示，RTT时间应该以RTT1为准；</p>
</blockquote>
<p>就像上面提及的两种情况，一会以第一个RTT1为准，一会以RTT2为准，那么TCP协议如何正确的计算出RTT呢？</p>
<h2 id="使用Timestamp方式计算RTT"><a href="#使用Timestamp方式计算RTT" class="headerlink" title="使用Timestamp方式计算RTT"></a>使用Timestamp方式计算RTT</h2><p>之前的文章中在介绍TCP超时与重传的笔记中有介绍通过使用Timtstamp的方式来区分相同Seq序列号的不同报文，<br>其实在TCP报文首部存储Timestamp的时候，会存储报文的发送时间和确认时间，如下所示：<br><image src="https://oscimg.oschina.net/oscnet/up-ad80265bbba417c72a8d02a5c0be7be5f83.png" width=800 height=230> </p>
<h2 id="如何计算RTO？"><a href="#如何计算RTO？" class="headerlink" title="如何计算RTO？"></a>如何计算RTO？</h2><p>上面👆说到了RTT如何计算，那个RTO和RTT有什么关系呢？<br><image src="https://oscimg.oschina.net/oscnet/up-e25afa62f99830eb02c4c1df0c015dbde8a.png"><br> RTO的取值将会影响到TCP的传输效率以及网络的吞吐量；</p>
<blockquote>
<p>通常来说RTO应该略大于RTT，如果RTO小于RTT，则会造成发送端频繁重发，可能会造成网络阻塞；如果RTO设置的过大，则接受端已经收到确认报文之后的一段时间内仍然不能发送其他报文，会造成两端性能的浪费和网络吞吐量的下降；</p>
</blockquote>
<h3 id="平滑RTO"><a href="#平滑RTO" class="headerlink" title="平滑RTO"></a>平滑RTO</h3><p>网络的RTT是不断的变化的，所以计算RTO的时候，应当考虑RTO的平滑性，尽量避免RTT波动带来的干扰，以抵挡瞬时变化；</p>
<p><strong>平滑RTO在文档RFC793定义，给出如下计算方式：</strong></p>
<ul>
<li>SRTT (smoothed round-trip time) = ( α * SRTT ) + ((1 - α) * RTT)<blockquote>
<p>α 从 0到 1(RFC 推荐 0.9)，越大越平滑</p>
</blockquote>
</li>
<li>RTO = min[ UBOUND, max[ LBOUND, (β * SRTT) ] ]<blockquote>
<p>如 UBOUND为1分钟，LBOUND为 1 秒钟， β从 1.3 到 2 之间 </p>
</blockquote>
</li>
</ul>
<p>这种计算方式不适用于 RTT 波动大(方差大)的场景,如果网络的RTT波动很大，会造成RTO调整不及时；</p>
<h3 id="追踪RTT方差计算RTO"><a href="#追踪RTT方差计算RTO" class="headerlink" title="追踪RTT方差计算RTO"></a>追踪RTT方差计算RTO</h3><blockquote>
<p>RFC6298(RFC2988)，其中α = 1/8， β = 1/4，K = 4，G 为最小时间颗粒:</p>
</blockquote>
<ul>
<li><strong>首次计算 RTO，R为第 1 次测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRTT(smoothed round-trip time) = R</span><br><span class="line">RTTVAR(round-trip time variation) = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li>
<li><strong>后续计算 RTO，R’为最新测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRTT= (1-α)*SRTT+α*R’</span><br><span class="line">RTTVAR=(1-β)*RTTVAR+β*|SRTT-R’|</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-四次挥手/断开连接</title>
    <url>/wiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h1><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="https://oscimg.oschina.net/oscnet/up-8d9a6b405e874bc02b91e453bd277c46d46.png" width=450 height=550>

<ul>
<li>开始客户端和服务端都是处理【established】状态</li>
<li>客户端发送「FIN」报文之后，进入FIN-WAIT-1状态</li>
<li>服务端收到客户端的FIN之后，恢复一个ACK，同时进入CLOSE_WAIT状态</li>
<li>客户端接收到ACK之后，进入到FIN-WAIT-2状态</li>
<li>服务端接着发送FIN报文，同时进入LAST-ACK状态</li>
<li>客户端接收到服务端的FIN报文之后，发送ACK报文，并进入TIME_WAIT状态</li>
<li>客户端在经历2个MSL时间之后，进入CLOSE状态</li>
<li>服务端接收到客户端的ACK之后，进入CLOSE状态</li>
</ul>
<blockquote>
<p>并不是所有的四次挥手都是上述流程，当客户端和服务端同时发送关闭连接的请求如下👇：</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-d859884b062bda56a946ae9e3c0c148235b.png" width=450 height=550>

<p>可以看到双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。</p>
<blockquote>
<p>挥手一定需要四次吗？</p>
</blockquote>
<p>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。<br>等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。<br>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？</p>
<blockquote>
<p>为什么要有 TIME_WAIT?</p>
</blockquote>
<p>断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。</p>
<blockquote>
<p><font color=red >那么为什么要等 2MSL 呢？</font></p>
</blockquote>
<ul>
<li>就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。</li>
<li>假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</li>
</ul>
<blockquote>
<p>等待 2MSL 会产生什么问题？</p>
</blockquote>
<p>如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。<br>如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-如何减少小报文提升网络效率</title>
    <url>/wiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<h1 id="如何减少小报文提升网络效率"><a href="#如何减少小报文提升网络效率" class="headerlink" title="如何减少小报文提升网络效率"></a>如何减少小报文提升网络效率</h1><p>每一个TCP报文段都包含20字节的IP头部和20字节的TCP首部，如果报文段的数据部分很少的话，网络效率会很差；</p>
<h2 id="SWS-Silly-Window-syndrome-糊涂窗口综合症"><a href="#SWS-Silly-Window-syndrome-糊涂窗口综合症" class="headerlink" title="SWS(Silly Window syndrome) 糊涂窗口综合症"></a>SWS(Silly Window syndrome) 糊涂窗口综合症</h2><image src="https://oscimg.oschina.net/oscnet/up-777275434842bda3be80da2687c4556ee3b.png" width=600 height=450 >

<p>如上图👆所示场景，在之前的滑动窗口已经了解过，随着服务端处理连接数据能力越来越低，服务端的可用窗口不断压缩，最终导致窗口关闭；</p>
<h3 id="SWS-避免算法"><a href="#SWS-避免算法" class="headerlink" title="SWS 避免算法"></a>SWS 避免算法</h3><p>SWS 避免算法对发送方和接收方都做客</p>
<ul>
<li>接收方<blockquote>
<p>David D Clark 算法:窗口边界移动值小于 min(MSS, 缓存/2)时，<br>通知窗口为 0</p>
</blockquote>
</li>
<li>发送方<blockquote>
<p>Nagle 算法:<br>1、TCP_NODELAY 用于关闭 Nagle 算法<br>2、没有已发送未确认报文段时，立刻发送数据<br>3、存在未确认报文段时，直到:1-没有已发送未确认报文段，或者 2-数据长度达到MSS时再发送</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-delayed-acknowledgment-延迟确认"><a href="#TCP-delayed-acknowledgment-延迟确认" class="headerlink" title="TCP delayed acknowledgment 延迟确认"></a>TCP delayed acknowledgment 延迟确认</h2><p>实际情况下，没有携带任何数据的ACK报文也会造成网络效率低下的，因为确认报文也包含40字节的头部信息，但仅仅是为了传输ACK=1这样的信息，为了解决这种情况，TCP有一种机制，叫做延迟确认，如下👇：</p>
<ul>
<li>当有响应数据要发送时,ack会随着响应数据立即发送给对方.</li>
<li>如果没有响应数据,ack的发送将会有一个延迟,以等待看是否有响应数据可以一起发送</li>
<li>如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack</li>
</ul>
<h3 id="那个延迟的时间如何设置呢？"><a href="#那个延迟的时间如何设置呢？" class="headerlink" title="那个延迟的时间如何设置呢？"></a>那个延迟的时间如何设置呢？</h3><image src="https://oscimg.oschina.net/oscnet/up-5933d7b1310c191603f366eb55669a7cdc8.png" width=400 height=250>

<p>上面👆是Linux操作系统对于TCP延时的定义。</p>
<p>HZ是什呢？其实那是和操作系统的时钟相关的，具体的操作系统间各有差别；<br>如何查看Linux操作系统下的HZ如何设置呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /boot/config- `-uname -r` | grep &#x27;^GONFIG_HZ=&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h2><blockquote>
<p>sendfile 零拷贝技术</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-拥塞控制之慢启动</title>
    <url>/wiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>由于TCP是面向字节流的传输协议，可以发送不定长的字节流数据，TCP连接发送数据时会“先天性”尝试占用整个带宽，而当所有的TCP连接都尝试占用网络带宽时，就会造成网络的堵塞，而TCP慢启动算法则是为了解决这一场景；</p>
<h2 id="全局思考"><a href="#全局思考" class="headerlink" title="全局思考"></a>全局思考</h2><img src="https://oscimg.oschina.net/oscnet/up-b70475e1aadd0776c54efdd5ecf26ef2606.png" width=700 height=400>

<p>拥塞控制要面向整体思考，如上👆网络拓扑图，当左边的网络节点通过路由交换设备向右边的设备传输报文的时候，中间的某一链路的带宽肯定是一定的，这里假设1000M带宽，当左边R1以700Mb/s的速度向链路中发送数据，同时R2以600Mb/s的速率发送报文，那势必会有300Mb的数据报丢失；「路由交换设备基于存储转发来实现报文的发送」大量报文都是时，路由设备的缓冲队列肯定是慢的，这也会造成某些数据报在网络链路中停留时间过长，从而导致TCP通讯变慢，甚至网络瘫痪；</p>
<p>理想的情况下，当链路带宽占满以后，链路以最大带宽传输数据，当然显示中是不可能的，当发生轻度拥塞时，链路的吞吐量就开始下降了，发展到严重阻塞时，链路的吞吐量会严重地下降，甚至瘫痪；</p>
<p>那么，慢启动是如何发挥作用的呢？</p>
<h2 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h2><blockquote>
<p>拥塞窗口cwnd(congestion window)</p>
</blockquote>
<ul>
<li>通告窗口rwnd(receiver‘s advertised window) <blockquote>
<p>其实就是RCV.WND，标志在TCP首部的Window字段！</p>
</blockquote>
</li>
<li>发送窗口swnd = min(cwnd，rwnd)<blockquote>
<p>前面学习滑动窗口的时候提到发送窗口大致等于接受窗口，当引入拥塞窗口时，发送窗口就是拥塞窗口和对方接受窗口的最小值</p>
</blockquote>
</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-4fffa8af1fb99c1ce534085f112fa9f065c.png" width=360 height=360>

<blockquote>
<p>每收到一个ACK，cwnd扩充一倍</p>
</blockquote>
<p>慢启动的窗口大小如何设置呢？<br>如上所示，起初拥塞窗口设置成1个报文段大小，当发送端发送一个报文段并且没有发生丢包时，调整拥塞窗口为2个报文段大小，如果还没有发生丢包，一次类推，知道发生丢包停止；发送窗口以「指数」的方式扩大；慢启动是无法确知网络拥塞程度的情况下，以试探性地方式快速扩大拥塞窗口；</p>
<h2 id="慢启动初始窗口"><a href="#慢启动初始窗口" class="headerlink" title="慢启动初始窗口"></a>慢启动初始窗口</h2><p>慢启动的拥塞窗口真的就如上面所说的以一个报文段大小作为初始值吗？  </p>
<img src="https://oscimg.oschina.net/oscnet/up-e632e6592fd276be90e5cf65a8365b3ddfb.png" width=360 height=360>  

<blockquote>
<p>慢启动初始窗口 IW(Initial Window)的变迁</p>
</blockquote>
<ul>
<li>1 SMSS:RFC2001(1997)</li>
<li>2 - 4 SMSS:RFC2414(1998)<blockquote>
<p>IW = min (4<em>SMSS, max (2</em>SMSS, 4380 bytes))</p>
</blockquote>
</li>
<li>10 SMSS:RFC6928(2013)<blockquote>
<p>IW = min (10<em>MSS, max (2</em>MSS, 14600))</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>其实在实际情况下，互联网中的网页都在10个mss左右，如果还是从1个mss开始，则会浪费3个RTT的时间；  </p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-滑动窗口</title>
    <url>/wiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote>
<p>之前学习了PAR方式的TCP超时和重传，其实在考虑发送方发送数据报的同时，也应该考虑接收方对于数据的处理能力，由此引出本次学习的主题 – 滑动窗口</p>
</blockquote>
<h2 id="发送端窗口"><a href="#发送端窗口" class="headerlink" title="发送端窗口"></a>发送端窗口</h2><p>滑动窗口按照传输数据方向分为两种，发送端窗口和接收端窗口；下面先看一下发送端窗口👇：</p>
<image src="https://oscimg.oschina.net/oscnet/up-13e77c53892b884d334614e4fa9550a1113.png">

<p>上图分为四个部分：</p>
<ol>
<li>已发送并收到 Ack 确认的数据:1-31 字节</li>
<li>已发送未收到 Ack 确认的数据:32-45 字节</li>
<li>未发送但总大小在接收方处理范围内:46-51 字节</li>
<li>未发送但总大小超出接收方处理范围:52-字节</li>
</ol>
<h3 id="可用窗口和发送窗口"><a href="#可用窗口和发送窗口" class="headerlink" title="可用窗口和发送窗口"></a>可用窗口和发送窗口</h3><image src="https://oscimg.oschina.net/oscnet/up-b8bb072922232fe6d62aec3520647d869fe.png"> 

<p>如上图这里可以引出两个概念：「可用窗口」和「发送窗口」</p>
<blockquote>
<p>【 <strong>可用窗口</strong> 】： 就是上图中的第三部分，属于还未发送，但是在接收端可以处理范围内的部分；<br>【 <strong>发送窗口</strong> 】： 就是发送端可以发送的最大报文大小，如上图中的第二部分+第三部分合成发送窗口；</p>
</blockquote>
<h3 id="可用窗口耗尽"><a href="#可用窗口耗尽" class="headerlink" title="可用窗口耗尽"></a>可用窗口耗尽</h3><image src="https://oscimg.oschina.net/oscnet/up-333b88e14f6fd5833fd92a9ab45894e60dd.png"> 

<p>可用窗口会在一个短暂的停留，当处于未发送并且接受端可以接受范围内的数据传输完成之后，可用窗口耗尽；<br>当然上面仅仅说的一瞬时的状态，这个状态下，已经发送的报文段还没有确认，并且发送窗口大小没有发生变化，此时发送窗口达到最大状态；</p>
<h3 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h3><image src="https://oscimg.oschina.net/oscnet/up-4436cdb5c6720e3e4a262ec1cad64660a77.png">  

<p>如果在发送窗口中已经发送的报文段已经得到接受端确认之后，那部分数据就会被移除发送窗口，在发送窗口大小不发生变化的情况下，发送窗口向右➡️移动5个字节，因为左边已经发送的5个字节得到确认之后，被移除发送窗口；</p>
<h3 id="可用窗口如何计算"><a href="#可用窗口如何计算" class="headerlink" title="可用窗口如何计算"></a>可用窗口如何计算</h3><image src="https://oscimg.oschina.net/oscnet/up-76f97fc92f6940c7197ff9fcad3c187fd98.png">

<p>再次引出三个概念：</p>
<ul>
<li>SND.WND<blockquote>
<p>SND 指的是发送端，WND指的是window，也就是发送端窗口的意思</p>
</blockquote>
</li>
<li>SND.UNA<blockquote>
<p>UNA 就是un ACK的意思，指的是已经发送但是没有没有确认 它指向窗口的第一个字节处</p>
</blockquote>
</li>
<li>SND.NXT<blockquote>
<p>NXT 是next的位置，是发送方接下来要发送的位置，它指向可用窗口的第一个字节处</p>
</blockquote>
</li>
</ul>
<p><strong>那就很容易得出可用窗口的大小了，计算公式如下：</strong></p>
<blockquote>
<p>Usable Window Size = SND.UNA + SND.WND - SND.NXT </p>
</blockquote>
<h2 id="接收端窗口"><a href="#接收端窗口" class="headerlink" title="接收端窗口"></a>接收端窗口</h2><p>上面介绍了发送端窗口的一些概念，下面👇是接收端窗口的学习：</p>
<image src="https://oscimg.oschina.net/oscnet/up-0313775eaecc790ad26b44c3daa17ced593.png">

<ol>
<li>已经接收并且已经确认 :28-31 字节</li>
<li>还未接收并且接收端可以接受:32-51 字节</li>
<li>还未接收并且超出接收处理能力:51-57 字节</li>
</ol>
<p>这里引出两个概念：</p>
<ul>
<li>RCV.WND<blockquote>
<p>RCV是接收端的意思，WND是接受端窗口的大小</p>
</blockquote>
</li>
<li>RCV.NXT<blockquote>
<p>NXT表示的是接受端接收窗口的开始位置，也就是接收方接下来处理的第一个字节；</p>
</blockquote>
</li>
</ul>
<p>RCV.WND的大小接受端的内存以及缓冲区大小有关，在某种意义上说，接受端的窗口大小和发送端大小大致相同；<br>接受端可接收的数据能力可以通过TCP首部的Window字段设置，但是接受端的处理能力是可能随时变化的，所以接受端和服务端的窗口大小大致是一样的；</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>下面👇根据一个例子来阐述流量控制，模拟一个GET请求，客户端向服务端请求一个260字节的文件，大致流程如下，比较繁琐：</p>
<image src="https://oscimg.oschina.net/oscnet/up-08e7b2cd9ee3ddaa44bca900a1824e08b09.png" width=900 height=480> 

<blockquote>
<p>这里假设MSS和窗口的大小不发生变化，同时客户端和发送端状态如下：<br>【 客户端 】： 发送窗口默认360字节 接收窗口设定200字节<br>【 服务端 】： 发送窗口设定200字节 接收窗口设定360字节</p>
</blockquote>
<p>Step1： 客户端发送140字节的数据到服务端</p>
<blockquote>
<p>【客户端】发送140字节，【SND.NXT】从1-&gt;141 </p>
</blockquote>
<blockquote>
<p>【服务端】状态不变，等待接收客户端传输的140字节</p>
</blockquote>
<p>Step2: 服务端接收140字节，发送80字节响应以及ACK</p>
<blockquote>
<p>【 客户端 】发送140字节之后等待【 服务端 】的ACK</p>
</blockquote>
<blockquote>
<p>【 服务端 】可用窗口右移，【RCV.NXT】从1-&gt;141<br>【 服务端 】发送80字节数据，【SND.NXT】从241-&gt;321</p>
</blockquote>
<p>Step3: 客户端接收响应ACK，并且发送ACK </p>
<blockquote>
<p>【 客户端 】发出的140字节得到确认，【SND.UNA】右移140字节<br>【 客户端 】接收80字节数据，【RCV.NXT】右移80字节，从241-&gt;321</p>
</blockquote>
<p>Step4: 服务端发送一个280字节的文件，但是280字节超出了客户端的接收窗口，所以客户端分成两部分传输，先传输120字节；</p>
<blockquote>
<p>【 服务端 】发送120字节，【SND.NXT】向右移动120字节，从321-&gt;441</p>
</blockquote>
<p>Step5: 客户端接收文件第一部分，并发送ACK</p>
<blockquote>
<p>【 客户端 】接收120字节，【RCV.NXT】从321-&gt;441</p>
</blockquote>
<p>Step6：服务端接收到第二步80字节的ACK</p>
<blockquote>
<p>[ 服务器 ] 80字节得到ACK 【SND.UNA】从241-&gt;321</p>
</blockquote>
<p>Step7: 服务端接收到第4步的确认</p>
<blockquote>
<p>【 服务端 】之前发送文件第一部分的120字节得到确认，【SND.UNA】右移动120，从321-&gt;441</p>
</blockquote>
<p>Step8: 服务端发送文件第二部分的160字节</p>
<blockquote>
<p>【 服务端 】： 发送160字节，【SND.NXT】向右移动160字节，从441-&gt;601</p>
</blockquote>
<p>Step9: 客户端接收到文件第二部分160字节，同时发送ACK</p>
<blockquote>
<p>【 客户端 】接收160字节，【RCV.NXT】向右移动160字节，从441-&gt;601</p>
</blockquote>
<p>Step10: 服务端收到文件第二部分的ACK</p>
<blockquote>
<p>【 服务端 】发送的160字节得到确认，【SND.UNA】向右一定160字节，从441-&gt;601；至此客户端收到服务端发送的完整的文件；</p>
</blockquote>
<p>上面通过表格列举服务端和客户端每个状态在每个步骤的状态，如果不是很好理解，可以看如下示意图辅助理解：</p>
<h3 id="客户端交互流程"><a href="#客户端交互流程" class="headerlink" title="客户端交互流程"></a>客户端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-6ee487f0677efac1a822207f45fc0a2b842.png" width=500 >

<h3 id="服务端交互流程"><a href="#服务端交互流程" class="headerlink" title="服务端交互流程"></a>服务端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-4a0095fb6e7a82a708e4df96dfdacd956aa.png" width="500"> 

<p>上面👆是模拟一个GET请求，服务端发送一个280字节的文件给到客户端，客户端的接收窗口是200字节场景加，客户端和服务端的数据传输与交互流程，通过这个流程来学习滑动窗口的移动状态和流量控制的大致流程；</p>
<h2 id="滑动窗口与操作系统缓冲区"><a href="#滑动窗口与操作系统缓冲区" class="headerlink" title="滑动窗口与操作系统缓冲区"></a>滑动窗口与操作系统缓冲区</h2><p>上面👆讲述的时候，都是假设窗口大小是不变的，而实际上，发送端和接受端的滑动窗口的字节数都吃存储在操作系统缓冲区的，操作系统的缓冲区受操作系统控制，当应用进程增加是，每个进程分配的内存减少，缓冲区减少，分配给每个连接的窗口就会压缩。**<font color="red">而且滑动窗口的大小也受应用进程读取缓冲区数据速度有关</font>**；</p>
<image src="https://oscimg.oschina.net/oscnet/up-3839118daafc840e059fa6f82d283bef7a9.png" width="500">   

<h3 id="应用进程读取缓冲区数据不及时造成窗口收缩"><a href="#应用进程读取缓冲区数据不及时造成窗口收缩" class="headerlink" title="应用进程读取缓冲区数据不及时造成窗口收缩"></a>应用进程读取缓冲区数据不及时造成窗口收缩</h3><p>step1: 客户端发送140字节</p>
<blockquote>
<p>客户端发送到140字节之后，可用窗口收缩到220字节，发送窗口不变</p>
</blockquote>
<p>Step2: 服务端接收140字节 但是应用进程仅仅读取40字节</p>
<blockquote>
<p>服务端应用进程仅仅读取40字节，仍有100字节占用缓冲区大小，导致接受窗口收缩，服务端发送ACK报文时，在首部Window带上接收窗口的大小260</p>
</blockquote>
<p>Step3: 客户端收到确认报文之后，发送窗口收缩到260</p>
<p>Step4: 客户端继续发送180字节数据</p>
<blockquote>
<p>客户端发送180字节之后，可用窗口变成80字节</p>
</blockquote>
<p>Step5: 服务端接收到180字节</p>
<blockquote>
<p>假设应用程序仍然不读取这180字节，最终也导致服务端接收窗口再次收缩180字节，仅剩下80字节，在发送确认报文时，设置首部window=80</p>
</blockquote>
<p>Step6: 客户端收到80字节的窗口时，调整发送窗口大小为80字节，可用窗口也是80字节</p>
<p>Step7: 客户端仍然发送80字节到服务端，此时可用窗口为空</p>
<p>Step8: 服务端应用进程继续不读区这80字节的缓冲区数据，最终导致服务端接收窗口大小为0，不能再接收任何数据，同时发送ACK报文；</p>
<p>Step9：客户端收到确认报文之后，调整发送窗口大小为0，这个状态叫做「 <strong>窗口关闭</strong> 」</p>
<h3 id="窗口收缩导致的丢包"><a href="#窗口收缩导致的丢包" class="headerlink" title="窗口收缩导致的丢包"></a>窗口收缩导致的丢包</h3><image src="https://oscimg.oschina.net/oscnet/up-174e19d4d8de9757707034b8271cb3c69a7.png" width="530">

<p>Step1：客户端服务端开始的窗口大小都是360字节，客户端发送140字节数据</p>
<blockquote>
<p>客户端发送140字节之后，可用窗口变成220字节</p>
</blockquote>
<p>Step2：服务端应用进程骤增，进程缓存区平均分配，造成服务端接收窗口减少，从360变成240字节；</p>
<blockquote>
<p>假设接收了140字节之后，应用进程没有读取，那个可用窗口进一步压缩，变成100字节；</p>
</blockquote>
<p>Step3：假设同一个连接在没有收到服务端确认之后，又发送了180个字节的数据（Retramission）</p>
<blockquote>
<p>先发送了140字节，后发送了180字节，都没有得到确认，客户端可用窗口大小变成40字节</p>
</blockquote>
<p>Step4：服务端收到上面👆第三步发送的180字节的数据，但是接受窗口的大小只有100字节，所以不能接收</p>
<blockquote>
<p>服务端拒绝接收180字节</p>
</blockquote>
<p>Step5：此时客户端才收到之前140字节的确认报文，才知道接收窗口发生了变化</p>
<blockquote>
<p>客户端由于没有收到180字节的确认，加入客户端正在准备发送180字节数据，得到接受端的窗口大小是100字节之后，须强制将右侧窗口向左收缩80字节；</p>
</blockquote>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>这个例子和上面的例子都发生了「 <strong><font color="red">窗口关闭</font></strong> 」</p>
<blockquote>
<p>窗口关闭： 发送端的发送窗口变成0的状态；</p>
</blockquote>
<p>上面讲的两种情况一般不会发生的，因为操作系统不会既收缩窗口，同时减少连接缓存；而是一般先使用窗口收缩策略，之后在压缩缓冲区的方式来规避以上问题；<br>发生窗口关闭之后，发送端不会被动的等待服务端的通知，而是会采用定时嗅探的方式去查看服务端接收窗口是否开放；</p>
<h2 id="Linux中对TCP缓冲区的调整方式"><a href="#Linux中对TCP缓冲区的调整方式" class="headerlink" title="Linux中对TCP缓冲区的调整方式"></a>Linux中对TCP缓冲区的调整方式</h2><ul>
<li><p>net.ipv4.tcp_rmem = 4096 87380 6291456</p>
<blockquote>
<p>读缓存最小值、默认值、最大值，单位字节，覆盖 net.core.rmem_max</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_wmem = 4096 16384 4194304</p>
<blockquote>
<p>写缓存最小值、默认值、最大值，单位字节，覆盖net.core.wmem_max</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_mem = 1541646 2055528 3083292</p>
<blockquote>
<p>系统无内存压力、启动压力模式阀值、最大值，单位为页的数量</p>
</blockquote>
</li>
<li><p>net.ipv4.tcp_moderate_rcvbuf = 1 </p>
<blockquote>
<p>开启自动调整缓存模式</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手</title>
    <url>/wiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h2 id="握手🤝的目的"><a href="#握手🤝的目的" class="headerlink" title="握手🤝的目的"></a>握手🤝的目的</h2><ul>
<li>同步Sequence序列号<blockquote>
<p>初始化序<br>列号ISN （Inital Sequence Number）</p>
</blockquote>
</li>
<li>交换TCP通讯的参数<blockquote>
<p>比如最大报文段参数（MSS）、窗口比例因子（Window）、选择性确认（SACK）、制定校验和算法；</p>
</blockquote>
</li>
</ul>
<h2 id="三次握手握手过程"><a href="#三次握手握手过程" class="headerlink" title="三次握手握手过程"></a>三次握手握手过程</h2><image src="https://oscimg.oschina.net/oscnet/up-7ee7a8388d0fc3798344cad07f585bf7961.png" width=500 height=300>

<p>TCP三次握手的大致流程图如上👆  </p>
<p>使用tcpdump抓包分析三次🤝握手报文中Seq和Ack的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump  port 80 -c 3 -S</span><br></pre></td></tr></table></figure>
<p><img src="https://sjwx.easydoc.xyz/47754217/files/kmov1k44.png" alt="image.png">  </p>
<h3 id="第一次握手🤝"><a href="#第一次握手🤝" class="headerlink" title="第一次握手🤝"></a>第一次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [S], seq 3800409106, win 29200, options [mss 1460,sackOK,TS val 839851765 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>
<p>客户端upay访问服务端80端口，发送一个「 seq=3800409106 」 ，同时标志位SYN=1，声明此次握手是要建立连接；</p>
<h3 id="第二次握手🤝"><a href="#第二次握手🤝" class="headerlink" title="第二次握手🤝"></a>第二次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP 100.100.15.23.http &gt; upay.60734: Flags [S.], seq 1981710286, ack 3800409107, win 14600, options [mss 1440,nop,nop,sackOK,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>
<p>第二次握手，服务端收到客户端的申请连接强求（SYN=1）之后，在服务端自己准备好的情况下，给客户端发送 「 ACK=1 SYN=1 」的确认报文，SYN=1同样也是声明此次报文是建立连接的报文请求； ack= 3800409107 也就是第一个客户端发给服务端的seq+1（ack是接收方下次期望接口报文的开始位置）</p>
<h3 id="第三次握手握手"><a href="#第三次握手握手" class="headerlink" title="第三次握手握手"></a>第三次握手握手</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [.], ack 1981710287, win 229, length 0</span><br></pre></td></tr></table></figure>
<p>客户端收到服务器返回的确认报文，确认可以进行连接，发送「 ack = 1981710287 」的确认报文，之后就完成了三次握手，TCP的连接就创建成功了，接下来双方就可以发送数据报了；</p>
<h2 id="TCP连接创建构成中状态的变更"><a href="#TCP连接创建构成中状态的变更" class="headerlink" title="TCP连接创建构成中状态的变更"></a>TCP连接创建构成中状态的变更</h2><image src="https://oscimg.oschina.net/oscnet/up-d6920a59ec1cb6a738265b6f182cbdbe2ba.png" width=550 height=400>

<ul>
<li>首先客户端和服务端都是【CLOSED】状态，客户端发起连接请求之后，进入【SYN-SENT】状态，这个状态维持的时间很短，我们使用netstat去查看tcp连接状态的时候，基本上都不会看到这个状态，而服务端是在【LISTEN】状态，等待客户端的请求；</li>
<li>服务端收到客户端请求之后，发送「SYN ACK」确认报文，同时服务端进入【SYN-RECEIVED】状态，等待客户端的确认报文；</li>
<li>客户端收到服务端的同步确认请求之后，发送「ACK」确认报文，同时进入【ESTABLISHED】状态，准备后续的数据传输；</li>
<li>服务端收到三次握手最后的确认报文之后，进入【ESTABLISHED】状态，至此，一个TCP连接算是建立完成了，后面就是双方的通信了；</li>
</ul>
<h2 id="TCB（Transmission-Control-Block）"><a href="#TCB（Transmission-Control-Block）" class="headerlink" title="TCB（Transmission Control Block）"></a>TCB（Transmission Control Block）</h2><blockquote>
<p>保存连接使用的源端口、目的端口、目的 ip、序号、 应答序号、对方窗口大小、己方窗口大小、tcp 状态、tcp 输入/输出队列、应用层输出队 列、tcp 的重传有关变量等</p>
</blockquote>
<h2 id="TCP性能优化和安全问题"><a href="#TCP性能优化和安全问题" class="headerlink" title="TCP性能优化和安全问题"></a>TCP性能优化和安全问题</h2><image src="https://oscimg.oschina.net/oscnet/up-e99592d430e1219134af66e69aee2e6ccbd.png"  width=550 height=400 >

<p>正如我们了解的TCP三次握手🤝的流程，当有大量SYN请求到达服务端时，会进入到【SYN队列】，服务端收到第二次确认报文之后，会进入【ESTABLISHED】状态，服务端操作系统内核会将连接放入到【ACCEPT】队列中，当Nginx或者Tomcat这些应用程序在调用accept（访问内核）的时候，就是在【ACCEPT】队列中取出连接进行处理；</p>
<blockquote>
<p>由此可见，【SYN】队列和【ACCEPT】是会影响服务器连接性能的重要因素，所以对于高并发的场景下，这两个队列一定是要设置的比较大的；</p>
</blockquote>
<h3 id="如何设置SYN队列大小"><a href="#如何设置SYN队列大小" class="headerlink" title="如何设置SYN队列大小"></a>如何设置SYN队列大小</h3><p>服务器端 SYN_RCV 状态</p>
<ul>
<li>net.ipv4.tcp_max_syn_backlog:SYN_RCVD 状态连接的最大个数</li>
<li>net.ipv4.tcp_synack_retries:被动建立连接时，发SYN/ACK的重试次数</li>
</ul>
<p>客户端 SYN_SENT 状态（服务端作为客户端，比如Ngnix转发等）</p>
<ul>
<li>net.ipv4.tcp_syn_retries = 6 主动建立连接时，发 SYN 的重试次数</li>
<li>net.ipv4.ip_local_port_range = 32768 60999 建立连接时的本地端口可用范围</li>
</ul>
<h2 id="Fast-Open机制"><a href="#Fast-Open机制" class="headerlink" title="Fast Open机制"></a>Fast Open机制</h2><image src="https://oscimg.oschina.net/oscnet/up-071f997614b36eb8b4511db0f3ba0637d70.png" width=550 height=400 >

<p>TCP如何对连接的次数以及连接时间进行优化的呢？这里提到Fast Open机制；<br>比如我们有一个Http Get请求，正常的三次握手🤝到收到服务端数据需要2个RTT的时间；FastOpen做出如下优化：</p>
<ul>
<li>第一次创建连接的时候，也是要经历2个RTT时间，但是在服务端发送确认报文的时候，在报文中添加一个cookie；</li>
<li>等到下次客户端再需要创建请求的时候，直接将【SYN】和cookie一并带上，可以一次就创建连接，经过一个RTT客户端就可以收到服务端的数据；</li>
</ul>
<h4 id="如何Linux上打开TCP-Fast-Open"><a href="#如何Linux上打开TCP-Fast-Open" class="headerlink" title="如何Linux上打开TCP Fast Open"></a>如何Linux上打开TCP Fast Open</h4><p> net.ipv4.tcp_fastopen:系统开启 TFO 功能 </p>
<ul>
<li>0:关闭</li>
<li>1:作为客户端时可以使用 TFO</li>
<li>2:作为服务器时可以使用 TFO</li>
<li>3:无论作为客户端还是服务器，都可以使用 TFO</li>
</ul>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><h4 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h4><p>  正常的服务通讯都是由操作系统内核实现的请求报文来创建连接的，但是，可以人为伪造大量不同IP地址的SYN报文，也就是上面👆状态变更图中的SYN请求，但是收到服务端的ACK报文之后，却不发送对于服务端的ACK请求，也就是没有第三次挥手，这样会造成大量处于【SYN-RECEIVED】状态的TCP连接占用大量服务端资源，导致正常的连接无法创建，从而导致系统崩坏；</p>
<h4 id="SYN攻击如何查看"><a href="#SYN攻击如何查看" class="headerlink" title="SYN攻击如何查看"></a>SYN攻击如何查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nap | grep SYN_RECV</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果存在大量【SYN-RECEIVED】的连接，就是发生SYN攻击了；</p>
</blockquote>
<h4 id="如何规避SYN攻击？"><a href="#如何规避SYN攻击？" class="headerlink" title="如何规避SYN攻击？"></a>如何规避SYN攻击？</h4><ul>
<li><p><strong>net.core.netdev_max_backlog</strong></p>
<blockquote>
<p>接收自网卡、但未被内核协议栈处理的报文队列长度</p>
</blockquote>
</li>
<li><p><strong>net.ipv4.tcp_max_syn_backlog</strong></p>
<blockquote>
<p>SYN_RCVD 状态连接的最大个数</p>
</blockquote>
</li>
<li><p><strong>net.ipv4.tcp_abort_on_overflow</strong></p>
<blockquote>
<p>超出处理能力时，对新来的 SYN 直接回包 RST，丢弃连接</p>
</blockquote>
</li>
<li><p>设置SYN Timeout</p>
<blockquote>
<p>由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下，可以成倍的降低服务器的负荷。但过低的SYN Timeout设置可能会影响客户的正常访问。</p>
</blockquote>
</li>
<li><p>设置SYN Cookie (net.ipv4.tcp_syncookies = 1)</p>
<blockquote>
<p>就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，并记录地址信息，以后从这个IP地址来的包会被一概丢弃。这样做的结果也可能会影响到正常用户的访问。</p>
</blockquote>
</li>
</ul>
<image src="https://oscimg.oschina.net/oscnet/up-8cce8662408ffa1f5ed678be972248b92ca.png" width=800 height=350>

<p>当 SYN 队列满后，新的 SYN 不进入队列，计算出 cookie 再 以 SYN+ACK 中的序列号返回客户端，正常客户端发报文时， 服务器根据报文中携带的 cookie 重新恢复连接</p>
<blockquote>
<p>由于 cookie 占用序列号空间，导致此时所有 TCP 可选 功能失效，例如扩充窗口、时间戳等</p>
</blockquote>
<h2 id="TCP-DEFER-ACCEPT"><a href="#TCP-DEFER-ACCEPT" class="headerlink" title="TCP_DEFER_ACCEPT"></a>TCP_DEFER_ACCEPT</h2><p>这个是做什么呢？ 正如上面👆操作系统内核展示图所示，内核中维护两个队列【SYN】队列和【ACCEPT】队列，只有当收到客户端的ACK报文之后，连接会进入到【ACCEPT】，同时服务器的状态是<br>【ESTABLISHED】状态，此时操作系统并不会去激活应用进程，而是会等待，知道收到真正的data分组之后，才会激活应用进程，这是为了提高应用进程的执行效率，避免应用进程的等待；</p>
<blockquote>
<p>TCP三次握手为什么不能是两次或者四次</p>
</blockquote>
<p>参见文章：<a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/wiki/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="TCP协议学习笔记📒"><a href="#TCP协议学习笔记📒" class="headerlink" title="TCP协议学习笔记📒"></a>TCP协议学习笔记📒</h2><blockquote>
<p>下面是本人在学习TCP协议的过程中，记录的笔记，按照学习的过程从前到后整理在这里！<br>可能会有很多的知识没有罗列，只是记录的大概框架，如果有问题或错误，欢迎指正！</p>
</blockquote>
<blockquote>
<p><a href="doc:RGuKLdsI">1、TCP报文头部</a><br><a href="doc:OMRc4svF">2、TCP三次握手</a><br><a href="doc:MpizaHTg">3、TCP最大报文段（MSS）</a><br><a href="doc:ELxUb4mv">4、TCP超时与重传</a><br><a href="doc:wqRVLcNo">5、RTO重传计时器的计算</a><br><a href="doc:IhqiYamL">6、滑动窗口</a><br><a href="doc:HoE3w3UG">7、提升网络效率</a><br><a href="doc:N7riiaCk">8、TCP拥塞控制之慢启动</a><br><a href="doc:GQoRKrER">9、TCP拥塞控制之拥塞避免</a><br><a href="doc:y4aESoPN">10、快速重传与快速恢复</a><br><a href="doc:g1Onj7OR">11、四次挥手</a></p>
</blockquote>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><blockquote>
<p>敖丙Github整理的笔记 </p>
</blockquote>
<p>有大概10篇左右的文章，都是高质量的，原地址请点击着👉 <a href="https://github.com/AobingJava/JavaFamily">【Github】</a></p>
<blockquote>
<p>极客时间《Web协议详解与抓包实战》– 陶辉老师</p>
</blockquote>
<p>这门课程专门讲解网络协议的，包括Http/Https,TLS协议，TCP协议，IP协议等；</p>
<blockquote>
<p>《计算机网络 自顶向下方法》第7版</p>
</blockquote>
<p>很多名校计算机网络课程在使用的教材，非常权威！</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP头部</title>
    <url>/wiki/TCP%E5%A4%B4%E9%83%A8/</url>
    <content><![CDATA[<h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><ul>
<li>如何校验报文段是否损坏？ 如何CRC校验</li>
<li>seq和ack是如何计算的？ </li>
<li>tcp校验位都有那些？ 6个 分别是什么含义？</li>
<li>tcp如何计算首部长度？ 偏移量</li>
<li>TCP Retransmission 重传？ </li>
<li>tcp spurious retransmission 又是什么呢？ </li>
<li>tcp dup ack 是什么？</li>
<li>ack与ACK有什么区别？ 分别有什么作用？</li>
</ul>
<h2 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-d3e5715ff000040a0b18b2c9374d7e55f53.png">   </p>
<p>学习TCP协议首先要看一下它的报文段是如何组成的；TCP报文段组成由两部分，第一部分是报文头部，第二部分是数据部分；</p>
<p>先看一下报文头，也就是TCP首部的组成；</p>
<h3 id="16位端口"><a href="#16位端口" class="headerlink" title="16位端口"></a>16位端口</h3><p>16位端口号：告知主机该报文段是来自哪里（源端口Source Port）以及传给哪个上层协议或应用程序（目的端口Destination Port）的。<br>进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（比如DNS协议对应端口53，HTTP协议对应80，这些端口号可在/etc/services文件中找到）。  </p>
<h3 id="序列号（Seq）"><a href="#序列号（Seq）" class="headerlink" title="序列号（Seq）"></a>序列号（Seq）</h3><p>占32位，也就是4字节长度，序号范围自然也是是0~2^32-1。TCP是面向字节流的，TCP连接中传送的字节流中的每个字节都按顺序编号。整个要传送的字节流的起始序号必须要在连接建立时设置。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。   </p>
<p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。  </p>
<p>**这里存在一个疑问，第一次建立TCP连接的时候，网上一些博客上说seq是client随机生成的，也有的博客说是seq=1； 这里经过我抓包后，看到第一次创建TCP连接的时候，确实是1; **    </p>
<h3 id="确认应答号（Ack）"><a href="#确认应答号（Ack）" class="headerlink" title="确认应答号（Ack）"></a>确认应答号（Ack）</h3><p>Ack占32位，4个字节长度，表示期望收到对方下一个报文段的序号值。 用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。<br>TCP的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。  </p>
<p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。    </p>
<p>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。    </p>
<h3 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了TCP报文段的首部长度 ，它指出了TCP报文段的数据起始处距离TCP报文的起始处有多远。</p>
<blockquote>
<p>注意数据起始处和报文起始处的意思，上面👆已经写到，TCP报文段的组成有两部分，TCP报文首部和数据部分，偏移量记录的是报文段开始和数据开始的长度，也就是报文首部的长度；  </p>
</blockquote>
<p>一个数据偏移量 = 4 byte，由于4位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了TCP首部的最大长度。  </p>
<h3 id="保留Reserved"><a href="#保留Reserved" class="headerlink" title="保留Reserved"></a>保留Reserved</h3><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p>
<h3 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h3><p><img src="https://oscimg.oschina.net/oscnet/up-869702a0e6199a93eb3be514c04e28274a7.png"><br>标志位，一共有6个，分别占1位，共6位。 每一位的值只有 0 和 1，分别表达不同意思。 如上图是使用wireshard抓包展示截图；  </p>
<h4 id="ACK-Acknowlegemt-：确认序号有效"><a href="#ACK-Acknowlegemt-：确认序号有效" class="headerlink" title="ACK(Acknowlegemt)  ：确认序号有效"></a>ACK(Acknowlegemt)  ：确认序号有效</h4><blockquote>
<p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。  </p>
</blockquote>
<h4 id="RST-Reset-：重置连接"><a href="#RST-Reset-：重置连接" class="headerlink" title="RST(Reset)：重置连接"></a>RST(Reset)：重置连接</h4><blockquote>
<p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。 </p>
</blockquote>
<h4 id="SYN-SYNchronization-：发起了一个新连接"><a href="#SYN-SYNchronization-：发起了一个新连接" class="headerlink" title="SYN(SYNchronization)：发起了一个新连接"></a>SYN(SYNchronization)：发起了一个新连接</h4><blockquote>
<p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p>
</blockquote>
<h4 id="PSH-Push-推送"><a href="#PSH-Push-推送" class="headerlink" title="PSH (Push): 推送"></a>PSH (Push): 推送</h4><blockquote>
<p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。  </p>
</blockquote>
<h4 id="FIN：释放一个连接"><a href="#FIN：释放一个连接" class="headerlink" title="FIN：释放一个连接"></a>FIN：释放一个连接</h4><blockquote>
<p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p>
</blockquote>
<h3 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h3><p>占16位。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p>
<blockquote>
<p>例如，假如确认号是701，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。  </p>
</blockquote>
<h3 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h3><p>占16位。 由发送端填充，接收端对TCP报文段执行【CRC算法】，以检验TCP报文段在传输过程中是否损坏，如果损坏这丢弃。</p>
<p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p>
<h3 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p>
<p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><image src="https://oscimg.oschina.net/oscnet/up-e071765090a2bbf6a9944907b288c70cd4a.png" width="400">

<ul>
<li>每个选项开始是1字节kind字段，说明选项的类型</li>
<li>kind为0和1的选项，只占一个字节</li>
<li>其他kind后有一字节len，表示该选项总长度（包括kind和len）</li>
<li>kind为11，12，13表示tcp事务</li>
</ul>
<p><strong>下面是常用选项：</strong><br><image src="https://oscimg.oschina.net/oscnet/up-1043e2bd27321e5ae0bc13be398e989be3e.png" width=800 height=300></p>
<h3 id="MTU（最大传输单元）"><a href="#MTU（最大传输单元）" class="headerlink" title="MTU（最大传输单元）"></a>MTU（最大传输单元）</h3><p>MTU（最大传输单元）是【链路层】中的网络对数据帧的一个限制，以以太网为例，MTU 为 1500 个字节。一个IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装。IP 数据报的分片与重组是在网络层进完成的。</p>
<h3 id="MSS-（最大分段大小）"><a href="#MSS-（最大分段大小）" class="headerlink" title="MSS （最大分段大小）"></a>MSS （最大分段大小）</h3><p>MSS 是 TCP 里的一个概念（首部的选项字段中）。MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 协议在建立连接的时候通常要协商双方的 MSS 值，每一方都有用于通告它期望接收的 MSS 选项（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（需要减去 IP 数据包包头的大小 20Bytes 和 TCP 数据段的包头 20Bytes）所以如果用链路层以太网，MSS 的值往往为 1460。而 Internet 上标准的 MTU 为 576，那么如果不设置，则MSS的默认值就为 536 个字节。TCP报文段的分段与重组是在运输层完成的。</p>
<h2 id="seq和ack的计算逻辑"><a href="#seq和ack的计算逻辑" class="headerlink" title="seq和ack的计算逻辑"></a>seq和ack的计算逻辑</h2><image src="https://oscimg.oschina.net/oscnet/up-710a22f4e6b6c961662879fe2ac6000cca9.png" width=900 height=500> 


<h2 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/15754b4e9458">TCP协议中的seq/ack序号是如何变化的？</a><br><a href="https://www.jianshu.com/p/ef892323e68f">TCP协议详解</a><br><a href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP协议详解（一）：TCP头部结构</a><br><a href="https://blog.csdn.net/zuochao_2013/article/details/80561793">TCP和UDP报文头格式</a><br><a href="https://juejin.cn/post/6844903685563105293">TCP协议详解</a><br><a href="https://juejin.cn/post/6844904131342123022">吃透TCP协议</a>  </p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP最大报文段（MSS）</title>
    <url>/wiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MSS产生的背景"><a href="#MSS产生的背景" class="headerlink" title="MSS产生的背景"></a>MSS产生的背景</h2><p>我们都知道TCP协议是运输在传输层的协议，它是面向【字节流】的传输协议；<br>它的上层，应用层传输的数据是无限制的，但是它的下层也就是网络层和链路层由于路由等转发设备有内存等限制是不可能无限制传输任何大小的报文的，它们一定会限制报文的长度，因此 <strong>TCP协议要完成的工作是将从应用层接受到的任意长度数据，切割成多个报文段，MSS就是如何切割报文段的依据。</strong></p>
<image src="https://oscimg.oschina.net/oscnet/up-004bb74a9d5648d949d9549219c677f568f.png" width=450 height=300>


<h2 id="什么是MSS"><a href="#什么是MSS" class="headerlink" title="什么是MSS"></a>什么是MSS</h2><p>MSS（Max Segment Size）：仅指 TCP 承载数据，不包含 TCP 头部的大小，参见 RFC879</p>
<h2 id="MSS-选择目的"><a href="#MSS-选择目的" class="headerlink" title="MSS 选择目的"></a>MSS 选择目的</h2><ul>
<li>尽量每个 Segment 报文段携带更多的数据，以减少头部空间占用比率 </li>
<li>防止 Segment 被某个设备的 IP 层基于 MTU 拆分<blockquote>
<p>IP层基于MTU的数据拆分是效率极差的，一个报文段丢失，所有的报文段都要重传</p>
</blockquote>
</li>
</ul>
<h2 id="MSS默认大小"><a href="#MSS默认大小" class="headerlink" title="MSS默认大小"></a>MSS默认大小</h2><blockquote>
<p>默认 MSS:536 字节(默认 MTU576 字节，20 字节 IP 头部，20 字节 TCP 头部)</p>
</blockquote>
<h2 id="MSS在什么时候使用"><a href="#MSS在什么时候使用" class="headerlink" title="MSS在什么时候使用"></a>MSS在什么时候使用</h2><blockquote>
<p>握手阶段协商 MSS 这个在TCP三次握手的文章中已经提及过了！</p>
</blockquote>
<h2 id="MSS-分类"><a href="#MSS-分类" class="headerlink" title="MSS 分类"></a>MSS 分类</h2><ul>
<li><strong>发送方最大报文段:</strong> <blockquote>
<p>SMSS:SENDER MAXIMUM SEGMENT SIZE</p>
</blockquote>
</li>
<li><strong>接收方最大报文段:</strong> <blockquote>
<p>RMSS:RECEIVER MAXIMUM SEGMENT SIZE</p>
</blockquote>
</li>
</ul>
<h2 id="在TCP常用选项中可以看到【MSS】的选项"><a href="#在TCP常用选项中可以看到【MSS】的选项" class="headerlink" title="在TCP常用选项中可以看到【MSS】的选项"></a>在TCP常用选项中可以看到【MSS】的选项</h2><image src="https://oscimg.oschina.net/oscnet/up-c1229634eb30eaa7391516cbee75258c9e1.png" width=750 height=420>


<h2 id="TCP流与报文段在数据传输中的状态"><a href="#TCP流与报文段在数据传输中的状态" class="headerlink" title="TCP流与报文段在数据传输中的状态"></a>TCP流与报文段在数据传输中的状态</h2><image src="https://oscimg.oschina.net/oscnet/up-1a0015bf7b4d8481a4e624b0920bbb43917.png" width=450 height=620>

<p>从上图可以看到，左边客户端在发送字节流数据给到右边客户端，客户端发送一个连续的字节流，会在TCP层按照MSS大小规定进行拆分成多个小的报文段，分别传送到另一个客户端或者其他的接收端；</p>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP超时与重传</title>
    <url>/wiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><image src="https://oscimg.oschina.net/oscnet/up-4f1230ee04f4c197dd5c6de167991878366.png" width=680 height=300>

<p>如上图👆所示，设备A向设备B发送消息，消息在网络中会由于各种各样的问题导致丢失，那么该如何解决上述问题呢？</p>
<h2 id="采用定时器重传"><a href="#采用定时器重传" class="headerlink" title="采用定时器重传"></a>采用定时器重传</h2><blockquote>
<p>PAR：Positive Acknowledgment with Retransmission</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-17f5567e452afb45cf18d01e62bdfa33f96.png" width=680 height=330>

<p><strong>最简单的思路是在发送方设置「 定时器 」：</strong></p>
<ul>
<li>当设备A发送第一条消息之后，在定时器规定的时间内，如果收到设备B的确认报文，则设备A继续发送下一个报文，同时定时器复位；</li>
<li>如果第一条消息发送时间超出了定时器规定的时间，则设备A将重新发送第一条消息，同时重新设置定时器；</li>
<li>这种方式是串型发送的，只有第一个消息发送成功之后，才可以发送下一条消息，「 <strong>效率极差</strong> 」；</li>
</ul>
<h2 id="并发能力PAR"><a href="#并发能力PAR" class="headerlink" title="并发能力PAR"></a>并发能力PAR</h2><blockquote>
<p>基于上述PAR效率低下的方式进行改造，在发送端采用并发+定时器的方式进行数据发送；</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-96114b57ac73a41915bea1a7d11e0145102.png" width=600 height="500">

<ul>
<li>首先设备A可以同时发送多个消息或者报文段，每个报文段具有一个标志字段【#XX】去标志唯一，每个报文段连接具有自己的定时器；</li>
<li>设备B规定时间内收到设备A发送的数据之后并且设备A得到设备B的确认之后，设备A将定时器清除</li>
<li>同PAR一样，设备B没有在规定的时间内发送确认报文，设备A将这个报文所对应的定时器复位，重新发送这个报文</li>
</ul>
<h3 id="并发发送带来的问题"><a href="#并发发送带来的问题" class="headerlink" title="并发发送带来的问题"></a>并发发送带来的问题</h3><p>采用并发的方式发送消息或者报文段固然提升了发送端的性能，但是发送端发送的消息可能接受端不能完全处理，<strong>这是双方报文处理速度或者效率不一致的问题</strong>；</p>
<p>所以对于接收端设备B，应该明确自己可能接受的数据量，并且在确认报文中同步到发送端设备A，设备A根据设备B的处理能力来调整发送数据的大小；也就是上图中的「 limit」；</p>
<h2 id="继续延伸"><a href="#继续延伸" class="headerlink" title="继续延伸"></a>继续延伸</h2><p>Sequment序列号和Ack序列号的设计理念或者设计初衷是「 <strong>解决应用层字节流的可靠发送</strong> 」 </p>
<ul>
<li>跟踪「应用层」的发送端数据是否送达</li>
<li>确定「接收端有序的」接收到「字节流」</li>
<li><strong>序列号的值针对的是字节而不是报文</strong> ⚠️⚠️⚠️</li>
</ul>
<blockquote>
<p>TCP的定位就是面向字节流的！</p>
</blockquote>
<h2 id="TCP序列号如何设计的"><a href="#TCP序列号如何设计的" class="headerlink" title="TCP序列号如何设计的"></a>TCP序列号如何设计的</h2><image src="https://oscimg.oschina.net/oscnet/up-f5f274ec300162985b9bef86ebd94f6a81e.png" width=450 height=450>

<p>通过TCP报文头我们可以知道，Sequment序列号包括32位长度；也就是说一个Sequment可以发送2的32次方个字节，大约4G的数量，Sequment就无法表示了，当传输的数据超过“4G”之后，如果这个连接依然要使用的话，Sequment会重新复用；Sequment复用会产生一个问题，也就是序列号回绕；👇</p>
<h2 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h2><blockquote>
<p>序列号回绕 (Protect Against Wrapped Sequence numbers)</p>
</blockquote>
<image src="https://oscimg.oschina.net/oscnet/up-4edfd2031f0ec6ebdaa23c497e18df359cd.png" width=800 height=380>


<ul>
<li>当一个连接要发送6G的数据是，A、B、C、D分别发送1G的数据，如果继续使用此连接，E下一次发送数据1G，Seq序列号复用，E报文段的序列号和A报文段的序列号表示相同</li>
<li>按照上面的逻辑继续发送数据，F报文段的Seq标志和B报文段的是一样的；</li>
<li>加入B报文段在发送过程中丢失了，直到接受端接收了F报文段的同时B报文段到达接受端，接受端该如何区分相同Seq序列号不同数据的报文段呢？</li>
<li>其实TCP解决这个问题很简单，就是在每个报文段上添加Tcp Timestamp时间戳，类似于版本号的理念；</li>
<li>接收端收到相同Seq序列号的报文段是可以根据时间戳来进行区分；</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>apache-flink-overview</title>
    <url>/wiki/apache-flink-overview/</url>
    <content><![CDATA[<img src="https://flink.apache.org/img/flink-header-logo.svg" width=300 height=300>

<h2 id="学习初衷"><a href="#学习初衷" class="headerlink" title="学习初衷"></a>学习初衷</h2><p>推荐系统数据需要实时处理，使用Apache Flink实时计算用户数据，分析用户行为，达到实时业务数据分析和实现业务相关推荐；</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li><a href="https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ashiamd.github.io</a></li>
<li><a href="https://www.bilibili.com/video/BV1qy4y1q728?p=11&spm_id_from=pageDriver">尚硅谷2021最新Java版Flink 武老师清华硕士，原IBM-CDL负责人</a></li>
<li><a href="https://flink.apache.org/">Apache Flink® — Stateful Computations over Data Streams</a></li>
<li><a href="https://flink.apache.org/zh/">Apache Flink® - 数据流上的有状态计算</a></li>
</ul>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql配置binlog</title>
    <url>/wiki/binlog%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="开启binlog"><a href="#开启binlog" class="headerlink" title="开启binlog"></a>开启binlog</h2><p>[mysqld]<br>log-bin=mysql-bin #添加这一行就ok<br>binlog-format=ROW #选择row模式<br>server_id=1 #配置mysql replaction需要定义，不能和canal的slaveId重复  </p>
<h2 id="查看binlog状态"><a href="#查看binlog状态" class="headerlink" title="查看binlog状态"></a>查看binlog状态</h2><p>mysql&gt; show variables like ‘binlog_format’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>show variables like ‘log_bin’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>canal同步es后部分字段为null</title>
    <url>/wiki/canal%E5%90%8C%E6%AD%A5es%E5%90%8E%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BAnull/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><img src="https://oscimg.oschina.net/oscnet/up-54f2fa4a9dfb35acb02b77c5c6bc8c84c0f.png" width=800 height=400>


<p>配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataSourceKey: defaultDS        # 源数据源的key, 对应上面配置的srcDataSources中的值</span><br><span class="line">destination: example            # cannal的instance或者MQ的topic</span><br><span class="line">groupId: g1 # 对应MQ模式下的groupId, 只会同步对应groupId的数据</span><br><span class="line">esMapping:</span><br><span class="line">  _index: rd_member_fans_info           # es 的索引名称</span><br><span class="line">  _type: _doc                   # es 的doc名称</span><br><span class="line">  _id: _id                      # es 的_id, 如果不配置该项必须配置下面的pk项_id则会由es自动分配</span><br><span class="line">#  pk: id                       # 如果不需要_id, 则需要指定一个属性为主键属性</span><br><span class="line">#  # sql映射</span><br><span class="line">  sql: &#x27;SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.create_time,t.update_time,t.`status` FROM rd_member_fans_info t&#x27;</span><br><span class="line">#  objFields:</span><br><span class="line">#    _labels: array:;           # 数组或者对象属性, array:; 代表以;字段里面是以;分隔的</span><br><span class="line">#    _obj: object               # json对象</span><br><span class="line">  etlCondition: &quot;where t.update_time&gt;=&#123;&#125;&quot; # etl 的条件参数</span><br><span class="line">  commitBatch: 3000 # 提交批大小</span><br></pre></td></tr></table></figure>

<p>⚠️ ⚠️<br>sql执行是没有问题的！</p>
<img src="https://oscimg.oschina.net/oscnet/up-24a77ccd81ae7be4c6d4434f3d1d28edea0.png" width=800 height=400>


<p>canal-adapter 获取binlog数据也没有问题，显示日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 15:39:24.588 [pool-1-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:3,&quot;redtom_id&quot;:1,&quot;fans_redtom_id&quot;:1,&quot;fans_username&quot;:&quot;1&quot;,&quot;fans_introduce&quot;:&quot;1&quot;,&quot;fans_avatar&quot;:&quot;1&quot;,&quot;is_each_following&quot;:1,&quot;follow_channel&quot;:1,&quot;create_time&quot;:1625556851000,&quot;update_time&quot;:1625556851000,&quot;status&quot;:2&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625557164000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;rd_member_fans_info&quot;,&quot;ts&quot;:1625557164587,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br></pre></td></tr></table></figure>


<p>然后看一下我创建索引的mapping<br><img src="https://oscimg.oschina.net/oscnet/up-8eac2e46423574ae04cd8694d2ac7389530.png" width=800 height=400>  </p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>调整sql如下： </p>
<p><code>SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.</code>status<code> as is_deleted , t.create_time,t.update_time FROM rd_member_fans_info t</code></p>
<p>调整了那些东西呢？     <code>status</code> 的顺序提前而已！</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行一下命令：<br><code>curl http://127.0.0.1:8081/etl/es7/rd_member_fans_info.yml -X POST</code></p>
<p>canal-adapter 日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 16:21:33.519 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member_fans_info</span><br><span class="line">2021-07-06 16:21:33.527 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - 数据全量导入完成, 一共导入 3 条数据, 耗时: 7</span><br></pre></td></tr></table></figure>

<p>查看es数据：</p>
<img src="https://oscimg.oschina.net/oscnet/up-69c4ac09e2b8fcd27a5b990e378664d6568.png" width=800 height=400>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>canal同步mysql数据到elasticsearch</title>
    <url>/wiki/canal%E5%90%8C%E6%AD%A5mysql%E6%95%B0%E6%8D%AE%E5%88%B0elasticsearch/</url>
    <content><![CDATA[<h2 id="首先安装elk"><a href="#首先安装elk" class="headerlink" title="首先安装elk"></a>首先安装elk</h2><p>推荐大家到elasic中文社区去下载 👉 <a href="https://elasticsearch.cn/">【传送】</a><br>⚠️ elastcisearch | logstash | kibana 的版本最好保持一直，否则会出现很多坑的，切记！</p>
<p>安装ELK的步骤这里就不做介绍了，可以查看 👉 【TODO】</p>
<h2 id="下载安装canal-adapter"><a href="#下载安装canal-adapter" class="headerlink" title="下载安装canal-adapter"></a>下载安装canal-adapter</h2><p>canal github传送门 👉  <a href="https://github.com/alibaba/canal">【Alibaba Canal】</a></p>
<h3 id="canal-client-模式"><a href="#canal-client-模式" class="headerlink" title="canal-client 模式"></a>canal-client 模式</h3><p>可以参照canal给出的example项目和<a href="https://github.com/alibaba/canal/wiki/ClientExample">官方文档</a>给出的例子来测试</p>
<h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h4><p>保证canal-server 已经正确启动 👈  然后启动下面服务，操作数据库即可看到控制台的日志输出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redtom.canal.deploy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/30 2:57 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanalClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;***.***.***.***&quot;</span>, <span class="number">11111</span>),</span><br><span class="line">                <span class="string">&quot;example&quot;</span>, <span class="string">&quot;canal&quot;</span>, <span class="string">&quot;canal&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            connector.connect();</span><br><span class="line">            <span class="comment">//订阅数据库表,全部表</span></span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            <span class="comment">//回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿</span></span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                Message message = connector.getWithoutAck(BATCH_SIZE);</span><br><span class="line">                <span class="comment">//获取批量ID</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="comment">//获取批量的数量</span></span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="comment">//如果没有数据</span></span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//线程休眠2秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果有数据,处理数据</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。</span></span><br><span class="line">                connector.ack(batchId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印canal server解析binlog获得的实体类信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;CanalEntry.Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="comment">//开启/关闭事务的实体类型，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RowChange对象，包含了一行数据变化的所有特征</span></span><br><span class="line">            <span class="comment">//比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等</span></span><br><span class="line">            CanalEntry.RowChange rowChage;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取操作类型：insert/update/delete类型</span></span><br><span class="line">            CanalEntry.EventType eventType = rowChage.getEventType();</span><br><span class="line">            <span class="comment">//打印Header信息</span></span><br><span class="line">            log.info(<span class="string">&quot;headers:&#123;&#125; &quot;</span>, String.format(<span class="string">&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line">            <span class="comment">//判断是否是DDL语句</span></span><br><span class="line">            <span class="keyword">if</span> (rowChage.getIsDdl()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;================》;isDdl: true,sql: &#123;&#125;&quot;</span>, rowChage.getSql());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取RowChange对象里的每一行数据，打印出来</span></span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="comment">//如果是删除语句</span></span><br><span class="line">                <span class="keyword">if</span> (eventType == CanalEntry.EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//如果是新增语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == CanalEntry.EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                    <span class="comment">//如果是更新的语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//变更前的数据</span></span><br><span class="line">                    log.info(<span class="string">&quot;-------&gt;; before&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//变更后的数据</span></span><br><span class="line">                    log.info(<span class="string">&quot;-------&gt;; after&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;CanalEntry.Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Column column : columns) &#123;</span><br><span class="line">            log.info(<span class="string">&quot; &#123;&#125; :  &#123;&#125;   update= &#123;&#125;&quot;</span>, column.getName(), column.getValue(), column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="canal-adapter-模式"><a href="#canal-adapter-模式" class="headerlink" title="canal-adapter 模式"></a>canal-adapter 模式</h3><p>adapter 配置文件如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span></span><br><span class="line"></span><br><span class="line"><span class="attr">canal.conf:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">tcp</span> <span class="comment">#tcp kafka rocketMQ rabbitMQ</span></span><br><span class="line">  <span class="attr">flatMessage:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">zookeeperHosts:</span></span><br><span class="line">  <span class="attr">syncBatchSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">batchSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">timeout:</span></span><br><span class="line">  <span class="attr">accessKey:</span></span><br><span class="line">  <span class="attr">secretKey:</span></span><br><span class="line">  <span class="attr">consumerProperties:</span></span><br><span class="line">    <span class="comment"># canal tcp consumer</span></span><br><span class="line">    <span class="attr">canal.tcp.server.host:</span> <span class="number">172.25</span><span class="number">.101</span><span class="number">.75</span><span class="string">:11111</span></span><br><span class="line">    <span class="attr">canal.tcp.zookeeper.hosts:</span></span><br><span class="line">    <span class="attr">canal.tcp.batch.size:</span> <span class="number">500</span></span><br><span class="line">    <span class="attr">canal.tcp.username:</span></span><br><span class="line">    <span class="attr">canal.tcp.password:</span></span><br><span class="line">  <span class="attr">srcDataSources:</span></span><br><span class="line">    <span class="attr">defaultDS:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://xxxx:pppp/database?useUnicode=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">pwd</span></span><br><span class="line">  <span class="attr">canalAdapters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">instance:</span> <span class="string">example</span> <span class="comment"># canal instance Name or mq topic name</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line">      <span class="attr">outerAdapters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logger</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">es7</span></span><br><span class="line">        <span class="attr">hosts:</span> <span class="number">172.25</span><span class="number">.101</span><span class="number">.75</span><span class="string">:9300</span> <span class="comment"># 127.0.0.1:9200 for rest mode</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">transport</span> <span class="comment"># or rest</span></span><br><span class="line"><span class="comment">#          # security.auth: test:123456 #  only used for rest mode</span></span><br><span class="line">          <span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment">#        - name: kudu</span></span><br><span class="line"><span class="comment">#          key: kudu</span></span><br><span class="line"><span class="comment">#          properties:</span></span><br><span class="line"><span class="comment">#            kudu.master.address: 127.0.0.1 # &#x27;,&#x27; split multi address</span></span><br></pre></td></tr></table></figure>

<p>我的elasticsearch是7.10.0版本的<br><code>application.yml  bootstrap.yml  es6  es7  hbase  kudu  logback.xml  META-INF  rdb</code><br>所以：👇</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd es7</span><br><span class="line">biz_order.yml  customer.yml  mytest_user.yml</span><br><span class="line">vim customer.yml</span><br></pre></td></tr></table></figure>

<p>customer.yml 配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dataSourceKey:</span> <span class="string">defaultDS</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">groupId:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">esMapping:</span></span><br><span class="line">  <span class="attr">_index:</span> <span class="string">customer</span></span><br><span class="line">  <span class="attr">_id:</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">relations:</span></span><br><span class="line">    <span class="attr">customer_order:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">customer</span></span><br><span class="line">  <span class="attr">sql:</span> <span class="string">&quot;select t.id, t.name, t.email from customer t&quot;</span></span><br><span class="line">  <span class="attr">etlCondition:</span> <span class="string">&quot;where t.c_time&gt;=&#123;&#125;&quot;</span></span><br><span class="line">  <span class="attr">commitBatch:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<h4 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `customer` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_serial` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `customer_order` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>


<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT customer</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_serial&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_time&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;customer_order&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;join&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;relations&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;customer&quot;</span>:<span class="string">&quot;order&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="测试canal-adapter同步效果"><a href="#测试canal-adapter同步效果" class="headerlink" title="测试canal-adapter同步效果"></a>测试canal-adapter同步效果</h4><h5 id="创建一条记录"><a href="#创建一条记录" class="headerlink" title="创建一条记录"></a>创建一条记录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:50:53.725 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;1&quot;,&quot;email&quot;:&quot;1&quot;,&quot;order_id&quot;:1,&quot;order_serial&quot;:&quot;1&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;1&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457053000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457053724,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;customer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;email&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;customer_order&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;customer&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:54:36.402 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;2&quot;,&quot;email&quot;:&quot;2&quot;,&quot;order_id&quot;:2,&quot;order_serial&quot;:&quot;2&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;2&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457275000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:[&#123;&quot;name&quot;:&quot;1&quot;,&quot;email&quot;:&quot;1&quot;,&quot;order_id&quot;:1,&quot;order_serial&quot;:&quot;1&quot;,&quot;customer_order&quot;:&quot;1&quot;&#125;],&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457276401,&quot;type&quot;:&quot;UPDATE&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果<br><img src="https://oscimg.oschina.net/oscnet/up-afadff417c35ecb74811967d8e1da10f134.png" width=700 height=400></p>
<h5 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-05 11:56:51.524 [pool-3-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;2&quot;,&quot;email&quot;:&quot;2&quot;,&quot;order_id&quot;:2,&quot;order_serial&quot;:&quot;2&quot;,&quot;order_time&quot;:1625457046000,&quot;customer_order&quot;:&quot;2&quot;,&quot;c_time&quot;:1625457049000&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625457411000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;customer&quot;,&quot;ts&quot;:1625457411523,&quot;type&quot;:&quot;DELETE&quot;&#125;</span><br><span class="line">Affected indexes: customer</span><br></pre></td></tr></table></figure>
<p>Elastcisearch 效果<br><img src="https://oscimg.oschina.net/oscnet/up-7f49aeda581a547bf528b55bad6d0af27de.png" width=700 height=400></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/puhaiyang/article/details/100171395">使用canal client-adapter完成mysql到es数据同步教程(包括全量和增量)</a></li>
<li><a href="https://github.com/alibaba/canal/issues/1514">es 同步问题 #1514 Github issue</a></li>
<li><a href="https://www.bookstack.cn/read/canal-v1.1.4/f5f4adc96eefafe4.md">canal v1.1.4 文档手册</a></li>
<li><a href="https://www.bookstack.cn/read/canal-v1.1.4/63ebbe076bc97d0f.md">Sync es</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>copy_to参数</title>
    <url>/wiki/copy-to%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/custom-all.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 自定义 _all 字段</a></li>
<li><a href="https://doc.codingdict.com/elasticsearch/319/">Docs » Mapping parameters（映射参数） » Mapping(映射) » copy_to（合并参数）</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>cross-fields跨字段查询</title>
    <url>/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_cross_fields_queries.html#_cross_fields_queries">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » cross-fields 跨字段查询</a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>dis_max查询</title>
    <url>/wiki/dis-max%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>假设有个网站允许用户搜索博客的内容，以下面两篇博客内容文档为例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Quick brown rabbits&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown rabbits are commonly seen.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Keeping pets healthy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;My quick brown fox eats rabbits on a regular basis.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户输入词组 <code>Brown fox</code> 然后点击搜索按钮。事先，我们并不知道用户的搜索项是会在 title 还是在 body 字段中被找到，但是，用户很有可能是想搜索相关的词组。用肉眼判断，文档 2 的匹配度更高，因为它同时包括要查找的两个词：</p>
<p>现在运行以下 bool 查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们发现查询的结果是文档 1 的评分更高：</p>
<img src="https://oscimg.oschina.net/oscnet/up-fa805607436bd64629e31ea8ea574c330cf.png" width=920 height=450>  

<p>为了理解导致这样的原因，需要回想一下 bool 是如何计算评分的：</p>
<p>它会执行 should 语句中的两个查询。<br>加和两个查询的评分。<br>乘以匹配语句的总数。<br>除以所有语句总数（这里为：2）。</p>
<p>文档 1 的两个字段都包含 <code>brown</code> 这个词，所以两个 <code>match</code> 语句都能成功匹配并且有一个评分。文档 2 的 body 字段同时包含 <code>brown</code> 和 <code>fox</code> 这两个词，但 title 字段没有包含任何词。这样， body 查询结果中的高分，加上 title 查询中的 0 分，然后乘以二分之一，就得到比文档 1 更低的整体评分。</p>
<p>在本例中， title 和 body 字段是相互竞争的关系，所以就需要找到单个 最佳匹配 的字段。</p>
<p>如果不是简单将每个字段的评分结果加在一起，而是将 <code>最佳匹配</code> 字段的评分作为查询的整体评分，结果会怎样？这样返回的结果可能是： 同时 包含 <code>brown</code> 和 <code>fox</code> 的单个字段比反复出现相同词语的多个不同字段有更高的相关度。</p>
<h2 id="dis-max-查询"><a href="#dis-max-查询" class="headerlink" title="dis_max 查询"></a>dis_max 查询</h2><p>不使用 <code>bool</code> 查询，可以使用 <code>dis_max</code> 即分离 最大化查询 <code>（Disjunction Max Query）</code> 。分离（Disjunction）的意思是 或（or） ，这与可以把结合（conjunction）理解成 与（and） 相对应。分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回 ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到我们想要的结果为：<br><img src="https://oscimg.oschina.net/oscnet/up-f4e15cd66644b0031abe4757efdcfdd2886.png" width=900 height=450>  </p>
<h2 id="Top-level-parameters-for-dis-maxedit"><a href="#Top-level-parameters-for-dis-maxedit" class="headerlink" title="Top-level parameters for dis_maxedit"></a>Top-level parameters for dis_maxedit</h2><ul>
<li><code>queries</code><br>(Required, array of query objects) Contains one or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, Elasticsearch uses the highest relevance score.</li>
<li><code>tie_breaker</code><br>(Optional, float) Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses. Defaults to 0.0.</li>
</ul>
<p>You can use the tie_breaker value to assign higher relevance scores to documents that contain the same term in multiple fields than documents that contain this term in only the best of those multiple fields, without confusing this with the better case of two different terms in the multiple fields.</p>
<p>If a document matches multiple clauses, the dis_max query calculates the relevance score for the document as follows:</p>
<p>Take the relevance score from a matching clause with the highest score.<br>Multiply the score from any other matching clauses by the tie_breaker value.<br>Add the highest score to the multiplied scores.<br>If the tie_breaker value is greater than 0.0, all matching clauses count, but the clause with the highest score counts most.</p>
<p><code>dis_max</code>，只是取分数最高的那个query的分数而已，完全不考虑其他query的分数，这种一刀切的做法，可能导致在有其他query的影响下，score不准确的情况，这时为了使用结果更准确，最好还是要考虑到其他query的影响;<br>使用 <code>tie_breaker</code> 将其他query的分数也考虑进去, <code>tie_breaker</code> 参数的意义，将其他query的分数乘以<code>tie_breaker</code>，然后综合考虑后与最高分数的那个query的分数综合在一起进行计算，这样做除了取最高分以外，还会考虑其他的query的分数。<code>tie_breaker</code>的值，设置在在0~1之间，是个小数就行，没有固定的值</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_best_fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 最佳字段</a></li>
<li><a href="https://learnku.com/docs/elasticsearch73/7.3">Elasticsearch中文文档</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-dis-max-query.html">Elasticsearch Guide [7.x] » Query DSL » Compound queries » Disjunction max query</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compost安装mongodb</title>
    <url>/wiki/docker-compost%E5%AE%89%E8%A3%85mongodb/</url>
    <content><![CDATA[<blockquote>
<p>mongo 配置文件 -&gt; <a href="https://www.cnblogs.com/xibuhaohao/p/12580331.html">https://www.cnblogs.com/xibuhaohao/p/12580331.html</a></p>
</blockquote>
<h2 id="docker-compose-配置文件"><a href="#docker-compose-配置文件" class="headerlink" title="docker-compose  配置文件"></a>docker-compose  配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.4.7</span> <span class="comment">#根据需要选择自己的镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span> <span class="comment">#对外暴露停供服务的端口，正式生产的时候理论不用暴露。</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/db:/data/db</span> <span class="comment"># 挂载数据目录</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/log:/var/log/mongodb</span>  <span class="comment"># 挂载日志目录</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./mongodb/data/config:/etc/mongo</span>  <span class="comment"># 挂载配置目录</span></span><br><span class="line">    <span class="comment"># command: --config /docker/mongodb/mongod.conf # 配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="按照上面👆配置文件设置目录"><a href="#按照上面👆配置文件设置目录" class="headerlink" title="按照上面👆配置文件设置目录"></a>按照上面👆配置文件设置目录</h2><p><code>/data/db/mongodb/data</code><br><code>ls -l</code><br><code>config  db  log</code></p>
<h2 id="mongo-配置文件"><a href="#mongo-配置文件" class="headerlink" title="mongo 配置文件"></a>mongo 配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Where and how to store data.</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/data/db/mongodb/data/db</span></span><br><span class="line">  <span class="attr">journal:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  engine:</span></span><br><span class="line"><span class="comment">#  mmapv1:</span></span><br><span class="line"><span class="comment">#  wiredTiger:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># where to write logging data.</span></span><br><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/data/db/mongodb/data/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network interfaces</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># how the process runs</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">  <span class="attr">timeZoneInfo:</span> <span class="string">/usr/share/zoneinfo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#security:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#operationProfiling:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#replication:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sharding:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Enterprise-Only Options:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#auditLog:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#snmp:</span></span><br></pre></td></tr></table></figure>

<p><code>bindIp: 0.0.0.0</code> 允许远程访问</p>
<h2 id="docker-compose启动mongo"><a href="#docker-compose启动mongo" class="headerlink" title="docker-compose启动mongo"></a>docker-compose启动mongo</h2><p><code>docker-compose up -d</code><br><code>docker ps</code></p>
<h2 id="进入docker"><a href="#进入docker" class="headerlink" title="进入docker"></a>进入docker</h2><p><code>docker ps</code><br><code>docker exec -it xxxxxxxxxx bash</code></p>
<h2 id="mongo创建数据库"><a href="#mongo创建数据库" class="headerlink" title="mongo创建数据库"></a>mongo创建数据库</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><code>mongo</code></p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p><code>show dbs</code></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>use wechat_spider</code>  然后 <code>db</code> 查看</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.createUser(</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">user</span>:&quot;wechat&quot;,</span><br><span class="line">       pwd:&quot;123456&quot;,</span><br><span class="line">       roles:[&#123;role:&quot;readWrite&quot;,db:&quot;wechat_spider&quot;&#125;]</span><br><span class="line">     &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<h2 id="Java客户端链接"><a href="#Java客户端链接" class="headerlink" title="Java客户端链接"></a>Java客户端链接</h2><h3 id="配置mvn"><a href="#配置mvn" class="headerlink" title="配置mvn"></a>配置mvn</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&#x27;wechat&#x27;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="comment">#      port: 3333</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">wechat_spider</span></span><br><span class="line"><span class="comment">#      host: 123.56.77.177</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">39.107</span><span class="number">.117</span><span class="number">.232</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/28 上午10:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;passenger&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContoller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Passenger passenger = <span class="keyword">new</span> Passenger();</span><br><span class="line">        passenger.setName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        passenger.setPassword(<span class="string">&quot;world1&quot;</span>);</span><br><span class="line">        passenger = mongoTemplate.insert(passenger);</span><br><span class="line">        <span class="keyword">if</span> (passenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>DataBase</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用手册</title>
    <url>/wiki/docker%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<blockquote>
<p><b>docker中文文档</b>  <a href="http://www.dockerinfo.net/document">http://www.dockerinfo.net/document</a><br><b>docker doc</b> <a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a><br><b>docker 中文社区</b> <a href="https://www.docker.org.cn/">https://www.docker.org.cn/</a></p>
</blockquote>
<h3 id="搜索可用镜像"><a href="#搜索可用镜像" class="headerlink" title="搜索可用镜像"></a>搜索可用镜像</h3><p><code>docker search tutorial</code></p>
<h3 id="检查运行的镜像"><a href="#检查运行的镜像" class="headerlink" title="检查运行的镜像"></a>检查运行的镜像</h3><p><code>docker inspect efe</code></p>
<h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p><code>docker push</code></p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p><code>docker pull</code></p>
<h3 id="在容器中安装新的程序"><a href="#在容器中安装新的程序" class="headerlink" title="在容器中安装新的程序"></a>在容器中安装新的程序</h3><p><code>apt-get update</code><br><code>apt-get install vim</code></p>
<h3 id="保存对容器的修改"><a href="#保存对容器的修改" class="headerlink" title="保存对容器的修改"></a>保存对容器的修改</h3><p><code>docker commit pid</code></p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker整体架构图</title>
    <url>/wiki/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Docker的总架构图"><a href="#Docker的总架构图" class="headerlink" title="Docker的总架构图"></a>Docker的总架构图</h1><img src='https://cdn.zsite.com/data/upload/d/docker/202104/f_e2031050ce83ec39ca6574875e047811.png' width=500 height=600>

<p>docker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<p>1、用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。<br>2、Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；<br>3、Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。<br>4、Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；<br>5、当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；<br>6、当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。<br>7、libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-analyzer</title>
    <url>/wiki/elasticsearch-analyzer/</url>
    <content><![CDATA[<h2 id="测试常见分析器"><a href="#测试常见分析器" class="headerlink" title="测试常见分析器"></a>测试常见分析器</h2><p><code>GET /_analyze</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code>  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code>   </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GET /_analyze</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="默认分析器"><a href="#默认分析器" class="headerlink" title="默认分析器"></a>默认分析器</h2><p>虽然我们可以在字段层级指定分析器，但是如果该层级没有指定任何的分析器，那么我们如何能确定这个字段使用的是哪个分析器呢？  </p>
<p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：</p>
<ul>
<li>字段映射里定义的 analyzer ，否则</li>
<li>索引设置中名为 default 的分析器，默认为</li>
<li>standard 标准分析器</li>
</ul>
<p>在搜索时，顺序有些许不同：</p>
<ul>
<li>查询自己定义的 analyzer ，否则</li>
<li>字段映射里定义的 analyzer ，否则</li>
<li>索引设置中名为 default 的分析器，默认为</li>
<li>standard 标准分析器</li>
</ul>
<p>有时，在索引时和搜索时使用不同的分析器是合理的。我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。</p>
<p>为了区分，Elasticsearch 也支持一个可选的 <code>search_analyzer</code> 映射，它仅会应用于搜索时（ <code>analyzer</code> 还用于索引时）。还有一个等价的 <code>default_search</code> 映射，用以指定索引层的默认配置。</p>
<p>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：</p>
<p>查询自己定义的 <code>analyzer</code> ，否则<br>字段映射里定义的 <code>search_analyzer</code> ，否则<br>字段映射里定义的 <code>analyzer</code> ，否则<br>索引设置中名为 <code>default_search</code> 的分析器，默认为<br>索引设置中名为 <code>default</code> 的分析器，默认为<code>standard</code> 标准分析器</p>
<h2 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h2><p>多数情况下，会提前知道文档会包括哪些字段。最简单的途径就是在创建索引或者增加类型映射时，为每个全文字段设置分析器。这种方式尽管有点麻烦，但是它让我们可以清楚的看到每个字段每个分析器是如何设置的。</p>
<p>通常，多数字符串字段都是 <code>not_analyzed</code> 精确值字段，比如标签（tag）或枚举（enum），而且更多的全文字段会使用默认的 <code>standard</code> 分析器或 <code>english</code> 或其他某种语言的分析器。这样只需要为少数一两个字段指定自定义分析：或许标题 title 字段需要以支持 输入即查找（find-as-you-type） 的方式进行索引。</p>
<p>可以在索引级别设置中，为绝大部分的字段设置你想指定的 <code>default</code> 默认分析器。然后在字段级别设置中，对某一两个字段配置需要指定的分析器。</p>
<p>📒 📒 📒<br>对于和时间相关的日志数据，通常的做法是每天自行创建索引，由于这种方式不是从头创建的索引，仍然可以用 索引模板（Index Template） 为新建的索引指定配置和映射。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_controlling_analysis.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 控制分析</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-overview</title>
    <url>/wiki/elasticsearch-overview/</url>
    <content><![CDATA[<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li> <a href="https://doc.codingdict.com/elasticsearch/">https://www.codingdict.com/</a></li>
<li> <a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></li>
<li> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indexing-buffer.html">https://www.elastic.co/guide/en/</a></li>
<li> <a href="https://elastic.blog.csdn.net/">铭毅天下</a></li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 查询值前缀不包含某个字符串</title>
    <url>/wiki/elasticsearch-%E6%9F%A5%E8%AF%A2%E5%80%BC%E5%89%8D%E7%BC%80%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<blockquote>
<p>需求 查询IP不是以11.开头的所有文档，然后获取文档访问量前100条</p>
</blockquote>
<p><code>curl -X GET &quot;localhost:9200/yj_visit_data2,yj_visit_data3/_search?pretty&quot; -u elastic:elastic -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;11.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;visitTime&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1577808000000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">1609430399000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term_article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;ip&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;min_doc_count&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch分页查询</title>
    <url>/wiki/elasticsearch%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：</p>
<p><code>size</code><br>显示应该返回的结果数量，默认是 10<br><code>from</code><br>显示应该跳过的初始结果数量，默认是 0<br>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p>
<p><code>GET /_search?size=5</code><br><code>GET /_search?size=5&amp;from=5</code><br><code>GET /_search?size=5&amp;from=10</code>  </p>
<p>⚠️ ⚠️ ⚠️<br>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。  </p>
<p>在分布式系统中深度分页</p>
<blockquote>
<p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
</blockquote>
<p>现在假设我们请求第 1000 页—​结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
<p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/pagination.html">elasticsearch权威指南</a>  </li>
<li><a href="https://blog.csdn.net/laoyang360/article/details/116472697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162549431316780269873046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162549431316780269873046&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-116472697.pc_v2_rank_blog_default&utm_term=%E5%88%86%E9%A1%B5&spm=1018.2226.3001.4450">干货 | 全方位深度解读 Elasticsearch 分页查询</a>  </li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/paginate-search-results.html">Paginate search results</a></li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch基础api</title>
    <url>/wiki/elasticsearch%E5%9F%BA%E7%A1%80cat_api/</url>
    <content><![CDATA[<h2 id="cat-API"><a href="#cat-API" class="headerlink" title="cat API"></a>cat API</h2><h3 id="集群健康状态"><a href="#集群健康状态" class="headerlink" title="集群健康状态"></a>集群健康状态</h3><p>GET _cat/health?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp cluster        status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1625489855 12:57:35  my-application yellow          1         1     35  35    0    0       23             0                  -                 60.3%</span><br></pre></td></tr></table></figure>
<p>或者直接在服务器上调用rest接口：<br>curl -XGET ‘localhost:9200/_cat/health?v&amp;pretty’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1475247709 17:01:49  elasticsearch green           1         1      0   0    0    0        0             0                  -                100.0%</span><br></pre></td></tr></table></figure>

<p>我们可以看到我们名为 my-application 的集群与 yellow 的 status。</p>
<p>无论何时我们请求集群健康，我们可以获得 green，yellow，或者 red 的 status。Green 表示一切正常（集群功能齐全）， yellow 表示所有数据可用，但是有些副本尚未分配（集群功能齐全），red 意味着由于某些原因有些数据不可用。注意，集群是 red，它仍然具有部分功能（例如，它将继续从可用的分片中服务搜索请求），但是您可能需要尽快去修复它，因为您已经丢失数据了。  </p>
<p>另外，从上面的响应中，我们可以看到共计 1 个 node（节点）和 0 个 shard（分片），因为我们还没有放入数据的。注意，因为我们使用的是默认的集群名称（elasticsearch），并且 Elasticsearch 默认情况下使用 unicast network（单播网络）来发现同一机器上的其它节点。有可能您不小心在您的电脑上启动了多个节点，然后它们全部加入到了单个集群。在这种情况下，你会在上面的响应中看到不止 1 个 node（节点）。</p>
<h3 id="查看集群分布"><a href="#查看集群分布" class="headerlink" title="查看集群分布"></a>查看集群分布</h3><p>GET _cat/nodes?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip         heap.percent ram.percent cpu load_1m load_5m load_15m node.role  master name</span><br><span class="line">172.19.0.1           20          61  15    0.02    0.04     0.29 cdhilmrstw *      redtom-es-1</span><br></pre></td></tr></table></figure>


<h3 id="查看所有索引"><a href="#查看所有索引" class="headerlink" title="查看所有索引"></a>查看所有索引</h3><p>GET _cat/indices?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">health status index                             uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   rd-logstash-2021.06.19            p5iej71MQVW12s2awNv8nw   1   1      61236            0     16.3mb         16.3mb</span><br><span class="line">yellow open   demo_index                        k6VTs7tdS0ysot-rPwxG9A   1   1          1            0      5.5kb          5.5kb</span><br><span class="line">green  open   kibana_sample_data_flights        A7c5DViGSISii8FA0dNlGw   1   0      13059            0      5.6mb          5.6mb</span><br></pre></td></tr></table></figure>


<h3 id="查看所有索引的数量"><a href="#查看所有索引的数量" class="headerlink" title="查看所有索引的数量"></a>查看所有索引的数量</h3><p>GET _cat/count?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoch      timestamp count</span><br><span class="line">1625490245 13:04:05  838913</span><br></pre></td></tr></table></figure>


<h3 id="磁盘分配情况"><a href="#磁盘分配情况" class="headerlink" title="磁盘分配情况"></a>磁盘分配情况</h3><p>GET _cat/allocation?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shards disk.indices disk.used disk.avail disk.total disk.percent host       ip         node</span><br><span class="line">    35      308.7mb    20.1gb    215.9gb    236.1gb            8 172.19.0.1 172.19.0.1 redtom-es-1</span><br><span class="line">    23                                                                                 UNASSIGNED</span><br></pre></td></tr></table></figure>


<h3 id="查看shard情况"><a href="#查看shard情况" class="headerlink" title="查看shard情况"></a>查看shard情况</h3><p>GET _cat/shards?v&amp;pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index                             shard prirep state        docs   store ip         node</span><br><span class="line">yj_visit_data                     0     p      STARTED         0    208b 172.19.0.1 redtom-es-1</span><br><span class="line">yj_visit_data                     0     r      UNASSIGNED                           </span><br><span class="line">demo_index                        0     p      STARTED         1   5.5kb 172.19.0.1 redtom-es-1</span><br><span class="line">demo_index                        0     r      UNASSIGNED                           </span><br><span class="line">rbtags                            0     p      STARTED         0    208b 172.19.0.1 redtom-es-1</span><br><span class="line">.kibana_1                         0     p      STARTED       280  11.5mb 172.19.0.1 redtom-es-1</span><br><span class="line">.kibana_task_manager_1            0     p      STARTED         5   5.8mb 172.19.0.1 redtom-es-1</span><br></pre></td></tr></table></figure>
<p>yj_visit_data 设置了一个副本分区，但是没有副节点，所以节点状态显示未分配；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/cat.html">Elastic 官方文档</a></li>
<li><a href="https://doc.codingdict.com/elasticsearch/4/">codingdict.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch字符串查询汇总</title>
    <url>/wiki/elasticsearch%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>filter<br>exists<br>fuzzy<br>ids<br>prefix<br>regexp<br>term<br>terms<br>terms_set<br>wildcard<br>text搜索 interval<br>match<br>match_bool_prefix<br>match_phrase<br>match_phrase_prefix<br>multi_match<br>common<br>query_string<br>simple_query_string</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/weixin_35143514/article/details/112607839">查询是否包含字符串_十九种Elasticsearch字符串搜索方式终极介绍</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch操作索引</title>
    <url>/wiki/elasticsearch%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT customer</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;:&#123;</span><br><span class="line">        &quot;id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">         &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;email&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_serial&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_time&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;customer_order&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;join&quot;,</span><br><span class="line">          &quot;relations&quot;:&#123;</span><br><span class="line">            &quot;customer&quot;:&quot;order&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看索引的mapping"><a href="#查看索引的mapping" class="headerlink" title="查看索引的mapping"></a>查看索引的mapping</h2><p><code>GET yj_visit_data/_mapping</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;yj_visit_data&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_class&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;article&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h2><p><code>GET yj_visit_data/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除所有"><a href="#删除所有" class="headerlink" title="删除所有"></a>删除所有</h2><p><code>POST yj_visit_data/_delete_by_query</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="通过文章删除"><a href="#通过文章删除" class="headerlink" title="通过文章删除"></a>通过文章删除</h2><p><code>POST yj_visit_data/_delete_by_query</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article.keyword&quot;</span>: <span class="string">&quot;2019/01/3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据文章查询"><a href="#根据文章查询" class="headerlink" title="根据文章查询"></a>根据文章查询</h2><p><code>GET yj_visit_data/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article.keyword&quot;</span>: <span class="string">&quot;2019/01/3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST customer/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch映射</title>
    <url>/wiki/elasticsearch%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Elasticsearch 支持如下简单域类型：</p>
<ul>
<li>字符串: string （es7之后编程text）</li>
<li>整数 : byte, short, integer, long</li>
<li>浮点数: float, double</li>
<li>布尔型: boolean</li>
<li>日期: date</li>
</ul>
<h2 id="查看索引的mapping"><a href="#查看索引的mapping" class="headerlink" title="查看索引的mapping"></a>查看索引的mapping</h2><p><code>GET /gb/_mapping/tweet</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;gb&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;date&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;strict_date_optional_time||epoch_millis&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h2><p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p>
<ul>
<li>全文字符串域和精确值字符串域的区别</li>
<li>使用特定语言分析器</li>
<li>优化域以适应部分匹配</li>
<li>指定自定义数据格式</li>
<li>还有更多</li>
</ul>
<p>域最重要的属性是 <code>type</code> 。对于不是 string 的域，你一般只需要设置 type ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认， <code>string</code> (text) 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
<p>string 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index 属性控制怎样索引字符串。它可以是下面三个值：</p>
<h4 id="analyzed"><a href="#analyzed" class="headerlink" title="analyzed"></a>analyzed</h4><p>首先分析字符串，然后索引它。换句话说，以全文索引这个域。</p>
<h4 id="not-analyzed"><a href="#not-analyzed" class="headerlink" title="not_analyzed"></a>not_analyzed</h4><p>  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</p>
<h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>不索引这个域。这个域不会被搜索到。 (比如一些隐私信息)</p>
<p>string 域 index 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 not_analyzed ：</p>
<p>⚠️ ⚠️<br>其他简单类型（例如 long ， double ， date 等）也接受 index 参数，但有意义的值只有 no 和 not_analyzed ， 因为它们永远不会被分析。  </p>
<h3 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h3><p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如 <code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>;</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h2><p>当你首次创建一个索引的时候，可以指定类型的映射。你也可以使用 /_mapping 为新类型（或者为存在的类型更新映射）增加映射。<br>⚠️ ⚠️<br>尽管你可以 增加 一个存在的映射，你不能 修改 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>
<p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。</p>
<p>为了描述指定映射的两种方式，我们先删除 gd 索引：<br><code>DELETE /gb</code><br>然后创建一个新索引，指定 tweet 域使用 english 分析器：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍后，我们决定在 tweet 映射增加一个新的名为 tag 的 not_analyzed 的文本域，使用 _mapping ：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;tag&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>:    <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中</p>
<h2 id="测试映射"><a href="#测试映射" class="headerlink" title="测试映射"></a>测试映射</h2><p>你可以使用 analyze API 测试字符串域的映射。比较下面两个请求的输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tweet&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tag&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tweet 域产生两个词条 black 和 cat ， tag 域产生单独的词条 Black-cats 。换句话说，我们的映射正常工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/mapping-intro.html">Elasticsearch权威指南</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch稳定性调优</title>
    <url>/wiki/elasticsearch%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p>
</blockquote>
<h2 id="稳定性调优"><a href="#稳定性调优" class="headerlink" title="稳定性调优"></a>稳定性调优</h2><p>一 Linux参数调优</p>
<p>修改系统资源限制 👇<br>单用户可以打开的最大文件数量，可以设置为官方推荐的65536或更大些 <code>echo &quot;* - nofile 655360&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户内存地址空间 <code>echo &quot;* - as unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户线程数 <code>echo &quot;* - nproc 2056474&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户文件大小 <code>echo &quot;* - fsize unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单用户锁定内存 <code>echo &quot;* - memlock unlimited&quot; &gt;&gt;/etc/security/limits.conf</code><br>单进程可以使用的最大map内存区域数量 <code>echo &quot;vm.max_map_count = 655300&quot; &gt;&gt;/etc/sysctl.conf</code><br>TCP全连接队列参数设置， 这样设置的目的是防止节点数较多（比如超过100）的ES集群中，节点异常重启时全连接队列在启动瞬间打满，造成节点hang住，整个集群响应迟滞的情况<br><code>echo &quot;net.ipv4.tcp_abort_on_overflow = 1&quot; &gt;&gt;/etc/sysctl.conf </code><br><code>echo &quot;net.core.somaxconn = 2048&quot; &gt;&gt;/etc/sysctl.conf</code><br>降低tcp alive time，防止无效链接占用链接数 <code>echo 300 &gt;/proc/sys/net/ipv4/tcp_keepalive_time</code></p>
<h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><h3 id="jvm-options"><a href="#jvm-options" class="headerlink" title="jvm.options"></a>jvm.options</h3><p>-Xms和-Xmx设置为相同的值，<code>推荐设置为机器内存的一半左右，剩余一半留给系统cache使用</code>。</p>
<p>jvm内存建议不要低于2G，否则有可能因为内存不足导致ES无法正常启动或OOM<br>jvm建议不要超过32G，否则<code>jvm会禁用内存对象指针压缩技术</code>，造成内存浪费</p>
<h3 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><p>设置内存熔断参数，防止写入或查询压力过高导致OOM，具体数值可根据使用场景调整。<br><code>indices.breaker.total.limit: 30% </code><br><code>indices.breaker.request.limit: 6% </code><br><code>indices.breaker.fielddata.limit: 3%</code></p>
<p>调小查询使用的cache，避免cache占用过多的jvm内存，具体数值可根据使用场景调整。<br><code>indices.queries.cache.count: 500 </code><br><code>indices.queries.cache.size: 5%</code></p>
<p>单机多节点时，主从shard分配以ip为依据，分配到不同的机器上，避免单机挂掉导致数据丢失。<br><code>cluster.routing.allocation.awareness.attributes: ip </code><br><code>node.attr.ip: 1.1.1.1</code></p>
<h2 id="ES使用方式"><a href="#ES使用方式" class="headerlink" title="ES使用方式"></a>ES使用方式</h2><h3 id="节点数较多的集群，增加专有master，提升集群稳定性"><a href="#节点数较多的集群，增加专有master，提升集群稳定性" class="headerlink" title="节点数较多的集群，增加专有master，提升集群稳定性"></a>节点数较多的集群，增加专有master，提升集群稳定性</h3><p>ES集群的元信息管理、index的增删操作、节点的加入剔除等集群管理的任务都是由master节点来负责的，master节点定期将最新的集群状态广播至各个节点。所以，master的稳定性对于集群整体的稳定性是至关重要的。当集群的节点数量较大时（比如超过30个节点），集群的管理工作会变得复杂很多。此时应该创建专有master节点，这些节点只负责集群管理，不存储数据，不承担数据读写压力；其他节点则仅负责数据读写，不负责集群管理的工作。</p>
<p>这样把集群管理和数据的写入/查询分离，互不影响，防止因读写压力过大造成集群整体不稳定。 将专有master节点和数据节点的分离，需要修改ES的配置文件，然后滚动重启各个节点。</p>
<blockquote>
<p>专有master节点的配置文件（conf/elasticsearch.yml）增加如下属性：<br>node.master: true<br>node.data: false<br>node.ingest: false<br>数据节点的配置文件增加如下属性（与上面的属性相反）：<br>node.master: false<br>node.data: true<br>node.ingest: true </p>
</blockquote>
<h3 id="控制index、shard总数量"><a href="#控制index、shard总数量" class="headerlink" title="控制index、shard总数量"></a>控制index、shard总数量</h3><p>上面提到，ES的元信息由master节点管理，定期同步给各个节点，也就是每个节点都会存储一份。这个元信息主要存储在clusterstate中，如所有node元信息（indices、节点各种统计参数）、所有index/shard的元信息（mapping, location, size）、元数据ingest等。</p>
<p>ES在创建新分片时，要根据现有的分片分布情况指定分片分配策略，从而使各个节点上的分片数基本一致，此过程中就需要深入遍历clusterstate。当集群中的index/shard过多时，clusterstate结构会变得过于复杂，导致遍历clusterstate效率低下，集群响应迟滞。基础架构部数据库团队曾经在一个20个节点的集群里，创建了4w+个shard，<code>导致新建一个index需要60s+才能完成</code>。 当index/shard数量过多时，可以考虑从以下几方面改进：</p>
<ul>
<li>降低数据量较小的index的shard数量</li>
<li>把一些有关联的index合并成一个index</li>
<li>数据按某个维度做拆分，写入多个集群</li>
</ul>
<h3 id="Segment-Memory优化"><a href="#Segment-Memory优化" class="headerlink" title="Segment Memory优化"></a>Segment Memory优化</h3><p>前面提到，ES底层采用Lucene做存储，而Lucene的一个index又由若干segment组成，每个segment都会建立自己的倒排索引用于数据查询。Lucene为了加速查询，为每个segment的倒排做了一层前缀索引，这个索引在Lucene4.0以后采用的数据结构是<code>FST</code> (Finite State Transducer)。Lucene加载segment的时候将其全量装载到内存中，加快查询速度。<code>这部分内存被称为SegmentMemory， 常驻内存，占用heap，无法被GC</code>。</p>
<p>前面提到，为利用JVM的对象指针压缩技术来节约内存，通常建议JVM内存分配不要超过32G。当集群的数据量过大时，SegmentMemory会吃掉大量的堆内存，而JVM内存空间又有限，此时就需要想办法降低SegmentMemory的使用量了，常用方法有下面几个：</p>
<ul>
<li>定期删除不使用的index</li>
<li>对于不常访问的index，可以通过close接口将其关闭，用到时再打开</li>
<li>通过force_merge接口强制合并segment，降低segment数量</li>
<li>基础架构部数据库团队在此基础上，对FST部分进行了优化，释放高达40%的Segment Memory内存空间。</li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch统计每年每小时访问量</title>
    <url>/wiki/elasticsearch%E7%BB%9F%E8%AE%A1%E6%AF%8F%E5%B9%B4%E6%AF%8F%E5%B0%8F%E6%97%B6%E8%AE%BF%E9%97%AE%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>需求背景，要统计文章在一年的时间内，每个小时的访问情况，按照0点举例子，每个文章，一年内每一天0点的访问次数累加起来；</p>
</blockquote>
<h2 id="Elasticsearch索引如下"><a href="#Elasticsearch索引如下" class="headerlink" title="Elasticsearch索引如下"></a>Elasticsearch索引如下</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;yj_visit_data&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_class&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;article&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;c&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ip&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;p&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ua&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;visitTime&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Java-RestHighLevelClient写法"><a href="#Java-RestHighLevelClient写法" class="headerlink" title="Java RestHighLevelClient写法"></a>Java RestHighLevelClient写法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDateDist</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">        searchRequest.indices(<span class="string">&quot;yj_visit_data2&quot;</span>);</span><br><span class="line">        TermsAggregationBuilder termsAggregation = AggregationBuilders.terms(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">                .field(<span class="string">&quot;article.keyword&quot;</span>).size(<span class="number">2200</span>)</span><br><span class="line">                .subAggregation(AggregationBuilders.dateHistogram(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                        .field(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                        .calendarInterval(DateHistogramInterval.HOUR));</span><br><span class="line"></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        sourceBuilder.aggregation(termsAggregation);</span><br><span class="line">        sourceBuilder.query(QueryBuilders.rangeQuery(<span class="string">&quot;visitTime&quot;</span>).gt(<span class="string">&quot;1609430400000&quot;</span>).lte(<span class="string">&quot;1625068799000&quot;</span>));</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">900000</span>));</span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        SearchResponse search = restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        Aggregations aggregations = search.getAggregations();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;agg -&gt; &#123;&#125;&quot;</span>, aggregations.asList().size());</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; buckets = ((ParsedStringTerms) aggregations.asList().get(<span class="number">0</span>)).getBuckets();</span><br><span class="line">        List&lt;ArticleHourData&gt; hourDataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">            List&lt;? extends Histogram.Bucket&gt; innerBuckets = ((ParsedDateHistogram) bucket.getAggregations().asList().get(<span class="number">0</span>)).getBuckets();</span><br><span class="line">            hourDataList.add(calcBucket(innerBuckets, bucket.getKeyAsString()));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;result ----&gt; &#123;&#125;&quot;</span>, JSONObject.toJSONString(hourDataList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArticleHourData <span class="title">calcBucket</span><span class="params">(List&lt;? extends Histogram.Bucket&gt; innerBuckets, String article)</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">&quot;innerBuckets get(0) ---&gt; &#123;&#125;&quot;</span>, JSON.toJSONString(innerBuckets.get(<span class="number">0</span>)));</span><br><span class="line">       Map&lt;String, ? extends List&lt;? extends Histogram.Bucket&gt;&gt; hourMap = innerBuckets.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(bucket -&gt; getHour(bucket.getKeyAsString())));</span><br><span class="line">       log.info(<span class="string">&quot;collect  ======&gt; &#123;&#125; &quot;</span>, JSONObject.toJSONString(hourMap.keySet()));</span><br><span class="line"></span><br><span class="line">       ArticleHourData hourData = ArticleHourData.builder().article(article).build();</span><br><span class="line">       <span class="keyword">if</span> (hourMap.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> hourData;</span><br><span class="line">       &#125;</span><br><span class="line">       HashMap&lt;String, Long&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String hour : hourMap.keySet()) &#123;</span><br><span class="line">           List&lt;? extends Histogram.Bucket&gt; list = hourMap.get(hour);</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           hashMap.put(hour, list.stream().mapToLong(Histogram.Bucket::getDocCount).sum());</span><br><span class="line">       &#125;</span><br><span class="line">       hourData.setCountMap(hashMap);</span><br><span class="line">       <span class="keyword">return</span> hourData;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取时间的小时"><a href="#获取时间的小时" class="headerlink" title="获取时间的小时"></a>获取时间的小时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getHour</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">      date = date.replace(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot; UTC&quot;</span>);</span><br><span class="line">      SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS Z&quot;</span>);</span><br><span class="line">      Date d = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          d = format.parse(date);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(DateUtil.asLocalDateTime(d).getHour());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Python写法"><a href="#Python写法" class="headerlink" title="Python写法"></a>Python写法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecoder</span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">import</span> logging,json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">es = Elasticsearch([&#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;39.107.117.232&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">9200</span>&#125;], http_auth=(<span class="string">&#x27;elastic&#x27;</span>, <span class="string">&#x27;elastic&#x27;</span>), timeout = <span class="number">90000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqs = &#123;</span><br><span class="line">   <span class="string">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;art&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;field&quot;</span>: <span class="string">&quot;article.keyword&quot;</span>,</span><br><span class="line">            <span class="string">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;art_total&quot;</span>: &#123; </span><br><span class="line">               <span class="string">&quot;value_count&quot;</span>: &#123;</span><br><span class="line">                  <span class="string">&quot;field&quot;</span>: <span class="string">&quot;article.keyword&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;_time&quot;</span>: &#123; </span><br><span class="line">                <span class="string">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;field&quot;</span>: <span class="string">&quot;visitTime&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;calendar_interval&quot;</span>: <span class="string">&quot;hour&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_search_result = es.search(index=<span class="string">&quot;yj_visit_data2&quot;</span> , body=sqs)</span><br><span class="line">_result_json = json.dumps(_search_result,sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;: &#x27;</span>), ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">aggregations = _search_result[<span class="string">&#x27;aggregations&#x27;</span>]</span><br><span class="line">art = aggregations[<span class="string">&#x27;art&#x27;</span>]</span><br><span class="line">buckets = art[<span class="string">&#x27;buckets&#x27;</span>]</span><br><span class="line"><span class="comment">#print(type(buckets)) ; print(buckets)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHour</span>(<span class="params">time</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)(time[<span class="number">11</span>:<span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个小时的点击数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByMonth</span>(<span class="params">dataList , hourTar</span>):</span></span><br><span class="line">    _count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataList:</span><br><span class="line">        timestamp = data[<span class="string">&#x27;key_as_string&#x27;</span>]</span><br><span class="line">        hour = getHour(timestamp)</span><br><span class="line">        <span class="keyword">if</span> hour == hourTar: </span><br><span class="line">            _count = (<span class="built_in">int</span>)(data[<span class="string">&#x27;doc_count&#x27;</span>]) + _count   </span><br><span class="line">    <span class="keyword">return</span> _count        </span><br><span class="line">            </span><br><span class="line">   </span><br><span class="line">final_list = []</span><br><span class="line"><span class="comment"># 循环计算每一个文章</span></span><br><span class="line"><span class="keyword">for</span> outBucket <span class="keyword">in</span> buckets: </span><br><span class="line">   simple_result = &#123;&#125;</span><br><span class="line">   _time = outBucket[<span class="string">&#x27;_time&#x27;</span>]</span><br><span class="line">   innerBuckets = _time[<span class="string">&#x27;buckets&#x27;</span>]</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;time inner bucker size&quot;</span> , <span class="built_in">len</span>(innerBuckets))</span><br><span class="line">   simple_list = []</span><br><span class="line">   <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">24</span>):</span><br><span class="line">      simple_list.append(countByMonth(innerBuckets,num))</span><br><span class="line">   simple_result[<span class="number">0</span>] = outBucket[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line">   simple_result[<span class="number">1</span>] = simple_list</span><br><span class="line">   final_list.append(simple_result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;final result ----&gt; &quot;</span>,final_list)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch被破坏的相似度</title>
    <url>/wiki/elasticsearch%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
    <content><![CDATA[<p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。</p>
<p>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤：用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。</p>
<p>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。</p>
<p>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。</p>
<p>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。</p>
<p>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。</p>
<p>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。</p>
<p>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。</p>
<p>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF 。</p>
<p>不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html">Elasticsearch: 权威指南 » 基础入门 » 排序与相关性 » 什么是相关性?</a></li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-is-broken.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 被破坏的相关度！</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch调优实践</title>
    <url>/wiki/elasticsearch%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-0/</url>
    <content><![CDATA[<blockquote>
<p>从性能和稳定性两方面，从linux参数调优、ES节点配置和ES使用方式三个角度入手，介绍ES调优的基本方案。当然，ES的调优绝不能一概而论，需要根据实际业务场景做适当的取舍和调整</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p>
</blockquote>
<h2 id="Linux优化"><a href="#Linux优化" class="headerlink" title="Linux优化"></a>Linux优化</h2><h3 id="关闭交换分区，防止内存置换降低性能。"><a href="#关闭交换分区，防止内存置换降低性能。" class="headerlink" title="关闭交换分区，防止内存置换降低性能。"></a>关闭交换分区，防止内存置换降低性能。</h3><p>将 <code>/etc/fstab</code> 文件中包含swap的行注释掉<br><code>sed -i &#39;/swap/s/^/#/&#39; /etc/fstabswapoff -a</code></p>
<h3 id="磁盘挂载选项"><a href="#磁盘挂载选项" class="headerlink" title="磁盘挂载选项"></a>磁盘挂载选项</h3><p>noatime：禁止记录访问时间戳，提高文件系统读写性能<br>data=writeback： 不记录data journal，提高文件系统写入性能<br>barrier=0：barrier保证journal先于data刷到磁盘，上面关闭了journal，这里的barrier也就没必要开启了<br>nobh：关闭buffer_head，防止内核打断大块数据的IO操作<br>mount -o noatime,data=writeback,barrier=0,nobh /dev/sda /es_data</p>
<h3 id="对于SSD磁盘，采用电梯调度算法"><a href="#对于SSD磁盘，采用电梯调度算法" class="headerlink" title="对于SSD磁盘，采用电梯调度算法"></a>对于SSD磁盘，采用电梯调度算法</h3><p>因为SSD提供了更智能的请求调度算法，不需要内核去做多余的调整 (仅供参考)<br><code>echo noop &gt; /sys/block/sda/queue/scheduler</code></p>
<h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><p>conf/elasticsearch.yml文件：</p>
<h3 id="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"><a href="#适当增大写入buffer和bulk队列长度，提高写入性能和稳定性" class="headerlink" title="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"></a>适当增大写入buffer和bulk队列长度，提高写入性能和稳定性</h3><p><code>indices.memory.index_buffer_size: 15%</code><br><code>thread_pool.bulk.queue_size: 1024</code></p>
<h3 id="计算disk使用量时，不考虑正在搬迁的shard"><a href="#计算disk使用量时，不考虑正在搬迁的shard" class="headerlink" title="计算disk使用量时，不考虑正在搬迁的shard"></a>计算disk使用量时，不考虑正在搬迁的shard</h3><p>在规模比较大的集群中，可以防止新建shard时扫描所有shard的元数据，提升shard分配速度。<br><code>cluster.routing.allocation.disk.include_relocations: false</code></p>
<h2 id="三-ES使用方式"><a href="#三-ES使用方式" class="headerlink" title="三 ES使用方式"></a>三 ES使用方式</h2><h3 id="控制字段的存储选项"><a href="#控制字段的存储选项" class="headerlink" title="控制字段的存储选项"></a>控制字段的存储选项</h3><p>ES底层使用Lucene存储数据，主要包括行存（StoreFiled）、列存（DocValues）和倒排索引（InvertIndex）三部分。 大多数使用场景中，没有必要同时存储这三个部分，可以通过下面的参数来做适当调整：</p>
<h4 id="StoreFiled"><a href="#StoreFiled" class="headerlink" title="StoreFiled"></a>StoreFiled</h4><p>行存，其中占比最大的是source字段，它控制doc原始数据的存储。在写入数据时，ES把doc原始数据的整个json结构体当做一个string，存储为source字段。查询时，可以通过source字段拿到当初写入时的整个json结构体。 所以，如果没有取出整个原始json结构体的需求，可以通过下面的命令，在mapping中关闭source字段或者只在source中存储部分字段，数据查询时仍可通过ES的docvaluefields获取所有字段的值。<br>注意：关闭source后， update, updatebyquery, reindex等接口将无法正常使用，所以有update等需求的index不能关闭source。</p>
<ul>
<li>关闭 _source<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="source只存储部分字段"><a href="#source只存储部分字段" class="headerlink" title="_source只存储部分字段"></a>_source只存储部分字段</h4><p>通过includes指定要存储的字段或者通过excludes滤除不需要的字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;includes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;*.count&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.*&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;excludes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;meta.description&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.other.*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="docvalues-控制列存。"><a href="#docvalues-控制列存。" class="headerlink" title="docvalues 控制列存。"></a>docvalues 控制列存。</h4><p>ES主要使用列存来支持sorting, aggregations和scripts功能，对于没有上述需求的字段，可以通过下面的命令关闭docvalues，降低存储成本。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ndex：控制倒排索引。"><a href="#ndex：控制倒排索引。" class="headerlink" title="ndex：控制倒排索引。"></a>ndex：控制倒排索引。</h4><p>ES默认对于所有字段都开启了倒排索引，用于查询。对于没有查询需求的字段，可以通过下面的命令关闭倒排索引。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="allES的一个特殊的字段"><a href="#allES的一个特殊的字段" class="headerlink" title="allES的一个特殊的字段"></a>allES的一个特殊的字段</h4><ul>
<li>ES把用户写入json的所有字段值拼接成一个字符串后，做分词，然后保存倒排索引，用于支持整个json的全文检索。<br>这种需求适用的场景较少，可以通过下面的命令将all字段关闭，节约存储成本和cpu开销。（ES 6.0+以上的版本不再支持_all字段，不需要设置）<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fieldnames"><a href="#fieldnames" class="headerlink" title="fieldnames"></a>fieldnames</h4>该字段用于exists查询，来确认某个doc里面有无一个字段存在。若没有这种需求，可以将其关闭。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_field_names&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启最佳压缩"><a href="#开启最佳压缩" class="headerlink" title="开启最佳压缩"></a>开启最佳压缩</h3><p>对于打开了上述_source字段的index，可以通过下面的命令来把lucene适用的压缩算法替换成 DEFLATE，提高数据压缩率。<br><code>PUT /my_index/_settings&#123;    &quot;index.codec&quot;: &quot;best_compression&quot;&#125;</code></p>
<h3 id="bulk批量写入"><a href="#bulk批量写入" class="headerlink" title="bulk批量写入"></a>bulk批量写入</h3><p>写入数据时尽量使用下面的bulk接口批量写入，提高写入效率。每个bulk请求的doc数量设定区间推荐为1k~1w，具体可根据业务场景选取一个适当的数量。</p>
<h3 id="调整translog同步策略"><a href="#调整translog同步策略" class="headerlink" title="调整translog同步策略"></a>调整translog同步策略</h3><p>默认情况下，translog的持久化策略是，对于每个写入请求都做一次flush，刷新translog数据到磁盘上。这种频繁的磁盘IO操作是严重影响写入性能的，如果可以接受一定概率的数据丢失（这种硬件故障的概率很小），可以通过下面的命令调整 translog 持久化策略为异步周期性执行，并适当调整translog的刷盘周期。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;translog&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;durability&quot;</span>: <span class="string">&quot;async&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整refresh-interval"><a href="#调整refresh-interval" class="headerlink" title="调整refresh_interval"></a>调整refresh_interval</h3><p>写入Lucene的数据，并不是实时可搜索的，ES必须通过refresh的过程把内存中的数据转换成Lucene的完整segment后，才可以被搜索。默认情况下，ES每一秒会refresh一次，产生一个新的segment，这样会导致产生的segment较多，从而segment merge较为频繁，系统开销较大。如果对数据的实时可见性要求较低，可以通过下面的命令提高refresh的时间间隔，降低系统开销。</p>
<p><code>PUT my_index&#123;  &quot;settings&quot;: &#123;    &quot;index&quot;: &#123;        &quot;refresh_interval&quot; : &quot;30s&quot;    &#125;  &#125;&#125;</code></p>
<h3 id="merge并发控制"><a href="#merge并发控制" class="headerlink" title="merge并发控制"></a>merge并发控制</h3><p>ES的一个index由多个shard组成，而一个shard其实就是一个Lucene的index，它又由多个segment组成，且Lucene会不断地把一些小的segment合并成一个大的segment，这个过程被称为merge。默认值是Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))，当节点配置的cpu核数较高时，merge占用的资源可能会偏高，影响集群的性能，可以通过下面的命令调整某个index的merge过程的并发度：</p>
<p><code>PUT /my_index/_settings&#123;    &quot;index.merge.scheduler.max_thread_count&quot;: 2&#125;</code></p>
<h3 id="写入数据不指定-id，让ES自动产生"><a href="#写入数据不指定-id，让ES自动产生" class="headerlink" title="写入数据不指定_id，让ES自动产生"></a>写入数据不指定_id，让ES自动产生</h3><p>当用户显示指定id写入数据时，ES会先发起查询来确定index中是否已经有相同id的doc存在，若有则先删除原有doc再写入新doc。这样每次写入时，ES都会耗费一定的资源做查询。如果用户写入数据时不指定doc，ES则通过内部算法产生一个随机的id，并且保证id的唯一性，这样就可以跳过前面查询id的步骤，提高写入效率。 所以，在不需要通过id字段去重、update的使用场景中，写入不指定id可以提升写入速率。基础架构部数据库团队的测试结果显示，无id的数据写入性能可能比有_id的高出近一倍，实际损耗和具体测试场景相关。</p>
<h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>对于数据量较大的index，一般会配置多个shard来分摊压力。这种场景下，一个查询会同时搜索所有的shard，然后再将各个shard的结果合并后，返回给用户。对于高并发的小查询场景，每个分片通常仅抓取极少量数据，此时查询过程中的调度开销远大于实际读取数据的开销，且查询速度取决于最慢的一个分片。开启routing功能后，ES会将routing相同的数据写入到同一个分片中（也可以是多个，由index.routingpartitionsize参数控制）。如果查询时指定routing，那么ES只会查询routing指向的那个分片，可显著降低调度开销，提升查询效率。 routing的使用方式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 写入PUT my_index/my_type/<span class="number">1</span>?routing=user1&#123;  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span>&#125;</span><br><span class="line"># 查询GET my_index/_search?routing=user1,user2 &#123;  <span class="attr">&quot;query&quot;</span>: &#123;    <span class="attr">&quot;match&quot;</span>: &#123;      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span>    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为string类型的字段选取合适的存储方式"><a href="#为string类型的字段选取合适的存储方式" class="headerlink" title="为string类型的字段选取合适的存储方式"></a>为string类型的字段选取合适的存储方式</h3><h4 id="存为text类型的字段（string字段默认类型为text）："><a href="#存为text类型的字段（string字段默认类型为text）：" class="headerlink" title="存为text类型的字段（string字段默认类型为text）："></a>存为text类型的字段（string字段默认类型为text）：</h4><pre><code>做分词后存储倒排索引，支持全文检索，可以通过下面几个参数优化其存储方式：
 -  norms：用于在搜索时计算该doc的_score（代表这条数据与搜索条件的相关度），如果不需要评分，可以将其关闭。
 - indexoptions：控制倒排索引中包括哪些信息（docs、freqs、positions、offsets）。对于不太注重score/highlighting的使用场景，可以设为 docs来降低内存/磁盘资源消耗。
 - fields: 用于添加子字段。对于有sort和聚合查询需求的场景，可以添加一个keyword子字段以支持这两种功能。

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;norms&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;index_options&quot;</span>: <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```    </span><br><span class="line">#### 存为keyword类型的字段</span><br><span class="line">不做分词，不支持全文检索。text分词消耗CPU资源，冗余存储keyword子字段占用存储空间。如果没有全文索引需求，只是要通过整个字段做搜索，可以设置该字段的类型为keyword，提升写入速率，降低存储成本。 设置字段类型的方法有两种：一是创建一个具体的index时，指定字段的类型；二是通过创建template，控制某一类index的字段类型。</span><br><span class="line"></span><br><span class="line">-  通过mapping指定 tags 字段为keyword类型</span><br><span class="line">```json</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 通过template，指定my_index*类的index，其所有string字段默认为keyword类型<br>PUT _template/my_template<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;order&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;template&quot;</span>: <span class="string">&quot;my_index*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_default_&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="attr">&quot;strings&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查询时，使用query-bool-filter组合取代普通query"><a href="#查询时，使用query-bool-filter组合取代普通query" class="headerlink" title="查询时，使用query-bool-filter组合取代普通query"></a>查询时，使用query-bool-filter组合取代普通query</h3><p>默认情况下，ES通过一定的算法计算返回的每条数据与查询语句的相关度，并通过score字段来表征。但对于非全文索引的使用场景，用户并不care查询结果与查询条件的相关度，只是想精确的查找目标数据。此时，可以通过query-bool-filter组合来让ES不计算score，并且尽可能的缓存filter的结果集，供后续包含相同filter的查询使用，提高查询效率。</p>
<ul>
<li>普通查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot; : &#123; &quot;user&quot; : &quot;Kimchy&quot; &#125;   &#125;&#125;</code></li>
<li>query-bool-filter 加速查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123; &quot;user&quot;: &quot;Kimchy&quot; &#125;      &#125;    &#125;  &#125;&#125;</code></li>
</ul>
<h3 id="index按日期滚动，便于管理"><a href="#index按日期滚动，便于管理" class="headerlink" title="index按日期滚动，便于管理"></a>index按日期滚动，便于管理</h3><p>写入ES的数据最好通过某种方式做分割，存入不同的index。<br>常见的做法是将数据按模块/功能分类，写入不同的index，然后按照时间去滚动生成index。这样做的好处是各种数据分开管理不会混淆，也易于提高查询效率。<code>同时index按时间滚动，数据过期时删除整个index，要比一条条删除数据或deletebyquery效率高很多</code>，因为删除整个index是直接删除底层文件，而deletebyquery是查询-标记-删除。</p>
<p>举例说明，假如有[modulea,moduleb]两个模块产生的数据，那么index规划可以是这样的：一类index名称是modulea + {日期}，另一类index名称是module_b+ {日期}。对于名字中的日期，可以在写入数据时自己指定精确的日期，也可以通过ES的ingest pipeline中的index-name-processor实现（会有写入性能损耗）。</p>
<h3 id="按需控制index的分片数和副本数"><a href="#按需控制index的分片数和副本数" class="headerlink" title="按需控制index的分片数和副本数"></a>按需控制index的分片数和副本数</h3><p>分片（shard）：一个ES的index由多个shard组成，每个shard承载index的一部分数据。</p>
<p>副本（replica）：index也可以设定副本数（numberofreplicas），也就是同一个shard有多少个备份。对于查询压力较大的index，可以考虑提高副本数（numberofreplicas），通过多个副本均摊查询压力。</p>
<p>shard数量（numberofshards）设置过多或过低都会引发一些问题：shard数量过多，则批量写入/查询请求被分割为过多的子写入/查询，导致该index的写入、查询拒绝率上升；对于数据量较大的inex，当其shard数量过小时，无法充分利用节点资源，造成机器资源利用率不高 或 不均衡，影响写入/查询的效率。</p>
<p>对于每个index的shard数量，可以根据数据总量、写入压力、节点数量等综合考量后设定，然后根据数据增长状态定期检测下shard数量是否合理。基础架构部数据库团队的推荐方案是：</p>
<p>对于数据量较小（100GB以下）的index，往往写入压力查询压力相对较低，一般设置3<del>5个shard，numberofreplicas设置为1即可（也就是一主一从，共两副本） 。<br>对于数据量较大（100GB以上）的index：<br>一般把单个shard的数据量控制在（20GB</del>50GB）<br>让index压力分摊至多个节点：可通过index.routing.allocation.totalshardsper_node参数，强制限定一个节点上该index的shard数量，让shard尽量分配到不同节点上<br>综合考虑整个index的shard数量，如果shard数量（不包括副本）超过50个，就很可能引发拒绝率上升的问题，此时可考虑把该index拆分为多个独立的index，分摊数据量，同时配合routing使用，降低每个查询需要访问的shard数量。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch踩坑</title>
    <url>/wiki/elasticsearch%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="search-max-buckets"><a href="#search-max-buckets" class="headerlink" title="search.max_buckets"></a>search.max_buckets</h2><p>This limit can be set by changing the [search.max_buckets] cluster level setting.]];</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;search.max_buckets&quot;</span>: <span class="number">100000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Required-one-of-fields-field-script"><a href="#Required-one-of-fields-field-script" class="headerlink" title="Required one of fields [field, script]"></a>Required one of fields [field, script]</h2><p>[Elasticsearch exception [type=illegal_argument_exception, reason=Required one of fields [field, script], but none were specified. ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      NativeSearchQuery nativeSearchQuery = <span class="keyword">new</span> NativeSearchQuery(QueryBuilders.matchAllQuery(), <span class="keyword">null</span>);</span><br><span class="line">      Script script = <span class="keyword">new</span> Script(<span class="string">&quot;doc[&#x27;article.keyword&#x27;]&quot;</span>);</span><br><span class="line">      nativeSearchQuery.addAggregation(AggregationBuilders.terms(<span class="string">&quot;art&quot;</span>)</span><br><span class="line">              .field(<span class="string">&quot;article.keyword&quot;</span>).size(<span class="number">10</span>)</span><br><span class="line">              .subAggregation(AggregationBuilders.dateHistogram(<span class="string">&quot;visitTime&quot;</span>)</span><br><span class="line">                      .field(<span class="string">&quot;visitTime&quot;</span>) <span class="comment">// 这一行没有写</span></span><br><span class="line">                      .calendarInterval(DateHistogramInterval.HOUR)));</span><br><span class="line">      SearchHits&lt;YjVisitData&gt; search = elasticsearchRestTemplate.search(nativeSearchQuery, YjVisitData.class);</span><br><span class="line">      System.err.println(<span class="string">&quot;search.getAggregations().asList() &#123;&#125;&quot;</span> + search.getAggregations().asList().size());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch重要配置</title>
    <url>/wiki/elasticsearch%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>虽然Elasticsearch仅需要很少的配置，但有许多设置需要手动配置，并且在进入生产之前绝对必须进行配置。</p>
<p><code>path.data</code> 和 <code>path.logs</code><br><code>cluster.name</code><br><code>node.name</code><br><code>bootstrap.memory_lock</code><br><code>network.host</code><br><code>discovery.zen.ping.unicast.hosts</code><br><code>discovery.zen.minimum_master_nodes</code><br><code>path.data</code> 和 <code>path.logs</code><br>如果使用.zip或.tar.gz归档，则数据和日志目录是$ES_HOME的子文件夹。 如果这些重要的文件夹保留在其默认位置，则存在将Elasticsearch升级到新版本时被删除的高风险。  </p>
<p>在生产使用中，肯定得更改数据和日志文件夹的位置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path:</span></span><br><span class="line">  <span class="attr">logs:</span> <span class="string">/var/log/elasticsearch</span></span><br><span class="line">  <span class="attr">data:</span> <span class="string">/var/data/elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>RPM和Debian发行版已经使用数据和日志的自定义路径。  </p>
<p><code>path.data</code> 设置可以设置为多个路径，在这种情况下，所有路径将用于存储数据（属于单个分片的文件将全部存储在同一数据路径上）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/mnt/elasticsearch_3</span></span><br></pre></td></tr></table></figure>
<h2 id="cluster-name"><a href="#cluster-name" class="headerlink" title="cluster.name"></a>cluster.name</h2><p>节点只能在群集与群集中的所有其他节点共享其cluster.name时才能加入群集。 默认名称为elasticsearch，但您应将其更改为描述集群用途的适当名称。<br><code>cluster.name: logging-prod</code><br>确保不要在不同的环境中重复使用相同的集群名称，否则可能会导致加入错误集群的节点。  </p>
<h2 id="node-name"><a href="#node-name" class="headerlink" title="node.name"></a>node.name</h2><p>默认情况下，Elasticsearch将使用随机生成的uuid的第一个字符作为节点id。 请注意，节点ID是持久化的，并且在节点重新启动时不会更改，因此默认节点名称也不会更改。<br>配置一个更有意义的名称是值得的，这是重启节点后也能一直保持的优势：<br><code>node.name: prod-data-2</code><br>node.name也可以设置为服务器的HOSTNAME，如下所示：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">node.name:</span> <span class="string">$&#123;HOSTNAME&#125;</span></span><br><span class="line"><span class="string">bootstrap.memory_lock</span></span><br></pre></td></tr></table></figure>
<p>没有JVM被交换到磁盘上这事对于节点的健康来说是至关重要的。一种实现方法是将bootstrap.memory_lock设置为true。<br>要使此设置生效，需要首先配置其他系统设置。 有关如何正确设置内存锁定的更多详细信息，请参阅启用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#mlockall">bootstrap.memory_lock</a>。  </p>
<h2 id="network-host"><a href="#network-host" class="headerlink" title="network.host"></a>network.host</h2><p>默认情况下，Elasticsearch仅仅绑定在本地回路地址——如：127.0.0.1与[::1]。这在一台服务器上跑一个开发节点是足够的。<br>提示</p>
<p>事实上，多个节点可以在单个节点上相同的$ES_HOME位置一同运行。这可以用于测试Elasticsearch形成集群的能力,但这种配置方式不推荐用于生产环境。</p>
<p>为了将其它服务器上的节点形成一个可以相互通讯的集群，你的节点将不能绑定在一个回路地址上。 这里有更多的网路配置，通常你只需要配置network.host：<br><code>network.host: 192.168.1.10</code><br>network.host也可以配置成一些能识别的特殊的值，譬如：_local_、_site、_global_，它们可以结合指定:ip4与ip6来使用。更多相信信息请参见：<a href="https://aqlu.gitbooks.io/elasticsearch-reference/content/Modules/Network_Settings.html">网路配置</a></p>
<p>重要 👇</p>
<p>一旦你自定义了network.host的配置，Elasticsearch将假设你已经从开发模式转到了生产模式，并将升级系统检测的警告信息为异常信息。更多信息请参见：开发模式vs生产模式</p>
<h2 id="discovery-zen-ping-unicast-hosts（单播发现）"><a href="#discovery-zen-ping-unicast-hosts（单播发现）" class="headerlink" title="discovery.zen.ping.unicast.hosts（单播发现）"></a>discovery.zen.ping.unicast.hosts（单播发现）</h2><p>开箱即用，无需任何网络配置，Elasticsearch将绑定到可用的回路地址，并扫描9300年到9305的端口去连接同一机器上的其他节点,试图连接到相同的服务器上运行的其他节点。它提供了不需要任何配置就能自动组建集群的体验。<br>当与其它机器上的节点要形成一个集群时，你需要提供一个在线且可访问的节点列表。像如下来配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts:</span><br><span class="line">   - 192.168.1.10:9300</span><br><span class="line">   - 192.168.1.11 #①</span><br><span class="line">   - seeds.mydomain.com #②</span><br></pre></td></tr></table></figure>
<p>① 未指定端口时，将使用默认的<code>transport.profiles.default.port</code>值，如果此值也为设置则使用<code>transport.tcp.port</code></p>
<p>② 主机名将被尝试解析成能解析的多个IP</p>
<h2 id="discovery-zen-minimum-master-nodes"><a href="#discovery-zen-minimum-master-nodes" class="headerlink" title="discovery.zen.minimum_master_nodes"></a>discovery.zen.minimum_master_nodes</h2><p>为防止数据丢失，配置discovery-zen-minimum_master_nodes将非常重要，他规定了必须至少要有多少个master节点才能形成一个集群。<br>没有此设置时，一个集群在发生网络问题是可能会分裂成多个集群——脑裂——这将导致数据丢失。更多详细信息请参见：通过minimum_master_nodes避免脑裂<br>为避免脑裂，你需要根据master节点数来设置法定人数：<br><code>(master_eligible_nodes / 2) + 1</code><br>换句话说，如果你有三个master节点，最小的主节点数因被设置为(3/2)+1或者是2<br><code>discovery.zen.minimum_master_nodes: 2</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#mlockall">elastic 官方文档</a></li>
<li><a href="https://www.codingdict.com/document">codingdict.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>field name is null or empty</title>
    <url>/wiki/field-name-is-null-or-empty/</url>
    <content><![CDATA[<h2 id="canal-adapter-报错信息"><a href="#canal-adapter-报错信息" class="headerlink" title="canal adapter 报错信息"></a>canal adapter 报错信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring FrameworkServlet &#x27;dispatcherServlet&#x27;</span><br><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization started</span><br><span class="line">2021-07-06 12:46:31.968 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization completed in 9 ms</span><br><span class="line">2021-07-06 12:46:31.995 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:46:32.027 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - field name is null or empty</span><br><span class="line">java.lang.IllegalArgumentException: field name is null or empty</span><br><span class="line">	at org.elasticsearch.index.query.BaseTermQueryBuilder.&lt;init&gt;(BaseTermQueryBuilder.java:113) ~[na:na]</span><br><span class="line">	at org.elasticsearch.index.query.TermQueryBuilder.&lt;init&gt;(TermQueryBuilder.java:75) ~[na:na]</span><br><span class="line">	at org.elasticsearch.index.query.QueryBuilders.termQuery(QueryBuilders.java:202) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.lambda$executeSqlImport$1(ESEtlService.java:141) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:60) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.executeSqlImport(ESEtlService.java:64) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:105) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) ~[na:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_292]</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke</span><br></pre></td></tr></table></figure>


<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>操作是向数据库中插入一条数据，通过canal-adapter同步到elasticsearch中，接口发生以上错误！<br>现象是canal-adapter检测到和mysql的数据变化，但是同步到es的时候发生了错误；<br>猜想大概是某个为空导致存到es的时候发生异常；</p>
<p>然后查看es7下的mapping配置：</p>
<img src="https://oscimg.oschina.net/oscnet/up-93dc9d1f9074d9d44946f2d5c3780dd7e13.png" width=400 height=300>

<p>发现我的sql查id的时候写错了，别名应该写成_id,对应elasticsearch的_id</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Other Question</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>flink 提交任务</title>
    <url>/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>下面演示如何通过admin页面提交任务 👇</p>
<h2 id="准备task-jar"><a href="#准备task-jar" class="headerlink" title="准备task jar"></a>准备task jar</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>mvn install -DskipTest</code> 可以得到相应的jar</p>
<h2 id="admin提交jar"><a href="#admin提交jar" class="headerlink" title="admin提交jar"></a>admin提交jar</h2><img src='https://oscimg.oschina.net/oscnet/up-6f96aa46a523c9cd32f12177775b6d6fab9.png' width=900 height=450> 

<p>提交完jar包之后，需要设置相关参数，这个根据自己的实际情况来设置，下面是参考样例： </p>
<ul>
<li>Enter Class : com.ibli.flink.StreamWordCount<br>也就是程序入口，我们这是写了一个main方法，如果是程序的话，可以写对应bootstrap的启动类</li>
<li>Program Arguments : –host localhost –port 7777 </li>
</ul>
<p>点击 <code>submit</code>  之后查看提交的任务状态</p>
<h2 id="查看任务"><a href="#查看任务" class="headerlink" title="查看任务"></a>查看任务</h2><img src='https://oscimg.oschina.net/oscnet/up-f11b32799d87f90c6e78732db82f191be3b.png' width=900 height=450>  

<p>可以看到是有两个任务，并且都是在执行状态；<br>点击一个任务，还可以查看任务详情信息，和一些其他的信息，非常全面；</p>
<img src="https://oscimg.oschina.net/oscnet/up-9678050d3906aae9ccead23d02927d46851.png" width=900 height=450>

<h2 id="查看运行时任务列表"><a href="#查看运行时任务列表" class="headerlink" title="查看运行时任务列表"></a>查看运行时任务列表</h2><img src='https://oscimg.oschina.net/oscnet/up-da8bf04ac90ae3c16095a6ebf25175b4452.png' width=900 height=350>


<h2 id="查看任务管理列表"><a href="#查看任务管理列表" class="headerlink" title="查看任务管理列表"></a>查看任务管理列表</h2><img src="https://oscimg.oschina.net/oscnet/up-a85746f93dc171f3d320a17c07294682bb3.png" width=900 height=450>

<p>点击任务可以跳转到详情页面 👇 下面是执行日志 </p>
<img src= 'https://oscimg.oschina.net/oscnet/up-a11c7ccc522c77d100d57a9c2a08ec9183b.png' width=900 height=500>

<p>我们还可以看到任务执行的标准输出结果✅</p>
<img src="https://oscimg.oschina.net/oscnet/up-3d990a6318fab3a11e7336fdcd271851fda.png" width=900 height=400>

<h2 id="任务源数据"><a href="#任务源数据" class="headerlink" title="任务源数据"></a>任务源数据</h2><p>通过nc 输入数据，由程序读取7777端口输入流并解析数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gaolei:geekibli gaolei$ nc -lk 7777</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure>

<h2 id="取消任务如下"><a href="#取消任务如下" class="headerlink" title="取消任务如下"></a>取消任务如下</h2><img src='https://oscimg.oschina.net/oscnet/up-05199d86b957e0adec4e4d91390a0aebbec.png' width=900 height=400> 

<p>再次查看已完成任务列表 如下：</p>
<img src='https://oscimg.oschina.net/oscnet/up-78c97d4c4aec1641a22165735764c54b969.png' width=900 height=400>]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Flink</title>
    <url>/wiki/flink%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<img src="https://flink.apache.org/img/flink-header-logo.svg" width=300 height=300>


<p>官方地址请戳👉 <a href="https://flink.apache.org/">【传送】</a> </p>
<blockquote>
<p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.  </p>
</blockquote>
<p>Apache Flink 是一个框架和分布式处理器引擎，用于对无界和有界数据进行状态计算；  </p>
<h2 id="Why-Flink"><a href="#Why-Flink" class="headerlink" title="Why Flink"></a>Why Flink</h2><ul>
<li>流数据更真实地反应了我们的生活方式</li>
<li>传统的数据架构是基于有限数据集的</li>
<li>我们的目标<br>1、低延迟 毫秒级响应<br>2、高吞吐 能够处理海量数据 分布式<br>3、结果的准确性和良好的容错性  </li>
</ul>
<h2 id="Where-need-Flink"><a href="#Where-need-Flink" class="headerlink" title="Where need Flink"></a>Where need Flink</h2><ul>
<li>电商和市场营销<br>数据报表、广告投放、业务流程需要</li>
<li>物联网（IOT）<br>传感器实时数据采集和显示，实时报警，交通运输业</li>
<li>电信业<br>基站流量调配</li>
<li>银行和金融业<br>实时结算和通知推送、实时检测异常行为</li>
</ul>
<h2 id="传统数据处理架构"><a href="#传统数据处理架构" class="headerlink" title="传统数据处理架构"></a>传统数据处理架构</h2><img src="https://oscimg.oschina.net/oscnet/up-5c77526cb1dbc4696143519dff42c447149.png" width=500 height=300>

<p>传统的数据处理架构如上👆<br>CRM(用户关系系统)， Order System(订单系统), Web App (用户点击时间)，当用户出发行为之后需要系统作出响应，首先由上层的计算层处理计算逻辑，计算层的逻辑计算依赖下面的存储层，计算层计算完成之后，将响应返回给客户端。<br>这种基于传统数据库方式无法满足高并发场景，数据库的并发量都是很低的。</p>
<h2 id="分析处理流程"><a href="#分析处理流程" class="headerlink" title="分析处理流程"></a>分析处理流程</h2><img src="https://oscimg.oschina.net/oscnet/up-060fc9ea54c7bfc0e2d5d73b2d674cad5d4.png" width="500" height="300">
分析处理流程架构如上👆，数据先有传统的关系数据库，经过提取，清洗过滤等，将数据存放到数据仓库，然后通过一些sql处理，生成数据报表和一些其他的查询。  

<ul>
<li>问题也很明显，实时性太差了，处理流程太长，无法满足毫秒级需求</li>
<li>数据来源不唯一，能满足海量数据和高并发的需求，但是无法满足实时的需求</li>
</ul>
<h2 id="有状态的流式处理"><a href="#有状态的流式处理" class="headerlink" title="有状态的流式处理"></a>有状态的流式处理</h2><img src="https://oscimg.oschina.net/oscnet/up-cdf03c1c17f534673e73968bb4a094aadbc.png" width="500" height="300">
把当前做流式计算所需要的数据不存放在数据库中，而是简单粗暴的直接放到本地内存中；

<h3 id="内存不稳定？"><a href="#内存不稳定？" class="headerlink" title="内存不稳定？"></a>内存不稳定？</h3><p>周期性的检查点，数据存盘和故障检测；    </p>
<h2 id="lambda架构"><a href="#lambda架构" class="headerlink" title="lambda架构"></a>lambda架构</h2><p>用两台系统同时保障低延迟和结果准确；<br><img src="https://oscimg.oschina.net/oscnet/up-d33708041d13956206958f26e3b5b209a37.png" width="500" height="300"></p>
<ul>
<li>这套架构分成两个流程，上面为批处理流程，数据收集到一定程序，交给批处理器处理，最终产生一个批处理结果</li>
<li>下面的流程为流式处理流程，保证能快速得到结果</li>
<li>最终有我们在应用层根据实际问题选择具体的处理结果交给应用程序这种架构有什么缺陷？<br>可能得到的结果是不准确的，我们可以先快速的得到一个实时计算的结果，隔一段时间之后在来看批处理产生的结果。<br>实现两台系统和维护两套系统，成本很大；  </li>
</ul>
<h2 id="第三代流式处理架构"><a href="#第三代流式处理架构" class="headerlink" title="第三代流式处理架构"></a>第三代流式处理架构</h2><p>Apache Flink 可以完美解决上面的问题👆<br><img src="https://oscimg.oschina.net/oscnet/up-0cec29eb67e668b76cd1387a0cfe71e47a0.png" width="350" height="350"><br>Strom无法满足海量数据； Sparking Stream 无法满足低延迟；  </p>
<h3 id="基于事件驱动-（Event-driven）"><a href="#基于事件驱动-（Event-driven）" class="headerlink" title="基于事件驱动 （Event-driven）"></a>基于事件驱动 （Event-driven）</h3><img src="https://oscimg.oschina.net/oscnet/up-cf462b316ee2d27df780fd551ce8ecc72cb.png" width="450" height="330">
  

<h3 id="处理无界和有界数据"><a href="#处理无界和有界数据" class="headerlink" title="处理无界和有界数据"></a>处理无界和有界数据</h3><p>任何类型的数据都可以形成一种事件流。信用卡交易、传感器测量、机器日志、网站或移动应用程序上的用户交互记录，所有这些数据都形成一种流。<br>数据可以被作为 无界 或者 有界 流来处理。  </p>
<ul>
<li><p><b>无界流</b> 有定义流的开始，但没有定义流的结束。它们会无休止地产生数据。无界流的数据必须持续处理，即数据被摄取后需要立刻处理。我们不能等到所有数据都到达再处理，因为输入是无限的，在任何时候输入都不会完成。处理无界数据通常要求以特定顺序摄取事件，例如事件发生的顺序，以便能够推断结果的完整性。</p>
</li>
<li><p><b>有界流&lt;/&gt; 有定义流的开始，也有定义流的结束。有界流可以在摄取所有数据后再进行计算。有界流所有数据可以被排序，所以并不需要有序摄取。有界流处理通常被称为批处理</p>
</li>
</ul>
<img src="https://flink.apache.org/img/bounded-unbounded.png" width="600" height="330" >

<p><b>Apache Flink 擅长处理无界和有界数据集</b> 精确的时间控制和状态化使得 Flink 的运行时(runtime)能够运行任何处理无界流的应用。有界流则由一些专为固定大小数据集特殊设计的算法和数据结构进行内部处理，产生了出色的性能。</p>
<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li>支持事件时间（event-time）和处理时间（processing-time）语义</li>
<li>精确一次的状态一致性保证</li>
<li>低延迟 每秒处理数百万个事件，毫秒级延迟</li>
<li>与众多常用的存储系统链接</li>
<li>高可用，动态扩展，支持7*24全天运行</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1、<a href="https://www.bilibili.com/video/BV1qy4y1q728?from=search&seid=13654102476223768024">尚硅谷 2021 Flink Java版</a><br>2、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/">Apache Flink Documentation</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>flink简单上手</title>
    <url>/wiki/flink%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="mac-安装-flink"><a href="#mac-安装-flink" class="headerlink" title="mac 安装 flink"></a>mac 安装 flink</h2><p><b>1、执行 brew install apache-flink 命令</b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gaolei:/ gaolei$ brew install apache-flink</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Auto-updated Homebrew!  </span><br><span class="line">Updated 1 tap (homebrew/services).</span><br><span class="line">No changes to formulae.</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://archive.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">🍺  /usr/local/Cellar/apache-flink/1.9.1: 166 files, 277MB, built in 15 minutes 29 seconds</span><br></pre></td></tr></table></figure>

<p><b>2、执行flink启动脚本</b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/apache-flink/1.9.1/libexec/bin</span><br><span class="line">./start-cluster.sh</span><br></pre></td></tr></table></figure>

<h2 id="WordCount批处理Demo"><a href="#WordCount批处理Demo" class="headerlink" title="WordCount批处理Demo"></a>WordCount批处理Demo</h2><h3 id="创建maven项目，导入依赖"><a href="#创建maven项目，导入依赖" class="headerlink" title="创建maven项目，导入依赖"></a>创建maven项目，导入依赖</h3><p> 注意自己的flink版本 👇👇</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写批处理程序"><a href="#编写批处理程序" class="headerlink" title="编写批处理程序"></a>编写批处理程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 1、创建执行环境</span></span><br><span class="line">       ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">       <span class="comment">// 2、读取文件数据</span></span><br><span class="line">       String inputPath = <span class="string">&quot;/Users/gaolei/Documents/DemoProjects/flink-start/src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">       DataSource&lt;String&gt; dataSource = env.readTextFile(inputPath);</span><br><span class="line">       <span class="comment">// 对数据集进行处理 按照空格分词展开 转换成（word，1）二元组</span></span><br><span class="line">       AggregateOperator&lt;Tuple2&lt;String, Integer&gt;&gt; result = dataSource.flatMap(<span class="keyword">new</span> MyFlatMapper())</span><br><span class="line">               <span class="comment">// 按照第一个位置 -&gt; word 分组</span></span><br><span class="line">               .groupBy(<span class="number">0</span>)</span><br><span class="line">               .sum(<span class="number">1</span>);</span><br><span class="line">       result.print();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 首先按照空格分词</span></span><br><span class="line">           String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历所有的word 包装成二元组输出</span></span><br><span class="line">           <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">               collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备数据源文件"><a href="#准备数据源文件" class="headerlink" title="准备数据源文件"></a>准备数据源文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello spark</span><br><span class="line">hello world</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br><span class="line">how are you</span><br><span class="line">what is your name</span><br></pre></td></tr></table></figure>

<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(is,1)</span><br><span class="line">(what,1)</span><br><span class="line">(you,1)</span><br><span class="line">(flink,1)</span><br><span class="line">(name,1)</span><br><span class="line">(world,1)</span><br><span class="line">(hello,4)</span><br><span class="line">(your,1)</span><br><span class="line">(are,1)</span><br><span class="line">(java,1)</span><br><span class="line">(how,1)</span><br><span class="line">(spark,1)</span><br></pre></td></tr></table></figure>




<h2 id="flink-处理流式数据"><a href="#flink-处理流式数据" class="headerlink" title="flink 处理流式数据"></a>flink 处理流式数据</h2><p>1、通过 <code>nc -lk &lt;port&gt;</code> 打开一个socket服务，监听7777端口 用于模拟实时的流数据</p>
<p>2、java代码处理流式数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并行度，默认值 = 当前计算机的CPU逻辑核数（设置成1即单线程处理）</span></span><br><span class="line">        <span class="comment">// env.setMaxParallelism(32);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line"><span class="comment">//        String inputPath = &quot;/tmp/Flink_Tutorial/src/main/resources/hello.txt&quot;;</span></span><br><span class="line"><span class="comment">//        DataStream&lt;String&gt; inputDataStream = env.readTextFile(inputPath);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在终端数据数据，如下：</p>
<img src="https://oscimg.oschina.net/oscnet/up-cca0ffbec5b010a4be539bab681d7276234.png" width="500" height="300">  

<p>4、在首次启动的时候遇到一个错误 ❌<br><code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/flink/streaming/api/datastream/DataStream</code><br>处理方法可参照 参考资料 👇</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/VIP099/article/details/106457522">Exception in thread “main” java.lang.NoClassDefFoundError 解决方案</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 运行时架构</title>
    <url>/wiki/flink%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Flink运行时组件"><a href="#Flink运行时组件" class="headerlink" title="Flink运行时组件"></a>Flink运行时组件</h2><ol>
<li><p>JobManager (作业管理器)<br>JobManager 具有许多与协调 Flink 应用程序的分布式执行有关的职责：它决定何时调度下一个 task（或一组 task）、对完成的 task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复等等。这个进程由三个不同的组件组成：</p>
<ul>
<li><p><code>ResourceManager</code><br>ResourceManager 负责 Flink 集群中的资源提供、回收、分配 - 它管理 <code>task slots</code>，这是 Flink 集群中资源调度的单位。Flink 为不同的环境和资源提供者（例如 YARN、Mesos、Kubernetes 和 standalone 部署）实现了对应的 <code>ResourceManager</code>。在 standalone 设置中，ResourceManager 只能分配可用 TaskManager 的 slots，而不能自行启动新的 TaskManager。</p>
</li>
<li><p><code>Dispatcher</code><br>Dispatcher 提供了一个 <code>REST</code> 接口，用来提交 Flink 应用程序执行，并为每个提交的作业启动一个新的 <code>JobMaster</code>。它还运行 Flink WebUI 用来提供作业执行信息。</p>
</li>
<li><p><code>JobMaster</code><br><code>JobMaster</code> 负责管理单个 <code>JobGraph</code> 的执行。Flink 集群中可以同时运行多个作业，每个作业都有自己的 <code>JobMaster。</code><br>始终至少有一个 <code>JobManager</code>。高可用（HA）设置中可能有多个 <code>JobManager</code>，其中一个始终是 leader，其他的则是 <code>standby</code>。</p>
</li>
</ul>
</li>
<li><p>TaskManager （任务管理器）</p>
</li>
</ol>
<ul>
<li><p>Flink中的工作进程，通常在flink中会有多个TaskManager运行，每一个TaskMaganer都包含一定数量的插槽（slots）. 插槽的数量限制了TaskManager能够执行的任务数量；</p>
</li>
<li><p>启动之后，TaskManager会向资源管理器注册他的插槽，收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用，JobManager就可以向插槽分配任务（tasks）来执行了</p>
</li>
<li><p>在执行的过程中，一个TaskManager可以跟其他运行同一应用程序的TaskManager交换数据。</p>
</li>
</ul>
<h2 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h2><img src="https://oscimg.oschina.net/oscnet/up-89cc1f4eb3aa51db738324a144a29b91db1.png" width=760 height=500>

<h2 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h2><p>Flink 运行时由两种类型的进程组成：一个 JobManager 和一个或者多个 TaskManager。</p>
<img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/processes.svg" width=760 height=500> 

<p>Client 不是运行时和程序执行的一部分，而是用于准备数据流并将其发送给 JobManager。之后，客户端可以断开连接（分离模式），或保持连接来接收进程报告（附加模式）。客户端可以作为触发执行 Java/Scala 程序的一部分运行，也可以在命令行进程./bin/flink run …中运行。</p>
<p>可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为standalone 集群启动、在容器中启动、或者通过YARN或Mesos等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。</p>
<h2 id="思考问题🤔"><a href="#思考问题🤔" class="headerlink" title="思考问题🤔"></a>思考问题🤔</h2><blockquote>
<ul>
<li>怎样实现并行计算？ 多线程</li>
<li>并行的任务，需要占用多少solt？</li>
<li>一个流处理程序，到底包含多少个任务？</li>
</ul>
</blockquote>
<h1 id="Tasks-和算子链"><a href="#Tasks-和算子链" class="headerlink" title="Tasks 和算子链"></a>Tasks 和算子链</h1><p><code>并行度（Parallelism）</code></p>
<p>一个特定算子的子任务（subtask）的个数被称之为并行度； 一般情况下，一个Stream的并行度就是其所有算子中最大的并行度。<br>整个流也有一个并行度，就是所有算子所有任务的并行度之和；<br>对于分布式执行，Flink 将算子的 subtasks 链接成 tasks。每个 task 由一个线程执行。将算子链接成 task 是个有用的优化：它减少线程间切换、缓冲的开销，并且减少延迟的同时增加整体吞吐量。链行为是可以配置的；请参考链文档以获取详细信息。<br><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_chains.svg" width=760 height=500></p>
<h2 id="TaskManager-和-Slots"><a href="#TaskManager-和-Slots" class="headerlink" title="TaskManager 和 Slots"></a>TaskManager 和 Slots</h2><img src='https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_slots.svg' width=800 height=380>]]></content>
      <categories>
        <category>Apache Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/wiki/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p><code>git init </code><br><code>git add .</code><br><code>git commit -m &lt;message&gt;</code><br><code>git remote add &lt;name&gt; &lt;url&gt;</code><br><code>git push</code><br><code>git push &lt;name&gt;</code><br><code>git push --set-upstream &lt;name&gt; &lt;branch&gt;</code></p>
<h2 id="批量删除分支"><a href="#批量删除分支" class="headerlink" title="批量删除分支"></a>批量删除分支</h2><p>远程：<code>git branch -r| grep &#39;ss-1&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;</code><br>本地：<code>git branch -a | grep &#39;feature-re-1&#39; | xargs git branch -D</code></p>
]]></content>
      <categories>
        <category>Develop Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hutool导出excel</title>
    <url>/wiki/hutool%E5%AF%BC%E5%87%BAexcel/</url>
    <content><![CDATA[<blockquote>
<p>如果你仅需一个Java导出excel的工具，👇就可以满足你的临时需求，当然代码下面这么写肯定是不规范的，可以稍后完善！</p>
</blockquote>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Export方法示例"><a href="#Export方法示例" class="headerlink" title="Export方法示例"></a>Export方法示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(List&lt;IPData&gt; rows)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       ExcelWriter writer = ExcelUtil.getWriter(<span class="keyword">true</span>);</span><br><span class="line">       writer.renameSheet(<span class="string">&quot;所有数据&quot;</span>);     <span class="comment">//甚至sheet的名称</span></span><br><span class="line">       writer.addHeaderAlias(<span class="string">&quot;ip&quot;</span>, <span class="string">&quot;IP&quot;</span>);</span><br><span class="line">       writer.write(rows, <span class="keyword">true</span>);</span><br><span class="line">       writer.setOnlyAlias(<span class="keyword">true</span>);</span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/IP1.xlsx&quot;</span>);</span><br><span class="line">       writer.flush(fileOutputStream);</span><br><span class="line">       writer.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>https协议</title>
    <url>/wiki/https%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26690712">《 HTTPS 升级指南 》 深入理解 HTTPS 原理、过程与实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62246556">HTTPS实现原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26682342">深入理解HTTPS原理、过程与实践</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to GeekIBLi</title>
    <url>/wiki/index/</url>
    <content><![CDATA[<h2 id="道阻-且长"><a href="#道阻-且长" class="headerlink" title="道阻 且长"></a>道阻 且长</h2><h2 id="不错的学习网站推荐"><a href="#不错的学习网站推荐" class="headerlink" title="不错的学习网站推荐"></a>不错的学习网站推荐</h2><blockquote>
<p><a href="https://e.juejin.cn/">掘金 博客</a><br><a href="https://www.codingdict.com/">https://www.codingdict.com/</a><br><a href="https://time.geekbang.org/">极客时间</a><br><a href="https://ashiamd.github.io/docsify-notes/#/README">ashiamd.github.io</a><br><a href="https://www.slidestalk.com/">示说</a> 「 提供了很多优质的PPT 还有很多大厂的沙龙视屏以及材料」<br><a href="https://bytedance.feishu.cn/base/appwBhd98QJ9cpMggHc5QMVHlfd">字节跳动后端面试题集</a><br><a href="https://www.zhihu.com/column/c_1155449617721315328">知乎 Java快速进阶通道</a><br><a href="https://hollischuang.github.io/toBeTopJavaer/#/">To Be Top Javaer - Java工程师成神之路</a><br><a href="https://blog.div-wang.com/">Div-wang</a></p>
</blockquote>
<h2 id="技术团队推荐"><a href="#技术团队推荐" class="headerlink" title="技术团队推荐"></a>技术团队推荐</h2><blockquote>
<p><a href="https://xiaomi-info.github.io/">小米信息部技术团队</a><br><a href="https://tech.youzan.com/">有赞技术团队</a><br><a href="https://tech.meituan.com/">美团技术团队</a></p>
</blockquote>
<h2 id="面试题合集"><a href="#面试题合集" class="headerlink" title="面试题合集"></a>面试题合集</h2><blockquote>
<p><a href="https://juejin.cn/post/6844904096957218823">2020年大厂Java面试前复习的正确姿势（800+面试题附答案解析）</a><br><a href="https://juejin.cn/post/6844904125939843079">Java集合面试题（总结最全面的面试题）</a></p>
</blockquote>
<p><b> 两年学说话 一生学闭嘴 </b></p>
]]></content>
      <categories>
        <category>Overview</category>
      </categories>
  </entry>
  <entry>
    <title>kafka-overview</title>
    <url>/wiki/kafka-overview/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/hellozpc/article/details/105680217">kafka详细教程</a></li>
<li><a href="http://download.kafka-eagle.org/">Kafka 集群管理</a></li>
<li><a href="https://www.orchome.com/kafka/index">OrcHome kafka中文教程</a></li>
<li><a href="https://juejin.cn/post/6847902220667748359">面试官：说说Kafka处理请求的全流程</a></li>
<li><a href="https://juejin.cn/post/6844904046340341768">蘑菇街千亿级消息Kafka上云实践</a></li>
<li><a href="https://www.imooc.com/article/262018">kafka 集群搭建</a></li>
<li><a href="https://wiki.eryajf.net/pages/2953.html">kafka-2-11集群部署</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka安装与初体验</title>
    <url>/wiki/kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="Kafka的安装"><a href="#Kafka的安装" class="headerlink" title="Kafka的安装"></a>Kafka的安装</h2><h3 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure>
<p>默认端口：2181<br>默认安装位置：/usr/local/Cellar/zookeeper<br>配置文件位置：/usr/local/etc/zookeeper<br>日志文件位置：/usr/local/var/log/zookeeper/zookeeper.log  </p>
<h3 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-d339f3f26756d950d6099483c5d033619bd.png"></p>
<h3 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></table></figure>
<p>默认端口：9092<br>默认安装位置：/usr/local/Cellar/kafka<br>配置文件位置：/usr/local/etc/kafka<br>日志文件位置：/usr/local/var/lib/kafka-logs  </p>
<h3 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h3><p>nohup kafka-server-start /usr/local/etc/kafka/server.properties &amp;<br><img src="https://oscimg.oschina.net/oscnet/up-6dcc2cdd724f403f0a5f1af44448cb5c523.png"></p>
<h2 id="订阅发布Demo"><a href="#订阅发布Demo" class="headerlink" title="订阅发布Demo"></a>订阅发布Demo</h2><h3 id="创建一个Topic"><a href="#创建一个Topic" class="headerlink" title="创建一个Topic"></a>创建一个Topic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>
<h3 id="查看创建的Topic"><a href="#查看创建的Topic" class="headerlink" title="查看创建的Topic"></a>查看创建的Topic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<h3 id="生产者生产消息"><a href="#生产者生产消息" class="headerlink" title="生产者生产消息"></a>生产者生产消息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure>

<h3 id="消费者消费消息"><a href="#消费者消费消息" class="headerlink" title="消费者消费消息"></a>消费者消费消息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server 127.0.0.1:9092 --topic test1 --from-beginning</span><br></pre></td></tr></table></figure>
<p>–from-beginning: 将从第一个消息开始接收</p>
<h2 id="SpringBoot集成Kafka"><a href="#SpringBoot集成Kafka" class="headerlink" title="SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h2><p><strong>源码地址：<a href="https://gitee.com/IBLiplus/kafka-demo.git">https://gitee.com/IBLiplus/kafka-demo.git</a></strong><br>项目启动前按照上述安装启动步骤，在本地启动kafka.<br>创建Maven项目，引入一下依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加如下配置，端口号可以自己定<br>配置文件：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port=9010</span></span><br><span class="line"><span class="string">spring.kafka.bootstrap-servers=</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line"><span class="comment"># 发生错误后，消息重发的次数。</span></span><br><span class="line"><span class="string">spring.kafka.producer.retries=</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</span></span><br><span class="line"><span class="string">spring.kafka.producer.batch-size=</span> <span class="number">16384</span></span><br><span class="line"><span class="comment"># 设置生产者内存缓冲区的大小。</span></span><br><span class="line"><span class="string">spring.kafka.producer.buffer-memory=</span> <span class="number">33554432</span></span><br><span class="line"><span class="comment"># 键的序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.producer.key-serializer=</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment"># 值的序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.producer.value-serializer</span> <span class="string">=</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment"># acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。</span></span><br><span class="line"><span class="comment"># acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。</span></span><br><span class="line"><span class="comment"># acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</span></span><br><span class="line"><span class="string">spring.kafka.producer.acks=</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 自动提交的时间间隔 在spring boot 2.X 版本中这里采用的是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-commit-interval=</span> <span class="string">1S</span></span><br><span class="line"><span class="comment"># 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span></span><br><span class="line"><span class="comment"># latest（默认值）在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）</span></span><br><span class="line"><span class="comment"># earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-offset-reset=</span> <span class="string">earliest</span></span><br><span class="line"><span class="comment"># 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span></span><br><span class="line"><span class="string">spring.kafka.consumer.enable-auto-commit=</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 键的反序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.consumer.key-deserializer=</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="comment"># 值的反序列化方式</span></span><br><span class="line"><span class="string">spring.kafka.consumer.value-deserializer=</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="comment"># 在侦听器容器中运行的线程数。</span></span><br><span class="line"><span class="string">spring.kafka.listener.concurrency=</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#listner负责ack，每调用一次，就立即commit</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-mode=</span> <span class="string">manual_immediate</span></span><br><span class="line"><span class="string">spring.kafka.listener.missing-topics-fatal=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>生产者生产消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDemo</span> </span>&#123;</span><br><span class="line">    Logger log = LoggerFactory.getLogger(ProductDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义topic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_TEST = <span class="string">&quot;topic.test&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_GROUP1 = <span class="string">&quot;topic.group1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_GROUP2 = <span class="string">&quot;topic.group2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;准备发送消息为：&#123;&#125;&quot;</span>, obj);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(TOPIC_TEST, obj);</span><br><span class="line">        future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//发送失败的处理</span></span><br><span class="line">                log.info(TOPIC_TEST + <span class="string">&quot; - 生产者 发送消息失败：&quot;</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//成功的处理</span></span><br><span class="line">                log.info(TOPIC_TEST + <span class="string">&quot; - 生产者 发送消息成功：&quot;</span> + stringObjectSendResult.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    Logger log = LoggerFactory.getLogger(ConsumerDemo.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = ProductDemo.TOPIC_TEST, groupId = ProductDemo.TOPIC_GROUP1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional message = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent()) &#123;</span><br><span class="line">            Object msg = message.get();</span><br><span class="line">            log.info(<span class="string">&quot;topic_test 消费了： Topic:&quot;</span> + topic + <span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = ProductDemo.TOPIC_TEST, groupId = ProductDemo.TOPIC_GROUP2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test1</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional message = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent()) &#123;</span><br><span class="line">            Object msg = message.get();</span><br><span class="line">            log.info(<span class="string">&quot;topic_test1 消费了： Topic:&quot;</span> + topic + <span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private ProductDemo productDemo;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/kafka/test&quot;)</span><br><span class="line">public void testKafka()&#123;</span><br><span class="line">    logger.info(&quot;start test&quot;);</span><br><span class="line">    productDemo.send(&quot;hello kafka&quot;);</span><br><span class="line">    logger.info(&quot;end test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p align="middle">山脚太拥挤 我们更高处见。</p></blockquote>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kibana添加用户及控制权限</title>
    <url>/wiki/kibana%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%8F%8A%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<blockquote>
<p>操作步骤： 【修改elasticsearch配置文件】 -&gt; 【重启elasticsearch】 -&gt; 【初始化账号&amp;密码】 -&gt; 【修改kibana配置文件】 -&gt; 【重启kibana】 -&gt; 【初始账号登录kibana】 -&gt; 【创建、配置角色】 -&gt; 【创建新用户】</p>
</blockquote>
<h2 id="配置elasticsearch"><a href="#配置elasticsearch" class="headerlink" title="配置elasticsearch"></a>配置elasticsearch</h2><p>开启自带的xpack的验证功能<br><code>xpack.security.enabled: true</code></p>
<p>配置单节点模式<br><code>discovery.type: single-node</code></p>
<h3 id="坑1-集群节点配置报错"><a href="#坑1-集群节点配置报错" class="headerlink" title="坑1: 集群节点配置报错"></a>坑1: 集群节点配置报错</h3><p><code>cluster.initial_master_nodes</code></p>
<h3 id="坑2-本次存储节点配置报错"><a href="#坑2-本次存储节点配置报错" class="headerlink" title="坑2: 本次存储节点配置报错"></a>坑2: 本次存储节点配置报错</h3><p>maybe these locations are not writable or multiple nodes were started without increasing [node.max_local_storage_nodes] (was [1])?<br><code>node.max_local_storage_nodes: 2</code></p>
<h2 id="为内置账号设置密码"><a href="#为内置账号设置密码" class="headerlink" title="为内置账号设置密码"></a>为内置账号设置密码</h2><p>在elasticsearch的bin下执行以下命令：<br><code>./elasticsearch-setup-passwords interactive</code></p>
<img src="https://oscimg.oschina.net/oscnet/up-2073ba41d73f8d4b16cd39e420ee017f62d.png" width="800" height='480'>


<h2 id="配置kibana"><a href="#配置kibana" class="headerlink" title="配置kibana"></a>配置kibana</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用初始用户kibana</span><br><span class="line">elasticsearch.username: &quot;kibana_system&quot;</span><br><span class="line">elasticsearch.password: &quot;密码&quot;</span><br></pre></td></tr></table></figure>

<p>重启kibana之后使用初始账号 <code>elastic</code> 登录</p>
<h2 id="创建、配置角色"><a href="#创建、配置角色" class="headerlink" title="创建、配置角色"></a>创建、配置角色</h2><img src='https://oscimg.oschina.net/oscnet/up-be2569d2151c190b3f49f2faebae05dd19a.png' width=840 height=750>


<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><img src='https://oscimg.oschina.net/oscnet/up-b662c15522750b55863cf006e9c8a9d63c4.png' width=840 height=750>


<h2 id="查看新用户访问界面"><a href="#查看新用户访问界面" class="headerlink" title="查看新用户访问界面"></a>查看新用户访问界面</h2><p>角色里面配置了kibana的访问权限，只开通了discover和dashboard两个入口<br><img src='https://oscimg.oschina.net/oscnet/up-3371b430006a3b65cffc8a41f04cb02f423.png' width=800 height=450></p>
<p>索引的话，有好几个索引，但是只配置了一个索引的权限<br><img src='https://oscimg.oschina.net/oscnet/up-10b5d2b6e179b6c200c691631dd43fc1713.png' width=800 height=450></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/QiaoRui_/article/details/97375237">kibana7.2添加登录及权限</a></li>
<li><a href="https://www.cnblogs.com/tq1226112215/p/8435127.html">Elasticsearch 安装</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>most_fields类型</title>
    <url>/wiki/most-fields%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="多字段映射"><a href="#多字段映射" class="headerlink" title="多字段映射"></a>多字段映射</h2><p>首先要做的事情就是对我们的字段索引两次：一次使用词干模式以及一次非词干模式。为了做到这点，采用 <code>multifields</code> 来实现，已经在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-fields.html">multifields</a> 有所介绍：</p>
<p><code>DELETE /my_index</code>  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123; <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span> &#125;, </span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123; </span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;std&quot;</span>:   &#123; </span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>title 字段使用 english 英语分析器来提取词干。</li>
<li>title.std 字段使用 standard 标准分析器，所以没有词干提取。</li>
</ul>
<p>接着索引一些文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里用一个简单 match 查询 title 标题字段是否包含 jumping rabbits （跳跃的兔子）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;jumping rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为有了 <code>english</code> 分析器，这个查询是在查找以 jump 和 rabbit 这两个被提取词的文档。两个文档的 title 字段都同时包括这两个词，所以两个文档得到的评分也相同：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只是查询 <code>title.std</code> 字段，那么只有文档 2 是匹配的。尽管如此，如果同时查询两个字段，然后使用 <code>bool</code> 查询将评分结果 合并 ，那么两个文档都是匹配的（ <code>title</code> 字段的作用），而且文档 2 的相关度评分更高（ <code>title.std</code> 字段的作用）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:   <span class="string">&quot;most_fields&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;title.std&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望将所有匹配字段的评分合并起来，所以使用 <code>most_fields</code> 类型。这让 <code>multi_match</code> 查询用 <code>bool</code> 查询将两个字段语句包在里面，而不是使用 <code>dis_max</code> (最佳字段) 查询。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.8226396</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.10741998</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文档 2 现在的评分要比文档 1 高。</p>
<p>用广度匹配字段 <code>title</code> 包括尽可能多的文档——以提升召回率——同时又使用字段 <code>title.std</code> 作为 信号 将相关度更高的文档置于结果顶部。</p>
<p>每个字段对于最终评分的贡献可以通过自定义值 <code>boost</code> 来控制。比如，使 <code>title</code> 字段更为重要，这样同时也降低了其他信号字段的作用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:       <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:        <span class="string">&quot;most_fields&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>:      [ <span class="string">&quot;title^10&quot;</span>, <span class="string">&quot;title.std&quot;</span> ] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>title 字段的 boost 的值为 10 使它比 title.std 更重要。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/most-fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 多数字段</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-工作原理</title>
    <url>/wiki/mybatis-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Mybatis工作原理"><a href="#Mybatis工作原理" class="headerlink" title="Mybatis工作原理"></a>Mybatis工作原理</h1><h2 id="Mybatis整体框架"><a href="#Mybatis整体框架" class="headerlink" title="Mybatis整体框架"></a>Mybatis整体框架</h2><p><img src="https://oscimg.oschina.net/oscnet/up-978b1c01a681073e4a020fdce7703887901.png">  </p>
<h2 id="工作原理解析"><a href="#工作原理解析" class="headerlink" title="工作原理解析"></a>工作原理解析</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0015501b933b36728b8f66f281d78358e97.png">  </p>
<p>1）读取MyBatis配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<blockquote>
<p>读取配置文件将mybatis-config.xml转换为org.apache.ibatis.session.Configuration类，这里mybatis包含9个全局配置；</p>
</blockquote>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<blockquote>
<p>扫描Mapping目录下的***Mapper.xml文件； </p>
</blockquote>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(name = &quot;sqlSessionFactory&quot;)</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(HikariDataSource dataSource) throws Exception &#123;</span><br><span class="line">    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();</span><br><span class="line">    bean.setDataSource(dataSource);</span><br><span class="line">    bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:com/****/mapping/**/*.xml&quot;));</span><br><span class="line">    return bean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成工厂实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);</span><br><span class="line">    <span class="keyword">private</span> Resource configLocation;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> Resource[] mapperLocations;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> TransactionFactory transactionFactory;</span><br><span class="line">    <span class="keyword">private</span> Properties configurationProperties;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> String environment = SqlSessionFactoryBean.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="keyword">private</span> Interceptor[] plugins;</span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt;[] typeHandlers;</span><br><span class="line">    <span class="keyword">private</span> String typeHandlersPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] typeAliases;</span><br><span class="line">    <span class="keyword">private</span> String typeAliasesPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;</span><br><span class="line">    <span class="keyword">private</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends VFS&gt; vfs;</span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
<blockquote>
<p>SqlSession对象完成和数据库的交互： </p>
</blockquote>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<blockquote>
<p>3种执行期类型（Simple Pre Batch）  Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</p>
</blockquote>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<blockquote>
<p>借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。 </p>
</blockquote>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。<br>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="http://c.biancheng.net/view/4304.html">MyBatis的工作原理 C语言网</a>  </p>
]]></content>
      <categories>
        <category>Spring Family</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/wiki/mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>title: mybatis配置文件解析<br>toc: true<br>date: 2021-07-28 17:05:46<br>tags: mybatis<br>categories: [Spring Family]</p>
<hr>
<h1 id="Mybatis配置文件"><a href="#Mybatis配置文件" class="headerlink" title="Mybatis配置文件"></a>Mybatis配置文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 引入数据库属性文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>  <span class="attr">resource</span>=<span class="string">&quot;database.properties&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;username&quot; value=&quot;sa&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- mybatis配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 别名的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;typeAlias type=&quot;com.xit.pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.xit.pojo&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">&lt;!-- 配置运行环境 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 由JDBC管理事务 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置数据源：连接池 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入Mapper映射文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xit/pojo/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- URL方式 --&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- &lt;mapper url=&quot;file:///C:/eclipse-workspace/mybatis-01/src/com/xit/pojo/UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Mybatis有几部分全局配置"><a href="#Mybatis有几部分全局配置" class="headerlink" title="Mybatis有几部分全局配置"></a>Mybatis有几部分全局配置</h2><p>properties=&gt;ettings=&gt;typeAliases=&gt;typeHandlers=&gt;objectFactory=&gt;plugins=&gt;environment=&gt;databaseIdProvider=&gt;mappers</p>
<h2 id="Mybatis-加载Mapper文件有几种方式？"><a href="#Mybatis-加载Mapper文件有几种方式？" class="headerlink" title="Mybatis 加载Mapper文件有几种方式？"></a>Mybatis 加载Mapper文件有几种方式？</h2><p><img src="https://oscimg.oschina.net/oscnet/up-418b861802897058c608593b4b159d5baa2.png"><br>以上是Mybatis官方文档介绍的样例👆，<a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">原文链接请点击这</a>  </p>
<p>  <strong>有4种方式；按照优先级从高到底依次是：</strong>  </p>
<ul>
<li>package</li>
<li>resource</li>
<li>url</li>
<li>class</li>
</ul>
<p>下面是Mybatis加载mybatis-config.xml文件配置的源码，从代码中也可以看到加载的4中方式和优先级！👇<br><strong>org.apache.ibatis.builder.xml.XMLConfigBuilder#typeHandlerElement</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = parent.getChildren().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    XNode child = (XNode)var2.next();</span><br><span class="line">                    String resource;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">                        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">                        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                        XMLMapperBuilder mapperParser;</span><br><span class="line">                        InputStream inputStream;</span><br><span class="line">                        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(resource);</span><br><span class="line">                            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(url);</span><br><span class="line">                            inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">## Mybatis有几种执行器</span><br><span class="line">mybatis有<span class="number">3</span>中执行器； </span><br><span class="line">```text</span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">    SIMPLE, <span class="comment">// 默认</span></span><br><span class="line">    REUSE,</span><br><span class="line">    BATCH;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExecutorType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mysql乐观锁实现分布式锁</title>
    <url>/wiki/mysql%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="基于数据表乐观锁实现分布式锁"><a href="#基于数据表乐观锁实现分布式锁" class="headerlink" title="基于数据表乐观锁实现分布式锁"></a>基于数据表乐观锁实现分布式锁</h1><h2 id="整体的实际思路"><a href="#整体的实际思路" class="headerlink" title="整体的实际思路"></a>整体的实际思路</h2><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源的时候，<br>我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。  </p>
<h2 id="基于数据表实现分布式锁的几个要点"><a href="#基于数据表实现分布式锁的几个要点" class="headerlink" title="基于数据表实现分布式锁的几个要点"></a>基于数据表实现分布式锁的几个要点</h2><p>1、这把锁依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解决操作失败，就会导致记录一直在数据库中，其他线程无法在获得锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁的操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库表中数据已经存在了。  </p>
<p><strong>当然，我们也可以有其它方式解决上面的问题：</strong>  </p>
<p>1、数据库是单点？那就搞两个数据库，数据库之前双向同步，一旦挂掉快速切换到备库上。<br>2、没有失效时间？可以做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>3、非阻塞？可以写一个while循环，直到insert成功再返回成功。<br>4、非重入？可以在数据库表中加一个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库中可以查到的话，就直接把锁分配给它即可。   </p>
<h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h2><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，<br>可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。  </p>
<blockquote>
<p>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，<br>每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。<br>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。<strong>一般的实现乐观锁的方式就是记录数据版本</strong>。  </p>
</blockquote>
<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<br>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。    </p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。<br>但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。  </p>
<h2 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h2><p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。  </p>
<h3 id="1、使用版本号实现乐观锁"><a href="#1、使用版本号实现乐观锁" class="headerlink" title="1、使用版本号实现乐观锁"></a>1、使用版本号实现乐观锁</h3><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查询出商品信息</span><br><span class="line">select (status,status,version) from t_goods where id=#&#123;id&#125;</span><br><span class="line">2.根据商品信息生成订单</span><br><span class="line">3.修改商品status为2</span><br><span class="line">update t_goods</span><br><span class="line">set status=2,version=version+1</span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，<br>因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，<br>对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p>
<blockquote>
<p>这一点其实在微服务架构中只要做好数据隔离就可以避免，比如user这张数据表，按照边界划分应该属于用户中心服务的，其他服务比如仓储，物流等需要<br>用户的信息，应该有用户中心暴露出接口，而不是仓储去数据库查询user这张表的数据，甚至update user的数据。</p>
</blockquote>
<h3 id="2、使用时间戳"><a href="#2、使用时间戳" class="headerlink" title="2、使用时间戳"></a>2、使用时间戳</h3><p>一般都是使用update_time字段，并且这个字段肯定是跟随数据库时间配置的，即 update on current_timestamp ；</p>
<h2 id="乐观锁的优点与不足"><a href="#乐观锁的优点与不足" class="headerlink" title="乐观锁的优点与不足"></a>乐观锁的优点与不足</h2><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。<br>能够提升数据库的吞吐量；<br>但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/lmb55/article/details/78495629">基于数据库的分布式锁实现</a><br><a href="https://blog.csdn.net/tianjiabin123/article/details/72625156">分布式锁方式（一、基于数据库的分布式锁）</a><br><a href="https://zhuanlan.zhihu.com/p/42056183">分布式锁看这篇就够了</a><br><a href="https://blog.csdn.net/lmb55/article/details/78266667">乐观锁与悲观锁深入学习</a></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用命令</title>
    <url>/wiki/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="binlog相关命令"><a href="#binlog相关命令" class="headerlink" title="binlog相关命令"></a>binlog相关命令</h2><p>mysql&gt; show variables like ‘binlog_format’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>show variables like ‘log_bin’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>



<h2 id="用户-amp-权限"><a href="#用户-amp-权限" class="headerlink" title="用户&amp;权限"></a>用户&amp;权限</h2><h3 id="创建用户并授权"><a href="#创建用户并授权" class="headerlink" title="创建用户并授权"></a>创建用户并授权</h3><p>root用户登录： mysql -u root -p 然后输入密码<br>创建用户： <code>create user &#39;yjuser&#39;@&#39;%&#39; identified by &#39;u-bx.com&#39;;</code><br>授权用户只读权限： <code>grant SELECT on mirror.* to &#39;yjuser&#39;@&#39;%&#39; IDENTIFIED by &#39;u-bx.com&#39;;</code><br>刷新权限：<code>flush privileges;</code></p>
<h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><p><code>select User();</code></p>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>multi_match 查询</title>
    <url>/wiki/multi-match-%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>multi_match 查询为能在多个字段上反复执行相同查询提供了一种便捷方式。</p>
<p>📒 📒 📒</p>
<blockquote>
<p>multi_match 多匹配查询的类型有多种，其中的三种恰巧与 了解我们的数据 中介绍的三个场景对应，即：<code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）。</p>
</blockquote>
<p>默认情况下，查询的类型是 <code>best_fields</code> ，这表示它会为每个字段生成一个 <code>match</code> 查询，然后将它们组合到 <code>dis_max</code> 查询的内部，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;queries&quot;</span>:  [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;tie_breaker&quot;</span>: <span class="number">0.3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个查询用 multi_match 重写成更简洁的形式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:                <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:                 <span class="string">&quot;best_fields&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>:               [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;body&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;tie_breaker&quot;</span>:          <span class="number">0.3</span>,</span><br><span class="line">        <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ ⚠️ ⚠️</p>
<ul>
<li>best_fields 类型是默认值，可以不指定。</li>
<li>如 minimum_should_match 或 operator 这样的参数会被传递到生成的 match 查询中。</li>
</ul>
<h2 id="查询字段名称的模糊匹配"><a href="#查询字段名称的模糊匹配" class="headerlink" title="查询字段名称的模糊匹配"></a>查询字段名称的模糊匹配</h2><p>字段名称可以用 <code>模糊匹配</code> 的方式给出：任何与模糊模式正则匹配的字段都会被包括在搜索条件中，例如可以使用以下方式同时匹配 <code>book_title</code> 、 <code>chapter_title</code> 和 <code>section_title</code> （书名、章名、节名）这三个字段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: <span class="string">&quot;*_title&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提升单个字段的权重"><a href="#提升单个字段的权重" class="headerlink" title="提升单个字段的权重"></a>提升单个字段的权重</h2><p>可以使用 ^ 字符语法为单个字段提升权重，在字段名称的末尾添加 ^boost ，其中 boost 是一个浮点数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;*_title&quot;</span>, <span class="string">&quot;chapter_title^2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chapter_title 这个字段的 boost 值为 2 ，而其他两个字段 book_title 和 section_title 字段的默认 boost 值为 1 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-match-query.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » multi_match 查询</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-multi-match-query.html">Elasticsearch Guide [7.x] » Query DSL » Full text queries » Multi-match query</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>netty实现简易RPC调用</title>
    <url>/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93RPC%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于Netty手写一个RPC简易远程调用"><a href="#基于Netty手写一个RPC简易远程调用" class="headerlink" title="基于Netty手写一个RPC简易远程调用"></a>基于Netty手写一个RPC简易远程调用</h1><p><img src="https://oscimg.oschina.net/oscnet/up-b813c676214fc02b6f107ca7f6133a635fb.png">    </p>
<h2 id="抽象协议"><a href="#抽象协议" class="headerlink" title="抽象协议"></a>抽象协议</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerProtocol</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于二进制流调用协议</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 形参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] params;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="RpcRegistry-基于Netty实现的RPC注册中心"><a href="#RpcRegistry-基于Netty实现的RPC注册中心" class="headerlink" title="RpcRegistry 基于Netty实现的RPC注册中心"></a>RpcRegistry 基于Netty实现的RPC注册中心</h3><blockquote>
<p>1、 ServerBootstrap 启动8080端口，等待客户端链接；<br>2、 RegisterHandler用来处理RPC接口的发现和注册；    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer post;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRegistry</span><span class="params">(Integer post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        server.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 接受客户端请求的处理</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//配置通用解码器</span></span><br><span class="line">                        <span class="keyword">int</span> fieldLength = <span class="number">4</span>;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, fieldLength, <span class="number">0</span>, fieldLength));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(fieldLength));</span><br><span class="line">                        <span class="comment">//对象编码器</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> RegisterHandler());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = server.bind(<span class="keyword">this</span>.post).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Rpc registry started in port &quot;</span> + <span class="keyword">this</span>.post);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RpcRegistry(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RegisterHandler-执行RPC的发现和注册"><a href="#RegisterHandler-执行RPC的发现和注册" class="headerlink" title="RegisterHandler 执行RPC的发现和注册"></a>RegisterHandler 执行RPC的发现和注册</h3><blockquote>
<p>1、扫描固定包下或者路径下的类;<br>2、接口为key，具体实例作为value；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; REGISTRY_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、扫描所有需要注册的类</span></span><br><span class="line">        scannerClass(<span class="string">&quot;com.ibli.netty.rpc.provider&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行注册</span></span><br><span class="line">        doRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        InvokerProtocol request = (InvokerProtocol) msg;</span><br><span class="line">        <span class="keyword">if</span> (REGISTRY_MAP.containsKey(request.getClassName())) &#123;</span><br><span class="line">            Object provider = REGISTRY_MAP.get(request.getClassName());</span><br><span class="line">            Method method = provider.getClass().getMethod(request.getMethodName(), request.getParams());</span><br><span class="line">            result = method.invoke(provider, request.getValues());</span><br><span class="line">            ctx.write(result);</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNameList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String className : classNameList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                Class&lt;?&gt; i = clazz.getInterfaces()[<span class="number">0</span>];</span><br><span class="line">                REGISTRY_MAP.put(i.getName(), clazz.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scannerClass</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(packageName.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                scannerClass(packageName + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                classNameList.add(packageName + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>).trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API以及实现"><a href="#API以及实现" class="headerlink" title="API以及实现"></a>API以及实现</h2><h3 id="RPC接口-定义一个简单的服务接口"><a href="#RPC接口-定义一个简单的服务接口" class="headerlink" title="RPC接口 定义一个简单的服务接口"></a>RPC接口 定义一个简单的服务接口</h3><blockquote>
<p>作为一个微服务对外暴露的API;  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRpcService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC接口实现"><a href="#RPC接口实现" class="headerlink" title="RPC接口实现"></a>RPC接口实现</h3><blockquote>
<p>provider实现具体的接口，提供具体的服务；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServiceImpl</span> <span class="keyword">implements</span> <span class="title">IRpcService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC调用方"><a href="#RPC调用方" class="headerlink" title="RPC调用方"></a>RPC调用方</h2><h3 id="调用RPC"><a href="#调用RPC" class="headerlink" title="调用RPC"></a>调用RPC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IRpcService rpc = RpcProxy.create(IRpcService.class);</span><br><span class="line">        System.err.println(rpc.add(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">        System.err.println(rpc.mul(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        System.err.println(rpc.sub(<span class="number">14</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="RpcProxy-动态代理对象请求RPC"><a href="#RpcProxy-动态代理对象请求RPC" class="headerlink" title="RpcProxy 动态代理对象请求RPC"></a>RpcProxy 动态代理对象请求RPC</h2><blockquote>
<p>通过Netty Bootstrap访问8080端口；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        MethodProxy proxy = <span class="keyword">new</span> MethodProxy(clazz);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.isInterface() ?</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;clazz&#125; :</span><br><span class="line">                clazz.getInterfaces();</span><br><span class="line">        T result = (T) Proxy.newProxyInstance(clazz.getClassLoader(), interfaces, proxy);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rpcInvoke(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">rpcInvoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装请求的内容</span></span><br><span class="line">            InvokerProtocol msg = <span class="keyword">new</span> InvokerProtocol();</span><br><span class="line">            msg.setClassName(<span class="keyword">this</span>.clazz.getName());</span><br><span class="line">            msg.setMethodName(method.getName());</span><br><span class="line">            msg.setParams(method.getParameterTypes());</span><br><span class="line">            msg.setValues(args);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> RpcProxyHandler consumerHandler = <span class="keyword">new</span> RpcProxyHandler();</span><br><span class="line">            EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Bootstrap client = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                client.group(group)</span><br><span class="line">                        .channel(NioSocketChannel.class)</span><br><span class="line">                        .handler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">//接收课客户端请求的处理流程</span></span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">int</span> fieldLength = <span class="number">4</span>;</span><br><span class="line">                                <span class="comment">//通用解码器设置</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, fieldLength, <span class="number">0</span>, fieldLength));</span><br><span class="line">                                <span class="comment">//通用编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(fieldLength));</span><br><span class="line">                                <span class="comment">//对象编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                                <span class="comment">//对象解码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">                                pipeline.addLast(<span class="string">&quot;handler&quot;</span>, consumerHandler);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                ChannelFuture future = client.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">                future.channel().writeAndFlush(msg).sync();</span><br><span class="line">                future.channel().closeFuture().sync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> consumerHandler.getResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC调用方接受并处理调用结果"><a href="#RPC调用方接受并处理调用结果" class="headerlink" title="RPC调用方接受并处理调用结果"></a>RPC调用方接受并处理调用结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.response = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>netty实现简易tomcat</title>
    <url>/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/</url>
    <content><![CDATA[<h1 id="基于Netty手写一个简易的Tomcat容器"><a href="#基于Netty手写一个简易的Tomcat容器" class="headerlink" title="基于Netty手写一个简易的Tomcat容器"></a>基于Netty手写一个简易的Tomcat容器</h1><p>本文主要基于传统的BIO来实现一个简单的Http请求处理过程；<br>1、Servlet请求无非就是doGet/doPost，所以我们定义抽象Servlet记忆GET/POST方法；<br>2、基于Netty API实现CS通信；<br>3、模拟Spring加载配置文件，注册请求以及控制器；  </p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6bb2d717164854e73513f9ed1355d1844bc.png">   </p>
<h2 id="Netty版本"><a href="#Netty版本" class="headerlink" title="Netty版本"></a>Netty版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;o.netty&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">4.1</span><span class="number">.6</span>.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单"><a href="#GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单" class="headerlink" title="GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单"></a>GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlRequest</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.uri();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.method().name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getParams() &#123;</span><br><span class="line">        QueryStringDecoder decoder = <span class="keyword">new</span> QueryStringDecoder(req.uri());</span><br><span class="line">        <span class="keyword">return</span> decoder.parameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParam</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = getParams();</span><br><span class="line">        List&lt;String&gt; strings = params.get(name);</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="GlResponse-基于Netty-amp-FullHttpResponse的API操作"><a href="#GlResponse-基于Netty-amp-FullHttpResponse的API操作" class="headerlink" title="GlResponse 基于Netty&amp;FullHttpResponse的API操作"></a>GlResponse 基于Netty&amp;FullHttpResponse的API操作</h2><blockquote>
<p>FullHttpResponse作为返回请求的主体；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlResponse</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                    HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK,</span><br><span class="line">                    Unpooled.wrappedBuffer(string.getBytes(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            response.headers().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            ctx.write(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="GlServlet-定义抽象servlet，定义GET方法和POST方法"><a href="#GlServlet-定义抽象servlet，定义GET方法和POST方法" class="headerlink" title="GlServlet 定义抽象servlet，定义GET方法和POST方法"></a>GlServlet 定义抽象servlet，定义GET方法和POST方法</h2><blockquote>
<p>定义抽象的Servlet和doGet方法和doPost方法，具体的业务去实现自己的方法和逻辑；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (GET.equals(request.getMethod())) &#123;</span><br><span class="line">               doGet(request, response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               doPost(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="FirstServlet-具体的业务Servlet实现抽象Servlet的方法"><a href="#FirstServlet-具体的业务Servlet实现抽象Servlet的方法" class="headerlink" title="FirstServlet 具体的业务Servlet实现抽象Servlet的方法"></a>FirstServlet 具体的业务Servlet实现抽象Servlet的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This is first servlet from NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondServlet-具体的业务Servlet实现抽象Servlet方法"><a href="#SecondServlet-具体的业务Servlet实现抽象Servlet方法" class="headerlink" title="SecondServlet 具体的业务Servlet实现抽象Servlet方法"></a>SecondServlet 具体的业务Servlet实现抽象Servlet方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This second request form NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="web-nio-properties-配置文件"><a href="#web-nio-properties-配置文件" class="headerlink" title="web-nio.properties 配置文件"></a>web-nio.properties 配置文件</h2><blockquote>
<p>配置请求和处理器，Spring中是通过Controller下的@XXXMapping注解去扫描并加载到工厂的；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servlet.one.className=com.ibli.netty.tomcat.nio.servlet.FirstServlet</span><br><span class="line">servlet.one.url=/firstServlet.<span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">servlet.two.className=com.ibli.netty.tomcat.nio.servlet.SecondServlet</span><br><span class="line">servlet.two.url=/secondServlet.<span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<h2 id="GlTomcat"><a href="#GlTomcat" class="headerlink" title="GlTomcat"></a>GlTomcat</h2><blockquote>
<p>启动服务端，在网页中访问本地8080端口，输入配置文件中定义的url进行测试：  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> Properties webXml = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GlServlet&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;String, GlServlet&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GlTomcat().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat的启动入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、加载web配置文件，解析配置</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Boss线程</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// Worker线程</span></span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2、创建Netty服务端对象</span></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3、 配置服务端参数</span></span><br><span class="line">        server.group(bossGroup, workGroup)</span><br><span class="line">                <span class="comment">// 配置主线程的处理逻辑</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 子线程的回调逻辑</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel client)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 处理具体的回调逻辑</span></span><br><span class="line">                        <span class="comment">// 责任链模式</span></span><br><span class="line">                        <span class="comment">//返回-编码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">                        <span class="comment">//请求-解码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">                        <span class="comment">//用户自己的逻辑处理</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> GlTomcatHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 配置主线程可分配的最大线程数</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//保持长链接</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future = server.bind(<span class="keyword">this</span>.PORT).sync();</span><br><span class="line">            System.err.println(<span class="string">&quot;Gl tomcat started in pory &quot;</span> + <span class="keyword">this</span>.PORT);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     * 这其实使用了策略模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String WEB_INF = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(WEB_INF + <span class="string">&quot;web-nio.properties&quot;</span>);</span><br><span class="line">            webXml.load(fis);</span><br><span class="line">            <span class="keyword">for</span> (Object k : webXml.keySet()) &#123;</span><br><span class="line">                String key = k.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&quot;.url&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//servlet.two.url</span></span><br><span class="line">                    String servletName = key.replaceAll(<span class="string">&quot;\\.url&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    String url = webXml.getProperty(key);</span><br><span class="line">                    <span class="comment">//servlet.two.className</span></span><br><span class="line">                    String className = webXml.getProperty(servletName + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">                    <span class="comment">//反射创建servlet实例</span></span><br><span class="line">                    <span class="comment">// load-on-startup &gt;=1 :web启动的时候初始化  0：用户请求的时候才启动</span></span><br><span class="line">                    GlServlet obj = (GlServlet) Class.forName(className).newInstance();</span><br><span class="line">                    <span class="comment">// 将url和servlet建立映射关系</span></span><br><span class="line">                    servletMapping.put(url, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">                HttpRequest req = (HttpRequest) msg;</span><br><span class="line">                GlRequest request = <span class="keyword">new</span> GlRequest(ctx,req);</span><br><span class="line">                GlResponse response = <span class="keyword">new</span> GlResponse(ctx,req);</span><br><span class="line">                String url = request.getUrl();</span><br><span class="line">                <span class="keyword">if</span> (servletMapping.containsKey(url))&#123;</span><br><span class="line">                    servletMapping.get(url).service(request,response);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    response.write(<span class="string">&quot;404 Not Fount&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><blockquote>
<p>请求 : <a href="http://localhost:8080/secoundServlet.do">http://localhost:8080/secoundServlet.do</a> 这的地址写错误  ⚠️<br><img src="https://oscimg.oschina.net/oscnet/up-4652c388dd368f575bc5c0719f68a8632df.png">  </p>
</blockquote>
<blockquote>
<p>请求 : <a href="http://localhost:8080/secondServlet.do">http://localhost:8080/secondServlet.do</a><br><img src="https://oscimg.oschina.net/oscnet/up-cc90b46288898bfe801e33f3a94bfab5070.png">  </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>python3基础语法</title>
    <url>/wiki/python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：<br><code># -*- coding: cp-1252 -*-</code></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>第一个字符必须是字母表中字母或下划线 _ 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。<br>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</li>
</ul>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>import keyword<br>keyword.kwlist<br>[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 # 开头,多行注释可以用多个 # 号，还有 ‘’’ 和 “””：</p>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>

<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \，例如：</p>
<p><code>total = [&#39;item_one&#39;, &#39;item_two&#39;, &#39;item_three&#39;,         &#39;item_four&#39;, &#39;item_five&#39;]</code></p>
<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li>int (整数) , 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li>bool (布尔), 如 True。</li>
<li>float (浮点数), 如 1.23、3E-2</li>
<li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</li>
<li>转义符 \</li>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
<li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li>
<li>Python中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li>
</ul>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p>记住：空行也是程序代码的一部分。</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression : </span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression : </span><br><span class="line">   suite </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">   suite</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line"><span class="comment">## print 输出</span></span><br><span class="line"><span class="built_in">print</span> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=<span class="string">&quot;&quot;</span>：</span><br><span class="line"></span><br><span class="line"><span class="comment">## import 与 from...import</span></span><br><span class="line">在 python 用 <span class="keyword">import</span> 或者 <span class="keyword">from</span>...<span class="keyword">import</span> 来导入相应的模块。</span><br><span class="line"></span><br><span class="line">将整个模块(somemodule)导入，格式为： <span class="keyword">import</span> somemodule</span><br><span class="line"></span><br><span class="line">从某个模块中导入某个函数,格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> somefunction</span><br><span class="line"></span><br><span class="line">从某个模块中导入多个函数,格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> firstfunc, secondfunc, thirdfunc</span><br><span class="line"></span><br><span class="line">将某个模块中的全部函数导入，格式为： <span class="keyword">from</span> somemodule <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令行参数</span></span><br><span class="line"></span><br><span class="line">很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</span><br></pre></td></tr></table></figure>
<p>$ python -h<br>usage: python [option] … [-c cmd | -m mod | file | -] [arg] …<br>Options and arguments (and corresponding environment variables):<br>-c cmd : program passed in as string (terminates option list)<br>-d     : debug output from parser (also PYTHONDEBUG=x)<br>-E     : ignore environment variables (such as PYTHONPATH)<br>-h     : print this help message and exit</p>
<p>[ etc. ]</p>
<p>```<br>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数;</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python3基本数据类型</title>
    <url>/wiki/python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
<li>Python3 的六个标准数据类型中：</li>
</ul>
<p><code>不可变数据</code>（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br><code>可变数据</code>（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 int、float、bool、complex（复数）。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">float</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">bool</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>⚠️ isinstance 和 type 的区别在于：<br>type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型。</p>
<blockquote>
<p>⚠️ 注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加 True==1，False==0 是会返回 Ture，但可以通过 is 来判断类型。<br>1、Python可以同时为多个变量赋值，如a, b = 1, 2。<br>2、一个变量可以通过赋值指向不同类型的对象。<br>3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。<br>4、在混合计算时，Python会把整型转换成为浮点数。</p>
</blockquote>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。<br>字符串的截取的语法格式如下：<br><code>变量[头下标:尾下标]</code><br>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：<br><code>变量[头下标:尾下标]</code><br>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br></pre></td></tr></table></figure>

<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<p>创建格式：<br><code>parame = &#123;value01,value02,...&#125;</code> 或者 <code>set(value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure>

<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<pre><code class="python">#!/usr/bin/python3

dict = &#123;&#125;
dict[&#39;one&#39;] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;

tinydict = &#123;&#39;name&#39;: &#39;runoob&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.runoob.com&#39;&#125;


print (dict[&#39;one&#39;])       # 输出键为 &#39;one&#39; 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre>
<p>注意：<br>1、字典是一种映射类型，它的元素是键值对。<br>2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用 { }。</p>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<img src = 'https://oscimg.oschina.net/oscnet/up-2af36cf02d5a8c9ba5c9148154bbdd83207.png' whdth='700'>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作elasticsearch</title>
    <url>/wiki/python%E6%93%8D%E4%BD%9Celasticsearch/</url>
    <content><![CDATA[<h2 id="下载python对应的elasticsearch依赖包"><a href="#下载python对应的elasticsearch依赖包" class="headerlink" title="下载python对应的elasticsearch依赖包"></a>下载python对应的elasticsearch依赖包</h2><p><code>pip3 install elasticsearch==7.10.0</code></p>
<h2 id="python操作elasticsearch代码"><a href="#python操作elasticsearch代码" class="headerlink" title="python操作elasticsearch代码"></a>python操作elasticsearch代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;init ...&quot;</span>)</span><br><span class="line">es = Elasticsearch([&#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;XXXXXX&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">9200</span>&#125;], http_auth=(<span class="string">&#x27;elastic&#x27;</span>, <span class="string">&#x27;XXXXXX&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(es.get(index=&#x27;yj_ip_pool&#x27;, doc_type=&#x27;_doc&#x27;, id=&#x27;9256058&#x27;))</span></span><br><span class="line">countRes = es.count(index=<span class="string">&#x27;yj_ip_pool&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(countRes)</span><br></pre></td></tr></table></figure>

<h2 id="查询效果"><a href="#查询效果" class="headerlink" title="查询效果"></a>查询效果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gaolei:awesome-python3-webapp gaolei$ /usr/local/opt/python/bin/python3.7 /Users/gaolei/Documents/DemoProjects/awesome-python3-webapp/www/es_test.py</span><br><span class="line">init ...</span><br><span class="line">&#123;&#x27;count&#x27;: 20095400, &#x27;_shards&#x27;: &#123;&#x27;total&#x27;: 1, &#x27;successful&#x27;: 1, &#x27;skipped&#x27;: 0, &#x27;failed&#x27;: 0&#125;&#125;</span><br><span class="line">gaolei:awesome-python3-webapp gaolei$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么禁止开发人员修改 serialVersionUID 字段的值?</title>
    <url>/wiki/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%BF%AE%E6%94%B9-serialVersionUID-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>序列化是一种对象持久化的手段。普遍应用在网络传输、RMI 等场景中。类通 过实现 java.io.Serializable 接口以启用其序列化功能。<br><a href="http://www.hollischuang.com/archives/1150">Java 对象的序列化与反序列化、深入分析 Java 的序列化与反序列化、单例与 序列化的那些事儿</a>  </p>
</blockquote>
<p>在这几篇文章中，分别介绍过了序列化涉及到的类和接口、如何自定义序列化 策略、transient 关键字和序列化的关系等，还通过学习 ArrayList 对序列化的实现源 码深入学习了序列化。并且还拓展分析了一下序列化对单例的影响等。<br>但是，还有一个知识点并未展开介绍，那就是关于 serialVersionUID 。这个 字段到底有什么用?如果不设置会怎么样?为什么《Java 开发手册》中有以下规定:</p>
<img src='https://oscimg.oschina.net/oscnet/up-5b1a6020460edc9c688c054bdbad957cc28.png'>   


<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Serializable 和 Externalizable<br>类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接 口的类将无法进行序列化或反序列化。可序列化类的所有子类型本身都是可序列 化的。<br>如果读者看过 Serializable 的源码，就会发现，他只是一个空的接口，里 面什么东西都没有。Serializable 接口没有方法或字段，仅用于标识可序列化的 语义。但是，如果一个类没有实现这个接口，想要被序列化的话，就会抛出 java. io.NotSerializableException 异常。</p>
<p>它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢?<br>原因是在执行序列化的过程中，会执行到以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在进行序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果都不是则直接抛出 NotSerializableException。<br>Java 中还提供了 Externalizable 接口，也可以实现它来提供序列化能力。</p>
<p>Externalizable 继承自 Serializable，该接口中定义了两个抽象方法: writeExternal() 与 readExternal()。<br>当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重 写 writeExternal() 与 readExternal() 方法。否则所有变量的值都会变成默认值。</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可 以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h2 id="自定义序列化策略"><a href="#自定义序列化策略" class="headerlink" title="自定义序列化策略"></a>自定义序列化策略</h2><p>在序列化过程中，如果被序列化的类中定义了 writeObject 和 readObject 方法， 虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的 序列化和反序列化。</p>
<p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteOb- ject 方法以及 ObjectInputStream 的 defaultReadObject 方法。<br>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程， 比如可以在序列化的过程中动态改变序列化的数值。</p>
<p>所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用 tran- sient 修 饰， 并 自 己 重 写 writeObject 和 readObject 方 法， 如 java.util. ArrayList 中就有这样的实现。</p>
<p>我们随便找几个 Java 中实现了序列化接口的类，如 String、Integer 等，我们 可以发现一个细节，那就是这些类除了实现了 Serializable 外，还定义了一个 serialVersionUID</p>
<img src='https://oscimg.oschina.net/oscnet/up-74a9507ed04462e44fb2b7dd941d6b00fd4.png'>

<p>那么，到底什么是 serialVersionUID 呢?为什么要设置这样一个字段呢?</p>
<h2 id="什么是-serialVersionUID"><a href="#什么是-serialVersionUID" class="headerlink" title="什么是 serialVersionUID"></a>什么是 serialVersionUID</h2><p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。我们都知道， Java 对象是保存在 JVM 的堆内存中的，也就是说，如果 JVM 堆不存在了，那么对 象也就跟着消失了。</p>
<p>而序列化提供了一种方案，可以让你在即使 JVM 停机的情况下也能把对象保存 下来的方案。就像我们平时用的 U 盘一样。把 Java 对象序列化成可存储或传输的形 式(如二进制流)，比如保存在文件中。这样，当再次需要这个对象的时候，从文件中 读取出二进制流，再从二进制流中反序列化出对象。</p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重 要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化 ID，就是我们在代码中 定义的 serialVersionUID。</p>
<h2 id="如果-serialVersionUID-变了会怎样"><a href="#如果-serialVersionUID-变了会怎样" class="headerlink" title="如果 serialVersionUID 变了会怎样"></a>如果 serialVersionUID 变了会怎样</h2><p>我们举个例子吧，看看如果 serialVersionUID 被修改了会发生什么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Initializes The Object User1 user = new User1(); user.setName(&quot;hollis&quot;);</span></span><br><span class="line">                <span class="comment">//Write Obj to File ObjectOutputStream oos = null; try &#123;</span></span><br><span class="line">                oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">                oos.writeObject(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(</span><br><span class="line">            IOException e)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                IOUtils.closeQuietly(oos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">我们先执行以上代码，把一个 User1 对象写入到文件中。然后我们修改一下 User1 类，把 serialVersionUID 的值改为 <span class="number">2L</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后执行以下代码，把文件中的对象反序列化出来:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo2</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Read Obj from File</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">                ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">                    User1 newUser = (User1) ois.readObject();</span><br><span class="line">                    System.out.println(newUser);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    IOUtils.closeQuietly(ois);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FileUtils.forceDelete(file);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">执行结果如下</span><br><span class="line">```java</span><br><span class="line">java.io.InvalidClassException: com.hollis.User1; local <span class="class"><span class="keyword">class</span> <span class="title">incompatible</span>: <span class="title">stream</span> <span class="title">classdesc</span></span></span><br><span class="line"><span class="class"><span class="title">serialVersionUID</span> </span>= <span class="number">1</span>, local <span class="class"><span class="keyword">class</span> <span class="title">serialVersionUID</span> </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，以上代码抛出了一个 java.io.InvalidClassException，并且 指出 serialVersionUID 不一致。</p>
<p>这是因为，在进行反序列化时，JVM 会把传来的字节流中的 serialVersio- nUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致 的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 Invalid- CastException。</p>
<p>这也是《Java 开发手册》中规定，在兼容性升级中，在修改类的时候，不要 修改 serialVersionUID 的原因。除非是完全不兼容的两个版本。所以，serialVersionUID 其实是验证版本一致性的。</p>
<p>如果读者感兴趣，可以把各个版本的 JDK 代码都拿出来看一下，那些向下兼容 的类的 serialVersionUID 是没有变化过的。比如 String 类的 serialVersionUID一直都是 -6849794470754667710L。</p>
<p>但是，作者认为，这个规范其实还可以再严格一些，那就是规定:<br>如果一个类实现了 Serializable 接口，就必须手动添加一个 private static final long serialVersionUID变量，并且设置初始值。</p>
<h2 id="为什么要明确定一个-serialVersionUID"><a href="#为什么要明确定一个-serialVersionUID" class="headerlink" title="为什么要明确定一个 serialVersionUID"></a>为什么要明确定一个 serialVersionUID</h2><p>如果我们没有在类中明确的定义一个 serialVersionUID 的话，看看会发生什么。</p>
<p>尝试修改上面的 demo 代码，先使用以下类定义一个对象，该类中不定义 serialVersionUID，将其写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们修改 User1 类，向其中增加一个属性。在尝试将其从文件中读取出来， 并进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执 行 结 果:java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc serialVersionUID = -2986778152837257883, local class serialVersionUID = 7961728318907695402</p>
<p>同样，抛出了 InvalidClassException，并且指出两个 serialVersio- nUID 不同，分别是 -2986778152837257883 和 7961728318907695402。<br>从这里可以看出，系统自己添加了一个 serialVersionUID。 所以，一旦类实现了 Serializable，就建议明确的定义一个 serialVersionUID。不然在修改类的时候，就会发生异常。</p>
<p>serialVersionUID 有两种显示的生成方式:</p>
<p>一是默认的1L，比如:private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段，比如:private static final long serialVersionUID = xxxxL;</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>serialVersionUID 是用来验证版本一致性的。所以在做兼容性升级的时候， 不要改变类中 serialVersionUID 的值。</p>
<p>如果一个类实现了 Serializable 接口，一定要记得定义 serialVersionUID，否则会发生异常。可以在 IDE 中通过设置，让他帮忙提示，并且可以一键快速生成一 个 serialVersionUID。</p>
<p>之所以会发生异常，是因为反序列化过程中做了校验，并且如果没有明确定义的 话，会根据类的属性自动生成一个。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="">Java技术灵魂15问</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>修改mysql表创建时间</title>
    <url>/wiki/%E4%BF%AE%E6%94%B9mysql%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<ul>
<li><p>修改服务器时间<br><code>date -s &quot;2021-07-14 21:22:10&quot;</code></p>
</li>
<li><p>执行DDL<br><code>alter table mirror_user comment &#39;用户表&#39;;</code></p>
</li>
<li><p>服务器时间修正<br><code>ntpdate ntp1.aliyun.com</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>倒排索引</title>
    <url>/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。  </p>
<p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：  </p>
<p>The quick brown fox jumped over the lazy dog<br>Quick brown foxes leap over lazy dogs in summer<br>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p>
<img src="https://oscimg.oschina.net/oscnet/up-ea663f731dfb8db97706ffd2d34a2297576.png" width=230 height=300>  

<p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：  </p>
<img src="https://oscimg.oschina.net/oscnet/up-6b1b6fb36d1467bfab8d222ace66f4f3dc7.png" width=230 height=160>
两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。  

<p>但是，我们目前的倒排索引有一些问题：</p>
<p><code>Quick</code> 和 <code>quick</code> 以独立的词条出现，然而用户可能认为它们是相同的词。<br><code>fox</code> 和 <code>foxes</code> 非常相似, 就像 <code>dog</code> 和 <code>dogs</code> ；他们有相同的词根。<br><code>jumped</code> 和 <code>leap</code>, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。<br>使用前面的索引搜索 <code>+Quick</code> <code>+fox</code> 不会得到任何匹配文档。（记住，+ 前缀表明这个词必须存在。）只有同时出现 <code>Quick</code> 和 <code>fox</code> 的文档才满足这个查询条件，但是第一个文档包含 <code>quick fox</code> ，第二个文档包含 <code>Quick foxes</code> 。</p>
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
<p><code>Quick</code> 可以小写化为 <code>quick</code> 。<br><code>foxes</code> 可以 词干提取 –变为词根的格式– 为 <code>fox</code> 。类似的， <code>dogs</code> 可以为提取为 <code>dog</code> 。<br><code>jumped</code> 和 <code>leap</code> 是同义词，可以索引为相同的单词 <code>jump</code> 。<br>现在索引看上去像这样：<br><img src="https://oscimg.oschina.net/oscnet/up-5ee716c408738e8394f2d9809f8be8354ba.png" width=230 height=270><br>这还远远不够。我们搜索 <code>+Quick</code> <code>+fox</code> 仍然 会失败，因为在我们的索引中，已经没有 <code>Quick</code> 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 <code>+quick</code> <code>+fox</code> ，这样两个文档都会匹配！</p>
<p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Elasticsearch 内存占用及分配</title>
    <url>/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>Elasticsearch 和 Lucene 对内存使用情况： </p>
<img src='https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/es-cache.png' width=500 height=550>


<p>Elasticsearch 限制的内存大小是 JAVA 堆空间的大小，不包括Lucene 缓存倒排索引数据空间。</p>
<p>Lucene 中的 倒排索引 segments 存储在文件中，为提高访问速度，都会把它加载到内存中，从而提高 Lucene 性能。所以建议至少留系统一半内存给Lucene。<br><code>Node Query Cache</code> (负责缓存f ilter 查询结果)，每个节点有一个，被所有 shard 共享，filter query查询结果要么是 yes 要么是no，不涉及 scores 的计算。<br>集群中每个节点都要配置，默认为：indices.queries.cache.size:10%</p>
<p><code>Indexing Buffer</code> 索引缓冲区，用于存储新索引的文档，当其被填满时，缓冲区中的文档被写入磁盘中的 <code>segments</code> 中。节点上所有 <code>shard</code> 共享。<br>缓冲区默认大小： indices.memory.index_buffer_size: 10%<br>如果缓冲区大小设置了百分百则 indices.memory.min_index_buffer_size 用于这是最小值，默认为 48mb。indices.memory.max_index_buffer_size 用于最大大小，无默认值。</p>
<p><code>segments</code><br>segments会长期占用内存，其初衷就是利用OS的cache提升性能。只有在Merge之后，才会释放掉标记为Delete的segments，释放部分内存。</p>
<p><code>Shard Request Cache</code> 用于缓存请求结果，但之缓存request size为0的。比如说 hits.total, aggregations 和 suggestions.<br>默认最大为indices.requests.cache.size:1%</p>
<p><code>Field Data Cache</code> 字段缓存重要用于对字段进行排序、聚合是使用。因为构建字段数据缓存代价昂贵，所以建议有足够的内训来存储。<br><code>Fielddata</code> 是 「 延迟 」 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中，也就不会使用大量的内存，所以可以考虑分配较小的heap给Elasticsearch。因为heap越小意味着Elasticsearch的GC会比较快，并且预留给Lucene的内存也会比较大。。<br>如果没有足够的内存保存fielddata时，Elastisearch会不断地从磁盘加载数据到内存，并剔除掉旧的内存数据。剔除操作会造成严重的磁盘I/O，并且引发大量的GC，会严重影响Elastisearch的性能。</p>
<p>默认情况下Fielddata会不断占用内存，直到它触发了fielddata circuit breaker。<br>fielddata circuit breaker会根据查询条件评估这次查询会使用多少内存，从而计算加载这部分内存之后，Field Data Cache所占用的内存是否会超过indices.breaker.fielddata.limit。如果超过这个值，就会触发fielddata circuit breaker，abort这次查询并且抛出异常，防止OOM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">indices.breaker.fielddata.limit:60% (默认heap的60%)  (es7之后改成70%)</span><br></pre></td></tr></table></figure>
<p>如果设置了indices.fielddata.cache.size，当达到size时，cache会剔除旧的fielddata。</p>
<blockquote>
<p>indices.breaker.fielddata.limit 必须大于 indices.fielddata.cache.size，否则只会触发fielddata circuit breaker，而不会剔除旧的fielddata。</p>
</blockquote>
<h2 id="配置Elasticsearch堆内存"><a href="#配置Elasticsearch堆内存" class="headerlink" title="配置Elasticsearch堆内存"></a>配置Elasticsearch堆内存</h2><p>Elasticsearch默认安装后设置的内存是 <code>1GB</code>，这是远远不够用于生产环境的。<br>有两种方式修改Elasticsearch的堆内存：</p>
<blockquote>
<ol>
<li>设置环境变量：<code>export ES_HEAP_SIZE=10g</code> 在es启动时会读取该变量；</li>
<li>启动时作为参数传递给es： <code>./bin/elasticsearch -Xmx10g -Xms10g</code></li>
</ol>
</blockquote>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>给es分配内存时要注意，至少要分配一半儿内存留给 Lucene。<br>分配给 es 的内存最好不要超过 32G ，因为如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。如果大于32G 每个指针占用 8字节，并且会占用更多的内存带宽，降低了cpu性能。</p>
<p>还有一点， 要关闭 <code>swap</code> 内存交换空间，禁用swapping。频繁的swapping 对服务器来说是致命的。<br>总结：给es JVM栈的内存最好不要超过32G，留给Lucene的内存越大越好，Lucene把所有的segment都缓存起来，会加快全文检索。</p>
<h2 id="关闭交换区"><a href="#关闭交换区" class="headerlink" title="关闭交换区"></a>关闭交换区</h2><p>这应该显而易见了，但仍然需要明确的写出来：把内存换成硬盘将毁掉服务器的性能，想象一下：涉及内存的操作是需要快速执行的。如果介质从内存变为了硬盘，一个10微秒的操作变成需要10毫秒。而且这种延迟发生在所有本该只花费10微秒的操作上，就不难理解为什么交换区对于性能来说是噩梦。</p>
<p>最好的选择是禁用掉操作系统的交换区。可以用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure>
<p>来禁用，你可能还需要编辑 <code>/etc/fstab</code> 文件。细节可以参考你的操作系统文档。</p>
<p>如果实际环境不允许禁用掉 <code>swap</code>，你可以尝试降低 <code>swappiness</code>。此值控制操作系统使用交换区的积极性。这可以防止在正常情况下使用交换区，但仍允许操作系统在紧急情况下将内存里的东西放到交换区。</p>
<p>对于大多数Linux系统来说，这可以用 <code>sysctl</code> 值来配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 将此值配置为1会比0好，在kernal内核的某些版本中，0可能会引起OOM异常。</span></span><br></pre></td></tr></table></figure>
<p>最后，如果两种方法都不可用，你应该在ElasticSearch的配置中启用 <code>mlockall.file</code>。这允许JVM锁定其使用的内存，而避免被放入操作系统交换区。</p>
<p>在elasticsearch.yml中，做如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.mlockall: true</span><br></pre></td></tr></table></figure>

<h2 id="查看node节点数据"><a href="#查看node节点数据" class="headerlink" title="查看node节点数据"></a>查看node节点数据</h2><p><code>GET /_cat/nodes?v&amp;h=id,ip,port,v,master,name,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p>
<p><code>GET /_cat/nodes?v&amp;h=id,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size</code></p>
<p><code>GET /_cat/nodes?v&amp;h=id,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-CAP理论</title>
    <url>/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。<br>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p>
<img src="https://oscimg.oschina.net/oscnet/up-1d3052b25a13428857fde791eaa01c02e9b.png">

<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值，即写操作之后的读操作，必须返回该值。（分为弱一致性、强一致性和最终一致性）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<h2 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h2><blockquote>
<p>CA without P</p>
</blockquote>
<p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
<blockquote>
<p>CP without A</p>
</blockquote>
<p>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要<font color=red>牺牲用户的体验</font>，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<blockquote>
<p>AP wihtout C</p>
</blockquote>
<p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h2 id="解决方案——BASE"><a href="#解决方案——BASE" class="headerlink" title="解决方案——BASE"></a>解决方案——BASE</h2><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果。</p>
<p>核心思想：即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
<blockquote>
<p>基本可用Basically Available</p>
</blockquote>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<p>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<blockquote>
<p>软状态Soft state</p>
</blockquote>
<p>软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<blockquote>
<p>最终一致性Eventually consistent</p>
</blockquote>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/lixinkuan328/article/details/95535691">https://blog.csdn.net/lixinkuan328/article/details/95535691</a></p>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>theory</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-一致性哈希算法</title>
    <url>/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。</p>
<h2 id="哈希指标"><a href="#哈希指标" class="headerlink" title="哈希指标"></a>哈希指标</h2><blockquote>
<p>评估一个哈希算法的优劣，有如下指标，而一致性哈希全部满足：</p>
</blockquote>
<ul>
<li>均衡性(Balance)：将关键字的哈希地址均匀地分布在地址空间中，使地址空间得到充分利用，这是设计哈希的一个基本特性。</li>
<li>单调性(Monotonicity): 单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。</li>
<li>分散性(Spread): 哈希经常用在分布式环境中，终端用户通过哈希函数将自己的内容存到不同的缓冲区。此时，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>
<li>负载(Load): 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote>
<p>将节点通过hash映射到hash环上，理想的情况是多个节点直接分布均匀</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-ac8ab4cd06d150b14ddfe58e2cdcbdb7dff.png" >


<p>当我们的对象通过hash算法分配在hash环上的时候，它是固定分配到一个节点的空间上的，当我们在BC之间插入一个节点时，仅仅会影响到BC这一段空间上的数据，而不是整个环上的数据都要跟着变化；</p>
<blockquote>
<p>现实情况下，节点之间可能分配不均匀</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-3a12f9634fed9d5f67debfcdd7fe22f1fae.png">

<p>这和传统的hash取模一样，同样会数据倾斜的问题！</p>
<blockquote>
<p>虚拟节点</p>
</blockquote>
<p>这个时候虚拟节点就此诞生，下面让我们来看一下虚拟节点在一致性Hash中的作用。当我们在Hash环上新增若干个点，那么每个点之间的距离就会接近相等。按照这个思路我们可以新增若干个片/表，但是成本有限，我们通过复制多个A、B、C的副本({A1-An},{B1-Bn},{C1-Cn})一起参与计算，按照顺时针的方向进行数据分布，按照下图示意:<br><img src="https://oscimg.oschina.net/oscnet/up-88c2aef2ec993ede090695ffe78f53f999a.png"></p>
<p>此时A=[A,C1)&amp;[A1,C2)&amp;[A2,B4)&amp;[A3,A4)&amp;[A4,B1)；B=[B,A1)&amp;[B2,C)&amp;[B3,C3)&amp;[B4,C4)&amp;[B1,A)；C=[C1,B)&amp;[C2,B2)&amp;[C,B3)&amp;[B3,C3)&amp;[C4,A3)；由图可以看出分布点越密集，平衡性约好。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>一致性哈希算法有多种具体的实现，包括 Chord 算法，KAD 算法等，都比较复杂。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 、<a href="https://blog.csdn.net/kefengwang/article/details/81628977">一致性哈希算法的原理与实现</a><br>2、<a href="https://www.cnblogs.com/xialihua1023/p/10304932.html">浅谈一致性Hash原理及应用</a></p>
]]></content>
      <categories>
        <category>Distributed Dir</category>
        <category>theory</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分析与分析器</title>
    <url>/wiki/%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>包含下面的过程：</p>
<p>首先，将一块文本分成适合于倒排索引的独立的 <code>词条</code> ，之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall<br>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：</p>
<h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p>
<h3 id="Token-过滤器"><a href="#Token-过滤器" class="headerlink" title="Token 过滤器"></a>Token 过滤器</h3><p>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。<br>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p>
<h2 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h2><p>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<br><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p>
<h3 id="标准分析器"><a href="#标准分析器" class="headerlink" title="标准分析器"></a>标准分析器</h3><p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</code></p>
<h3 id="简单分析器"><a href="#简单分析器" class="headerlink" title="简单分析器"></a>简单分析器</h3><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set, trans</code></p>
<h3 id="空格分析器"><a href="#空格分析器" class="headerlink" title="空格分析器"></a>空格分析器</h3><p>空格分析器在空格的地方划分文本。它会产生<br><code>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</code></p>
<h3 id="语言分析器"><a href="#语言分析器" class="headerlink" title="语言分析器"></a>语言分析器</h3><p>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p>
<h3 id="英语-分词器会产生下面的词条："><a href="#英语-分词器会产生下面的词条：" class="headerlink" title="英语 分词器会产生下面的词条："></a>英语 分词器会产生下面的词条：</h3><p><code>set, shape, semi, transpar, call, set_tran, 5</code><br>注意看 <code>transparent、</code> <code>calling</code> 和 <code>set_trans</code> 已经变为词根格式。</p>
<h2 id="什么时候使用分析器"><a href="#什么时候使用分析器" class="headerlink" title="什么时候使用分析器"></a>什么时候使用分析器</h2><p>当我们 <code>索引</code> 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p>
<p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p>
<p>当你查询一个 <code>全文</code> 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。<br>当你查询一个 <code>精确值</code> 域时，不会分析查询字符串，而是搜索你指定的精确值。</p>
<h2 id="测试分析器"><a href="#测试分析器" class="headerlink" title="测试分析器"></a>测试分析器</h2><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 <code>analyze API</code> 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Text to analyze&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果中每个元素代表一个单独的词条：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;text&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;to&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;analyze&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>token</code> 是实际存储到索引中的词条。 <code>position</code> 指明词条在原始文本中出现的位置。 <code>start_offset</code> 和 <code>end_offset</code> 指明字符在原始字符串中的位置。</p>
<p>每个分析器的 <code>type</code> 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于​keep_types token 过滤器​。</p>
<p>analyze API 是一个有用的工具，它有助于我们理解Elasticsearch索引内部发生了什么，随着深入，我们会进一步讨论它。</p>
<h2 id="指定分析器"><a href="#指定分析器" class="headerlink" title="指定分析器"></a>指定分析器</h2><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文 <code>字符串</code> 域，使用 <code>标准</code> 分析器对它进行分析。</p>
<p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域—​不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。</p>
<p>要做到这一点，我们必须手动指定这些域的映射。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>启动ELK脚本命令</title>
    <url>/wiki/%E5%90%AF%E5%8A%A8ELK%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="esuser-授权"><a href="#esuser-授权" class="headerlink" title="esuser 授权"></a>esuser 授权</h2><p><code>chown -R esuser /usr/local/elasticsearch/*</code></p>
<h2 id="elastcisearch-启动脚本"><a href="#elastcisearch-启动脚本" class="headerlink" title="elastcisearch 启动脚本"></a>elastcisearch 启动脚本</h2><p><code>nohup ./elasticsearch-7.10.0/bin/elasticsearch &gt;&gt; ./elasticsearch-7.10.0/nohup.out 2&gt;&amp;1 &amp;</code></p>
<h2 id="kibana-启动脚本"><a href="#kibana-启动脚本" class="headerlink" title="kibana 启动脚本"></a>kibana 启动脚本</h2><p><code>nohup ./bin/kibana &gt;&gt; ./nohup.out 2&gt;&amp;1 &amp;</code></p>
<h2 id="logstash-启动脚本"><a href="#logstash-启动脚本" class="headerlink" title="logstash 启动脚本"></a>logstash 启动脚本</h2><p><code>nohup /usr/local/logstash/logstash-7.10.0/bin/logstash -f /usr/local/logstash/logstash-7.10.0/config/redtom-logstash.conf</code></p>
<p><code>nohup /usr/local/logstash/logstash-7.10.0/bin/logstash -f /usr/local/logstash/logstash-7.10.0/config/redtom-logstash.conf &gt;&gt; /usr/local/logstash/logstash-7.10.0/nohup.out 2&gt;&amp;1 &amp;</code></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Administration and Deployment</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>基础面试题目</title>
    <url>/wiki/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-String不可变"><a href="#1-String不可变" class="headerlink" title="1.String不可变"></a>1.String不可变</h2><p>String 对象的不可变性</p>
<p>了解了 String 对象的实现后，你有没有发现在实现代码中 String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。</p>
<p>我们知道类被 final 修饰代表该类不可继承，而 char[] 被 final+private 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。</p>
<p>Java 这样做的好处在哪里呢？</p>
<p>第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被恶意修改。</p>
<p>第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。</p>
<p>第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。</p>
<p>当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p>
<h3 id="2-String-和-StringBuilder、StringBuffer-的区别？"><a href="#2-String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="2.String 和 StringBuilder、StringBuffer 的区别？"></a>2.String 和 StringBuilder、StringBuffer 的区别？</h3><p><a href="https://www.cnblogs.com/weibanggang/p/9455926.html">https://www.cnblogs.com/weibanggang/p/9455926.html</a></p>
<h2 id="3-描述一下-JVM-加载-class-文件的原理机制？"><a href="#3-描述一下-JVM-加载-class-文件的原理机制？" class="headerlink" title="3.描述一下 JVM 加载 class 文件的原理机制？"></a>3.描述一下 JVM 加载 class 文件的原理机制？</h2><p><a href="https://www.cnblogs.com/williamjie/p/11167920.html">https://www.cnblogs.com/williamjie/p/11167920.html</a></p>
<h2 id="4-char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#4-char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="4.char 型变量中能不能存贮一个中文汉字，为什么？"></a>4.char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>正确答案：</p>
<p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，</p>
<p>所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，</p>
<p>那么，这个char型变量中就不能存储这个特殊汉字。</p>
<p>补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节</p>
<h2 id="5-抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#5-抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="5.抽象类（abstract class）和接口（interface）有什么异同？"></a>5.抽象类（abstract class）和接口（interface）有什么异同？</h2><p><a href="https://blog.csdn.net/aptentity/article/details/68942916">https://blog.csdn.net/aptentity/article/details/68942916</a></p>
<h2 id="6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p><a href="https://blog.csdn.net/machinecat0898/article/details/80071242">https://blog.csdn.net/machinecat0898/article/details/80071242</a></p>
<h2 id="7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？"><a href="#7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？" class="headerlink" title="7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？"></a>7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？</h2><p> 答：都不能。<br>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。<br>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。<br>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 </p>
<h2 id="8-如何实现对象克隆"><a href="#8-如何实现对象克隆" class="headerlink" title="8.如何实现对象克隆"></a>8.如何实现对象克隆</h2><p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html">https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html</a></p>
<h2 id="9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"><a href="#9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制" class="headerlink" title="9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"></a>9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</h2><p><a href="https://www.cnblogs.com/aademeng/articles/11084885.html">https://www.cnblogs.com/aademeng/articles/11084885.html</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
<p>静态内部类：它是用static修饰的，在访问限制上它只能访问外部类中的static所修饰的成员变量或者是方法<br>成员内部类：成员内部类是最普通的内部类，它可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br>【注意】当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br>局部内部类：局部内部类是定义在外围类的方法中的，在访问的时候它可以直接访问外围类的所有成员！但是不能随便访问局部变量，除非这个局部变量被final修饰。<br>匿名内部类：</p>
<h2 id="10-Java-中的-final-关键字有哪些用法？"><a href="#10-Java-中的-final-关键字有哪些用法？" class="headerlink" title="10.Java 中的 final 关键字有哪些用法？"></a>10.Java 中的 final 关键字有哪些用法？</h2><p><a href="https://www.cnblogs.com/dotgua/p/6357951.html">https://www.cnblogs.com/dotgua/p/6357951.html</a><br>多线程下的final语义 👇<br><a href="https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B">https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B</a></p>
<ul>
<li>修饰变量<br>基本类型的变量，值是不可以变化的<br>引用类型的变量，引用是不可以变化的，但是可以修改引用的值<br>方法参数： 保证这个变量在这个方法中的值不会发生变化</li>
<li>修饰方法<br>它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它</li>
<li>修饰类<br>用final修饰的类是无法被继承的</li>
</ul>
<h2 id="11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?"></a>11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep()方法是Thread类</p>
<pre><code>sleep是Thread的静态native方法,可随时调用,会使当前线程休眠,并释放CPU资源,但不会释放对象锁;
</code></pre>
<p>wait()方法是Object类</p>
<pre><code>wait()方法是Object的native方法,只能在同步方法或同步代码块中使用,调用会进入休眠状态,并释放CPU资源与对象锁,需要我们调用notify/notifyAll方法唤醒指定或全部的休眠线程,再次竞争CPU资源.
</code></pre>
<p>注意:<br>sleep(long millis)存在睡眠时间,不算特点<br>因为wait()方法存在重载wait(long timeout),即设置了等待超时时间<br>它们两个都需要再次抢夺CPU资源</p>
<h2 id="12-线程的-sleep-方法和-yield-方法有什么区别？"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别？"></a>12.线程的 sleep()方法和 yield()方法有什么区别？</h2><p>sleep()方法在给其他线程运行机会时不考虑线程的优先级。因此会给低优先级的线程运行的机会，而yield()方法只会给相同优先级或更高优先级的线程运行的机会。<br>线程执行sleep()方法后会转入阻塞状态，所以执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到就绪状态，所以执行yield()方法的线程有可能在进入到就绪状态后又立马被执行。</p>
<h2 id="13-线程的基本状态以及状态之间的关系"><a href="#13-线程的基本状态以及状态之间的关系" class="headerlink" title="13.线程的基本状态以及状态之间的关系"></a>13.线程的基本状态以及状态之间的关系</h2><img src='https://cdn.jsdelivr.net/gh/it-briefcode/it-briefcode-images/images/2020-10/15/15-58-29-0925f9fed78f11a87bbef280245e1e49-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E8%BD%AC%E6%8D%A2-6ff1d1.png' width=600 height=450>
https://blog.csdn.net/zhangdongnihao/article/details/104029972
https://juejin.cn/post/6885159254764814349


<h2 id="14-访问修饰符-public-private-protected-以及不写（默认）时的区别？"><a href="#14-访问修饰符-public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="14.访问修饰符 public,private,protected,以及不写（默认）时的区别？"></a>14.访问修饰符 public,private,protected,以及不写（默认）时的区别？</h2><img src="https://oscimg.oschina.net/oscnet/up-07ccdf4c85f874c49b19c6201cb826dc739.png" width=600 height=280 >

<h2 id="15-请说出与线程同步以及线程调度相关的方法。"><a href="#15-请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="15.请说出与线程同步以及线程调度相关的方法。"></a>15.请说出与线程同步以及线程调度相关的方法。</h2><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；<br>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；<br>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<blockquote>
<p>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</p>
</blockquote>
<h2 id="16-synchronized-关键字的用法？"><a href="#16-synchronized-关键字的用法？" class="headerlink" title="16.synchronized 关键字的用法？"></a>16.synchronized 关键字的用法？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncDemo.class)&#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Java-中如何实现序列化，有什么意义？"><a href="#17-Java-中如何实现序列化，有什么意义？" class="headerlink" title="17.Java 中如何实现序列化，有什么意义？"></a>17.Java 中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p>
<h2 id="18-阐述-JDBC-操作数据库的步骤"><a href="#18-阐述-JDBC-操作数据库的步骤" class="headerlink" title="18.阐述 JDBC 操作数据库的步骤"></a>18.阐述 JDBC 操作数据库的步骤</h2><p>下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。<br>（1） 加载驱动。<br><code>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);</code><br>（2） 创建连接。<br><code>Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;,&quot;scott&quot;, &quot;tiger&quot;);</code><br>（3） 创建语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">&quot;select * from emp where sal between ? and ?&quot;</span>);</span><br><span class="line">ps.setint(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">ps.setint(<span class="number">2</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>（4）执行语句。<br><code>ResultSet rs = ps.executeQuery();</code><br>（5）处理结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">	System.out.println(rs.getint(<span class="string">&quot;empno&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">	rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（6） 关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(con != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			con.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<h2 id="19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><a href="#19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？" class="headerlink" title="19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？"></a>19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？</h2><p>与 Statement 相比，<br>①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；<br>③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<blockquote>
<p>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
</blockquote>
<h2 id="20-在进行数据库编程时，连接池有什么作用？"><a href="#20-在进行数据库编程时，连接池有什么作用？" class="headerlink" title="20.在进行数据库编程时，连接池有什么作用？"></a>20.在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），<code>为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销</code>，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。</p>
<blockquote>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
</blockquote>
<h2 id="21-什么是-DAO-模式"><a href="#21-什么是-DAO-模式" class="headerlink" title="21.什么是 DAO 模式?"></a>21.什么是 DAO 模式?</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。<br>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 DataAccessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h2 id="22-Java-中是如何支持正则表达式操作的？"><a href="#22-Java-中是如何支持正则表达式操作的？" class="headerlink" title="22.Java 中是如何支持正则表达式操作的？"></a>22.Java 中是如何支持正则表达式操作的？</h2><p>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作。面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;北京市(朝阳区)(西城区)(海淀区)&quot;</span>;</span><br><span class="line">		Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\()&quot;</span>);</span><br><span class="line">		Matcher m = p.matcher(str);</span><br><span class="line">		<span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BIO实现简易tomcat</title>
    <url>/wiki/%E5%9F%BA%E4%BA%8EBIO%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/</url>
    <content><![CDATA[<h1 id="基于传统的BIO手写一个简易Tomcat"><a href="#基于传统的BIO手写一个简易Tomcat" class="headerlink" title="基于传统的BIO手写一个简易Tomcat"></a>基于传统的BIO手写一个简易Tomcat</h1><p>本文主要基于传统的BIO来实现一个简单的Http请求处理过程；<br>1、Servlet请求无非就是doGet/doPost，所以我们定义抽象Servlet记忆GET/POST方法；<br>2、基于Socket和ServerSocket实现CS通信；<br>3、模拟Spring加载配置文件，注册请求以及控制器；  </p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6fb1dfc1fbbb3ae4d616c0a9572b08b4ad.png">   </p>
<h2 id="GlRequest-封装一个请求"><a href="#GlRequest-封装一个请求" class="headerlink" title="GlRequest 封装一个请求"></a>GlRequest 封装一个请求</h2><blockquote>
<p>当然是一个很简单的请求，这里只处理请求的URL和请求方法；<br>获取请求，也就是输入流，解析数据Url和Method，并做相应的处理；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlRequest</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析http请求的具体内容；</span></span><br><span class="line">            String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ((len = is.read(buff)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                content = <span class="keyword">new</span> String(buff, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            String line = content.split(<span class="string">&quot;\\n&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            String [] arr = line.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.method = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.url = arr[<span class="number">1</span>].split(<span class="string">&quot;\\?&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GlResponse-定义返回值response"><a href="#GlResponse-定义返回值response" class="headerlink" title="GlResponse 定义返回值response"></a>GlResponse 定义返回值response</h2><blockquote>
<p>处理请求返回值，将业务处理的结果通过输出流输出；<br>输出大致分为两部分，第一是返回的数据，第二是返回数据的Header;  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlResponse</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream = os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;HTTP/1.1 200 OK\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;Content-Type: text/html;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">                .append(string);</span><br><span class="line">        outputStream.write(sb.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GlServlet-定义抽象servlet，定义GET方法和POST方法"><a href="#GlServlet-定义抽象servlet，定义GET方法和POST方法" class="headerlink" title="GlServlet 定义抽象servlet，定义GET方法和POST方法"></a>GlServlet 定义抽象servlet，定义GET方法和POST方法</h2><blockquote>
<p>定义抽象的Servlet和doGet方法和doPost方法，具体的业务去实现自己的方法和逻辑；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (GET.equals(request.getMethod())) &#123;</span><br><span class="line">               doGet(request, response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               doPost(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FirstServlet-具体的业务Servlet实现抽象Servlet的方法"><a href="#FirstServlet-具体的业务Servlet实现抽象Servlet的方法" class="headerlink" title="FirstServlet 具体的业务Servlet实现抽象Servlet的方法"></a>FirstServlet 具体的业务Servlet实现抽象Servlet的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This is first servlet from BIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondServlet-具体的业务Servlet实现抽象Servlet方法"><a href="#SecondServlet-具体的业务Servlet实现抽象Servlet方法" class="headerlink" title="SecondServlet 具体的业务Servlet实现抽象Servlet方法"></a>SecondServlet 具体的业务Servlet实现抽象Servlet方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This second request form BIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="web-bio-properties-配置文件"><a href="#web-bio-properties-配置文件" class="headerlink" title="web-bio.properties 配置文件"></a>web-bio.properties 配置文件</h2><blockquote>
<p>配置请求和处理器，Spring中是通过Controller下的@XXXMapping注解去扫描并加载到工厂的；  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servlet.one.className=com.ibli.netty.tomcat.bio.servlet.FirstServlet</span><br><span class="line">servlet.one.url=/firstServlet.<span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">servlet.two.className=com.ibli.netty.tomcat.bio.servlet.SecondServlet</span><br><span class="line">servlet.two.url=/secondServlet.<span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<h2 id="GlTomcat测试类"><a href="#GlTomcat测试类" class="headerlink" title="GlTomcat测试类"></a>GlTomcat测试类</h2><blockquote>
<p>启动服务端，在网页中访问本地8080端口，输入配置文件中定义的url进行测试：  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> Properties webXml = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GlServlet&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;String, GlServlet&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟项目main方法，启动加载配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 启动参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GlTomcat().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat的启动入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、加载web配置文件，解析配置</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、启动服务器socket，等待用户请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.PORT);</span><br><span class="line">            System.err.println(<span class="string">&quot;Gl tomcat started in port &quot;</span> + <span class="keyword">this</span>.PORT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                <span class="comment">// 3、获得请求信息，解析HTTP协议的内容</span></span><br><span class="line">                process(client);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String WEB_INF = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(WEB_INF + <span class="string">&quot;web-bio.properties&quot;</span>);</span><br><span class="line">            webXml.load(fis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Object k : webXml.keySet()) &#123;</span><br><span class="line">                String key = k.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&quot;.url&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//servlet.two.url</span></span><br><span class="line">                    String servletName = key.replaceAll(<span class="string">&quot;\\.url&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    String url = webXml.getProperty(key);</span><br><span class="line">                    <span class="comment">//servlet.two.className</span></span><br><span class="line">                    String className = webXml.getProperty(servletName + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">                    <span class="comment">//反射创建servlet实例</span></span><br><span class="line">                    <span class="comment">// load-on-startup &gt;=1 :web启动的时候初始化  0：用户请求的时候才启动</span></span><br><span class="line">                    GlServlet obj = (GlServlet) Class.forName(className).newInstance();</span><br><span class="line">                    <span class="comment">// 将url和servlet建立映射关系</span></span><br><span class="line">                    servletMapping.put(url, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析客户端请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//请求</span></span><br><span class="line">            is = client.getInputStream();</span><br><span class="line">            <span class="comment">//封装返回值</span></span><br><span class="line">            os = client.getOutputStream();</span><br><span class="line">            GlRequest request = <span class="keyword">new</span> GlRequest(is);</span><br><span class="line">            GlResponse response = <span class="keyword">new</span> GlResponse(os);</span><br><span class="line"></span><br><span class="line">            String url = request.getUrl();</span><br><span class="line">            <span class="keyword">if</span> (servletMapping.containsKey(url)) &#123;</span><br><span class="line">                servletMapping.get(url).service(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.write(<span class="string">&quot;404 Not found!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                os.flush();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印请求信息"><a href="#打印请求信息" class="headerlink" title="打印请求信息"></a>打印请求信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request content : GET /fitstServlet.<span class="keyword">do</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost:<span class="number">8080</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_14_5</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">88.0</span><span class="number">.4324</span><span class="number">.150</span> Safari/<span class="number">537.36</span> OPR/<span class="number">74.0</span><span class="number">.3911</span><span class="number">.160</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Sec-Fetch-Site: none</span></span><br><span class="line"><span class="comment">Sec-Fetch-Mode: navigate</span></span><br><span class="line"><span class="comment">Sec-Fetch-User: ?1</span></span><br><span class="line"><span class="comment">Sec-Fetch-Dest: document</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.9</span></span><br></pre></td></tr></table></figure>

<h2 id="客户端发送请求及结果展示"><a href="#客户端发送请求及结果展示" class="headerlink" title="客户端发送请求及结果展示"></a>客户端发送请求及结果展示</h2><blockquote>
<p>请求： <a href="http://localhost:8080/firstServlet.do">http://localhost:8080/firstServlet.do</a><br><img src="https://oscimg.oschina.net/oscnet/up-e4faf840776bb504c26ddd7266033651a09.png">  </p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>多桶排序</title>
    <url>/wiki/%E5%A4%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>多值桶（ terms 、 histogram 和 date_histogram ）动态生成很多桶。 Elasticsearch 是如何决定这些桶展示给用户的顺序呢？</p>
<p>默认的，桶会根据 doc_count 降序排列。这是一个好的默认行为，因为通常我们想要找到文档中与查询条件相关的最大值：售价、人口数量、频率。但有些时候我们希望能修改这个顺序，不同的桶有着不同的处理方式。</p>
<h2 id="内置排序"><a href="#内置排序" class="headerlink" title="内置排序"></a>内置排序</h2><p>这些排序模式是桶 固有的 能力：它们操作桶生成的数据 ，比如 doc_count 。 它们共享相同的语法，但是根据使用桶的不同会有些细微差别。</p>
<p>让我们做一个 terms 聚合但是按 doc_count 值的升序排序：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;_count&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

<p>用关键字 _count ，我们可以按 doc_count 值的升序排序。</p>
<p>我们为聚合引入了一个 order 对象， 它允许我们可以根据以下几个值中的一个值进行排序：</p>
<ul>
<li>_count<br>按文档数排序。对 terms 、 histogram 、 date_histogram 有效。</li>
<li>_term<br>按词项的字符串值的字母顺序排序。只在 terms 内使用。</li>
<li>_key<br>按每个桶的键值数值排序（理论上与 _term 类似）。 只在 histogram 和 date_histogram 内使用。</li>
</ul>
<h2 id="按度量排序"><a href="#按度量排序" class="headerlink" title="按度量排序"></a>按度量排序</h2><p>有时，我们会想基于度量计算的结果值进行排序。 在我们的汽车销售分析仪表盘中，我们可能想按照汽车颜色创建一个销售条状图表，但按照汽车平均售价的升序进行排序。</p>
<p>我们可以增加一个度量，再指定 order 参数引用这个度量即可：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;avg&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>计算每个桶的平均售价。</p>
</li>
<li><p>桶按照计算平均值的升序排序。</p>
</li>
</ul>
<p>我们可以采用这种方式用任何度量排序，只需简单的引用度量的名字。不过有些度量会输出多个值。 extended_stats 度量是一个很好的例子：它输出好几个度量值。</p>
<p>如果我们想使用多值度量进行排序， 我们只需以关心的度量为关键词使用点式路径：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 . 符号，根据感兴趣的度量进行排序。</li>
</ul>
<h2 id="深度度量排序"><a href="#深度度量排序" class="headerlink" title="深度度量排序"></a>深度度量排序</h2><p>在前面的示例中，度量是桶的直接子节点。平均售价是根据每个 term 来计算的。 在一定条件下，我们也有可能对 更深 的度量进行排序，比如孙子桶或从孙桶。</p>
<p>我们可以定义更深的路径，将度量用尖括号（ &gt; ）嵌套起来，像这样： my_bucket&gt;another_bucket&gt;metric 。</p>
<p>需要提醒的是嵌套路径上的每个桶都必须是 单值 的。 filter 桶生成 一个单值桶：所有与过滤条件匹配的文档都在桶中。 多值桶（如：terms ）动态生成许多桶，无法通过指定一个确定路径来识别。</p>
<p>目前，只有三个单值桶： filter 、 global 和 reverse_nested 。让我们快速用示例说明，创建一个汽车售价的直方图，但是按照红色和绿色（不包括蓝色）车各自的方差来排序：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;histogram&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;interval&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&gt;tats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;filter&quot;</span>: &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;color&quot;</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]&#125;&#125;, </span><br><span class="line">                    <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;stats&quot;</span>: &#123;<span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>&#125;&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>按照嵌套度量的方差对桶的直方图进行排序。</p>
</li>
<li><p>因为我们使用单值过滤器 filter ，我们可以使用嵌套排序。</p>
</li>
<li><p>按照生成的度量对统计结果进行排序。</p>
</li>
</ul>
<p>本例中，可以看到我们如何访问一个嵌套的度量。 stats 度量是 red_green_cars 聚合的子节点，而 red_green_cars 又是 colors 聚合的子节点。 为了根据这个度量排序，我们定义了路径 red_green_cars&gt;tats.variance 。我们可以这么做，因为 filter 桶是个单值桶。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>多索引多类型搜索</title>
    <url>/wiki/%E5%A4%9A%E7%B4%A2%E5%BC%95%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。Elasticsearch 转发搜索请求到每一个主分片或者副本分片，汇集查询出的前10个结果，并且返回给我们。</p>
<p>然而，经常的情况下，你想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
<p><code>/_search</code><br>在所有的索引中搜索所有的类型<br><code>/gb/_search</code><br>在 gb 索引中搜索所有的类型<br><code>/gb,us/_search</code><br>在 gb 和 us 索引中搜索所有的文档<br><code>/g*,u*/_search</code><br>在任何以 g 或者 u 开头的索引中搜索所有的类型<br><code>/gb/user/_search</code><br>在 gb 索引中搜索 user 类型<br><code>/gb,us/user,tweet/_search</code><br>在 gb 和 us 索引中搜索 user 和 tweet 类型<br><code>/_all/user,tweet/_search</code><br>在所有的索引中搜索 user 和 tweet 类型<br>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的—​只是会涉及到更多的分片。  </p>
<p>注意 ⚠️<br>搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串排序与多字段</title>
    <url>/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p>
<p>你可以使用 min 和 max 排序模式（默认是 min ），但是这会导致排序以 art 或是 old ，任何一个都不是所希望的。</p>
<p>为了以字符串字段进行排序，这个字段应仅包含一项： 整个 not_analyzed 字符串。 但是我们仍需要 analyzed 字段，这样才能以全文进行查询</p>
<p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： analyzed 用于搜索， not_analyzed 用于排序</p>
<p>但是保存相同的字符串两次在 _source 字段是浪费空间的。 我们真正想要做的是传递一个 单字段 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 fields 参数</p>
<p>该参数允许你转化一个简单的映射如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为一个多字段映射如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;raw&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>tweet 主字段与之前的一样: 是一个 analyzed 全文字段。</p>
</li>
<li><p>新的 tweet.raw 子字段是 not_analyzed.</p>
</li>
</ul>
<p>现在，至少只要我们重新索引了我们的数据，使用 tweet 字段用于搜索，<code>tweet.raw</code> 字段用于排序：<br><code>curl -X GET &quot;localhost:9200/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tweet&quot;</span>: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="string">&quot;tweet.raw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌套桶</title>
    <url>/wiki/%E5%B5%8C%E5%A5%97%E6%A1%B6/</url>
    <content><![CDATA[<h2 id="两层嵌套"><a href="#两层嵌套" class="headerlink" title="两层嵌套"></a>两层嵌套</h2><p>在我们使用不同的嵌套方案时，聚合的力量才能真正得以显现。 在前例中，我们已经看到如何将一个度量嵌入桶中，它的功能已经十分强大了。</p>
<p>但真正令人激动的分析来自于将桶嵌套进 另外一个桶 所能得到的结果。 现在，我们想知道每个颜色的汽车制造商的分布：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; </span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;make&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意前例中的 avg_price 度量仍然保持原位。</p>
</li>
<li><p>另一个聚合 make 被加入到了 color 颜色桶中。</p>
</li>
<li><p>这个聚合是 terms 桶，它会为每个汽车制造商生成唯一的桶。</p>
</li>
</ul>
<p>这里发生了一些有趣的事。 首先，我们可能会观察到之前例子中的 <code>avg_price</code> 度量完全没有变化，还在原来的位置。 一个聚合的每个 层级 都可以有多个度量或桶， <code>avg_price</code> 度量告诉我们每种颜色汽车的平均价格。它与其他的桶和度量相互独立。</p>
<p>这对我们的应用非常重要，因为这里面有很多相互关联，但又完全不同的度量需要收集。聚合使我们能够用一次数据请求获得所有的这些信息。</p>
<p>另外一件值得注意的重要事情是我们新增的这个 make 聚合，它是一个 <code>terms</code> 桶（嵌套在 colors 、 terms 桶内）。这意味着它会为数据集中的每个唯一组合生成（ color 、 make ）元组。</p>
<p>让我们看看返回的响应（为了简单我们只显示部分结果）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>, </span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>正如期望的那样，新的聚合嵌入在每个颜色桶中。</p>
</li>
<li><p>现在我们看见按不同制造商分解的每种颜色下车辆信息。</p>
</li>
<li><p>最终，我们看到前例中的 avg_price 度量仍然维持不变。</p>
</li>
</ul>
<h2 id="三层嵌套"><a href="#三层嵌套" class="headerlink" title="三层嵌套"></a>三层嵌套</h2><p>让我们回到话题的原点，在进入新话题之前，对我们的示例做最后一个修改， 为每个汽车生成商计算最低和最高的价格：<br><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; <span class="attr">&quot;avg&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;make&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">                    <span class="attr">&quot;min_price&quot;</span> : &#123; <span class="attr">&quot;min&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125;, </span><br><span class="line">                    <span class="attr">&quot;max_price&quot;</span> : &#123; <span class="attr">&quot;max&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们需要增加另外一个嵌套的 aggs 层级。</p>
</li>
<li><p>然后包括 min 最小度量。</p>
</li>
<li><p>以及 max 最大度量。</p>
</li>
</ul>
<p>得到以下输出（只显示部分结果）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">10000</span> </span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">20000</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>有了这两个桶，我们可以对查询的结果进行扩展并得到以下信息：  </p>
<p>有四辆红色车。<br>红色车的平均售价是 $32，500 美元。<br>其中三辆红色车是 Honda 本田制造，一辆是 BMW 宝马制造。<br>最便宜的红色本田售价为 $10，000 美元。<br>最贵的红色本田售价为 $20，000 美元。  </p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>拥塞避免</title>
    <url>/wiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/</url>
    <content><![CDATA[<h1 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h1><p>拥塞控制的慢启动是以指数方式快速的通过试探来扩大拥塞窗口的，但是一旦发生网络丢包，则肯定是很多报文段都会都是，因为窗口时称被增长的；为了解决这种问题，需要引入– 拥塞避免</p>
<h2 id="什么是拥塞避免"><a href="#什么是拥塞避免" class="headerlink" title="什么是拥塞避免"></a>什么是拥塞避免</h2><p>拥塞避免为了解决慢启动下，当拥塞窗口超出网络带宽时发生的大量丢包问题，它提出一个「慢启动阈值」的概念，当拥塞窗口到达这个阈值之后，不在以指数方式增长，而选择涨幅比较缓慢的「线性增长」，计算方式：</p>
<blockquote>
<p>cwnd += SMSS*SMSS/cwnd</p>
</blockquote>
<img src="https://oscimg.oschina.net/oscnet/up-e56d8072b2a74fa9b18ff6ca2d605405d2f.png" width=760 height=360>

<p>当拥塞窗口在线性增长时发生丢包，将慢启动阈值设置为当前窗口的一半，慢启动窗口恢复初始窗口（init wnd）；</p>
<blockquote>
<p>拥塞避免和慢启动是结合使用的，当发生网络丢包是，拥塞控制采用快速重传和快速启动来解决丢包问题！</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>快速重传/快速恢复</title>
    <url>/wiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h1><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><blockquote>
<p>d 为何会接收到以个失序数据段？ </p>
</blockquote>
<ul>
<li>若报文丢失，将会产生连续的失序ACK段 </li>
<li>若网络路径与设备导致数据段失序，将会产生少量的失序ACK段</li>
<li>若报文重复，将会产生少量的失序ACK段</li>
</ul>
<img src="https://oscimg.oschina.net/oscnet/up-eaadaebd682089bdd3919de4f0d232749dc.png" width=450 height= 520>

<ul>
<li>当发送端发送pkt0是正常的，由于滑动窗口为满，发送方可以继续发送pkt1，pkt2；</li>
<li>加入pkt1发生了丢包，虽然pkt2接收端接收成功了，但是没有pkt1的数据段，接收端还是发送ACK1的确认报文；</li>
<li>在没有「快速重传」的情况下，发送端需要等到RTO之后，才可以重新发送pkt1</li>
<li>重传成功之后，接收端其实收到了pkt2之前的所有数据段，所以发送ACK3的确认报文<blockquote>
<p>这种需要等待RTO才可以重传的方式效率是比较低的，因此需要快速重传来进行优化；</p>
</blockquote>
</li>
</ul>
<h2 id="快速重传和累积确认"><a href="#快速重传和累积确认" class="headerlink" title="快速重传和累积确认"></a>快速重传和累积确认</h2><img src="https://oscimg.oschina.net/oscnet/up-9da669c35316aafb318674d3364ea07d72d.png" width=450 height=520>

<p>当发送方连续发送pkt3，pkt4，pkt5，pkt6四个数据端，但是pkt5在网络中丢包了，那后面发送的pkt6，pkt7，pkt8的确认报文都返回ACK5，希望发送方吃昂传pkt5的数据段；这个时候，发送方收到连续3个相同的确认报文，便立即重新发送pkt5的数据段；</p>
<blockquote>
<p>接收方:</p>
</blockquote>
<ul>
<li>当接收到一个失序数据段时，立刻发送它所期待的缺口 ACK 序列号</li>
<li>当接收到填充失序缺口的数据段时，立刻发 送它所期待的下一个 ACK 序列号</li>
</ul>
<blockquote>
<p>发送方</p>
</blockquote>
<ul>
<li>当接收到3个重复的失序 ACK 段(4个相同的失序ACK段)时，不再等待重传定时器的触发，立刻基于快速重传机制重发报文段</li>
</ul>
<p>当pkt5重新发送并被接收端接收之后，接收端发送ACK9的确认报文，而不是再分别发送ACK6，ACK7，ACK8，这个称谓「 <strong><font color=red>累计确认</font></strong> 」。</p>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><blockquote>
<p>快速重传下一定要进入慢启动吗?</p>
</blockquote>
<p>接受端收到重复ACK，意味着网络仍在流动，而如果要重新进入慢启动，会导致网络突然减少数据流，拥塞窗口恢复初始窗口，所以，「<strong>在快速恢复下发生丢包的场景下</strong>」，应该使用快速恢复，简单的讲，就是将慢启动阈值设置成当前拥塞窗口的一半，而拥塞窗口也适当放低，而不是一下字恢复到初始窗口大小；</p>
<img src="https://oscimg.oschina.net/oscnet/up-4a7f76cb315a13d1d905f2bfb3a376db087.png" >

<p>快速恢复的流程如上图👆所示！</p>
<blockquote>
<p>快速恢复的具体操作：</p>
</blockquote>
<ul>
<li>将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上 3*MSS</li>
<li>每收到一个重复 ACK，cwnd 增加 1 个 MSS</li>
<li>当新数据 ACK 到达后，设置 cwnd 为 ssthresh</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-死锁</title>
    <url>/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/44125bb12ebf">死锁是什么？如何避免死锁？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统进程调度策略</title>
    <url>/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://blog.csdn.net/qq_35642036/article/details/82809812">操作系统中的进程调度策略有哪几种</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统-Overview</title>
    <url>/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/</url>
    <content><![CDATA[<h2 id="博客资料"><a href="#博客资料" class="headerlink" title="博客资料"></a>博客资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_40027052/article/details/78733365">深度解析京东个性化推荐系统演进史</a>  </li>
<li><a href="https://www.cnblogs.com/liuning8023/p/5522619.html">用 Mahout 和 Elasticsearch 实现推荐系统</a></li>
<li><a href="https://tech.meituan.com/2015/01/22/mt-recommend-practice.html">美团推荐算法实践</a></li>
<li><a href="https://blog.csdn.net/love284969214/article/details/82932064">58同城推荐系统设计与实现</a></li>
<li><a href="http://www.360doc.com/content/16/0307/22/31263000_540328712.shtml">微博推荐系统的架构演进之路</a></li>
<li><a href="https://blog.csdn.net/tzs_1041218129/article/details/103331908">Flink 在小红书推荐系统中的应用</a></li>
<li><a href="https://www.slidestalk.com/YunQi/XiaoHongShu_BigData_Platform_Evolution">小红书大数据在推荐系统中的应用</a></li>
<li><a href="https://www.slidestalk.com/u223/rs_in_kuaikan">快看漫画个性化推荐探索与实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45123018">数据仓库系列篇——唯品会大数据架构</a></li>
<li><a href="https://developer.aliyun.com/article/763941">推荐系统基本概念和架构</a></li>
<li><a href="https://bp.aliyun.com/detail/140">PAI平台搭建企业级个性化推荐系统 - Aliyun</a></li>
<li><a href="https://www.aliyun.com/product/bigdata/product/learn"></a></li>
<li><a href="https://toutiao.io/posts/35tpcy/preview">蘑菇街推荐工程实践</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Recommend System</category>
        <category>Overview</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>段合并</title>
    <url>/wiki/%E6%AE%B5%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://learnku.com/articles/41593">learnku.com</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Getting Started</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>统计去重数据 (近似度量)</title>
    <url>/wiki/%E7%BB%9F%E8%AE%A1%E5%8E%BB%E9%87%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="cardinality用法"><a href="#cardinality用法" class="headerlink" title="cardinality用法"></a>cardinality用法</h2><p>常用写法如下👇<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;months&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;sold&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;month&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p><code>cardinality</code> 度量是一个 <code>近似算法</code>。 它是基于 HyperLogLog++ （HLL）算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。</p>
<p>我们不需要理解技术细节， 但我们最好应该关注一下这个算法的 特性 ：</p>
<ul>
<li>可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）。</li>
<li>小的数据集精度是非常高的。</li>
<li>我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</li>
</ul>
<p>要配置精度，我们必须指定 <code>precision_threshold</code> 参数的值。 这个阈值定义了在何种基数水平下我们希望得到一个近乎精确的结果。参考以下示例：</p>
<p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;precision_threshold&quot;</span> : <span class="number">100</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ ⚠️<br><code>precision_threshold</code> 接受 0–40000 之间的数字，更大的值还是会被当作 40000 来处理 </p>
<p>示例会确保当字段唯一值在 100 以内时会得到非常准确的结果。尽管算法是无法保证这点的，但如果基数在阈值以下，几乎总是 100% 正确的。高于阈值的基数会开始节省内存而牺牲准确度，同时也会对度量结果带入误差。</p>
<p>对于指定的阈值，<code>HLL</code> 的数据结构会大概使用 <code>precision_threshold</code> * 8 字节的内存，所以就必须在牺牲内存和获得额外的准确度间做平衡。</p>
<p>在实际应用中， 100 的阈值可以在唯一值为百万的情况下仍然将误差维持 5% 以内</p>
<h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>如果想要获得唯一值的数目， 通常 需要查询整个数据集合（或几乎所有数据）。 所有基于所有数据的操作都必须迅速，原因是显然的。 <code>HyperLogLog</code> 的速度已经很快了，它只是简单的对数据做哈希以及一些位操作。</p>
<p>但如果速度对我们至关重要，可以做进一步的优化。 因为 HLL 只需要字段内容的哈希值，我们可以在索引时就预先计算好。 就能在查询时跳过哈希计算然后将哈希值从 <code>fielddata</code> 直接加载出来。</p>
<blockquote>
<p>预先计算哈希值只对内容很长或者基数很高的字段有用，计算这些字段的哈希值的消耗在查询时是无法忽略的。<br>  尽管数值字段的哈希计算是非常快速的，存储它们的原始值通常需要同样（或更少）的内存空间。这对低基数的字符串字段同样适用，Elasticsearch 的内部优化能够保证每个唯一值只计算一次哈希。<br>  基本上说，预先计算并不能保证所有的字段都更快，它只对那些具有高基数和/或者内容很长的字符串字段有作用。需要记住的是，预计算只是简单的将查询消耗的时间提前转移到索引时，并非没有任何代价，区别在于你可以选择在 什么时候 做这件事，要么在索引时，要么在查询时。</p>
</blockquote>
<p>创建索引时添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /cars/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;transactions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;color&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;hash&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;murmur3&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多值字段的类型是 <code>murmur3</code> ，这是一个哈希函数。</p>
</blockquote>
<p>现在当我们执行聚合时，我们使用 <code>color.hash</code> 字段而不是 color 字段：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color.hash&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在 <code>cardinality</code> 度量会读取 “<code>color.hash</code>“ 里的值（预先计算的哈希值），取代动态计算原始值的哈希。</p>
<p>单个文档节省的时间是非常少的，但是如果你聚合一亿数据，每个字段多花费 10 纳秒的时间，那么在每次查询时都会额外增加 1 秒，如果我们要在非常大量的数据里面使用 <code>cardinality</code> ，我们可以权衡使用预计算的意义，是否需要提前计算 hash，从而在查询时获得更好的性能，做一些性能测试来检验预计算哈希是否适用于你的应用场景。。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合 条形图</title>
    <url>/wiki/%E8%81%9A%E5%90%88-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合 高级概念</title>
    <url>/wiki/%E8%81%9A%E5%90%88-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h2><p><code>桶</code> 简单来说就是满足特定条件的文档的集合：</p>
<ul>
<li>一个雇员属于 男性 桶或者 女性 桶</li>
<li>奥尔巴尼属于 纽约 桶</li>
<li>日期2014-10-28属于 十月 桶<br>当聚合开始被执行，每个文档里面的值通过计算来决定符合哪个桶的条件。如果匹配到，文档将放入相应的桶并接着进行聚合操作。</li>
</ul>
<p>桶也可以被嵌套在其他桶里面，提供层次化的或者有条件的划分方案。例如，辛辛那提会被放入俄亥俄州这个桶，而 整个 俄亥俄州桶会被放入美国这个桶。</p>
<p>Elasticsearch 有很多种类型的桶，能让你通过很多种方式来划分文档（<code>时间</code>、<code>最受欢迎的词</code>、<code>年龄区间</code>、<code>地理位置</code> 等等）。其实根本上都是通过同样的原理进行操作：基于条件来划分文档。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>桶能让我们划分文档到有意义的集合，但是最终我们需要的是对这些桶内的文档进行一些指标的计算。分桶是一种达到目的的手段：它提供了一种给文档分组的方法来让我们可以计算感兴趣的指标。</p>
<p>大多数 <code>指标</code> 是简单的数学运算（例如最小值、平均值、最大值，还有汇总），这些是通过文档的值来计算。在实践中，指标能让你计算像平均薪资、最高出售价格、95%的查询延迟这样的数据。</p>
<h2 id="桶和指标的组合"><a href="#桶和指标的组合" class="headerlink" title="桶和指标的组合"></a>桶和指标的组合</h2><p><code>聚合</code> 是由桶和指标组成的。 聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。也有可能有一些桶嵌套在其他桶里面。例如，我们可以通过所属国家来划分文档（桶），然后计算每个国家的平均薪酬（指标）。</p>
<p>由于桶可以被嵌套，我们可以实现非常多并且非常复杂的聚合：</p>
<p>1.通过国家划分文档（桶）</p>
<p>2.然后通过性别划分每个国家（桶）</p>
<p>3.然后通过年龄区间划分每种性别（桶）</p>
<p>4.最后，为每个年龄区间计算平均薪酬（指标）</p>
<p>最后将告诉你每个 &lt;国家, 性别, 年龄&gt; 组合的平均薪酬。所有的这些都在一个请求内完成并且只遍历一次数据！</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤和聚合</title>
    <url>/wiki/%E8%BF%87%E6%BB%A4%E5%92%8C%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h2 id="过滤和聚合"><a href="#过滤和聚合" class="headerlink" title="过滤和聚合"></a>过滤和聚合</h2><p>聚合范围限定还有一个自然的扩展就是过滤。因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合上。</p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>如果我们想找到售价在 $10,000 美元之上的所有汽车同时也为这些车计算平均售价， 可以简单地使用一个 <code>constant_score</code> 查询和 <code>filter</code> 约束：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;gte&quot;</span>: <span class="number">10000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;single_avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从根本上讲，使用 <code>non-scoring</code> 查询和使用 <code>match</code> 查询没有任何区别。查询（包括了一个过滤器）返回一组文档的子集，聚合正是操作这些文档。使用 <code>filtering query</code> 会忽略评分，并有可能会缓存结果数据等等。</p>
<h2 id="过滤桶"><a href="#过滤桶" class="headerlink" title="过滤桶"></a>过滤桶</h2><p>但是如果我们只想对聚合结果过滤怎么办？ 假设我们正在为汽车经销商创建一个搜索页面， 我们希望显示用户搜索的结果，但是我们同时也想在页面上提供更丰富的信息，包括（与搜索匹配的）上个月度汽车的平均售价。</p>
<p>这里我们无法简单的做范围限定，因为有两个不同的条件。搜索结果必须是 ford ，但是聚合结果必须满足 ford AND sold &gt; now - 1M 。</p>
<p>为了解决这个问题，我们可以用一种特殊的桶，叫做 filter （注：过滤桶） 。 我们可以指定一个过滤桶，当文档满足过滤桶的条件时，我们将其加入到桶内。</p>
<p>查询结果如下：<br><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;recent_sales&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;filter&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;sold&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;now-1M&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;average_price&quot;</span>:&#123;</span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 过滤 桶在 查询 范围基础上应用过滤器。</p>
</li>
<li><p>avg 度量只会对 ford 和上个月售出的文档计算平均售价。</p>
</li>
</ul>
<p>因为 <code>filter</code> 桶和其他桶的操作方式一样，所以可以随意将其他桶和度量嵌入其中。所有嵌套的组件都会 “继承” 这个过滤，这使我们可以按需针对聚合过滤出选择部分。</p>
<h2 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器"></a>后过滤器</h2><p>目前为止，我们可以同时对搜索结果和聚合结果进行过滤（不计算得分的 filter 查询），以及针对聚合结果的一部分进行过滤（ filter 桶）。</p>
<p>我们可能会想，”只过滤搜索结果，不过滤聚合结果呢？” 答案是使用 post_filter 。</p>
<p>它是接收一个过滤器的顶层搜索请求元素。这个过滤器在查询 之后 执行（这正是该过滤器的名字的由来：它在查询之后 post 执行）。正因为它在查询之后执行，它对查询范围没有任何影响，所以对聚合也不会有任何影响。</p>
<p>我们可以利用这个行为对查询条件应用更多的过滤器，而不会影响其他的操作，就如 UI 上的各个分类面。让我们为汽车经销商设计另外一个搜索页面，这个页面允许用户搜索汽车同时可以根据颜色来过滤。颜色的选项是通过聚合获得的：</p>
<p><code>GET /cars/transactions/_search</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;post_filter&quot;</span>: &#123;    </span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;color&quot;</span> : <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;all_colors&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>post_filter 元素是 top-level 而且仅对命中结果进行过滤。</p>
</blockquote>
<p>查询 部分找到所有的 ford 汽车，然后用 terms 聚合创建一个颜色列表。因为聚合对查询范围进行操作，颜色列表与福特汽车有的颜色相对应。</p>
<p>最后， post_filter 会过滤搜索结果，只展示绿色 ford 汽车。这在查询执行过 后 发生，所以聚合不受影响。</p>
<p>这通常对 UI 的连贯一致性很重要，可以想象用户在界面商选择了一类颜色（比如：绿色），期望的是搜索结果已经被过滤了，而 不是 过滤界面上的选项。如果我们应用 filter 查询，界面会马上变成 只 显示 绿色 作为选项，这不是用户想要的！</p>
<p>⚠️ ⚠️ ⚠️</p>
<h2 id="性能考虑（Performance-consideration）"><a href="#性能考虑（Performance-consideration）" class="headerlink" title="性能考虑（Performance consideration）"></a>性能考虑（Performance consideration）</h2><p>当你需要对搜索结果和聚合结果做不同的过滤时，你才应该使用 post_filter ， 有时用户会在普通搜索使用 post_filter 。</p>
<p>不要这么做！ post_filter 的特性是在查询 之后 执行，任何过滤对性能带来的好处（比如缓存）都会完全失去。</p>
<p>在我们需要不同过滤时， post_filter 只与聚合一起使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择合适类型的过滤（如：搜索命中、聚合或两者兼有）通常和我们期望如何表现用户交互有关。选择合适的过滤器（或组合）取决于我们期望如何将结果呈现给用户。</p>
<ul>
<li>在 filter 过滤中的 non-scoring 查询，同时影响搜索结果和聚合结果。</li>
<li>filter 桶影响聚合。</li>
<li>post_filter 只影响搜索结果。</li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Aggregations</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象特征</title>
    <url>/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是保证软件部件具有优良的模块性的基础，封装的目标就是实现软件内部的“高内聚、低耦合”。防止程序相互依赖而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、也更为有力，面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，或者说是一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</p>
<p>将一个类中的成员变量全部定义为私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p>
<p>继承是子类自动共享父类资源（数据或者方法）的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在该编程时不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态性增强了软件的灵活性和扩展性，简单一句话理解多态的话就是，编译看左边，运行看右边</p>
<blockquote>
<p>编译看左边 – 是指 想要成功的保存,就要使用左边也就是 只能使用父类提供的功能!!如果父类中没有，那么会编译报错<br>运行看右边 – 是指 想要得到结果,就要看右边也就是 使用子类的方法体!!!</p>
</blockquote>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux System</category>
        <category>Process</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/wiki/Java%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。</p>
<h2 id="位操作基础"><a href="#位操作基础" class="headerlink" title="位操作基础"></a>位操作基础</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p>
<ul>
<li>在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。</li>
<li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li>
<li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，      5，9这些2^i+1的数字。写成int a = 1 « i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 « i) + 1;</li>
<li>另外位操作还有一些复合操作符，如&amp;=、|=、 ^=、«=、»=。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">        System.out.println(a &gt;&gt; <span class="number">2</span>); <span class="comment">// -4：-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4</span></span><br><span class="line">        System.out.println(b &gt;&gt; <span class="number">2</span>); <span class="comment">// 3：15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用位操作小技巧"><a href="#常用位操作小技巧" class="headerlink" title="常用位操作小技巧"></a>常用位操作小技巧</h2><p>下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。</p>
<h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。下面程序将输出0到100之间的所有偶数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">       System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>, d = <span class="number">2</span>;</span><br><span class="line">c ^= d;</span><br><span class="line">d ^= c;</span><br><span class="line">c ^= d;</span><br><span class="line">System.out.println(<span class="string">&quot;c=&quot;</span> + c);</span><br><span class="line">System.out.println(<span class="string">&quot;d=&quot;</span> + d);</span><br></pre></td></tr></table></figure>
<p>可以这样理解：</p>
<p>第一步 a=b 即a=(ab)；<br>第二步 b=a 即b=b(ab)，由于运算满足交换律，b(ab)=bba。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值；<br>第三步 a=b 就是a=ab，由于前面二步可知a=(ab)，b=a，所以a=ab即a=(ab)a。故a会被赋上b的值；</p>
<h3 id="变换符号"><a href="#变换符号" class="headerlink" title="变换符号"></a>变换符号</h3><p>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)</span><br></pre></td></tr></table></figure>
<p>同样可以这样的将11变成-11</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 1011(二进制) –取反-&gt; 0000 0100(二进制) –加1-&gt; 1111 0101(二进制)</span><br></pre></td></tr></table></figure>
<p>因此变换符号只需要取反后加1即可。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(~a + <span class="number">1</span>);</span><br><span class="line">System.out.println(~b + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="求绝对值"><a href="#求绝对值" class="headerlink" title="求绝对值"></a>求绝对值</h3><p>位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)</span><br></pre></td></tr></table></figure>
<p>来得到6。</p>
<p>因此先移位来取符号位，int i = a » 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println(i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println((a ^ j) - j);</span><br></pre></td></tr></table></figure>
<p>注意这种方法没用任何判断表达式，而且有些笔面试题就要求这样做，因此建议读者记住该方法（_讲解过后应该是比较好记了）。</p>
<h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><p>筛素数法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码（注2）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印100以内素数：</span></span><br><span class="line"><span class="comment">// （1）对每个素数，它的倍数必定不是素数；</span></span><br><span class="line"><span class="comment">// （2）有很多重复访问如flag[10]会在访问flag[2]和flag[5]时各访问一次；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max];</span><br><span class="line"><span class="keyword">int</span> [] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flags[m]) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags[n] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。</p>
<p>下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个数指定位上置1</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">e |=  <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure>
<p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断指定位上是0还是1</span></span><br><span class="line"><span class="keyword">if</span> ((e &amp; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) != <span class="number">0</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m += <span class="number">3</span>) &#123;</span><br><span class="line">    bits[m / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (m % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出整个bits</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((bits[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        System.out.print(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.print(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1001001001001001001001001001001001001001</span></span><br></pre></td></tr></table></figure>
<p>可以看出该数组每3个就置成了1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] flags2 = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((((flags2[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags2[n / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (n % <span class="number">32</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="位操作工具类"><a href="#位操作工具类" class="headerlink" title="位操作工具类"></a>位操作工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 位运算的常用方法封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运算数指定位置的值</span></span><br><span class="line"><span class="comment">     * 例如： 0000 1011 获取其第 0 位的值为 1, 第 2 位 的值为 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定位置的值(0 or 1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) ((source &gt;&gt; pos) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置的值置为指定值</span></span><br><span class="line"><span class="comment">     * 例: 0000 1011 需要更新为 0000 1111, 即第 2 位的值需要置为 1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     *            只能取值为 0, 或 1, 所有大于0的值作为1处理, 所有小于0的值作为0处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">setBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            source |= mask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source &amp;= (~mask);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置取反值</span></span><br><span class="line"><span class="comment">     * 例： 0000 1011 指定第 3 位取反, 结果为 0000 0011; 指定第2位取反, 结果为 0000 1111</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">reverseBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) (source ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查运算数的指定位置是否为1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示指定位置值为1, false 表示指定位置值为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        source = (<span class="keyword">byte</span>) (source &gt;&gt;&gt; pos);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (source &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入口函数做测试</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取十进制 11 (二级制 0000 1011) 为例子</span></span><br><span class="line">        <span class="keyword">byte</span> source = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取第2位值并输出, 结果应为 0000 1011</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, getBitValue(source, i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位置为1并输出 , 结果为 75 (0100 1011)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + setBitValue(source, <span class="number">6</span>, (<span class="keyword">byte</span>) <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位取反并输出, 结果应为75(0100 1011)</span></span><br><span class="line">        System.out.println(reverseBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 检查第6位是否为1，结果应为false</span></span><br><span class="line">        System.out.println(checkBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 输出为1的位, 结果应为 0 1 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBitValue(source, i)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitSet类"><a href="#BitSet类" class="headerlink" title="BitSet类"></a>BitSet类</h2><p>BitSet类：大小可动态改变, 取值为true或false的位集合。用于表示一组布尔标志。 此类实现了一个按需增长的位向量。位 set 的每个组件都有一个 boolean 值。用非负的整数将 BitSet 的位编入索引。可以对每个编入索引的位进行测试、设置或者清除。通过逻辑与、逻辑或和逻辑异或操作，可以使用一个 BitSet 修改另一个 BitSet 的内容。默认情况下，set 中所有位的初始值都是 false。</p>
<p>每个位 set 都有一个当前大小，也就是该位 set 当前所用空间的位数。注意，这个大小与位 set 的实现有关，所以它可能随实现的不同而更改。位 set 的长度与位 set 的逻辑长度有关，并且是与实现无关而定义的。</p>
<p>除非另行说明，否则将 null 参数传递给 BitSet 中的任何方法都将导致 NullPointerException。 在没有外部同步的情况下，多个线程操作一个 BitSet 是不安全的。</p>
<p>构造函数: BitSet() or BitSet(int nbits)，默认初始大小为64。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bitIndex, <span class="keyword">boolean</span> value)</span>: 将指定索引处的位设置为指定的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>: 将此 BitSet 中的所有位设置为 <span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cardinality</span><span class="params">()</span>: 返回此 BitSet 中设置为 <span class="keyword">true</span> 的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span>: 返回位置是pos的字位值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet other)</span>: other同该字位集进行与操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet other)</span>: other同该字位集进行或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet other)</span>: other同该字位集进行异或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span>: 清除此 BitSet 中所有的位,set – 用来屏蔽此 BitSet 的 BitSet</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 返回此 BitSet 表示位值时实际使用空间的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>: 返回此 BitSet 的“逻辑大小”：BitSet 中最高设置位的索引加 1。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>: 返回该集合Hash 码， 这个码同集合中的字位值有关。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span>: 如果other中的字位同集合中的字位相同，返回<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span>: 克隆此 BitSet，生成一个与之相等的新 BitSet。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>: 返回此位 set 的字符串表示形式。</span></span><br></pre></td></tr></table></figure>

<p>例1：标明一个字符串中用了哪些字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhichChars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BitSet used = <span class="keyword">new</span> BitSet();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhichChars</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            used.set(str.charAt(i));  <span class="comment">// set bit for char</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String desc = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> size = used.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.get(i))</span><br><span class="line">                desc += (<span class="keyword">char</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> desc + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        WhichChars w = <span class="keyword">new</span> WhichChars(<span class="string">&quot;How do you do&quot;</span>);</span><br><span class="line">        System.out.println(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestThree</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm = <span class="keyword">new</span> BitSet();</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">1</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        System.out.println(bm.get(<span class="number">65</span>));</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestFour</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm1 = <span class="keyword">new</span> BitSet(<span class="number">7</span>);</span><br><span class="line">        System.out.println(bm1.isEmpty() + <span class="string">&quot;--&quot;</span> + bm1.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm2 = <span class="keyword">new</span> BitSet(<span class="number">63</span>);</span><br><span class="line">        System.out.println(bm2.isEmpty() + <span class="string">&quot;--&quot;</span> + bm2.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm3 = <span class="keyword">new</span> BitSet(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm3.isEmpty() + <span class="string">&quot;--&quot;</span> + bm3.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm4 = <span class="keyword">new</span> BitSet(<span class="number">111</span>);</span><br><span class="line">        System.out.println(bm4.isEmpty() + <span class="string">&quot;--&quot;</span> + bm4.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位操作技巧"><a href="#位操作技巧" class="headerlink" title="位操作技巧"></a>位操作技巧</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获得int型最大值</span></span><br><span class="line">System.out.println((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);<span class="comment">// 2147483647， 由于优先级关系，括号不可省略</span></span><br><span class="line">System.out.println(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));<span class="comment">// 2147483647</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 获得int型最小值</span></span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 获得long类型的最大值</span></span><br><span class="line">System.out.println(((<span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">127</span>) - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 乘以2运算</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5. 除以2运算(负奇数的运算不可用)</span></span><br><span class="line">System.out.println(<span class="number">10</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 6. 乘以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 7. 除以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">16</span>&gt;&gt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8. 判断一个数的奇偶性</span></span><br><span class="line">System.out.println((<span class="number">10</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">System.out.println((<span class="number">9</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 9. 不用临时变量交换两个数（面试常考）</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 10. 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">System.out.println((n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>));</span><br><span class="line"><span class="comment">/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1</span></span><br><span class="line"><span class="comment">若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，</span></span><br><span class="line"><span class="comment">结果n变号并且绝对值减1，再减去-1就是绝对值 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 11. 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）</span></span><br><span class="line">System.out.println(b&amp;((a-b)&gt;&gt;<span class="number">31</span>) | a&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 12. 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）</span></span><br><span class="line">System.out.println(a&amp;((a-b)&gt;&gt;<span class="number">31</span>) | b&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 13. 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)</span></span><br><span class="line">System.out.println((a ^ b) &gt; <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 14. 计算2的n次方 n &gt; 0</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;(n-<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 15. 判断一个数n是不是2的幂</span></span><br><span class="line">System.out.println((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果是2的幂，n一定是100... n-1就是1111....</span></span><br><span class="line"><span class="comment">所以做与运算结果为0*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 16. 求两个整数的平均值</span></span><br><span class="line">System.out.println((a+b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17. 从低位到高位,取n的第m位</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line">System.out.println((n &gt;&gt; (m-<span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 18. 从低位到高位.将n的第m位置为1</span></span><br><span class="line">System.out.println(n | (<span class="number">1</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/*将1左移m-1位找到第m位，得到000...1...000</span></span><br><span class="line"><span class="comment">n在和这个数做或运算*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 19. 从低位到高位,将n的第m位置为0</span></span><br><span class="line">System.out.println(n &amp; ~(<span class="number">0</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/* 将1左移m-1位找到第m位，取反后变成111...0...1111</span></span><br><span class="line"><span class="comment">n再和这个数做与运算*/</span></span><br></pre></td></tr></table></figure>

<br>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/wiki/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><p>虽然Java线程池理论，以及构造线程池的各种参数，以及 Executors 提供的默认实现之前研读过，不过线上还没有发生过线程池误用引发的事故，所以有必要把这些参数再仔细琢磨一遍。</p>
<p>优先补充一些线程池的工作理论，有助于展开下面的内容。线程池顾名思义，就是由很多线程构成的池子，来一个任务，就从池子中取一个线程，处理这个任务。这个理解是我在第一次接触到这个概念时候的理解，虽然整体基本切入到核心，但是实际上会比这个复杂。例如线程池肯定不会无限扩大的，否则资源会耗尽；当线程数到达一个阶段，提交的任务会被暂时存储在一个队列中，如果队列内容可以不断扩大，极端下也会耗尽资源，那选择什么类型的队列，当队列满如何处理任务，都有涉及很多内容。线程池总体的工作过程如下图：</p>
<p>+++++++=</p>
<p>线程池内的线程数的大小相关的概念有两个，一个是核心池大小，还有最大池大小。如果当前的线程个数比核心池个数小，当任务到来，会优先创建一个新的线程并执行任务。当已经到达核心池大小，则把任务放入队列，为了资源不被耗尽，队列的最大容量可能也是有上限的，如果达到队列上限则考虑继续创建新线程执行任务，如果此刻线程的个数已经到达最大池上限，则考虑把任务丢弃。</p>
<p>在 java.util.concurrent 包中，提供了 ThreadPoolExecutor 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>既然有了刚刚对线程池工作原理对概述，这些参数就很容易理解了：</p>
<h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3><p> 核心池大小，既然如前原理部分所述。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用prestartAllCoreThreads方法。</p>
<h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3><p>池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</p>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>当线程数大于核心时，多于的空闲线程最多存活时间</p>
<h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime 参数的时间单位。</p>
<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现Runnable接口的任务。 别看这个参数位置很靠后，但是真的很重要，因为楼主的坑就因这个参数而起，这些细节有必要仔细了解清楚。</p>
<h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>执行程序创建新线程时使用的工厂。</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。</p>
<h2 id="可选择的阻塞队列BlockingQueue详解"><a href="#可选择的阻塞队列BlockingQueue详解" class="headerlink" title="可选择的阻塞队列BlockingQueue详解"></a>可选择的阻塞队列BlockingQueue详解</h2><p>在重复一下新任务进入时线程池的执行策略：<br>如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）<br>如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。<br>主要有3种类型的BlockingQueue：</p>
<h3 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h3><p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p>
<h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p>
<h3 id="同步移交队列"><a href="#同步移交队列" class="headerlink" title="同步移交队列"></a>同步移交队列</h3><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h2 id="可选择的饱和策略RejectedExecutionHandler详解"><a href="#可选择的饱和策略RejectedExecutionHandler详解" class="headerlink" title="可选择的饱和策略RejectedExecutionHandler详解"></a>可选择的饱和策略RejectedExecutionHandler详解</h2><p>JDK主要提供了4种饱和策略供选择。4种策略都做为静态内部类在ThreadPoolExcutor中进行实现。</p>
<h3 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h3><p>该策略是默认饱和策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p>
<h3 id="DiscardPolicy抛弃策略"><a href="#DiscardPolicy抛弃策略" class="headerlink" title="DiscardPolicy抛弃策略"></a>DiscardPolicy抛弃策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，什么都不做。</p>
<h3 id="DiscardOldestPolicy抛弃旧任务策略"><a href="#DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="DiscardOldestPolicy抛弃旧任务策略"></a>DiscardOldestPolicy抛弃旧任务策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h3 id="CallerRunsPolicy调用者运行"><a href="#CallerRunsPolicy调用者运行" class="headerlink" title="CallerRunsPolicy调用者运行"></a>CallerRunsPolicy调用者运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>
<h2 id="Java提供的四种常用线程池解析"><a href="#Java提供的四种常用线程池解析" class="headerlink" title="Java提供的四种常用线程池解析"></a>Java提供的四种常用线程池解析</h2><p>既然楼主踩坑就是使用了 JDK 的默认实现，那么再来看看这些默认实现到底干了什么，封装了哪些参数。简而言之 Executors 工厂方法Executors.newCachedThreadPool() 提供了无界线程池，可以进行自动线程回收；Executors.newFixedThreadPool(int) 提供了固定大小线程池，内部使用无界队列；Executors.newSingleThreadExecutor() 提供了单个后台线程。</p>
<p>详细介绍一下上述四种线程池。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在newCachedThreadPool中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为0，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 SynchronousQueue中进行等待，而SynchronousQueue的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲SynchronousQueue时其实已经给出了，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。因此即便SynchronousQueue一开始为空且大小为1，第一个任务也无法放入其中，因为没有线程在等待从SynchronousQueue中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看代码一目了然了，线程数量固定，使用无限大的队列。再次强调，楼主就是踩的这个无限大队列的坑。</p>
<p>4.3 newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在来看看ScheduledThreadPoolExecutor（）的构造函数</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledThreadPoolExecutor的父类即ThreadPoolExecutor，因此这里各参数含义和上面一样。值得关心的是DelayedWorkQueue这个阻塞对列，在上面没有介绍，它作为静态内部类就在ScheduledThreadPoolExecutor中进行了实现。简单的说，DelayedWorkQueue是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>首先new了一个线程数目为 1 的ScheduledThreadPoolExecutor，再把该对象传入DelegatedScheduledExecutorService中，看看DelegatedScheduledExecutorService的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor);</span><br><span class="line">            e = executor;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在看看它的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; </span><br><span class="line">           e = executor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是使用装饰模式增强了ScheduledExecutorService（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。</p>
<h2 id="为什么禁止使用-Executors-创建线程池"><a href="#为什么禁止使用-Executors-创建线程池" class="headerlink" title="为什么禁止使用 Executors 创建线程池?"></a>为什么禁止使用 Executors 创建线程池?</h2><img src='https://oscimg.oschina.net/oscnet/up-9d0200e116259f64c5485a1bbf0d4265c31.png'>

<h3 id="实验证明Executors缺陷"><a href="#实验证明Executors缺陷" class="headerlink" title="实验证明Executors缺陷"></a>实验证明Executors缺陷</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">               executor.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       <span class="comment">//do nothing &#125;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过指定JVM参数:-Xmx8m -Xms8m运行以上代码，会抛出OOM:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue. java:<span class="number">416</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor. java:<span class="number">1371</span>)</span><br><span class="line">at com.hollis.ExecutorsDemo.main(ExecutorsDemo.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码指出，ExecutorsDemo.java 的第 16 行，就是代码中的 execu- tor.execute(new SubThread());。</p>
<h3 id="Executors-为什么存在缺陷"><a href="#Executors-为什么存在缺陷" class="headerlink" title="Executors 为什么存在缺陷"></a>Executors 为什么存在缺陷</h3><p>通过上面的例子，我们知道了 Executors 创建的线程池存在 OOM 的风险，那 么到底是什么原因导致的呢?我们需要深入 Executors 的源码来分析一下。</p>
<p>其实，在上面的报错信息中，我们是可以看出蛛丝马迹的，在以上的代码中其实 已经说了，真正的导致 OOM 的其实是 LinkedBlockingQueue.offer 方法。</p>
<p>如果读者翻看代码的话，也可以发现，其实底层确实是通过 LinkedBlock- ingQueue 实现的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>如果读者对 Java 中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。</p>
<p>Java 中 的 BlockingQueue 主 要 有 两 种 实 现， 分 别 是 ArrayBlockingQ- ueue 和 LinkedBlockingQueue。</p>
<ul>
<li>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，必须设置容量。</li>
<li>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列，容量可以选择 进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为 Integer.MAX_ VALUE。  </li>
</ul>
<p>这里的问题就出在:不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置 LinkedBlockingQueue 的 容量的话，其默认容量将会是 Integer.MAX_VALUE。</p>
<p>而 newFixedThreadPool 中创建 LinkedBlockingQueue 时，并未指定容 量。此时，LinkedBlockingQueue 就是一个无边界队列，对于一个无边界队列 来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导 致内存溢出问题。</p>
<p>上面提到的问题主要体现在newFixedThreadPool 和 newSingleThreadExecutor 两个工厂方法上，并不是说 newCachedThreadPool 和 newScheduledThreadPool 这两个方法就安全了，这两种方式创建的最大线程数可能是 Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致 OOM。</p>
<h3 id="创建线程池的正确姿势"><a href="#创建线程池的正确姿势" class="headerlink" title="创建线程池的正确姿势"></a>创建线程池的正确姿势</h3><p>避免使用 Executors 创建线程池，主要是避免使用其中的默认实现，那么我们 可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的 同时，给 BlockQueue 指定容量就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util. concurrent.RejectedExecutionException，这是因为当前线程池使用的队列 是有边界队列，队列已经满了便无法继续处理新的请求。但是异常(Exception)总比 发生错误(Error)要好。</p>
<p>除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间 就应该想到开源类库，如 apache 和 guava 等。</p>
<p>作者推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">            ThreadPoolExecutor. AbortPolicy());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123; pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名 称，更加方便的出错的时候溯源。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-reindex</title>
    <url>/wiki/elasticsearch-reindex/</url>
    <content><![CDATA[<h2 id="reindex-常规使用"><a href="#reindex-常规使用" class="headerlink" title="reindex 常规使用"></a>reindex 常规使用</h2><blockquote>
<p>Reindex要求为源索引中的所有文档启用_source。<br>Reindex不尝试设置目标索引，它不复制源索引的设置，你应该在运行_reindex操作之前设置目标索引，包括设置映射、碎片计数、副本等。</p>
</blockquote>
<p>如下示例将把文档从twitter索引复制到new_twitter索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &quot;http://127.0.0.1:9200/_reindex?pretty&quot; -H &quot;Content-Type:application/json&quot; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;twitter&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;new_twitter&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>下面是返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">299</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;batches&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">-1.0</span>,</span><br><span class="line">  <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;failures&quot;</span> : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像_update_by_query一样，_reindex获取源索引的快照，但它的目标必须是不同的索引，因此不太可能发生版本冲突。可以像index API那样配置dest元素来控制乐观并发控制。仅仅省略version_type(如上所述)或将其设置为internal，都会导致Elasticsearch盲目地将文档转储到目标中，覆盖任何碰巧具有相同类型和id的文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;internal&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将version_type设置为external将导致Elasticsearch保存源文件的版本，创建任何缺失的文档，并更新目标索引中比源索引中版本更旧的文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;external&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置op_type=create将导致_reindex只在目标索引中创建缺失的文档。所有现有文件将导致版本冲突：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter3&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;op_type&quot;</span>: <span class="string">&quot;create&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>默认情况下，版本冲突将中止_reindex进程，“conflicts”请求体参数可用于指示_reindex处理关于版本冲突的下一个文档，需要注意的是，其他错误类型的处理不受“conflicts”参数的影响，当在请求体中设置“conflicts”:“proceed”时，_reindex进程将继续处理版本冲突，并返回所遇到的版本冲突计数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter3&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;op_type&quot;</span>: <span class="string">&quot;create&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>返回值如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">7</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;batches&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">-1.0</span>,</span><br><span class="line">  <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;failures&quot;</span> : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过向源添加查询来限制文档。这将只复制由kimchy发出的tweet到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;kimchy&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>source中的index可以是一个列表，允许你在一个请求中从多个源复制。这将从twitter和blog索引复制文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: [<span class="string">&quot;twitter&quot;</span>,<span class="string">&quot;blog&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：Reindex API不处理ID冲突，因此最后编写的文档将“胜出”，但顺序通常是不可预测的，因此依赖这种行为不是一个好主意，相反，可以使用脚本确保id是惟一的。<br>还可以通过设置大小来限制处理文档的数量，示例将只复制一个单一的文件从twitter到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>如果你想从twitter索引中获得一组特定的文档，你需要使用sort。排序会降低滚动的效率，但在某些上下文中，这样做是值得的。如果可能的话，选择一个比大小和排序更具选择性的查询。这将把10000个文档从twitter复制到new_twitter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;blog2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: &#123; <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>source部分支持搜索请求中支持的所有元素。例如，只有原始文档中的一部分字段可以使用源过滤重新索引，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;user&quot;</span>, <span class="string">&quot;_doc&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>与_update_by_query一样，_reindex支持修改文档的脚本。与_update_by_query不同，脚本允许修改文档的元数据。这个例子改变了源文档的版本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;blog2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;external&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;if (ctx._source.foo == \&quot;bar\&quot;) &#123;ctx._version++; ctx._source.remove(\&quot;foo\&quot;)&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>就像在_update_by_query中一样，你可以设置ctx.op更改在目标索引上执行的操作，值为noop，delete。<br>设置ctx.op到任何其他字段都会返回一个错误，在ctx中设置任何其他字段也是如此。可以修改以下值：_id、_index<br>、_version、_routing。<br>将_version设置为null或将它从ctx映射中清除，就像没有在索引请求中发送版本一样;它将导致在目标索引中覆盖文档，而不管目标上的版本或在_reindex请求中使用的版本类型。<br>默认情况下，如果_reindex看到一个带有路由的文档，那么该路由将被保留，除非脚本更改了它，你可以设置路由对dest的请求，以改变这一点：<br>keep：将为每个匹配发送的批量请求上的路由设置为匹配上的路由。这是默认值。<br>discard：将为每个匹配发送的批量请求上的路由设置为null。<br>=<some text>：将为每个匹配发送的批量请求上的路由设置为=之后的所有文本。<br>例如，你可以使用以下请求将所有文档从具有公司名称cat的源索引复制到路由设置为cat的dest索引中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;company&quot;</span>: <span class="string">&quot;cat&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: <span class="string">&quot;=cat&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>默认情况下，_reindex使用滚动批次为1000，可以使用源元素中的size字段更改批大小：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: <span class="string">&quot;=cat&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>_reindex还可以通过像这样指定管道来使用Ingest节点特性：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pipeline&quot;</span>: <span class="string">&quot;some_ingest_pipeline&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>




<h2 id="远程reindex"><a href="#远程reindex" class="headerlink" title="远程reindex"></a>远程reindex</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;pass&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>host参数必须包含scheme, host, port（如：<a href="http://otherhost:9200）,也可以加路径（如：http://otherhost:9200/proxy），username和password是可选的，如果远程集群开启了安全认证，那么是必选的，如果需要使用username和password，需要使用https。">http://otherhost:9200）,也可以加路径（如：http://otherhost:9200/proxy），username和password是可选的，如果远程集群开启了安全认证，那么是必选的，如果需要使用username和password，需要使用https。</a><br>远程主机需要设置白名单，可以通过elasticsearch.yml文件里的reindex.remote.whitelist属性进行设置，如果设置多个值可以使用逗号来进行分隔（如：otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*），这里的配置可以忽略scheme，如：</p>
<p><code>reindex.remote.whitelist: &quot;otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*&quot;</code></p>
<p>必须让每个处理reindex的节点上添加白名单的配置。<br>这个特性应该适用于可能找到的任何版本的Elasticsearch的远程集群，这应该允许通过从旧版本的集群reindex，将Elasticsearch的任何版本升级到当前版本。<br>要启用发送到旧版本Elasticsearch的查询，无需验证或修改即可将查询参数直接发送到远程主机，注意：远程reindex不支持手动或者自动slicing。<br>从远程服务器reindex使用堆上缓冲区，默认最大大小为100mb，如果远程索引包含非常大的文档，则需要使用更小的批处理大小，下面的示例将批处理大小设置为10。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>还可以使用socket_timeout字段设置远程连接上的套接字读取超时，使用connect_timeout字段设置连接超时，他们的默认值为30秒，下面示例例将套接字读取超时设置为1分钟，连接超时设置为10秒：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;remote&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;http://otherhost:9200&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;socket_timeout&quot;</span>: <span class="string">&quot;1m&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;connect_timeout&quot;</span>: <span class="string">&quot;10s&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;source&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;data&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;dest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="配置SSL参数"><a href="#配置SSL参数" class="headerlink" title="配置SSL参数"></a>配置SSL参数</h2><p>远程reindex支持配置SSL参数，除了在Elasticsearch秘钥库中添加安全设置之外，还需要在elasticsearch.yml文件中进行配置，不可能在_reindex请求体中配置。<br>支持以下设置：<br>reindex.ssl.certificate_authorities<br>应受信任的PEM编码证书文件的路径列表，不同同时指定reindex.ssl.certificate_authorities和reindex.ssl.truststore.path。<br>reindex.ssl.truststore.path<br>包含要信任的证书的Java密钥存储文件的路径，这个密钥存储库可以是“JKS”或“PKCS#12”格式，不能同时指定reindex.ssl.certificate_authorities和reindex.ssl.truststore.path。<br>reindex.ssl.truststore.password<br>reindex.ssl.truststore.path配置的密码，不能和reindex.ssl.truststore.secure_password一起使用。<br>reindex.ssl.truststore.secure_password<br>reindex.ssl.truststore.path配置的密码，不能和reindex.ssl.truststore.password一起使用。<br>reindex.ssl.truststore.type<br>reindex.ssl.truststore.path信任存储库的类型，必须是jks或PKCS12，如果reindex.ssl.truststore.path的结束是”.p12”, “.pfx”或者”pkcs12”，那么该配置的默认值是PKCS12，否则默认值是jks。<br>reindex.ssl.verification_mode<br>指示用于防止中间人攻击和伪造证书的验证类型。可以设置为full（验证主机名和证书路径）、certificate（验证证书路径，但不验证主机名）、none（不执行验证——这在生产环境中是强烈不鼓励的），默认是full。<br>reindex.ssl.certificate<br>指定PEM编码证书的路径或者证书链用于HTTP客户端身份认证，这个配置还需要设置reindex.ssl.key值，不能同时设置reindex.ssl.certificate和reindex.ssl.keystore.path。<br>reindex.ssl.key<br>指定与用于客户端身份验证的证书相关联的PEM编码私钥的路径，不能同时设置reindex.ssl.key和reindex.ssl.keystore.path。<br>reindex.ssl.key_passphrase<br>指定用于解密已加密的PEM编码私钥(reindex.ssl.key)的口令，不能与reindex.ssl.secure_key_passphrase一起使用。<br>reindex.ssl.secure_key_passphrase<br>指定用于解密已加密的PEM编码私钥(reindex.ssl.key)的口令，不能与reindex.ssl.key_passphrase一起使用。<br>reindex.ssl.keystore.path<br>指定密钥存储库的路径，其中包含用于HTTP客户机身份验证的私钥和证书(如果远程集群需要)，这个密钥存储库可以是“JKS”或“PKCS#12”格式，不能同时指定reindex.ssl.key和reindex.ssl.keystore.path。<br>reindex.ssl.keystore.type<br>密钥存储库的类型(reindex.ssl.keystore.path)，必须是jks或者PKCS12，如果reindex.ssl.keystore.path的结束是”.p12”, “.pfx”或者”pkcs12”，那么该配置的默认值是PKCS12，否则默认值是jks。<br>reindex.ssl.keystore.password<br>密钥存储库的密码(reindex.ssl.keystore.path)，此设置不能与reindex.ssl.keystore.secure_password一起使用。<br>reindex.ssl.keystore.secure_password<br>密钥存储库的密码(reindex.ssl.keystore.path)，此设置不能与reindex.ssl.keystore.password一起使用。<br>reindex.ssl.keystore.key_password<br>密钥存储库中密钥的密码(reindex.ssl.keystore.path)，默认为密钥存储库密码，此设置不能与reindex.ssl.keystore.secure_key_password一起使用。<br>reindex.ssl.keystore.secure_key_password<br>密钥存储库中密钥的密码(reindex.ssl.keystore.path)，默认为密钥存储库密码，此设置不能与reindex.ssl.keystore.key_password一起使用。</p>
<h2 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h2><p>除了标准的pretty参数外， reindex还支持refresh, wait_for_completion, wait_for_active_shards, timeout, scroll和requests_per_second。<br>发送refresh url参数将导致对所写请求的所有索引进行刷新，这与Index API的refresh参数不同，后者只会刷新接收新数据的碎片，与index API不同的是，它不支持wait_for。<br>如果请求包含wait_for_completion=false，则Elasticsearch将执行一些执行前检查，启动请求，然后返回一个任务，该任务可与Tasks api一起用于取消或获取任务状态，Elasticsearch还将创建此任务的记录，作为.tasks/task/${taskId}的文档，你可以自己决定是保留或者删除他，当你已经完成了，删除他，这样es会回收他使用的空间。<br>wait_for_active_shards控制在进行重新索引之前必须激活多少个shard副本，超时控制每个写请求等待不可用碎片变为可用的时间，两者在批量API中的工作方式完全相同，由于_reindex使用滚动搜索，你还可以指定滚动参数来控制“搜索上下文”存活的时间(例如?scroll=10m)，默认值是5分钟。<br>requests_per_second可以设置为任何正数(1.4、6、1000等)，并通过在每个批中填充等待时间来控制_reindex发出批索引操作的速率，可以通过将requests_per_second设置为-1来禁用。<br>节流是通过在批之间等待来完成的，这样就可以给_reindex内部使用的滚动设置一个考虑填充的超时，填充时间是批大小除以requests_per_second和写入时间之间的差额，默认情况下批处理大小为1000，所以如果requests_per_second被设置为500：</p>
<p><code>target_time = 1000 / 500 per second = 2 seconds </code>padding time<code> = target_time - write_time = 2 seconds - 0.5 seconds = 1.5 seconds</code></p>
<p>由于批处理是作为单个_bulk请求发出的，因此较大的批处理大小将导致Elasticsearch创建许多请求，然后等待一段时间再启动下一个请求集，这是“bursty”而不是“smooth”，默认值是-1。</p>
<p>响应体 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">639</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;updated&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;created&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;deleted&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;batches&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;noops&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;version_conflicts&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;retries&quot;</span>: &#123;</span><br><span class="line">	<span class="attr">&quot;bulk&quot;</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">&quot;search&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;throttled_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;requests_per_second&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;throttled_until_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failures&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>took<br>整个操作花费的总毫秒数。<br>timed_out<br>如果在reindex期间执行的任何请求超时，则将此标志设置为true。<br>total<br>成功处理的文档数量。<br>updated<br>成功更新的文档数量。<br>created<br>成功创建的文档的数量。<br>deleted<br>成功删除的文档数量。<br>batches<br>由reindex回拉的滚动响应的数量。<br>noops<br>由于用于reindex的脚本返回了ctx.op的noop值而被忽略的文档数量。<br>version_conflicts<br>reindex命中的版本冲突数。<br>retries<br>reindex尝试重试的次数,bulk是重试的批量操作的数量，search是重试的搜索操作的数量。<br>throttled_millis<br>请求休眠以符合requests_per_second的毫秒数。<br>requests_per_second<br>在reindex期间每秒有效执行的请求数。<br>throttled_until_millis<br>在_reindex响应中，该字段应该始终等于零，它只有在使用任务API时才有意义，在任务API中，它指示下一次(毫秒)再次执行节流请求，以符合requests_per_second。<br>failures<br>出现多个错误以数组返回。</p>
<h2 id="使用task-api"><a href="#使用task-api" class="headerlink" title="使用task api"></a>使用task api</h2><p>获取task</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&amp;wait_for_completion=false&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>返回值为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;task&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q:18&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用任务API获取所有正在运行的reindex请求的状态：<br><code>curl -XGET &quot;http://127.0.0.1:9200/_tasks?detailed=true&amp;actions=*reindex&amp;pretty&quot;</code><br>或者根据task id获取<br><code>curl -XGET &quot;http://127.0.0.1:9200/_tasks/8uQK-B00RiWq03awtJok1Q:48?pretty&quot;</code><br>返回值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;completed&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;task&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;node&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span> : <span class="number">48</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;transport&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;action&quot;</span> : <span class="string">&quot;indices:data/write/reindex&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;total&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;updated&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;created&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;deleted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;batches&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;version_conflicts&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;noops&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;retries&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;bulk&quot;</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;search&quot;</span> : <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;throttled_millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;requests_per_second&quot;</span> : <span class="number">0.0</span>,</span><br><span class="line">      <span class="attr">&quot;throttled_until_millis&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;reindex from [twitter] to [new_twitter][_doc]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start_time_in_millis&quot;</span> : <span class="number">1566216815832</span>,</span><br><span class="line">    <span class="attr">&quot;running_time_in_nanos&quot;</span> : <span class="number">86829</span>,</span><br><span class="line">    <span class="attr">&quot;cancellable&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;headers&quot;</span> : &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;no such index [new_twitter] and [action.auto_create_index] ([twitter,index10,-index1*,+ind*,-myIndex]) doesn&#x27;t match&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span> : <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span> : <span class="string">&quot;new_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消task"><a href="#取消task" class="headerlink" title="取消task"></a>取消task</h2><p>任何reindex接口都可以使用task cancel api取消：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_tasks/8uQK-B00RiWq03awtJok1Q:48/_cancel?pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;node_failures&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;failed_node_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;Failed node [8uQK-B00RiWq03awtJok1Q]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;node_id&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;caused_by&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;resource_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;task [8uQK-B00RiWq03awtJok1Q:48] doesn&#x27;t support cancellation&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span> : &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消应该很快发生，但可能需要几秒钟，Tasks API将继续列出任务，直到它醒来取消自己。</p>
<h2 id="rethrottle"><a href="#rethrottle" class="headerlink" title="rethrottle"></a>rethrottle</h2><p>可以在url中使用_rethrottle，并使用requests_per_second参数来设置节流：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex/8uQK-B00RiWq03awtJok1Q:250/_rethrottle?requests_per_second=-1&amp;pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;node_failures&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;failed_node_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;Failed node [8uQK-B00RiWq03awtJok1Q]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;node_id&quot;</span> : <span class="string">&quot;8uQK-B00RiWq03awtJok1Q&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;caused_by&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;resource_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span> : <span class="string">&quot;task [8uQK-B00RiWq03awtJok1Q:250] is missing&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span> : &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reindex改变属性名称"><a href="#reindex改变属性名称" class="headerlink" title="reindex改变属性名称"></a>reindex改变属性名称</h2><p>_reindex可以重命名属性名，假设你创建了一个包含如下文档的索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/test/_doc/1?refresh&amp;pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;words words&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;flag&quot;</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>在reindex的时候想把flag修改为tag，示例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.tag = ctx._source.remove(\&quot;flag\&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看order2的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">&quot;http://127.0.0.1:9200/order2/_doc/1?pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;order2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;text&quot;</span> : <span class="string">&quot;words words&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;foo&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Reindex支持切片滚动，以并行化重新索引过程。这种并行化可以提高效率，并提供一种方便的方法将请求分解为更小的部分</p>
<h3 id="手动切片"><a href="#手动切片" class="headerlink" title="手动切片"></a>手动切片</h3><p>通过为每个请求提供一个片id和片的总数，手工切片一个重索引请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;slice&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;max&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;slice&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;max&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以通过以下方法来验证：</p>
<p><code>curl -XGET &quot;http://127.0.0.1:9200/_refresh?pretty&quot;</code></p>
<p><code>curl -XPOST &quot;http://127.0.0.1:9200/order2/_search?size=0&amp;filter_path=hits.total&amp;pretty&quot;</code></p>
<p>返回值为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="自动切面"><a href="#自动切面" class="headerlink" title="自动切面"></a>自动切面</h3><p>你还可以让_reindex使用切片滚动自动并行化_uid上的切片，使用slices指定要使用的片数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?slices=5&amp;refresh&amp;pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;order2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过下面请求进行验证：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/order2/_search?size=0&amp;filter_path=hits.total&amp;pretty&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="reindex多个索引"><a href="#reindex多个索引" class="headerlink" title="reindex多个索引"></a>reindex多个索引</h2><p>如果有许多索引需要reindex，通常最好一次reindex一个索引，而不是使用一个glob模式来获取许多索引。这样，如果有任何错误，可以删除部分完成的索引并从该索引重新开始，从而恢复该过程。它还使并行化过程变得相当简单：将索引列表拆分为reindex并并行运行每个列表。<br>可以使用一次性脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">for index in i1 i2 i3 i4 i5; do</span><br><span class="line">  curl -HContent-Type:application/json -XPOST localhost:<span class="number">9200</span>/_reindex?pretty -d&#x27;&#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;&#x27;$index&#x27;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;&#x27;$index&#x27;-reindexed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#x27;</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="reindex每日索引"><a href="#reindex每日索引" class="headerlink" title="reindex每日索引"></a>reindex每日索引</h2><p>尽管有上述建议，你仍然可以结合使用_reindex和Painless来reindex每日索引，从而将新模板应用于现有文档。<br>假设有以下文件组成的索引:</p>
<p><code>curl -XPUT &quot;http://127.0.0.1:9200/metricbeat-2016.05.30/_doc/1?refresh&amp;pretty&quot; -H &quot;Content-Type:application/json&quot; -d</code><br>{“system.cpu.idle.pct”:  0.908}’</p>
<p><code>curl -XPUT &quot;http://127.0.0.1:9200/metricbeat-2016.05.31/_doc/1?refresh&amp;pretty&quot; -H &quot;Content-Type:application/json&quot; -d&#39;</code><br>{“system.cpu.idle.pct”:  0.105}</p>
<p>metricbeat-*索引的新模板已经加载到Elasticsearch中，但它只适用于新创建的索引。<br>下面的脚本从索引名称中提取日期，并创建一个附加-1的新索引。所有来自metricbeat-2016.05.31的数据将reindex到metricbeat-2016.05.31-1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;metricbeat-*&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;metricbeat&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._index = &#x27;metricbeat-&#x27; + (ctx._index.substring(&#x27;metricbeat-&#x27;.length(),ctx._index.length())) + &#x27;-1&#x27;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以前metricbeat索引中的所有文档现在都可以在*-1索引中找到。</p>
<p><code>curl -XGET &quot;http://127.0.0.1:9200/metricbeat-2016.05.30-1/_doc/1?pretty&quot;</code><br><code>curl -XGET &quot;http://127.0.0.1:9200/metricbeat-2016.05.31-1/_doc/1?pretty&quot;</code></p>
<p>前一种方法还可以与更改字段名称结合使用，以便仅将现有数据加载到新索引中，并在需要时重命名任何字段。</p>
<h2 id="提取索引中的子集合"><a href="#提取索引中的子集合" class="headerlink" title="提取索引中的子集合"></a>提取索引中的子集合</h2><p>_reindex可用于提取索引的随机子集进行测试：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&quot;http://127.0.0.1:9200/_reindex?pretty&quot;</span> -H <span class="string">&quot;Content-Type:application/json&quot;</span> -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;twitter&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;function_score&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span> : &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">        <span class="attr">&quot;random_score&quot;</span> : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="string">&quot;_score&quot;</span>    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;random_twitter&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_reindex默认按_doc排序，因此random_score不会有任何效果，除非你覆盖sort属性为_score。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Search in Depth</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>极尽HashMap底层原理</title>
    <url>/wiki/%E6%9E%81%E5%B0%BDHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/92481037">HashMap 中的容量与扩容实现，细致入微，值的一品</a></li>
<li><a href="https://www.zhihu.com/search?type=content&q=hashmap">Java 8系列之重新认识HashMap 美团技术团队</a> </li>
</ul>
</blockquote>
<blockquote>
<p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：<br><img src="https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png"></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<img src='https://pic1.zhimg.com/8db4a3bdfb238da1a1c4431d2b6e075c_b.png'>

<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;美团&quot;</span>,<span class="string">&quot;小美&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下:</p>
<p>int threshold;             // 所能容纳的key-value对极限<br>    final float loadFactor;    // 负载因子<br>    int modCount;<br>    int size;</p>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，<code>例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</code></p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159]%EF%BC%8CHashtable%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%B8%BA11%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A1%B6%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hashtable%E6%89%A9%E5%AE%B9%E5%90%8E%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%BF%98%E6%98%AF%E7%B4%A0%E6%95%B0%EF%BC%89%E3%80%82HashMap%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E9%9D%9E%E5%B8%B8%E8%A7%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%8F%96%E6%A8%A1%E5%92%8C%E6%89%A9%E5%AE%B9%E6%97%B6%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81%EF%BC%8CHashMap%E5%AE%9A%E4%BD%8D%E5%93%88%E5%B8%8C%E6%A1%B6%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%97%B6%EF%BC%8C%E4%B9%9F%E5%8A%A0%E5%85%A5%E4%BA%86%E9%AB%98%E4%BD%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://blog.csdn.net/liuqiyao_01/article/details/14475159]，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考[<a href="http://blog.csdn.net/v_july_v/article/details/6105630]%E3%80%82">http://blog.csdn.net/v_july_v/article/details/6105630]。</a></p>
<h2 id="实现-方法"><a href="#实现-方法" class="headerlink" title="实现-方法"></a>实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。<br><img src='https://pic2.zhimg.com/8e8203c1b51be6446cda4026eaaccf19_b.png'></p>
<h2 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。<br><img src='https://pic3.zhimg.com/58e67eae921e4b431782c07444af824e_b.png'></p>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);                      <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;                  <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                  </span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<img src='https://pic1.zhimg.com/e5aa99e811d1814e010afa7779b759d4_b.png'>

<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<img src='https://pic2.zhimg.com/a285d9b2da279a18b052fe5eed69afe9_b.png'>

<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<img src='https://pic2.zhimg.com/b2cb057773e3d67976c535d6ef547d51_b.png'>

<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<img src='https://pic3.zhimg.com/544caeb82a329fa49cc99842818ed1ba_b.png'>

<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             <span class="keyword">return</span> oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">         newCap = oldThr;</span><br><span class="line">     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 计算新的resize上限</span></span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                         next = e.next;</span><br><span class="line">                         <span class="comment">// 原索引</span></span><br><span class="line">                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j] = loHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<img src="https://pic4.zhimg.com/fa10635a66de637fe3cbd894882ff0c7_b.png">  

<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。<br>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<img src="https://pic4.zhimg.com/d39d7eff6e8e04f98f5b53bebe2d4d7f_b.png">  

<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<img src="https://pic2.zhimg.com/5f3cf5300f041c771a736b40590fd7b1_b.png">  

<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
]]></content>
      <categories>
        <category>Develop Lan</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
