<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="geolei blog">
  <meta name="keyword" content="hexo-theme">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      并发中的一些问题 | GeekIBLi
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="GeekIBLi" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>GeekIBLi</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>并发中的一些问题</h2>
  <p class="post-date">2022-01-04</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h2><h3 id="2-1-volatile的作用"><a href="#2-1-volatile的作用" class="headerlink" title="2.1 volatile的作用"></a>2.1 volatile的作用</h3><p><font color=red>Volatile 只能修饰成员变量，不能修饰局部变量。</font></p>
<blockquote>
<p>1、及时可见性   </p>
<p>2、指令重排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jmm04_CodeAtomic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                        counter++;<span class="comment">//分三步- 读，自加，写回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>volatile无法保证原子操作</strong></p>
<h3 id="2-2-volatile-count-为什么会小于正确的结果？"><a href="#2-2-volatile-count-为什么会小于正确的结果？" class="headerlink" title="2.2 volatile count++为什么会小于正确的结果？"></a>2.2 volatile count++为什么会小于正确的结果？</h3><p>count++ 不是原子操作！count = count + 1;</p>
<ul>
<li>读count</li>
<li>计算count + 1</li>
<li>重新赋值count</li>
</ul>
<blockquote>
<p>s多个线程下可能会出现少加的情况。</p>
</blockquote>
<h4 id="2-2-1-这个数据是被丢失了呢-还是被覆盖了呢？"><a href="#2-2-1-这个数据是被丢失了呢-还是被覆盖了呢？" class="headerlink" title="2.2.1 这个数据是被丢失了呢 还是被覆盖了呢？"></a>2.2.1 这个数据是被丢失了呢 还是被覆盖了呢？</h4><p>mesi协议</p>
<h4 id="2-2-2-如何保证count-正确呢？"><a href="#2-2-2-如何保证count-正确呢？" class="headerlink" title="2.2.2 如何保证count++正确呢？"></a>2.2.2 如何保证count++正确呢？</h4><p>同步锁 synchronized</p>
<h3 id="2-3-什么是指令重排序？"><a href="#2-3-什么是指令重排序？" class="headerlink" title="2.3 什么是指令重排序？"></a>2.3 什么是指令重排序？</h3><p>在保证结果正确性的前提下，指令从内存中加载，重排序之后，可以减少内存数据加载的次数。</p>
<p>编译器重排  指令级重排序 执行器重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jmm05_CodeReorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    shortWait(<span class="number">10000</span>);</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">                    <span class="comment">///</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            String result = <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次 (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;）&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待一段时间，时间单位纳秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上不考虑指令重拍的情况下有几种结果呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 1, y = 0;</span><br><span class="line">x = 0, y = 1;</span><br><span class="line">x = 1, y = 1;</span><br><span class="line">x = 0, y = 0; volatile禁止指令重排序，不会出现这种情况！</span><br></pre></td></tr></table></figure>



<h3 id="2-4-禁止指令重排序的实现原理？"><a href="#2-4-禁止指令重排序的实现原理？" class="headerlink" title="2.4 禁止指令重排序的实现原理？"></a>2.4 禁止指令重排序的实现原理？</h3><h4 id="2-4-1-内存屏障"><a href="#2-4-1-内存屏障" class="headerlink" title="2.4.1 内存屏障"></a>2.4.1 <strong>内存屏障</strong></h4><p><img src="https://oscimg.oschina.net/oscnet/up-19f862e1ab685fc440550c90b9e3a46066b.png"></p>
<h3 id="2-5-指令重排有哪些现实中的例子"><a href="#2-5-指令重排有哪些现实中的例子" class="headerlink" title="2.5 指令重排有哪些现实中的例子"></a>2.5 指令重排有哪些现实中的例子</h3><h4 id="2-5-1-DCL"><a href="#2-5-1-DCL" class="headerlink" title="2.5.1 DCL"></a>2.5.1 <strong>DCL</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看汇编指令</span></span><br><span class="line"><span class="comment">     * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton myinstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重锁机制保证单例安全</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myinstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (myinstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    myinstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myinstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L8</span><br><span class="line">    LINENUMBER <span class="number">26</span> L8</span><br><span class="line">    NEW com/yg/edu/jmm/dcl/Singleton</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL com/yg/edu/jmm/dcl/Singleton.&lt;init&gt; ()V</span><br><span class="line">    PUTSTATIC com/yg/edu/jmm/dcl/Singleton.myinstance : Lcom/yg/edu/jmm/dcl/Singleton;</span><br></pre></td></tr></table></figure>

<p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p>
<blockquote>
<p>因为instance = new DoubleCheckLock();可以分为以下3步完成(伪代码)       </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间 </span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象 </span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null   </span></span><br></pre></td></tr></table></figure>

<p>由于步骤1和步骤2间可能会重排序，如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间 </span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！ instance(memory);//2.初始化对象       </span></span><br></pre></td></tr></table></figure>

<p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p>
<blockquote>
<p> //禁止指令重排优化 private volatile static DoubleCheckLock instance; </p>
</blockquote>
<h3 id="2-6-volatile内存语义的实现"><a href="#2-6-volatile内存语义的实现" class="headerlink" title="2.6 volatile内存语义的实现"></a>2.6 <strong>volatile内存语义的实现</strong></h3><p><img src="https://oscimg.oschina.net/oscnet/up-506a15a3e2902d645d3b418d7af730b8bc0.png"></p>
<p>举例来说，第二行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上图可以看出：</p>
<ul>
<li><ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li>
</ul>
</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li><ul>
<li>·在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>·在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>·在每个volatile读操作的前面插入一个LoadLoad屏障。</li>
<li>·在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<h3 id="2-7-synchronized能否禁止指令重排序？"><a href="#2-7-synchronized能否禁止指令重排序？" class="headerlink" title="2.7 synchronized能否禁止指令重排序？"></a>2.7 synchronized能否禁止指令重排序？</h3><p>不能</p>
<h3 id="2-8-如何在java代码中手动添加内存屏障？"><a href="#2-8-如何在java代码中手动添加内存屏障？" class="headerlink" title="2.8 如何在java代码中手动添加内存屏障？"></a>2.8 如何在java代码中手动添加内存屏障？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">    y = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-MESI协议"><a href="#3-MESI协议" class="headerlink" title="3. MESI协议"></a>3. MESI协议</h2><h3 id="3-1-java代码是如何执行的？"><a href="#3-1-java代码是如何执行的？" class="headerlink" title="3.1 java代码是如何执行的？"></a>3.1 java代码是如何执行的？</h3><img src="https://oscimg.oschina.net/oscnet/up-5e2b4236c26b626b78e0a5c54ffd60478eb.png" style="zoom:50%;" />



<h3 id="3-2-CPU是如何与内存交互的？"><a href="#3-2-CPU是如何与内存交互的？" class="headerlink" title="3.2 CPU是如何与内存交互的？"></a>3.2 CPU是如何与内存交互的？</h3><img src="https://oscimg.oschina.net/oscnet/up-da07e86004a11f1c46c1734fa59ba63daac.png" style="zoom:50%;" />

<p><font color=red>CPU访问内存是通过总线，而访问总线，必须先获取总线索，而lock前缀的执行，可以获取总线锁，阻塞其他CPU进行访问。</font>这是最初的一种设计，这种方式的效率显然是很差的。</p>
<h3 id="3-3-MESI协议工作流程？"><a href="#3-3-MESI协议工作流程？" class="headerlink" title="3.3 MESI协议工作流程？"></a>3.3 MESI协议工作流程？</h3><img src="https://oscimg.oschina.net/oscnet/up-8b18e489f07c8be3db2b26eb2e90524ca1b.png" style="zoom:50%;" />

<h3 id="3-4-什么是总线裁决？"><a href="#3-4-什么是总线裁决？" class="headerlink" title="3.4 什么是总线裁决？"></a>3.4 什么是总线裁决？</h3><p>多个cpu操作一个数据的时候，去对缓存行加锁的时候，需要总线来判断给那个cpu加锁。获取锁的缓存行变成m状态，其他的缓存行变成i状态。</p>
<h3 id="3-5-缓存行是几级缓存的？"><a href="#3-5-缓存行是几级缓存的？" class="headerlink" title="3.5 缓存行是几级缓存的？"></a>3.5 缓存行是几级缓存的？</h3><p>L1 Cache</p>
<h3 id="3-6-一个缓存行64字节装不下数据会怎样？"><a href="#3-6-一个缓存行64字节装不下数据会怎样？" class="headerlink" title="3.6 一个缓存行64字节装不下数据会怎样？"></a>3.6 一个缓存行64字节装不下数据会怎样？</h3><p><font color=red>升级成总线锁</font></p>
<h3 id="3-7-缓存行上加锁会影响到其他的数据吗？"><a href="#3-7-缓存行上加锁会影响到其他的数据吗？" class="headerlink" title="3.7 缓存行上加锁会影响到其他的数据吗？"></a>3.7 缓存行上加锁会影响到其他的数据吗？</h3><p>？？？</p>
<h3 id="3-8-MESI协议不能对寄存器失效"><a href="#3-8-MESI协议不能对寄存器失效" class="headerlink" title="3.8 MESI协议不能对寄存器失效"></a>3.8 MESI协议不能对寄存器失效</h3><p>已经加载到寄存器的指令不能失效，比如count++操作不能保证原子性</p>
<h3 id="3-9-MESI-数据失效之后，怎么读正确的数据呢？"><a href="#3-9-MESI-数据失效之后，怎么读正确的数据呢？" class="headerlink" title="3.9 MESI 数据失效之后，怎么读正确的数据呢？"></a>3.9 MESI 数据失效之后，怎么读正确的数据呢？</h3><p>是实时去内存中读取数据吗？ 不是的。</p>
<img src="https://oscimg.oschina.net/oscnet/up-c037376bafc96bbbe79db73378d27e402c2.png" style="zoom:50%;" />



<ul>
<li>获取到lock的数据修改之后，并不是直接把数据写到缓存行中，而是写到了store buffer中。</li>
<li>获取lock的cpu在修改数据是，会把当前缓存行设置成m状态，同时发送一个消息到其他cpu</li>
<li>其他没有获取到lock的缓存行中的数据就失效了，变成i状态，同时把失效的数据放到一个队列中</li>
<li>当失效数据都放到缓冲队列之后，获取lock的cpu把store buffer中的数据刷到缓存行中。最后在更新到内存中。</li>
<li>在Cpu空闲的时候，将失效的数据在队列中清除，之前仅仅是把数据放到失效队列中，缓存行中的数据其实还在</li>
</ul>
<h3 id="3-10-happens-before原则"><a href="#3-10-happens-before原则" class="headerlink" title="3.10 happens-before原则"></a>3.10 happens-before原则</h3><p><img src="https://oscimg.oschina.net/oscnet/up-f9a3b32c0737241fdbbe79d7bf104de61b4.png"></p>
<h2 id="4、synchronized关键字"><a href="#4、synchronized关键字" class="headerlink" title="4、synchronized关键字"></a>4、synchronized关键字</h2><h3 id="4-1-synchronized-1-6之前和之后有什么区别"><a href="#4-1-synchronized-1-6之前和之后有什么区别" class="headerlink" title="4.1 synchronized 1.6之前和之后有什么区别"></a>4.1 synchronized 1.6之前和之后有什么区别</h3><img src="https://oscimg.oschina.net/oscnet/up-b88652d8e316f622103f29c5c917e92f5c6.png" style="zoom:50%;" />

<ul>
<li>偏向锁只针对有一个线程加锁的情况</li>
<li>轻量级锁针对有少数线程竞争，但是竞争不强烈（如何定义不强烈？ 锁占用时间短，线程可交替执行）</li>
<li>重量级锁 依赖管程 依靠操作系统底层的互斥量Mutex, 由操作系统维护，涉及到CPU用户态和内核态的切换，比较重</li>
</ul>
<h3 id="4-2-什么是自旋锁"><a href="#4-2-什么是自旋锁" class="headerlink" title="4.2 什么是自旋锁"></a>4.2 什么是自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">do</span>....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个线程竞争锁资源的时候，后到的线程自旋等待正在执行的线程释放锁资源，然后自己去竞争，自旋的过程中，一直占用CPU。</p>
<p><font color=red>自旋锁使用于同步代码块里面执行逻辑很简单或者比较快的场景。这样另一个进程可以很快获得锁。</font></p>
<p><strong>自旋锁是处于性能的考虑。避免进程上下文切换，等待线程阻塞和唤醒的性能开销。</strong></p>
<p>自旋锁成功之后升级为轻量级锁，如果自旋次数够了依旧没有获取到锁，便升级成为重量级锁。</p>
<h3 id="4-3-锁升级的过程是否可逆？"><a href="#4-3-锁升级的过程是否可逆？" class="headerlink" title="4.3 锁升级的过程是否可逆？"></a><strong>4.3 锁升级的过程是否可逆？</strong></h3><p>不可逆</p>
<h3 id="4-4-synchronized如何使用？"><a href="#4-4-synchronized如何使用？" class="headerlink" title="4.4 synchronized如何使用？"></a>4.4 synchronized如何使用？</h3><ul>
<li>普通方法<ul>
<li>锁的是当前的对象，凡是这个实例对象相关的方法都互斥</li>
<li>即便这个类存在static的同步方法，不和这个实例对象相关的两个线程，不会冲突</li>
</ul>
</li>
<li>静态方法<ul>
<li>锁范围是当前类实例</li>
<li>注意所的范围才好弄清楚是否冲突</li>
<li>普通同步方法和静态同步方法不冲突，因为不是所的一个实例</li>
</ul>
</li>
<li>方法内部同步块<ul>
<li>锁的范围最小</li>
<li>锁实例一般是成员对象，不同成员对象的同步代码块执行不冲突</li>
</ul>
</li>
</ul>
<h3 id="4-5-synchronized底层原理是怎样的？"><a href="#4-5-synchronized底层原理是怎样的？" class="headerlink" title="4.5 synchronized底层原理是怎样的？"></a>4.5 synchronized底层原理是怎样的？</h3><p><strong>synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。</strong></p>
<p>synchronized加锁的方式如上已经阐述。</p>
<p><strong>synchronized是基于JVM</strong>内置锁实现，通过内部对象<strong>Monitor</strong>(监视器锁)实现，基于进入与退出<strong>Monitor</strong>对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的<strong>Mutex lock</strong>（互斥锁）实现，它是一个重量级锁性能较低。当然，<strong>JVM内置锁在1.5之后版本做了重大的优化，</strong>如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。</p>
<p><font color=red>synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置。</font></p>
<img src="https://oscimg.oschina.net/oscnet/up-53aba5e9abb1ea04b386b23591a04372c6a.png" style="zoom:50%;" />

<h3 id="4-6什么是Monitor监视器锁？"><a href="#4-6什么是Monitor监视器锁？" class="headerlink" title="4.6什么是Monitor监视器锁？"></a>4.6什么是<strong>Monitor监视器锁</strong>？</h3><p><strong>Monitor监视器锁</strong></p>
<p>​    <strong>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态</strong>。Synchronized在JVM里的实现都是 <strong>基于进入和退出Monitor对象来实现方法同步和代码块同步</strong>，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<ul>
<li><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
</li>
<li><ol>
<li><strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li>
<li><strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</li>
<li><strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li>
</ol>
</li>
<li><p><strong>monitorexit</strong>：执行monitorexit的线程必须是objectref所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
</li>
</ul>
<p><strong>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁</strong>；</p>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象</strong>，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，<strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e69029578748db53d6ce688c724f4771610.png"></p>
<p>从编译的结果来看，方法的同步并没有通过指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 <strong>ACC_SYNCHRONIZED</strong> 标示符。<strong>JVM就是根据该标示符来实现方法的同步的</strong>：</p>
<p><font color=red>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置</strong>，如果设置了，<strong>执行线程将先获取monitor</strong>，获取成功之后才能执行方法体，<strong>方法执行完后再释放monitor</strong>。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</font></p>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度</strong>，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h4 id="什么是monitor？"><a href="#什么是monitor？" class="headerlink" title="什么是monitor？"></a><strong>什么是monitor？</strong></h4><p>可以把它理解为 <strong>一个同步工具</strong>，也可以描述为 <strong>一种同步机制</strong>，它通常被 <strong>描述为一个对象</strong>。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，<strong>因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。<strong>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址</strong>。在Java虚拟机（HotSpot）中，<strong>Monitor是由ObjectMonitor实现的</strong>，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor中有两个队列，**_WaitSet 和 _EntryList<strong>，用来保存ObjectWaiter对象列表（ <strong>每个等待锁的线程都会被封装成ObjectWaiter对象</strong> ），</strong>_owner指向持有ObjectMonitor对象的线程**，当多个线程同时访问一段同步代码时：</p>
<ol>
<li>首先会进入 _EntryList 集合，<strong>当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</strong>；</li>
<li>若线程调用 wait() 方法，<strong>将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒</strong>；</li>
<li>若当前线程执行完毕，**也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)**；</li>
</ol>
<p>同时，<strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的</strong>，也是为什么Java中任意对象可以作为锁的原因，<strong>同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。监视器Monitor有两种同步方式：<strong>互斥与协作</strong>。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，<strong>监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问</strong>。</p>
<h3 id="4-7-对象头中锁是如何标记的？"><a href="#4-7-对象头中锁是如何标记的？" class="headerlink" title="4.7 对象头中锁是如何标记的？"></a>4.7 对象头中锁是如何标记的？</h3><p>32位虚拟机的对象头如下👇</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f5d9bf5e5d69b16c4201310d0401065d8b0.png"></p>
<h3 id="4-8-锁对象hashCode在各种状态下都存放在那里？"><a href="#4-8-锁对象hashCode在各种状态下都存放在那里？" class="headerlink" title="4.8 锁对象hashCode在各种状态下都存放在那里？"></a>4.8 锁对象hashCode在各种状态下都存放在那里？</h3><ul>
<li>无锁状态下hashcode存放在markword中</li>
<li>偏向锁调用hashcode会升级成轻量级锁</li>
<li>轻量级锁的hashCode存放在线程栈的Lock Record中</li>
<li>重量级锁的hashCode存放在Monitor中</li>
</ul>
<h3 id="4-9-验证锁标志"><a href="#4-9-验证锁标志" class="headerlink" title="4.9 验证锁标志"></a>4.9 验证锁标志</h3><p>项目中引入一下依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>打印锁对象的对象头，如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//  TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(<span class="string">&quot;a   &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    o.hashCode();</span><br><span class="line">    System.out.println(<span class="string">&quot;b    &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c   &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-9-一开始要sleep5-秒有什么作用？"><a href="#4-9-一开始要sleep5-秒有什么作用？" class="headerlink" title="4.9 一开始要sleep5 秒有什么作用？"></a>4.9 一开始要sleep5 秒有什么作用？</h3><p>因为jvm在启动的时候，要初始化很多的数据，会涉及到很多对象处于偏向锁。</p>
<ul>
<li>如果一开始不sleep，第一次打印是无锁状态，第二次打印，是轻量级锁，因为此时进程中可能有很多偏向锁占用CPU,这里直接升级为轻量级锁</li>
<li>一开始sleep，锁对象会是偏向锁的状态，然后只有一个线程竞争，第二次打印也还是偏向锁</li>
</ul>
<h3 id="4-10-什么是匿名偏向？"><a href="#4-10-什么是匿名偏向？" class="headerlink" title="4.10 什么是匿名偏向？"></a>4.10 什么是匿名偏向？</h3><h3 id="4-11-为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？"><a href="#4-11-为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？" class="headerlink" title="4.11 为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？"></a>4.11 为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？</h3><p>可能是因为轻量级锁的对象头markword中，没有地方存放偏向锁的标志和hashcode，而轻量级锁则由地方存储，在线程栈的Lock record中记录</p>
<h3 id="4-12-锁升级过程是怎样的？"><a href="#4-12-锁升级过程是怎样的？" class="headerlink" title="4.12 锁升级过程是怎样的？"></a>4.12 锁升级过程是怎样的？</h3><p><img src="https://oscimg.oschina.net/oscnet/up-c4d41493d771bf980f88488c2a928e23439.png"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h4><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。\</p>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认开启偏向锁</span><br><span class="line">开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line">关闭偏向锁：-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h4><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<strong>这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，</strong>因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h4><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。<strong>锁消除的依据是逃逸分析的数据支持。</strong></p>
<p>锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析</p>
<p>:-XX:+DoEscapeAnalysis 开启逃逸分析</p>
<p>-XX:+EliminateLocks 表示开启锁消除。</p>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p><a target="_blank" rel="noopener" href="https://geekibli.github.io/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/">Java-锁消除和锁膨胀</a></p>
<h3 id="4-13-什么是逃逸分析？"><a href="#4-13-什么是逃逸分析？" class="headerlink" title="4.13 什么是逃逸分析？"></a>4.13 什么是逃逸分析？</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>二、<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>三、分离对象或标量(基本数据类型)替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>是不是所有的对象和数组都会在堆内存分配空间？</p>
<p><strong>不一定</strong></p>
<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p>
<p> -XX:+DoEscapeAnalysis ： 表示开启逃逸分析</p>
<p> -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析。</p>
<p>从jdk 1.7开始已经默认开启逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T0_ObjectStackAlloc</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行两种测试</span></span><br><span class="line"><span class="comment">     * 关闭逃逸分析，同时调大堆空间，避免堆内GC的发生，如果有GC信息将会被打印出来</span></span><br><span class="line"><span class="comment">     * VM运行参数：-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 开启逃逸分析</span></span><br><span class="line"><span class="comment">     * VM运行参数：-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 执行main方法后</span></span><br><span class="line"><span class="comment">     * jps 查看进程</span></span><br><span class="line"><span class="comment">     * jmap -histo 进程ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//查看执行时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cost-time &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TulingStudent <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Jit对编译时会对代码进行 逃逸分析</span></span><br><span class="line">        <span class="comment">//并不是所有对象存放在堆区，有的一部分存在线程栈空间</span></span><br><span class="line">        TulingStudent student = <span class="keyword">new</span> TulingStudent();</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingStudent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用jmap查看对象创建情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo pid</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>逃逸分析可以节省堆空间，有利于GC</strong></p>
</blockquote>
<h2 id="5-AQS框架Lock详解"><a href="#5-AQS框架Lock详解" class="headerlink" title="5. AQS框架Lock详解"></a>5. AQS框架Lock详解</h2><h3 id="5-1-Lock的核心点"><a href="#5-1-Lock的核心点" class="headerlink" title="5.1 Lock的核心点"></a>5.1 Lock的核心点</h3><ul>
<li>循环 </li>
<li>CAS 多线程竞争锁</li>
<li>队列 （公平和非公平）存储阻塞的线程们</li>
<li>阻塞和唤醒</li>
</ul>
<h3 id="5-2-LockSupport-park-和-object-notify-有什么区别？"><a href="#5-2-LockSupport-park-和-object-notify-有什么区别？" class="headerlink" title="5.2 LockSupport.park()  和 object.notify() 有什么区别？"></a>5.2 LockSupport.park()  和 object.notify() 有什么区别？</h3><p>如果大量线程阻塞，每个线程都会有自己的线程栈，这样会占用大量的内存。可能会导致栈溢出。</p>
<p>LockSupport.unpark可以唤醒特定的线程，而object.notify是随机的唤醒</p>
<p><strong>puck有参和无参有什么区别？</strong></p>
<p>Puck无参数，阻塞一次</p>
<p>puck有参数，未被唤醒，一直阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125;,开始执行!&quot;</span>,current.getName());</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;<span class="comment">//spin 自旋</span></span><br><span class="line">                    log.info(<span class="string">&quot;准备park住当前线程：&#123;&#125;....&quot;</span>,current.getName());</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                    System.out.println(Thread.interrupted());</span><br><span class="line">                    log.info(<span class="string">&quot;当前线程&#123;&#125;已经被唤醒....&quot;</span>,current.getName());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;准备唤醒&#123;&#125;线程!&quot;</span>,t0.getName());</span><br><span class="line">            LockSupport.unpark(t0);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            t0.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-CAS是什么？"><a href="#5-3-CAS是什么？" class="headerlink" title="5.3 CAS是什么？"></a>5.3 CAS是什么？</h3><p>A: 内存中实际存储的值，B： 期望内存中的值， C: 修改之后的值</p>
<p>如果 A = B , 则修改；否则重新读区内存中的值，不断循环上面的过程。</p>
<blockquote>
<p>其实这个是和JMM息息相关的。<strong>整个比较并交换的操作是原子操作</strong></p>
</blockquote>
<p>在java中是用到了Unsafe类下的方法。底层其实是用到了汇编 <code>cmpxchg</code>指令</p>
<p>java代码演绎cas原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Juc04_Thread_Cas</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前加锁状态,记录加锁的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Juc04_Thread_Cas cas = <span class="keyword">new</span> Juc04_Thread_Cas();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-0&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求:&#123;&#125;到达预定点,准备开始抢state:)&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="keyword">if</span>(cas.compareAndSwapState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;当前请求:&#123;&#125;,抢到锁!&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;当前请求:&#123;&#125;,抢锁失败!&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException|BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue</span></span><br><span class="line"><span class="comment">     *        oldvalue:线程工作内存当中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     *        newValue:要替换的新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapState</span><span class="params">(<span class="keyword">int</span> oldValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,stateOffset,oldValue,newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(Juc04_Thread_Cas.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-什么是公平锁什么是非公平锁"><a href="#5-4-什么是公平锁什么是非公平锁" class="headerlink" title="5.4 什么是公平锁什么是非公平锁"></a>5.4 什么是公平锁什么是非公平锁</h3><ul>
<li>公平锁 ： 按照队列的顺序获取锁，新来的线程进入队列排队</li>
<li>非公平锁 ： 获取锁的时候，新来的线程也可以参与竞争锁</li>
</ul>
<blockquote>
<p>针对的是 <strong>新来的线程</strong>是否马上可以竞争锁资源，其实就是是否破坏了<strong>先来后到，先来先的</strong>的公平性。</p>
</blockquote>
<h3 id="5-5-在reentrantLock代码中如何体现？"><a href="#5-5-在reentrantLock代码中如何体现？" class="headerlink" title="5.5 在reentrantLock代码中如何体现？"></a>5.5 在reentrantLock代码中如何体现？</h3><p>默认非公平</p>
<h3 id="5-6-如何判断那个线程获取了锁？"><a href="#5-6-如何判断那个线程获取了锁？" class="headerlink" title="5.6 如何判断那个线程获取了锁？"></a>5.6 如何判断那个线程获取了锁？</h3><p>AQS的属性 <code>exclusiceOwnerThread</code>  指向当前获取锁的线程。</p>
<h3 id="5-7-锁到底加到了哪里，加了多少次？"><a href="#5-7-锁到底加到了哪里，加了多少次？" class="headerlink" title="5.7 锁到底加到了哪里，加了多少次？"></a>5.7 锁到底加到了哪里，加了多少次？</h3><p>AQS 的属性 int <code>status</code> = 0; 0 表示没有加锁，&gt;0 表示锁重入的次数。</p>
<h3 id="5-8-队列是如何创建的？"><a href="#5-8-队列是如何创建的？" class="headerlink" title="5.8 队列是如何创建的？"></a>5.8 队列是如何创建的？</h3><p>CLH队列 ： Node类型，本质是双向链表的结构 。 三个人名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	Node pre;</span><br><span class="line">	Node next;</span><br><span class="line">	Node head;</span><br><span class="line">	Node tail;</span><br><span class="line">  Thread thread; <span class="comment">// 对线程的引用</span></span><br><span class="line">  <span class="keyword">int</span> waitStatus; <span class="comment">// 状态 信号量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>waitStatus变量的状态:</strong></p>
<ul>
<li>Init = 0 初始状态</li>
<li>singal = -1 <strong>下一个结点</strong>可被唤醒</li>
<li>cancled = 1 可能发生了异常 比如终端或者其他因素，需要被废弃掉这样的结点</li>
<li>condition = -2  </li>
<li>propagate(广播) = -3</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-743aa07d2d8916013c231dbbfaacfd623ca.png"></p>
<h3 id="5-9-公平锁加锁流程"><a href="#5-9-公平锁加锁流程" class="headerlink" title="5.9 公平锁加锁流程"></a>5.9 公平锁加锁流程</h3><ul>
<li>先判断status == 0</li>
<li>判断队列是否为空 （head == tail）</li>
<li>cas修改status = 1 &amp;&amp; exclusiveOwnerThread = curThread</li>
<li>如果status ！= 0  有两种情况，判断 exclusiveOwnerThread == curThread ？ 如果是curThread ， status +1 ， 如果不是，加入CLH队列</li>
</ul>
<h4 id="5-9-1-如果T0获取了锁，T1-T2…线程怎么办？"><a href="#5-9-1-如果T0获取了锁，T1-T2…线程怎么办？" class="headerlink" title="5.9.1 如果T0获取了锁，T1 T2…线程怎么办？"></a>5.9.1 如果T0获取了锁，T1 T2…线程怎么办？</h4><h5 id="5-9-1-1-尝试加入CLH队列"><a href="#5-9-1-1-尝试加入CLH队列" class="headerlink" title="5.9.1.1 尝试加入CLH队列"></a>5.9.1.1 尝试加入CLH队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 可能多线程进入</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          <span class="comment">// cas只会有一个线程修改成功</span></span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只会有一个线程进入，也就是当前线程再次获取锁的时候，所以这里没有并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法可以被多个线程同时调用，性能会比较高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">  			<span class="comment">// 队列不是空的时候走下面</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		  <span class="comment">// 队列是空的时候，走这个方法</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列是空的时候，第一次想队列中添加等待的结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么循环等待呢？ 要确保结点一定要添加到队列尾部</li>
<li><code>if (t == null) &#123; // Must initialize </code> 是什么逻辑？</li>
</ul>
<blockquote>
<p>第一次初始化的时候，头结点搞一个空的Node对象，然后下一次循环的时候把结点添加到尾部。</p>
</blockquote>
<p><strong>如果不循环，可能导致线程结点丢失，永远无法唤醒，但是内存空间中还存在该线程的堆栈信息。</strong></p>
<h5 id="5-9-1-2-加入队列后，该把线程阻塞了"><a href="#5-9-1-2-加入队列后，该把线程阻塞了" class="headerlink" title="5.9.1.2 加入队列后，该把线程阻塞了"></a>5.9.1.2 加入队列后，该把线程阻塞了</h5><p><font color=red>执行到这的话，只是把线程添加到队列中了，但是显示还没有阻塞，下面就是去阻塞的逻辑</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            		<span class="comment">// 获取前一个结点</span></span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             	<span class="comment">// 如果前一个结点是头结点，并且当前线程获取成功了</span></span><br><span class="line">             	<span class="comment">// 因为可能在入队前的瞬间，头结点的线程释放锁了</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 <span class="comment">// 当前获取锁的线程的node是第一个，而且是空的node，这个enq方法呼应！</span></span><br><span class="line">                  setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC 把之前的结点设置成null</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong>  ⚠️ ⚠️ ⚠️</p>
<p><code>if (p == head &amp;&amp; tryAcquire(arg)) </code></p>
<ul>
<li>如果是公平锁，则一定可以tryAcquire 获取到锁</li>
<li>如果是非公平锁，则 if 不一定为true</li>
</ul>
<h5 id="5-9-1-3-结点阻塞之前，还会再次尝试获取锁"><a href="#5-9-1-3-结点阻塞之前，还会再次尝试获取锁" class="headerlink" title="5.9.1.3 结点阻塞之前，还会再次尝试获取锁"></a>5.9.1.3 结点阻塞之前，还会再次尝试获取锁</h5><p>（如果是第一个结点）</p>
<h5 id="5-9-1-4-如果获取锁成功，设置成头结点"><a href="#5-9-1-4-如果获取锁成功，设置成头结点" class="headerlink" title="5.9.1.4 如果获取锁成功，设置成头结点"></a>5.9.1.4 如果获取锁成功，设置成头结点</h5><p><img src="https://oscimg.oschina.net/oscnet/up-3d3f02435ab216e6de2b04ac13fa4385508.png"></p>
<p>设置成头结点的时候，之前的头结点（肯定是个 “空结点”）断开，并且设置成null，方便GC. 然后把当前线程的Node结点设置成head结点，同时把Node设置成 “空结点”。 怎么设置的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>头指针指向当前结点</li>
<li>把线程设置成null，因为当前线程已经获取到锁了，这里没有必要还继续占着引用</li>
<li>把当前结点的前指针断开（因为在enq方法里面，要阻塞的结点都是添加在tail，所以它的prev肯定是有的，这里要断开头结点）</li>
</ul>
<h5 id="5-9-1-5-如果没有获取成功，执行阻塞"><a href="#5-9-1-5-如果没有获取成功，执行阻塞" class="headerlink" title="5.9.1.5 如果没有获取成功，执行阻塞"></a>5.9.1.5 如果没有获取成功，执行阻塞</h5><ul>
<li><p>第一轮循环，shouldParkAfterFailedAcquire(p, node)  返回false ，修改head的waitStatus = singal = -1，下一个结点可以被唤醒</p>
</li>
<li><p>第二次循环进行阻塞操作，shouldParkAfterFailedAcquire(p, node) 返回true ， 执行parkAndCheckInterrupt()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞当前线程。此时当前结点的waitStatus = 0. 和上面之前的操作一样了，等待这个线程执行的时候，又开始了上面的操作，设置head结点的waitStatus = signal = -1 等等。</p>
</li>
</ul>
<h4 id="5-9-2-被阻塞的线程什么时候会唤醒呢？"><a href="#5-9-2-被阻塞的线程什么时候会唤醒呢？" class="headerlink" title="5.9.2 被阻塞的线程什么时候会唤醒呢？"></a>5.9.2 被阻塞的线程什么时候会唤醒呢？</h4><p><strong>在获取锁的线程执行 <code>unlock</code> 的时候。</strong></p>
<p>下面是AQS的模版方法，tryRelease在子类实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先减AQS的 state</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">          	<span class="comment">// h.waitStatus != 0 不能为0 在reentrantLock中，waitStatus = -1, 唤醒CLH队列下一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是tryRelease在ReentrantLock方法中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果state - 1 成功，则接下来执行唤醒操作。</p>
<p><strong>AQS# unparkSuccessor唤醒方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结</p>
<ul>
<li>head结点的状态肯定是 “空结点”， waitStatus 状态=-1 ，说明线程正在执行，当线程执行完成之后，在unlock的时候，再把waitStatus改成0</li>
<li>为什么waitStatus的状态在unlock的时候要 ‘恢复’ 成 0 呢？<ul>
<li>因为在非公平锁的情况下，不一定是后续结点一定能获得锁</li>
<li>而且node 的waitStatus的状态设置成-1是有固定方法固定的时候</li>
</ul>
</li>
</ul>
<h3 id="5-10-什么是可重入锁"><a href="#5-10-什么是可重入锁" class="headerlink" title="5.10 什么是可重入锁"></a>5.10 什么是可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.lock()</span><br><span class="line">	...</span><br><span class="line">	lock.lock()</span><br><span class="line">		...</span><br><span class="line">	lock.unlock()</span><br><span class="line">	...</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure>

<h3 id="5-11-什么是中断"><a href="#5-11-什么是中断" class="headerlink" title="5.11 什么是中断"></a>5.11 什么是中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;in thread 111&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">              <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;响应中断&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread.start();</span><br><span class="line">      System.err.println(<span class="string">&quot;before interrupt &quot;</span> + thread.isInterrupted());</span><br><span class="line">      thread.interrupt();</span><br><span class="line">      System.err.println(<span class="string">&quot;after interrupt &quot;</span> + thread.isInterrupted());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>中断的三个方法：</p>
<ul>
<li>Thread.interrupted(); 中断线程并且清除中断标记</li>
<li>Thread.currentThread().interrupt();  中断线程</li>
<li>Thread.currentThread().isInterrupted();  判断中断标记，并不清除</li>
</ul>
<blockquote>
<p>用户程序自己响应中断，比直接调用stop方法要友好的多</p>
</blockquote>
<h4 id="如果获取锁的线程调用了wait方法会怎样？"><a href="#如果获取锁的线程调用了wait方法会怎样？" class="headerlink" title="如果获取锁的线程调用了wait方法会怎样？"></a><strong><font color=red>如果获取锁的线程调用了wait方法会怎样？</font></strong></h4><h3 id="5-12-waitStatus-cancel-1-状态"><a href="#5-12-waitStatus-cancel-1-状态" class="headerlink" title="5.12 waitStatus = cancel = 1 状态"></a>5.12 waitStatus = cancel = 1 状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">       <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">       <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">       <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">       <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">           compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">           <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">           <span class="keyword">int</span> ws;</span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   compareAndSetNext(pred, predNext, next);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           node.next = node; <span class="comment">// help GC</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当node是cancel状态的时候，说明当前线程已经没用了，但是之前呢，已经把node添加到了队列里面了。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b9d30c07b820fa121616ea71504a08148f2.png"></p>
<p>分成3种情况</p>
<ul>
<li>第一种，如果结点是tail, 把当前结点去掉</li>
<li>如果是head后面的第一个结点，那么，直接唤醒该结点后面的结点</li>
<li>如果是队列中间，比如图中红色的位置，则去掉就行了</li>
</ul>
<p>这里呢 还有一些细节，node的thread = null，这样方便GC, 因为线程栈也是占用内存空间的。</p>
<h2 id="6-AQS框架Blocking-Queue详解"><a href="#6-AQS框架Blocking-Queue详解" class="headerlink" title="6. AQS框架Blocking Queue详解"></a>6. AQS框架Blocking Queue详解</h2><p>任意时刻，无论并发多高，在单机jvm上面，同一时间，永远都只有一个线程可以进行入队和出队操作</p>
<h3 id="6-1-阻塞队列特性"><a href="#6-1-阻塞队列特性" class="headerlink" title="6.1 阻塞队列特性"></a>6.1 阻塞队列特性</h3><ul>
<li>线程安全</li>
<li>有界队列和无界队列</li>
<li>队列满 添加阻塞 队列空 读取阻塞</li>
</ul>
<h3 id="6-2-使用场景"><a href="#6-2-使用场景" class="headerlink" title="6.2 使用场景"></a>6.2 使用场景</h3><ul>
<li>线程池的任务队列</li>
<li>注册中心底层</li>
<li>常用语生产者和消费者</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=e59837f57323a12defbb62fa837b330d&type=note&_time=1641267390260">JMM讲解&amp;volatile</a></li>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=73fc01483ff8b40c47d6898ad17a66c8&type=note&_time=1641280508219">MESI协议</a></li>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=ee257490aa10fc87bb8c3823ed1e5421&type=note&_time=1641289972738">并发编程之synchronized详解</a></li>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=695b21d540f1a6c8c0dae11c4d696b1f&type=note&_time=1641371184468">抽象队列同步器AQS应用Lock详解【更多课程 zx-cc.net】</a></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#多线程" >
    <span class="tag-code">多线程</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/wiki/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/">
        <span class="nav-arrow">← </span>
        
          MySQL为什么有时会选错索引
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-volatile"><span class="toc-nav-text">2. volatile</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-nav-text">2.1 volatile的作用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-volatile-count-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%B0%8F%E4%BA%8E%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-nav-text">2.2 volatile count++为什么会小于正确的结果？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-1-%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%98%AF%E8%A2%AB%E4%B8%A2%E5%A4%B1%E4%BA%86%E5%91%A2-%E8%BF%98%E6%98%AF%E8%A2%AB%E8%A6%86%E7%9B%96%E4%BA%86%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">2.2.1 这个数据是被丢失了呢 还是被覆盖了呢？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81count-%E6%AD%A3%E7%A1%AE%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">2.2.2 如何保证count++正确呢？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-nav-text">2.3 什么是指令重排序？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-4-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-nav-text">2.4 禁止指令重排序的实现原理？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-1-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-nav-text">2.4.1 内存屏障</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-5-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-nav-text">2.5 指令重排有哪些现实中的例子</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-5-1-DCL"><span class="toc-nav-text">2.5.1 DCL</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">2.6 volatile内存语义的实现</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-synchronized%E8%83%BD%E5%90%A6%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-nav-text">2.7 synchronized能否禁止指令重排序？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-8-%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-nav-text">2.8 如何在java代码中手动添加内存屏障？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-MESI%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">3. MESI协议</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">3.1 java代码是如何执行的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-CPU%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">3.2 CPU是如何与内存交互的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-MESI%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">3.3 MESI协议工作流程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%BB%E7%BA%BF%E8%A3%81%E5%86%B3%EF%BC%9F"><span class="toc-nav-text">3.4 什么是总线裁决？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-5-%E7%BC%93%E5%AD%98%E8%A1%8C%E6%98%AF%E5%87%A0%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">3.5 缓存行是几级缓存的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-6-%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E8%A1%8C64%E5%AD%97%E8%8A%82%E8%A3%85%E4%B8%8D%E4%B8%8B%E6%95%B0%E6%8D%AE%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-nav-text">3.6 一个缓存行64字节装不下数据会怎样？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-7-%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%8A%E5%8A%A0%E9%94%81%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-nav-text">3.7 缓存行上加锁会影响到其他的数据吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-8-MESI%E5%8D%8F%E8%AE%AE%E4%B8%8D%E8%83%BD%E5%AF%B9%E5%AF%84%E5%AD%98%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-nav-text">3.8 MESI协议不能对寄存器失效</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-9-MESI-%E6%95%B0%E6%8D%AE%E5%A4%B1%E6%95%88%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AF%BB%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">3.9 MESI 数据失效之后，怎么读正确的数据呢？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-10-happens-before%E5%8E%9F%E5%88%99"><span class="toc-nav-text">3.10 happens-before原则</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4%E3%80%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-nav-text">4、synchronized关键字</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-synchronized-1-6%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">4.1 synchronized 1.6之前和之后有什么区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-nav-text">4.2 什么是自旋锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E9%80%86%EF%BC%9F"><span class="toc-nav-text">4.3 锁升级的过程是否可逆？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-4-synchronized%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-nav-text">4.4 synchronized如何使用？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-5-synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">4.5 synchronized底层原理是怎样的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-6%E4%BB%80%E4%B9%88%E6%98%AFMonitor%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%EF%BC%9F"><span class="toc-nav-text">4.6什么是Monitor监视器锁？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmonitor%EF%BC%9F"><span class="toc-nav-text">什么是monitor？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-7-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%AD%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E6%A0%87%E8%AE%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">4.7 对象头中锁是如何标记的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-8-%E9%94%81%E5%AF%B9%E8%B1%A1hashCode%E5%9C%A8%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B8%8B%E9%83%BD%E5%AD%98%E6%94%BE%E5%9C%A8%E9%82%A3%E9%87%8C%EF%BC%9F"><span class="toc-nav-text">4.8 锁对象hashCode在各种状态下都存放在那里？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-9-%E9%AA%8C%E8%AF%81%E9%94%81%E6%A0%87%E5%BF%97"><span class="toc-nav-text">4.9 验证锁标志</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-9-%E4%B8%80%E5%BC%80%E5%A7%8B%E8%A6%81sleep5-%E7%A7%92%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-nav-text">4.9 一开始要sleep5 秒有什么作用？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-10-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E5%81%8F%E5%90%91%EF%BC%9F"><span class="toc-nav-text">4.10 什么是匿名偏向？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-11-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8hashCode%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9F"><span class="toc-nav-text">4.11 为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-12-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">4.12 锁升级过程是怎样的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-nav-text">偏向锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-nav-text">轻量级锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-nav-text">自旋锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-nav-text">锁消除</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-nav-text">锁膨胀</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-13-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-nav-text">4.13 什么是逃逸分析？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-AQS%E6%A1%86%E6%9E%B6Lock%E8%AF%A6%E8%A7%A3"><span class="toc-nav-text">5. AQS框架Lock详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-Lock%E7%9A%84%E6%A0%B8%E5%BF%83%E7%82%B9"><span class="toc-nav-text">5.1 Lock的核心点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-LockSupport-park-%E5%92%8C-object-notify-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">5.2 LockSupport.park()  和 object.notify() 有什么区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">5.3 CAS是什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-nav-text">5.4 什么是公平锁什么是非公平锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-5-%E5%9C%A8reentrantLock%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-nav-text">5.5 在reentrantLock代码中如何体现？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-6-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%82%A3%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E4%BA%86%E9%94%81%EF%BC%9F"><span class="toc-nav-text">5.6 如何判断那个线程获取了锁？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-7-%E9%94%81%E5%88%B0%E5%BA%95%E5%8A%A0%E5%88%B0%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%8C%E5%8A%A0%E4%BA%86%E5%A4%9A%E5%B0%91%E6%AC%A1%EF%BC%9F"><span class="toc-nav-text">5.7 锁到底加到了哪里，加了多少次？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-8-%E9%98%9F%E5%88%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">5.8 队列是如何创建的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-9-%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">5.9 公平锁加锁流程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-9-1-%E5%A6%82%E6%9E%9CT0%E8%8E%B7%E5%8F%96%E4%BA%86%E9%94%81%EF%BC%8CT1-T2%E2%80%A6%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-nav-text">5.9.1 如果T0获取了锁，T1 T2…线程怎么办？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-9-1-1-%E5%B0%9D%E8%AF%95%E5%8A%A0%E5%85%A5CLH%E9%98%9F%E5%88%97"><span class="toc-nav-text">5.9.1.1 尝试加入CLH队列</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-9-1-2-%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97%E5%90%8E%EF%BC%8C%E8%AF%A5%E6%8A%8A%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%BA%86"><span class="toc-nav-text">5.9.1.2 加入队列后，该把线程阻塞了</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-9-1-3-%E7%BB%93%E7%82%B9%E9%98%BB%E5%A1%9E%E4%B9%8B%E5%89%8D%EF%BC%8C%E8%BF%98%E4%BC%9A%E5%86%8D%E6%AC%A1%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-nav-text">5.9.1.3 结点阻塞之前，还会再次尝试获取锁</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-9-1-4-%E5%A6%82%E6%9E%9C%E8%8E%B7%E5%8F%96%E9%94%81%E6%88%90%E5%8A%9F%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%88%90%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-nav-text">5.9.1.4 如果获取锁成功，设置成头结点</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-9-1-5-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%8E%B7%E5%8F%96%E6%88%90%E5%8A%9F%EF%BC%8C%E6%89%A7%E8%A1%8C%E9%98%BB%E5%A1%9E"><span class="toc-nav-text">5.9.1.5 如果没有获取成功，执行阻塞</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-9-2-%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%94%A4%E9%86%92%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">5.9.2 被阻塞的线程什么时候会唤醒呢？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-10-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-nav-text">5.10 什么是可重入锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-11-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="toc-nav-text">5.11 什么是中断</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A6%82%E6%9E%9C%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E4%BA%86wait%E6%96%B9%E6%B3%95%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-nav-text">如果获取锁的线程调用了wait方法会怎样？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-12-waitStatus-cancel-1-%E7%8A%B6%E6%80%81"><span class="toc-nav-text">5.12 waitStatus &#x3D; cancel &#x3D; 1 状态</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-AQS%E6%A1%86%E6%9E%B6Blocking-Queue%E8%AF%A6%E8%A7%A3"><span class="toc-nav-text">6. AQS框架Blocking Queue详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-1-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7"><span class="toc-nav-text">6.1 阻塞队列特性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-nav-text">6.2 使用场景</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-nav-text">参考文档</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/wiki/并发中的一些问题/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>