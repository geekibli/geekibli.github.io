<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="geolei blog">
  <meta name="keyword" content="hexo-theme">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      elasticsearch调优实践 | GeekIBLi
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="GeekIBLi" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>GeekIBLi</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>elasticsearch调优实践</h2>
  <p class="post-date">2021-07-14</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>从性能和稳定性两方面，从linux参数调优、ES节点配置和ES使用方式三个角度入手，介绍ES调优的基本方案。当然，ES的调优绝不能一概而论，需要根据实际业务场景做适当的取舍和调整</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p>
</blockquote>
<h2 id="Linux优化"><a href="#Linux优化" class="headerlink" title="Linux优化"></a>Linux优化</h2><h3 id="关闭交换分区，防止内存置换降低性能。"><a href="#关闭交换分区，防止内存置换降低性能。" class="headerlink" title="关闭交换分区，防止内存置换降低性能。"></a>关闭交换分区，防止内存置换降低性能。</h3><p>将 <code>/etc/fstab</code> 文件中包含swap的行注释掉<br><code>sed -i &#39;/swap/s/^/#/&#39; /etc/fstabswapoff -a</code></p>
<h3 id="磁盘挂载选项"><a href="#磁盘挂载选项" class="headerlink" title="磁盘挂载选项"></a>磁盘挂载选项</h3><p>noatime：禁止记录访问时间戳，提高文件系统读写性能<br>data=writeback： 不记录data journal，提高文件系统写入性能<br>barrier=0：barrier保证journal先于data刷到磁盘，上面关闭了journal，这里的barrier也就没必要开启了<br>nobh：关闭buffer_head，防止内核打断大块数据的IO操作<br>mount -o noatime,data=writeback,barrier=0,nobh /dev/sda /es_data</p>
<h3 id="对于SSD磁盘，采用电梯调度算法"><a href="#对于SSD磁盘，采用电梯调度算法" class="headerlink" title="对于SSD磁盘，采用电梯调度算法"></a>对于SSD磁盘，采用电梯调度算法</h3><p>因为SSD提供了更智能的请求调度算法，不需要内核去做多余的调整 (仅供参考)<br><code>echo noop &gt; /sys/block/sda/queue/scheduler</code></p>
<h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><p>conf/elasticsearch.yml文件：</p>
<h3 id="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"><a href="#适当增大写入buffer和bulk队列长度，提高写入性能和稳定性" class="headerlink" title="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"></a>适当增大写入buffer和bulk队列长度，提高写入性能和稳定性</h3><p><code>indices.memory.index_buffer_size: 15%</code><br><code>thread_pool.bulk.queue_size: 1024</code></p>
<h3 id="计算disk使用量时，不考虑正在搬迁的shard"><a href="#计算disk使用量时，不考虑正在搬迁的shard" class="headerlink" title="计算disk使用量时，不考虑正在搬迁的shard"></a>计算disk使用量时，不考虑正在搬迁的shard</h3><p>在规模比较大的集群中，可以防止新建shard时扫描所有shard的元数据，提升shard分配速度。<br><code>cluster.routing.allocation.disk.include_relocations: false</code></p>
<h2 id="三-ES使用方式"><a href="#三-ES使用方式" class="headerlink" title="三 ES使用方式"></a>三 ES使用方式</h2><h3 id="控制字段的存储选项"><a href="#控制字段的存储选项" class="headerlink" title="控制字段的存储选项"></a>控制字段的存储选项</h3><p>ES底层使用Lucene存储数据，主要包括行存（StoreFiled）、列存（DocValues）和倒排索引（InvertIndex）三部分。 大多数使用场景中，没有必要同时存储这三个部分，可以通过下面的参数来做适当调整：</p>
<h4 id="StoreFiled"><a href="#StoreFiled" class="headerlink" title="StoreFiled"></a>StoreFiled</h4><p>行存，其中占比最大的是source字段，它控制doc原始数据的存储。在写入数据时，ES把doc原始数据的整个json结构体当做一个string，存储为source字段。查询时，可以通过source字段拿到当初写入时的整个json结构体。 所以，如果没有取出整个原始json结构体的需求，可以通过下面的命令，在mapping中关闭source字段或者只在source中存储部分字段，数据查询时仍可通过ES的docvaluefields获取所有字段的值。<br>注意：关闭source后， update, updatebyquery, reindex等接口将无法正常使用，所以有update等需求的index不能关闭source。</p>
<ul>
<li>关闭 _source<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="source只存储部分字段"><a href="#source只存储部分字段" class="headerlink" title="_source只存储部分字段"></a>_source只存储部分字段</h4><p>通过includes指定要存储的字段或者通过excludes滤除不需要的字段</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;includes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;*.count&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.*&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;excludes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;meta.description&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.other.*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="docvalues-控制列存。"><a href="#docvalues-控制列存。" class="headerlink" title="docvalues 控制列存。"></a>docvalues 控制列存。</h4><p>ES主要使用列存来支持sorting, aggregations和scripts功能，对于没有上述需求的字段，可以通过下面的命令关闭docvalues，降低存储成本。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ndex：控制倒排索引。"><a href="#ndex：控制倒排索引。" class="headerlink" title="ndex：控制倒排索引。"></a>ndex：控制倒排索引。</h4><p>ES默认对于所有字段都开启了倒排索引，用于查询。对于没有查询需求的字段，可以通过下面的命令关闭倒排索引。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="allES的一个特殊的字段"><a href="#allES的一个特殊的字段" class="headerlink" title="allES的一个特殊的字段"></a>allES的一个特殊的字段</h4><ul>
<li>ES把用户写入json的所有字段值拼接成一个字符串后，做分词，然后保存倒排索引，用于支持整个json的全文检索。<br>这种需求适用的场景较少，可以通过下面的命令将all字段关闭，节约存储成本和cpu开销。（ES 6.0+以上的版本不再支持_all字段，不需要设置）<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fieldnames"><a href="#fieldnames" class="headerlink" title="fieldnames"></a>fieldnames</h4>该字段用于exists查询，来确认某个doc里面有无一个字段存在。若没有这种需求，可以将其关闭。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_field_names&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启最佳压缩"><a href="#开启最佳压缩" class="headerlink" title="开启最佳压缩"></a>开启最佳压缩</h3><p>对于打开了上述_source字段的index，可以通过下面的命令来把lucene适用的压缩算法替换成 DEFLATE，提高数据压缩率。<br><code>PUT /my_index/_settings&#123;    &quot;index.codec&quot;: &quot;best_compression&quot;&#125;</code></p>
<h3 id="bulk批量写入"><a href="#bulk批量写入" class="headerlink" title="bulk批量写入"></a>bulk批量写入</h3><p>写入数据时尽量使用下面的bulk接口批量写入，提高写入效率。每个bulk请求的doc数量设定区间推荐为1k~1w，具体可根据业务场景选取一个适当的数量。</p>
<h3 id="调整translog同步策略"><a href="#调整translog同步策略" class="headerlink" title="调整translog同步策略"></a>调整translog同步策略</h3><p>默认情况下，translog的持久化策略是，对于每个写入请求都做一次flush，刷新translog数据到磁盘上。这种频繁的磁盘IO操作是严重影响写入性能的，如果可以接受一定概率的数据丢失（这种硬件故障的概率很小），可以通过下面的命令调整 translog 持久化策略为异步周期性执行，并适当调整translog的刷盘周期。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;translog&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;durability&quot;</span>: <span class="string">&quot;async&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整refresh-interval"><a href="#调整refresh-interval" class="headerlink" title="调整refresh_interval"></a>调整refresh_interval</h3><p>写入Lucene的数据，并不是实时可搜索的，ES必须通过refresh的过程把内存中的数据转换成Lucene的完整segment后，才可以被搜索。默认情况下，ES每一秒会refresh一次，产生一个新的segment，这样会导致产生的segment较多，从而segment merge较为频繁，系统开销较大。如果对数据的实时可见性要求较低，可以通过下面的命令提高refresh的时间间隔，降低系统开销。</p>
<p><code>PUT my_index&#123;  &quot;settings&quot;: &#123;    &quot;index&quot;: &#123;        &quot;refresh_interval&quot; : &quot;30s&quot;    &#125;  &#125;&#125;</code></p>
<h3 id="merge并发控制"><a href="#merge并发控制" class="headerlink" title="merge并发控制"></a>merge并发控制</h3><p>ES的一个index由多个shard组成，而一个shard其实就是一个Lucene的index，它又由多个segment组成，且Lucene会不断地把一些小的segment合并成一个大的segment，这个过程被称为merge。默认值是Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))，当节点配置的cpu核数较高时，merge占用的资源可能会偏高，影响集群的性能，可以通过下面的命令调整某个index的merge过程的并发度：</p>
<p><code>PUT /my_index/_settings&#123;    &quot;index.merge.scheduler.max_thread_count&quot;: 2&#125;</code></p>
<h3 id="写入数据不指定-id，让ES自动产生"><a href="#写入数据不指定-id，让ES自动产生" class="headerlink" title="写入数据不指定_id，让ES自动产生"></a>写入数据不指定_id，让ES自动产生</h3><p>当用户显示指定id写入数据时，ES会先发起查询来确定index中是否已经有相同id的doc存在，若有则先删除原有doc再写入新doc。这样每次写入时，ES都会耗费一定的资源做查询。如果用户写入数据时不指定doc，ES则通过内部算法产生一个随机的id，并且保证id的唯一性，这样就可以跳过前面查询id的步骤，提高写入效率。 所以，在不需要通过id字段去重、update的使用场景中，写入不指定id可以提升写入速率。基础架构部数据库团队的测试结果显示，无id的数据写入性能可能比有_id的高出近一倍，实际损耗和具体测试场景相关。</p>
<h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>对于数据量较大的index，一般会配置多个shard来分摊压力。这种场景下，一个查询会同时搜索所有的shard，然后再将各个shard的结果合并后，返回给用户。对于高并发的小查询场景，每个分片通常仅抓取极少量数据，此时查询过程中的调度开销远大于实际读取数据的开销，且查询速度取决于最慢的一个分片。开启routing功能后，ES会将routing相同的数据写入到同一个分片中（也可以是多个，由index.routingpartitionsize参数控制）。如果查询时指定routing，那么ES只会查询routing指向的那个分片，可显著降低调度开销，提升查询效率。 routing的使用方式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 写入PUT my_index/my_type/<span class="number">1</span>?routing=user1&#123;  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span>&#125;</span><br><span class="line"># 查询GET my_index/_search?routing=user1,user2 &#123;  <span class="attr">&quot;query&quot;</span>: &#123;    <span class="attr">&quot;match&quot;</span>: &#123;      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span>    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为string类型的字段选取合适的存储方式"><a href="#为string类型的字段选取合适的存储方式" class="headerlink" title="为string类型的字段选取合适的存储方式"></a>为string类型的字段选取合适的存储方式</h3><h4 id="存为text类型的字段（string字段默认类型为text）："><a href="#存为text类型的字段（string字段默认类型为text）：" class="headerlink" title="存为text类型的字段（string字段默认类型为text）："></a>存为text类型的字段（string字段默认类型为text）：</h4><pre><code>做分词后存储倒排索引，支持全文检索，可以通过下面几个参数优化其存储方式：
 -  norms：用于在搜索时计算该doc的_score（代表这条数据与搜索条件的相关度），如果不需要评分，可以将其关闭。
 - indexoptions：控制倒排索引中包括哪些信息（docs、freqs、positions、offsets）。对于不太注重score/highlighting的使用场景，可以设为 docs来降低内存/磁盘资源消耗。
 - fields: 用于添加子字段。对于有sort和聚合查询需求的场景，可以添加一个keyword子字段以支持这两种功能。

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;norms&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;index_options&quot;</span>: <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```    </span><br><span class="line">#### 存为keyword类型的字段</span><br><span class="line">不做分词，不支持全文检索。text分词消耗CPU资源，冗余存储keyword子字段占用存储空间。如果没有全文索引需求，只是要通过整个字段做搜索，可以设置该字段的类型为keyword，提升写入速率，降低存储成本。 设置字段类型的方法有两种：一是创建一个具体的index时，指定字段的类型；二是通过创建template，控制某一类index的字段类型。</span><br><span class="line"></span><br><span class="line">-  通过mapping指定 tags 字段为keyword类型</span><br><span class="line">```json</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> 通过template，指定my_index*类的index，其所有string字段默认为keyword类型<br>PUT _template/my_template<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;order&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;template&quot;</span>: <span class="string">&quot;my_index*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_default_&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="attr">&quot;strings&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查询时，使用query-bool-filter组合取代普通query"><a href="#查询时，使用query-bool-filter组合取代普通query" class="headerlink" title="查询时，使用query-bool-filter组合取代普通query"></a>查询时，使用query-bool-filter组合取代普通query</h3><p>默认情况下，ES通过一定的算法计算返回的每条数据与查询语句的相关度，并通过score字段来表征。但对于非全文索引的使用场景，用户并不care查询结果与查询条件的相关度，只是想精确的查找目标数据。此时，可以通过query-bool-filter组合来让ES不计算score，并且尽可能的缓存filter的结果集，供后续包含相同filter的查询使用，提高查询效率。</p>
<ul>
<li>普通查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot; : &#123; &quot;user&quot; : &quot;Kimchy&quot; &#125;   &#125;&#125;</code></li>
<li>query-bool-filter 加速查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123; &quot;user&quot;: &quot;Kimchy&quot; &#125;      &#125;    &#125;  &#125;&#125;</code></li>
</ul>
<h3 id="index按日期滚动，便于管理"><a href="#index按日期滚动，便于管理" class="headerlink" title="index按日期滚动，便于管理"></a>index按日期滚动，便于管理</h3><p>写入ES的数据最好通过某种方式做分割，存入不同的index。<br>常见的做法是将数据按模块/功能分类，写入不同的index，然后按照时间去滚动生成index。这样做的好处是各种数据分开管理不会混淆，也易于提高查询效率。<code>同时index按时间滚动，数据过期时删除整个index，要比一条条删除数据或deletebyquery效率高很多</code>，因为删除整个index是直接删除底层文件，而deletebyquery是查询-标记-删除。</p>
<p>举例说明，假如有[modulea,moduleb]两个模块产生的数据，那么index规划可以是这样的：一类index名称是modulea + {日期}，另一类index名称是module_b+ {日期}。对于名字中的日期，可以在写入数据时自己指定精确的日期，也可以通过ES的ingest pipeline中的index-name-processor实现（会有写入性能损耗）。</p>
<h3 id="按需控制index的分片数和副本数"><a href="#按需控制index的分片数和副本数" class="headerlink" title="按需控制index的分片数和副本数"></a>按需控制index的分片数和副本数</h3><p>分片（shard）：一个ES的index由多个shard组成，每个shard承载index的一部分数据。</p>
<p>副本（replica）：index也可以设定副本数（numberofreplicas），也就是同一个shard有多少个备份。对于查询压力较大的index，可以考虑提高副本数（numberofreplicas），通过多个副本均摊查询压力。</p>
<p>shard数量（numberofshards）设置过多或过低都会引发一些问题：shard数量过多，则批量写入/查询请求被分割为过多的子写入/查询，导致该index的写入、查询拒绝率上升；对于数据量较大的inex，当其shard数量过小时，无法充分利用节点资源，造成机器资源利用率不高 或 不均衡，影响写入/查询的效率。</p>
<p>对于每个index的shard数量，可以根据数据总量、写入压力、节点数量等综合考量后设定，然后根据数据增长状态定期检测下shard数量是否合理。基础架构部数据库团队的推荐方案是：</p>
<p>对于数据量较小（100GB以下）的index，往往写入压力查询压力相对较低，一般设置3<del>5个shard，numberofreplicas设置为1即可（也就是一主一从，共两副本） 。<br>对于数据量较大（100GB以上）的index：<br>一般把单个shard的数据量控制在（20GB</del>50GB）<br>让index压力分摊至多个节点：可通过index.routing.allocation.totalshardsper_node参数，强制限定一个节点上该index的shard数量，让shard尽量分配到不同节点上<br>综合考虑整个index的shard数量，如果shard数量（不包括副本）超过50个，就很可能引发拒绝率上升的问题，此时可考虑把该index拆分为多个独立的index，分摊数据量，同时配合routing使用，降低每个查询需要访问的shard数量。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#elasticsearch" >
    <span class="tag-code">elasticsearch</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/wiki/%E4%BF%AE%E6%94%B9mysql%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/">
        <span class="nav-arrow">← </span>
        
          修改mysql表创建时间
        
      </a>
    
    
      <a class="nav-right" href="/wiki/%E5%90%AF%E5%8A%A8ELK%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/">
        
          启动ELK脚本命令
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Linux%E4%BC%98%E5%8C%96"><span class="toc-nav-text">Linux优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%85%B3%E9%97%AD%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E7%BD%AE%E6%8D%A2%E9%99%8D%E4%BD%8E%E6%80%A7%E8%83%BD%E3%80%82"><span class="toc-nav-text">关闭交换分区，防止内存置换降低性能。</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E9%80%89%E9%A1%B9"><span class="toc-nav-text">磁盘挂载选项</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E4%BA%8ESSD%E7%A3%81%E7%9B%98%EF%BC%8C%E9%87%87%E7%94%A8%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-nav-text">对于SSD磁盘，采用电梯调度算法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ES%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">ES节点配置</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%80%82%E5%BD%93%E5%A2%9E%E5%A4%A7%E5%86%99%E5%85%A5buffer%E5%92%8Cbulk%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%EF%BC%8C%E6%8F%90%E9%AB%98%E5%86%99%E5%85%A5%E6%80%A7%E8%83%BD%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-nav-text">适当增大写入buffer和bulk队列长度，提高写入性能和稳定性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%AE%A1%E7%AE%97disk%E4%BD%BF%E7%94%A8%E9%87%8F%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%80%83%E8%99%91%E6%AD%A3%E5%9C%A8%E6%90%AC%E8%BF%81%E7%9A%84shard"><span class="toc-nav-text">计算disk使用量时，不考虑正在搬迁的shard</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%89-ES%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">三 ES使用方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AD%98%E5%82%A8%E9%80%89%E9%A1%B9"><span class="toc-nav-text">控制字段的存储选项</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#StoreFiled"><span class="toc-nav-text">StoreFiled</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#source%E5%8F%AA%E5%AD%98%E5%82%A8%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5"><span class="toc-nav-text">_source只存储部分字段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#docvalues-%E6%8E%A7%E5%88%B6%E5%88%97%E5%AD%98%E3%80%82"><span class="toc-nav-text">docvalues 控制列存。</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ndex%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E3%80%82"><span class="toc-nav-text">ndex：控制倒排索引。</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#allES%E7%9A%84%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-nav-text">allES的一个特殊的字段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#fieldnames"><span class="toc-nav-text">fieldnames</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%BC%80%E5%90%AF%E6%9C%80%E4%BD%B3%E5%8E%8B%E7%BC%A9"><span class="toc-nav-text">开启最佳压缩</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bulk%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5"><span class="toc-nav-text">bulk批量写入</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%B0%83%E6%95%B4translog%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-nav-text">调整translog同步策略</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%B0%83%E6%95%B4refresh-interval"><span class="toc-nav-text">调整refresh_interval</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#merge%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-nav-text">merge并发控制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%8C%87%E5%AE%9A-id%EF%BC%8C%E8%AE%A9ES%E8%87%AA%E5%8A%A8%E4%BA%A7%E7%94%9F"><span class="toc-nav-text">写入数据不指定_id，让ES自动产生</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#routing"><span class="toc-nav-text">routing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BAstring%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">为string类型的字段选取合适的存储方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%AD%98%E4%B8%BAtext%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%88string%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B%E4%B8%BAtext%EF%BC%89%EF%BC%9A"><span class="toc-nav-text">存为text类型的字段（string字段默认类型为text）：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8query-bool-filter%E7%BB%84%E5%90%88%E5%8F%96%E4%BB%A3%E6%99%AE%E9%80%9Aquery"><span class="toc-nav-text">查询时，使用query-bool-filter组合取代普通query</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#index%E6%8C%89%E6%97%A5%E6%9C%9F%E6%BB%9A%E5%8A%A8%EF%BC%8C%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86"><span class="toc-nav-text">index按日期滚动，便于管理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%8C%89%E9%9C%80%E6%8E%A7%E5%88%B6index%E7%9A%84%E5%88%86%E7%89%87%E6%95%B0%E5%92%8C%E5%89%AF%E6%9C%AC%E6%95%B0"><span class="toc-nav-text">按需控制index的分片数和副本数</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/wiki/elasticsearch调优实践-0/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>