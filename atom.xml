<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="https://github.com/geekibli/geekibli.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/geekibli/geekibli.github.io/"/>
  <updated>2021-07-04T08:47:38.792Z</updated>
  <id>https://github.com/geekibli/geekibli.github.io/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拥塞避免</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D/</id>
    <published>2021-07-04T08:46:13.000Z</published>
    <updated>2021-07-04T08:47:38.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h1><p>拥塞控制的慢启动是以指数方式快速的通过试探来扩大拥塞窗口的，但是一旦发生网络丢包，则肯定是很多报文段都会都是，因为窗口时称被增长的；为了解决这种问题，需要引入– 拥塞避免</p><h2 id="什么是拥塞避免"><a href="#什么是拥塞避免" class="headerlink" title="什么是拥塞避免"></a>什么是拥塞避免</h2><p>拥塞避免为了解决慢启动下，当拥塞窗口超出网络带宽时发生的大量丢包问题，它提出一个「慢启动阈值」的概念，当拥塞窗口到达这个阈值之后，不在以指数方式增长，而选择涨幅比较缓慢的「线性增长」，计算方式：</p><blockquote><p>w cwnd += SMSS*SMSS/cwnd</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-e56d8072b2a74fa9b18ff6ca2d605405d2f.png" width=760 height=360><p>当拥塞窗口在线性增长时发生丢包，将慢启动阈值设置为当前窗口的一半，慢启动窗口恢复初始窗口（init wnd）；</p><blockquote><p>i 拥塞避免和慢启动是结合使用的，当发生网络丢包是，拥塞控制采用快速重传和快速启动来解决丢包问题！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拥塞避免&quot;&gt;&lt;a href=&quot;#拥塞避免&quot; class=&quot;headerlink&quot; title=&quot;拥塞避免&quot;&gt;&lt;/a&gt;拥塞避免&lt;/h1&gt;&lt;p&gt;拥塞控制的慢启动是以指数方式快速的通过试探来扩大拥塞窗口的，但是一旦发生网络丢包，则肯定是很多报文段都会都是，因为窗口时称被</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP-四次挥手/断开连接</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-07-04T08:34:11.000Z</published>
    <updated>2021-07-04T08:47:31.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h1><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="https://oscimg.oschina.net/oscnet/up-8d9a6b405e874bc02b91e453bd277c46d46.png" width=450 height=550><ul><li>开始客户端和服务端都是处理【established】状态</li><li>客户端发送「FIN」报文之后，进入FIN-WAIT-1状态</li><li>服务端收到客户端的FIN之后，恢复一个ACK，同时进入CLOSE_WAIT状态</li><li>客户端接收到ACK之后，进入到FIN-WAIT-2状态</li><li>服务端接着发送FIN报文，同时进入LAST-ACK状态</li><li>客户端接收到服务端的FIN报文之后，发送ACK报文，并进入TIME_WAIT状态</li><li>客户端在经历2个MSL时间之后，进入CLOSE状态</li><li>服务端接收到客户端的ACK之后，进入CLOSE状态</li></ul><blockquote><p>i 并不是所有的四次挥手都是上述流程，当客户端和服务端同时发送关闭连接的请求如下👇：</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-d859884b062bda56a946ae9e3c0c148235b.png" width=450 height=550><p>可以看到双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。</p><blockquote><p>i 挥手一定需要四次吗？</p></blockquote><p>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。<br>等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。<br>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？</p><blockquote><p>i 为什么要有 TIME_WAIT?</p></blockquote><p>断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。</p><blockquote><p>w <font color=red >那么为什么要等 2MSL 呢？</font></p></blockquote><ul><li>就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。</li><li>假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</li></ul><blockquote><p>i 等待 2MSL 会产生什么问题？</p></blockquote><p>如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。<br>如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP断开连接&quot;&gt;&lt;a href=&quot;#TCP断开连接&quot; class=&quot;headerlink&quot; title=&quot;TCP断开连接&quot;&gt;&lt;/a&gt;TCP断开连接&lt;/h1&gt;&lt;h2 id=&quot;四次挥手&quot;&gt;&lt;a href=&quot;#四次挥手&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>快速重传/快速恢复</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/</id>
    <published>2021-07-04T08:33:35.000Z</published>
    <updated>2021-07-04T08:47:36.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h1><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><blockquote><p>d 为何会接收到以个失序数据段？ </p></blockquote><ul><li>若报文丢失，将会产生连续的失序ACK段 </li><li>若网络路径与设备导致数据段失序，将会产生少量的失序ACK段</li><li>若报文重复，将会产生少量的失序ACK段</li></ul><img src="https://oscimg.oschina.net/oscnet/up-eaadaebd682089bdd3919de4f0d232749dc.png" width=450 height= 520><ul><li>当发送端发送pkt0是正常的，由于滑动窗口为满，发送方可以继续发送pkt1，pkt2；</li><li>加入pkt1发生了丢包，虽然pkt2接收端接收成功了，但是没有pkt1的数据段，接收端还是发送ACK1的确认报文；</li><li>在没有「快速重传」的情况下，发送端需要等到RTO之后，才可以重新发送pkt1</li><li>重传成功之后，接收端其实收到了pkt2之前的所有数据段，所以发送ACK3的确认报文<blockquote><p>w 这种需要等待RTO才可以重传的方式效率是比较低的，因此需要快速重传来进行优化；</p></blockquote></li></ul><h2 id="快速重传和累积确认"><a href="#快速重传和累积确认" class="headerlink" title="快速重传和累积确认"></a>快速重传和累积确认</h2><img src="https://oscimg.oschina.net/oscnet/up-9da669c35316aafb318674d3364ea07d72d.png" width=450 height=520><p>当发送方连续发送pkt3，pkt4，pkt5，pkt6四个数据端，但是pkt5在网络中丢包了，那后面发送的pkt6，pkt7，pkt8的确认报文都返回ACK5，希望发送方吃昂传pkt5的数据段；这个时候，发送方收到连续3个相同的确认报文，便立即重新发送pkt5的数据段；</p><blockquote><p>i 接收方:</p></blockquote><ul><li>当接收到一个失序数据段时，立刻发送它所期待的缺口 ACK 序列号</li><li>当接收到填充失序缺口的数据段时，立刻发 送它所期待的下一个 ACK 序列号</li></ul><blockquote><p>i 发送方</p></blockquote><ul><li>当接收到3个重复的失序 ACK 段(4个相同的失序ACK段)时，不再等待重传定时器的触发，立刻基于快速重传机制重发报文段</li></ul><p>当pkt5重新发送并被接收端接收之后，接收端发送ACK9的确认报文，而不是再分别发送ACK6，ACK7，ACK8，这个称谓「 <strong><font color=red>累计确认</font></strong> 」。</p><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><blockquote><p>i 快速重传下一定要进入慢启动吗?</p></blockquote><p>接受端收到重复ACK，意味着网络仍在流动，而如果要重新进入慢启动，会导致网络突然减少数据流，拥塞窗口恢复初始窗口，所以，「<strong>在快速恢复下发生丢包的场景下</strong>」，应该使用快速恢复，简单的讲，就是将慢启动阈值设置成当前拥塞窗口的一半，而拥塞窗口也适当放低，而不是一下字恢复到初始窗口大小；</p><img src="https://oscimg.oschina.net/oscnet/up-4a7f76cb315a13d1d905f2bfb3a376db087.png" ><p>快速恢复的流程如上图👆所示！</p><blockquote><p>w 快速恢复的具体操作：</p></blockquote><ul><li>将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上 3*MSS</li><li>每收到一个重复 ACK，cwnd 增加 1 个 MSS</li><li>当新数据 ACK 到达后，设置 cwnd 为 ssthresh</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速重传和快速恢复&quot;&gt;&lt;a href=&quot;#快速重传和快速恢复&quot; class=&quot;headerlink&quot; title=&quot;快速重传和快速恢复&quot;&gt;&lt;/a&gt;快速重传和快速恢复&lt;/h1&gt;&lt;h2 id=&quot;快速重传&quot;&gt;&lt;a href=&quot;#快速重传&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP-拥塞控制之慢启动</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%85%A2%E5%90%AF%E5%8A%A8/</id>
    <published>2021-07-04T08:33:19.000Z</published>
    <updated>2021-07-04T08:44:47.627Z</updated>
    
    <content type="html"><![CDATA[<p>由于TCP是面向字节流的传输协议，可以发送不定长的字节流数据，TCP连接发送数据时会“先天性”尝试占用整个带宽，而当所有的TCP连接都尝试占用网络带宽时，就会造成网络的堵塞，而TCP慢启动算法则是为了解决这一场景；</p><h2 id="全局思考"><a href="#全局思考" class="headerlink" title="全局思考"></a>全局思考</h2><img src="https://oscimg.oschina.net/oscnet/up-b70475e1aadd0776c54efdd5ecf26ef2606.png" width=700 height=400><p>拥塞控制要面向整体思考，如上👆网络拓扑图，当左边的网络节点通过路由交换设备向右边的设备传输报文的时候，中间的某一链路的带宽肯定是一定的，这里假设1000M带宽，当左边R1以700Mb/s的速度向链路中发送数据，同时R2以600Mb/s的速率发送报文，那势必会有300Mb的数据报丢失；「路由交换设备基于存储转发来实现报文的发送」大量报文都是时，路由设备的缓冲队列肯定是慢的，这也会造成某些数据报在网络链路中停留时间过长，从而导致TCP通讯变慢，甚至网络瘫痪；</p><p>理想的情况下，当链路带宽占满以后，链路以最大带宽传输数据，当然显示中是不可能的，当发生轻度拥塞时，链路的吞吐量就开始下降了，发展到严重阻塞时，链路的吞吐量会严重地下降，甚至瘫痪；</p><p>那么，慢启动是如何发挥作用的呢？</p><h2 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h2><blockquote><p>s 拥塞窗口cwnd(congestion window)</p></blockquote><ul><li>通告窗口rwnd(receiver‘s advertised window) <blockquote><p>其实就是RCV.WND，标志在TCP首部的Window字段！</p></blockquote></li><li>发送窗口swnd = min(cwnd，rwnd)<blockquote><p>前面学习滑动窗口的时候提到发送窗口大致等于接受窗口，当引入拥塞窗口时，发送窗口就是拥塞窗口和对方接受窗口的最小值</p></blockquote></li></ul><img src="https://oscimg.oschina.net/oscnet/up-4fffa8af1fb99c1ce534085f112fa9f065c.png" width=360 height=360><blockquote><p>i 每收到一个ACK，cwnd扩充一倍</p></blockquote><p>慢启动的窗口大小如何设置呢？<br>如上所示，起初拥塞窗口设置成1个报文段大小，当发送端发送一个报文段并且没有发生丢包时，调整拥塞窗口为2个报文段大小，如果还没有发生丢包，一次类推，知道发生丢包停止；发送窗口以「指数」的方式扩大；慢启动是无法确知网络拥塞程度的情况下，以试探性地方式快速扩大拥塞窗口；</p><h2 id="慢启动初始窗口"><a href="#慢启动初始窗口" class="headerlink" title="慢启动初始窗口"></a>慢启动初始窗口</h2><p>慢启动的拥塞窗口真的就如上面所说的以一个报文段大小作为初始值吗？  </p><img src="https://oscimg.oschina.net/oscnet/up-e632e6592fd276be90e5cf65a8365b3ddfb.png" width=360 height=360>  <blockquote><p>w 慢启动初始窗口 IW(Initial Window)的变迁</p></blockquote><ul><li>1 SMSS:RFC2001(1997)</li><li>2 - 4 SMSS:RFC2414(1998)<blockquote><p>IW = min (4<em>SMSS, max (2</em>SMSS, 4380 bytes))</p></blockquote></li><li>10 SMSS:RFC6928(2013)<blockquote><p>IW = min (10<em>MSS, max (2</em>MSS, 14600))</p></blockquote></li></ul><blockquote><p>w 其实在实际情况下，互联网中的网页都在10个mss左右，如果还是从1个mss开始，则会浪费3个RTT的时间；  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于TCP是面向字节流的传输协议，可以发送不定长的字节流数据，TCP连接发送数据时会“先天性”尝试占用整个带宽，而当所有的TCP连接都尝试占用网络带宽时，就会造成网络的堵塞，而TCP慢启动算法则是为了解决这一场景；&lt;/p&gt;
&lt;h2 id=&quot;全局思考&quot;&gt;&lt;a href=&quot;#全</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP-如何减少小报文提升网络效率</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B0%8F%E6%8A%A5%E6%96%87%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%95%88%E7%8E%87/</id>
    <published>2021-07-04T08:32:55.000Z</published>
    <updated>2021-07-04T08:47:34.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何减少小报文提升网络效率"><a href="#如何减少小报文提升网络效率" class="headerlink" title="如何减少小报文提升网络效率"></a>如何减少小报文提升网络效率</h1><p>每一个TCP报文段都包含20字节的IP头部和20字节的TCP首部，如果报文段的数据部分很少的话，网络效率会很差；</p><h2 id="SWS-Silly-Window-syndrome-糊涂窗口综合症"><a href="#SWS-Silly-Window-syndrome-糊涂窗口综合症" class="headerlink" title="SWS(Silly Window syndrome) 糊涂窗口综合症"></a>SWS(Silly Window syndrome) 糊涂窗口综合症</h2><image src="https://oscimg.oschina.net/oscnet/up-777275434842bda3be80da2687c4556ee3b.png" width=600 height=450 ><p>如上图👆所示场景，在之前的滑动窗口已经了解过，随着服务端处理连接数据能力越来越低，服务端的可用窗口不断压缩，最终导致窗口关闭；</p><h3 id="SWS-避免算法"><a href="#SWS-避免算法" class="headerlink" title="SWS 避免算法"></a>SWS 避免算法</h3><p>SWS 避免算法对发送方和接收方都做客</p><ul><li>接收方<blockquote><p>i David D Clark 算法:窗口边界移动值小于 min(MSS, 缓存/2)时，<br>通知窗口为 0</p></blockquote></li><li>发送方<blockquote><p>w Nagle 算法:<br>1、TCP_NODELAY 用于关闭 Nagle 算法<br>2、没有已发送未确认报文段时，立刻发送数据<br>3、存在未确认报文段时，直到:1-没有已发送未确认报文段，或者 2-数据长度达到MSS时再发送</p></blockquote></li></ul><h2 id="TCP-delayed-acknowledgment-延迟确认"><a href="#TCP-delayed-acknowledgment-延迟确认" class="headerlink" title="TCP delayed acknowledgment 延迟确认"></a>TCP delayed acknowledgment 延迟确认</h2><p>实际情况下，没有携带任何数据的ACK报文也会造成网络效率低下的，因为确认报文也包含40字节的头部信息，但仅仅是为了传输ACK=1这样的信息，为了解决这种情况，TCP有一种机制，叫做延迟确认，如下👇：</p><ul><li>当有响应数据要发送时,ack会随着响应数据立即发送给对方.</li><li>如果没有响应数据,ack的发送将会有一个延迟,以等待看是否有响应数据可以一起发送</li><li>如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack</li></ul><h3 id="那个延迟的时间如何设置呢？"><a href="#那个延迟的时间如何设置呢？" class="headerlink" title="那个延迟的时间如何设置呢？"></a>那个延迟的时间如何设置呢？</h3><image src="https://oscimg.oschina.net/oscnet/up-5933d7b1310c191603f366eb55669a7cdc8.png" width=400 height=250><p>上面👆是Linux操作系统对于TCP延时的定义。</p><p>HZ是什呢？其实那是和操作系统的时钟相关的，具体的操作系统间各有差别；<br>如何查看Linux操作系统下的HZ如何设置呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config- `-uname -r` | grep &#x27;^GONFIG_HZ=&#x27;</span><br></pre></td></tr></table></figure><h2 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h2><blockquote><p>sendfile 零拷贝技术</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何减少小报文提升网络效率&quot;&gt;&lt;a href=&quot;#如何减少小报文提升网络效率&quot; class=&quot;headerlink&quot; title=&quot;如何减少小报文提升网络效率&quot;&gt;&lt;/a&gt;如何减少小报文提升网络效率&lt;/h1&gt;&lt;p&gt;每一个TCP报文段都包含20字节的IP头部和20字节</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP-滑动窗口</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2021-07-04T08:32:40.000Z</published>
    <updated>2021-07-04T08:43:48.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>i 之前学习了PAR方式的TCP超时和重传，其实在考虑发送方发送数据报的同时，也应该考虑接收方对于数据的处理能力，由此引出本次学习的主题 – 滑动窗口</p></blockquote><h2 id="发送端窗口"><a href="#发送端窗口" class="headerlink" title="发送端窗口"></a>发送端窗口</h2><p>滑动窗口按照传输数据方向分为两种，发送端窗口和接收端窗口；下面先看一下发送端窗口👇：</p><image src="https://oscimg.oschina.net/oscnet/up-13e77c53892b884d334614e4fa9550a1113.png"><p>上图分为四个部分：</p><ol><li>已发送并收到 Ack 确认的数据:1-31 字节</li><li>已发送未收到 Ack 确认的数据:32-45 字节</li><li>未发送但总大小在接收方处理范围内:46-51 字节</li><li>未发送但总大小超出接收方处理范围:52-字节</li></ol><h3 id="可用窗口和发送窗口"><a href="#可用窗口和发送窗口" class="headerlink" title="可用窗口和发送窗口"></a>可用窗口和发送窗口</h3><image src="https://oscimg.oschina.net/oscnet/up-b8bb072922232fe6d62aec3520647d869fe.png"> <p>如上图这里可以引出两个概念：「可用窗口」和「发送窗口」</p><blockquote><p>s 【 <strong>可用窗口</strong> 】： 就是上图中的第三部分，属于还未发送，但是在接收端可以处理范围内的部分；<br>【 <strong>发送窗口</strong> 】： 就是发送端可以发送的最大报文大小，如上图中的第二部分+第三部分合成发送窗口；</p></blockquote><h3 id="可用窗口耗尽"><a href="#可用窗口耗尽" class="headerlink" title="可用窗口耗尽"></a>可用窗口耗尽</h3><image src="https://oscimg.oschina.net/oscnet/up-333b88e14f6fd5833fd92a9ab45894e60dd.png"> <p>可用窗口会在一个短暂的停留，当处于未发送并且接受端可以接受范围内的数据传输完成之后，可用窗口耗尽；<br>当然上面仅仅说的一瞬时的状态，这个状态下，已经发送的报文段还没有确认，并且发送窗口大小没有发生变化，此时发送窗口达到最大状态；</p><h3 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h3><image src="https://oscimg.oschina.net/oscnet/up-4436cdb5c6720e3e4a262ec1cad64660a77.png">  <p>如果在发送窗口中已经发送的报文段已经得到接受端确认之后，那部分数据就会被移除发送窗口，在发送窗口大小不发生变化的情况下，发送窗口向右➡️移动5个字节，因为左边已经发送的5个字节得到确认之后，被移除发送窗口；</p><h3 id="可用窗口如何计算"><a href="#可用窗口如何计算" class="headerlink" title="可用窗口如何计算"></a>可用窗口如何计算</h3><image src="https://oscimg.oschina.net/oscnet/up-76f97fc92f6940c7197ff9fcad3c187fd98.png"><p>再次引出三个概念：</p><ul><li>SND.WND<blockquote><p>i SND 指的是发送端，WND指的是window，也就是发送端窗口的意思</p></blockquote></li><li>SND.UNA<blockquote><p>i UNA 就是un ACK的意思，指的是已经发送但是没有没有确认 它指向窗口的第一个字节处</p></blockquote></li><li>SND.NXT<blockquote><p>i NXT 是next的位置，是发送方接下来要发送的位置，它指向可用窗口的第一个字节处</p></blockquote></li></ul><p><strong>那就很容易得出可用窗口的大小了，计算公式如下：</strong></p><blockquote><p>i Usable Window Size = SND.UNA + SND.WND - SND.NXT </p></blockquote><h2 id="接收端窗口"><a href="#接收端窗口" class="headerlink" title="接收端窗口"></a>接收端窗口</h2><p>上面介绍了发送端窗口的一些概念，下面👇是接收端窗口的学习：</p><image src="https://oscimg.oschina.net/oscnet/up-0313775eaecc790ad26b44c3daa17ced593.png"><ol><li>已经接收并且已经确认 :28-31 字节</li><li>还未接收并且接收端可以接受:32-51 字节</li><li>还未接收并且超出接收处理能力:51-57 字节</li></ol><p>这里引出两个概念：</p><ul><li>RCV.WND<blockquote><p>i RCV是接收端的意思，WND是接受端窗口的大小</p></blockquote></li><li>RCV.NXT<blockquote><p>i NXT表示的是接受端接收窗口的开始位置，也就是接收方接下来处理的第一个字节；</p></blockquote></li></ul><p>RCV.WND的大小接受端的内存以及缓冲区大小有关，在某种意义上说，接受端的窗口大小和发送端大小大致相同；<br>接受端可接收的数据能力可以通过TCP首部的Window字段设置，但是接受端的处理能力是可能随时变化的，所以接受端和服务端的窗口大小大致是一样的；</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>下面👇根据一个例子来阐述流量控制，模拟一个GET请求，客户端向服务端请求一个260字节的文件，大致流程如下，比较繁琐：</p><image src="https://oscimg.oschina.net/oscnet/up-08e7b2cd9ee3ddaa44bca900a1824e08b09.png" width=900 height=480> <blockquote><p>s 这里假设MSS和窗口的大小不发生变化，同时客户端和发送端状态如下：<br>【 客户端 】： 发送窗口默认360字节 接收窗口设定200字节<br>【 服务端 】： 发送窗口设定200字节 接收窗口设定360字节</p></blockquote><p>Step1： 客户端发送140字节的数据到服务端</p><blockquote><p>i 【客户端】发送140字节，【SND.NXT】从1-&gt;141 </p></blockquote><blockquote><p>w 【服务端】状态不变，等待接收客户端传输的140字节</p></blockquote><p>Step2: 服务端接收140字节，发送80字节响应以及ACK</p><blockquote><p>i 【 客户端 】发送140字节之后等待【 服务端 】的ACK</p></blockquote><blockquote><p>w【 服务端 】可用窗口右移，【RCV.NXT】从1-&gt;141<br>【 服务端 】发送80字节数据，【SND.NXT】从241-&gt;321</p></blockquote><p>Step3: 客户端接收响应ACK，并且发送ACK </p><blockquote><p>i 【 客户端 】发出的140字节得到确认，【SND.UNA】右移140字节<br>【 客户端 】接收80字节数据，【RCV.NXT】右移80字节，从241-&gt;321</p></blockquote><p>Step4: 服务端发送一个280字节的文件，但是280字节超出了客户端的接收窗口，所以客户端分成两部分传输，先传输120字节；</p><blockquote><p>w 【 服务端 】发送120字节，【SND.NXT】向右移动120字节，从321-&gt;441</p></blockquote><p>Step5: 客户端接收文件第一部分，并发送ACK</p><blockquote><p>i 【 客户端 】接收120字节，【RCV.NXT】从321-&gt;441</p></blockquote><p>Step6：服务端接收到第二步80字节的ACK</p><blockquote><p>w [ 服务器 ] 80字节得到ACK 【SND.UNA】从241-&gt;321</p></blockquote><p>Step7: 服务端接收到第4步的确认</p><blockquote><p>w 【 服务端 】之前发送文件第一部分的120字节得到确认，【SND.UNA】右移动120，从321-&gt;441</p></blockquote><p>Step8: 服务端发送文件第二部分的160字节</p><blockquote><p>w 【 服务端 】： 发送160字节，【SND.NXT】向右移动160字节，从441-&gt;601</p></blockquote><p>Step9: 客户端接收到文件第二部分160字节，同时发送ACK</p><blockquote><p>i 【 客户端 】接收160字节，【RCV.NXT】向右移动160字节，从441-&gt;601</p></blockquote><p>Step10: 服务端收到文件第二部分的ACK</p><blockquote><p>w 【 服务端 】发送的160字节得到确认，【SND.UNA】向右一定160字节，从441-&gt;601；至此客户端收到服务端发送的完整的文件；</p></blockquote><p>上面通过表格列举服务端和客户端每个状态在每个步骤的状态，如果不是很好理解，可以看如下示意图辅助理解：</p><h3 id="客户端交互流程"><a href="#客户端交互流程" class="headerlink" title="客户端交互流程"></a>客户端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-6ee487f0677efac1a822207f45fc0a2b842.png" width=500 ><h3 id="服务端交互流程"><a href="#服务端交互流程" class="headerlink" title="服务端交互流程"></a>服务端交互流程</h3><image src="https://oscimg.oschina.net/oscnet/up-4a0095fb6e7a82a708e4df96dfdacd956aa.png" width="500"> <p>上面👆是模拟一个GET请求，服务端发送一个280字节的文件给到客户端，客户端的接收窗口是200字节场景加，客户端和服务端的数据传输与交互流程，通过这个流程来学习滑动窗口的移动状态和流量控制的大致流程；</p><h2 id="滑动窗口与操作系统缓冲区"><a href="#滑动窗口与操作系统缓冲区" class="headerlink" title="滑动窗口与操作系统缓冲区"></a>滑动窗口与操作系统缓冲区</h2><p>上面👆讲述的时候，都是假设窗口大小是不变的，而实际上，发送端和接受端的滑动窗口的字节数都吃存储在操作系统缓冲区的，操作系统的缓冲区受操作系统控制，当应用进程增加是，每个进程分配的内存减少，缓冲区减少，分配给每个连接的窗口就会压缩。**<font color="red">而且滑动窗口的大小也受应用进程读取缓冲区数据速度有关</font>**；</p><image src="https://oscimg.oschina.net/oscnet/up-3839118daafc840e059fa6f82d283bef7a9.png" width="500">   <h3 id="应用进程读取缓冲区数据不及时造成窗口收缩"><a href="#应用进程读取缓冲区数据不及时造成窗口收缩" class="headerlink" title="应用进程读取缓冲区数据不及时造成窗口收缩"></a>应用进程读取缓冲区数据不及时造成窗口收缩</h3><p>step1: 客户端发送140字节</p><blockquote><p>i 客户端发送到140字节之后，可用窗口收缩到220字节，发送窗口不变</p></blockquote><p>Step2: 服务端接收140字节 但是应用进程仅仅读取40字节</p><blockquote><p>w 服务端应用进程仅仅读取40字节，仍有100字节占用缓冲区大小，导致接受窗口收缩，服务端发送ACK报文时，在首部Window带上接收窗口的大小260</p></blockquote><p>Step3: 客户端收到确认报文之后，发送窗口收缩到260</p><p>Step4: 客户端继续发送180字节数据</p><blockquote><p>i 客户端发送180字节之后，可用窗口变成80字节</p></blockquote><p>Step5: 服务端接收到180字节</p><blockquote><p>w 假设应用程序仍然不读取这180字节，最终也导致服务端接收窗口再次收缩180字节，仅剩下80字节，在发送确认报文时，设置首部window=80</p></blockquote><p>Step6: 客户端收到80字节的窗口时，调整发送窗口大小为80字节，可用窗口也是80字节</p><p>Step7: 客户端仍然发送80字节到服务端，此时可用窗口为空</p><p>Step8: 服务端应用进程继续不读区这80字节的缓冲区数据，最终导致服务端接收窗口大小为0，不能再接收任何数据，同时发送ACK报文；</p><p>Step9：客户端收到确认报文之后，调整发送窗口大小为0，这个状态叫做「 <strong>窗口关闭</strong> 」</p><h3 id="窗口收缩导致的丢包"><a href="#窗口收缩导致的丢包" class="headerlink" title="窗口收缩导致的丢包"></a>窗口收缩导致的丢包</h3><image src="https://oscimg.oschina.net/oscnet/up-174e19d4d8de9757707034b8271cb3c69a7.png" width="530"><p>Step1：客户端服务端开始的窗口大小都是360字节，客户端发送140字节数据</p><blockquote><p>i 客户端发送140字节之后，可用窗口变成220字节</p></blockquote><p>Step2：服务端应用进程骤增，进程缓存区平均分配，造成服务端接收窗口减少，从360变成240字节；</p><blockquote><p>w 假设接收了140字节之后，应用进程没有读取，那个可用窗口进一步压缩，变成100字节；</p></blockquote><p>Step3：假设同一个连接在没有收到服务端确认之后，又发送了180个字节的数据（Retramission）</p><blockquote><p>i 先发送了140字节，后发送了180字节，都没有得到确认，客户端可用窗口大小变成40字节</p></blockquote><p>Step4：服务端收到上面👆第三步发送的180字节的数据，但是接受窗口的大小只有100字节，所以不能接收</p><blockquote><p>w 服务端拒绝接收180字节</p></blockquote><p>Step5：此时客户端才收到之前140字节的确认报文，才知道接收窗口发生了变化</p><blockquote><p>i 客户端由于没有收到180字节的确认，加入客户端正在准备发送180字节数据，得到接受端的窗口大小是100字节之后，须强制将右侧窗口向左收缩80字节；</p></blockquote><h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>这个例子和上面的例子都发生了「 <strong><font color="red">窗口关闭</font></strong> 」</p><blockquote><p>s 窗口关闭： 发送端的发送窗口变成0的状态；</p></blockquote><p>上面讲的两种情况一般不会发生的，因为操作系统不会既收缩窗口，同时减少连接缓存；而是一般先使用窗口收缩策略，之后在压缩缓冲区的方式来规避以上问题；<br>发生窗口关闭之后，发送端不会被动的等待服务端的通知，而是会采用定时嗅探的方式去查看服务端接收窗口是否开放；</p><h2 id="Linux中对TCP缓冲区的调整方式"><a href="#Linux中对TCP缓冲区的调整方式" class="headerlink" title="Linux中对TCP缓冲区的调整方式"></a>Linux中对TCP缓冲区的调整方式</h2><ul><li><p>net.ipv4.tcp_rmem = 4096 87380 6291456</p><blockquote><p>读缓存最小值、默认值、最大值，单位字节，覆盖 net.core.rmem_max</p></blockquote></li><li><p>net.ipv4.tcp_wmem = 4096 16384 4194304</p><blockquote><p>写缓存最小值、默认值、最大值，单位字节，覆盖net.core.wmem_max</p></blockquote></li><li><p>net.ipv4.tcp_mem = 1541646 2055528 3083292</p><blockquote><p>系统无内存压力、启动压力模式阀值、最大值，单位为页的数量</p></blockquote></li><li><p>net.ipv4.tcp_moderate_rcvbuf = 1 </p><blockquote><p>开启自动调整缓存模式</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;i 之前学习了PAR方式的TCP超时和重传，其实在考虑发送方发送数据报的同时，也应该考虑接收方对于</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP-RTO重传计数器的计算</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP-RTO%E9%87%8D%E4%BC%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97/</id>
    <published>2021-07-04T08:32:27.000Z</published>
    <updated>2021-07-04T08:43:21.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>i 之前的文章已经介绍了TCP超时重传的过程中使用了定时器的策略，当定时器规定时间内未收到确认报文之后，就会触发报文的重传，同时定时器复位；那么定时器超时时间（RTO Retramission Timeout）是如何计算的呢？</p></blockquote><h2 id="什么是RTT？"><a href="#什么是RTT？" class="headerlink" title="什么是RTT？"></a>什么是RTT？</h2><p>了解RTO如何计算之前，首先明确一个概念「 <strong>RTT</strong> 」；</p><image src="https://oscimg.oschina.net/oscnet/up-9b45623a3b0652d842ffa3eecea13e92183.png" width=550 height=400>   <p>如上图所示，从client发送第一个「SYN」报文，到Server接受到报文，并且返回「SYN ACK」报文之后，client接受到Server的「ACK」报文之后，client所经历的时间，叫做1个RTT时间；</p><h2 id="如何在重传下有效测量RTT？"><a href="#如何在重传下有效测量RTT？" class="headerlink" title="如何在重传下有效测量RTT？"></a>如何在重传下有效测量RTT？</h2><p><img src="https://oscimg.oschina.net/oscnet/up-6c558bfea1825bf5d3b2da74e087cdde43a.png"></p><p>如上图两种情况：<br>第一种，左侧a图所示，当一端发送的数据报丢失后要进行重传，到重传之后接收到确认报文之后，这种场景下该如何计算RTT呢？开始时间是按照第一次发送数据报时间呢还是按照重传数据报的时间呢？</p><blockquote><p>w 按照常理来说，如右侧b图所示，RTT时间应该以RTT2为准；</p></blockquote><p>第二种，左侧b图所示，第一次发送数据报文时，由于网络时延导致RTO时间内没有收到接收段的确认报文，发送端进行重发，但是在刚刚重发之后就收到了第一次报文的确认报文，那这种情况RTT该如何计算呢？</p><blockquote><p>w 如右侧a图所示，RTT时间应该以RTT1为准；</p></blockquote><p>就像上面提及的两种情况，一会以第一个RTT1为准，一会以RTT2为准，那么TCP协议如何正确的计算出RTT呢？</p><h2 id="使用Timestamp方式计算RTT"><a href="#使用Timestamp方式计算RTT" class="headerlink" title="使用Timestamp方式计算RTT"></a>使用Timestamp方式计算RTT</h2><p>之前的文章中在介绍TCP超时与重传的笔记中有介绍通过使用Timtstamp的方式来区分相同Seq序列号的不同报文，<br>其实在TCP报文首部存储Timestamp的时候，会存储报文的发送时间和确认时间，如下所示：<br><image src="https://oscimg.oschina.net/oscnet/up-ad80265bbba417c72a8d02a5c0be7be5f83.png" width=800 height=230> </p><h2 id="如何计算RTO？"><a href="#如何计算RTO？" class="headerlink" title="如何计算RTO？"></a>如何计算RTO？</h2><p>上面👆说到了RTT如何计算，那个RTO和RTT有什么关系呢？<br><image src="https://oscimg.oschina.net/oscnet/up-e25afa62f99830eb02c4c1df0c015dbde8a.png"><br> RTO的取值将会影响到TCP的传输效率以及网络的吞吐量；</p><blockquote><p>s 通常来说RTO应该略大于RTT，如果RTO小于RTT，则会造成发送端频繁重发，可能会造成网络阻塞；如果RTO设置的过大，则接受端已经收到确认报文之后的一段时间内仍然不能发送其他报文，会造成两端性能的浪费和网络吞吐量的下降；</p></blockquote><h3 id="平滑RTO"><a href="#平滑RTO" class="headerlink" title="平滑RTO"></a>平滑RTO</h3><p>网络的RTT是不断的变化的，所以计算RTO的时候，应当考虑RTO的平滑性，尽量避免RTT波动带来的干扰，以抵挡瞬时变化；</p><p><strong>平滑RTO在文档RFC793定义，给出如下计算方式：</strong></p><ul><li>SRTT (smoothed round-trip time) = ( α * SRTT ) + ((1 - α) * RTT)<blockquote><p>w α 从 0到 1(RFC 推荐 0.9)，越大越平滑</p></blockquote></li><li>RTO = min[ UBOUND, max[ LBOUND, (β * SRTT) ] ]<blockquote><p>w 如 UBOUND为1分钟，LBOUND为 1 秒钟， β从 1.3 到 2 之间 </p></blockquote></li></ul><p>这种计算方式不适用于 RTT 波动大(方差大)的场景,如果网络的RTT波动很大，会造成RTO调整不及时；</p><h3 id="追踪RTT方差计算RTO"><a href="#追踪RTT方差计算RTO" class="headerlink" title="追踪RTT方差计算RTO"></a>追踪RTT方差计算RTO</h3><blockquote><p>i RFC6298(RFC2988)，其中α = 1/8， β = 1/4，K = 4，G 为最小时间颗粒:</p></blockquote><ul><li><strong>首次计算 RTO，R为第 1 次测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SRTT(smoothed round-trip time) = R</span><br><span class="line">RTTVAR(round-trip time variation) = R/2</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li><li><strong>后续计算 RTO，R’为最新测量出的 RTT</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SRTT= (1-α)*SRTT+α*R’</span><br><span class="line">RTTVAR=(1-β)*RTTVAR+β*|SRTT-R’|</span><br><span class="line">RTO = SRTT + max (G, K*RTTVAR)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;i 之前的文章已经介绍了TCP超时重传的过程中使用了定时器的策略，当定时器规定时间内未收到确认报文之后，就会触发报文的重传，同时定时器复位；那么定时器超时时间（RTO Retramission Timeout）是如何计算的呢？&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP超时与重传</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</id>
    <published>2021-07-04T08:32:08.000Z</published>
    <updated>2021-07-04T08:42:50.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><image src="https://oscimg.oschina.net/oscnet/up-4f1230ee04f4c197dd5c6de167991878366.png" width=680 height=300><p>如上图👆所示，设备A向设备B发送消息，消息在网络中会由于各种各样的问题导致丢失，那么该如何解决上述问题呢？</p><h2 id="采用定时器重传"><a href="#采用定时器重传" class="headerlink" title="采用定时器重传"></a>采用定时器重传</h2><blockquote><p>i PAR：Positive Acknowledgment with Retransmission</p></blockquote><image src="https://oscimg.oschina.net/oscnet/up-17f5567e452afb45cf18d01e62bdfa33f96.png" width=680 height=330><p><strong>最简单的思路是在发送方设置「 定时器 」：</strong></p><ul><li>当设备A发送第一条消息之后，在定时器规定的时间内，如果收到设备B的确认报文，则设备A继续发送下一个报文，同时定时器复位；</li><li>如果第一条消息发送时间超出了定时器规定的时间，则设备A将重新发送第一条消息，同时重新设置定时器；</li><li>这种方式是串型发送的，只有第一个消息发送成功之后，才可以发送下一条消息，「 <strong>效率极差</strong> 」；</li></ul><h2 id="并发能力PAR"><a href="#并发能力PAR" class="headerlink" title="并发能力PAR"></a>并发能力PAR</h2><blockquote><p>i 基于上述PAR效率低下的方式进行改造，在发送端采用并发+定时器的方式进行数据发送；</p></blockquote><image src="https://oscimg.oschina.net/oscnet/up-96114b57ac73a41915bea1a7d11e0145102.png" width=600 height="500"><ul><li>首先设备A可以同时发送多个消息或者报文段，每个报文段具有一个标志字段【#XX】去标志唯一，每个报文段连接具有自己的定时器；</li><li>设备B规定时间内收到设备A发送的数据之后并且设备A得到设备B的确认之后，设备A将定时器清除</li><li>同PAR一样，设备B没有在规定的时间内发送确认报文，设备A将这个报文所对应的定时器复位，重新发送这个报文</li></ul><h3 id="并发发送带来的问题"><a href="#并发发送带来的问题" class="headerlink" title="并发发送带来的问题"></a>并发发送带来的问题</h3><p>采用并发的方式发送消息或者报文段固然提升了发送端的性能，但是发送端发送的消息可能接受端不能完全处理，<strong>这是双方报文处理速度或者效率不一致的问题</strong>；</p><p>所以对于接收端设备B，应该明确自己可能接受的数据量，并且在确认报文中同步到发送端设备A，设备A根据设备B的处理能力来调整发送数据的大小；也就是上图中的「 limit」；</p><h2 id="继续延伸"><a href="#继续延伸" class="headerlink" title="继续延伸"></a>继续延伸</h2><p>Sequment序列号和Ack序列号的设计理念或者设计初衷是「 <strong>解决应用层字节流的可靠发送</strong> 」 </p><ul><li>跟踪「应用层」的发送端数据是否送达</li><li>确定「接收端有序的」接收到「字节流」</li><li><strong>序列号的值针对的是字节而不是报文</strong> ⚠️⚠️⚠️</li></ul><blockquote><p>i TCP的定位就是面向字节流的！</p></blockquote><h2 id="TCP序列号如何设计的"><a href="#TCP序列号如何设计的" class="headerlink" title="TCP序列号如何设计的"></a>TCP序列号如何设计的</h2><image src="https://oscimg.oschina.net/oscnet/up-f5f274ec300162985b9bef86ebd94f6a81e.png" width=450 height=450><p>通过TCP报文头我们可以知道，Sequment序列号包括32位长度；也就是说一个Sequment可以发送2的32次方个字节，大约4G的数量，Sequment就无法表示了，当传输的数据超过“4G”之后，如果这个连接依然要使用的话，Sequment会重新复用；Sequment复用会产生一个问题，也就是序列号回绕；👇</p><h2 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h2><blockquote><p>i 序列号回绕 (Protect Against Wrapped Sequence numbers)</p></blockquote><image src="https://oscimg.oschina.net/oscnet/up-4edfd2031f0ec6ebdaa23c497e18df359cd.png" width=800 height=380><ul><li>当一个连接要发送6G的数据是，A、B、C、D分别发送1G的数据，如果继续使用此连接，E下一次发送数据1G，Seq序列号复用，E报文段的序列号和A报文段的序列号表示相同</li><li>按照上面的逻辑继续发送数据，F报文段的Seq标志和B报文段的是一样的；</li><li>加入B报文段在发送过程中丢失了，直到接受端接收了F报文段的同时B报文段到达接受端，接受端该如何区分相同Seq序列号不同数据的报文段呢？</li><li>其实TCP解决这个问题很简单，就是在每个报文段上添加Tcp Timestamp时间戳，类似于版本号的理念；</li><li>接收端收到相同Seq序列号的报文段是可以根据时间戳来进行区分；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;image src=&quot;https://oscimg.oschina.net/oscnet/up-4f1230ee04f4c197dd5c6de1</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP最大报文段（MSS）</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88MSS%EF%BC%89/</id>
    <published>2021-07-04T08:31:56.000Z</published>
    <updated>2021-07-04T08:42:16.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MSS产生的背景"><a href="#MSS产生的背景" class="headerlink" title="MSS产生的背景"></a>MSS产生的背景</h2><p>我们都知道TCP协议是运输在传输层的协议，它是面向【字节流】的传输协议；<br>它的上层，应用层传输的数据是无限制的，但是它的下层也就是网络层和链路层由于路由等转发设备有内存等限制是不可能无限制传输任何大小的报文的，它们一定会限制报文的长度，因此 <strong>TCP协议要完成的工作是将从应用层接受到的任意长度数据，切割成多个报文段，MSS就是如何切割报文段的依据。</strong></p><image src="https://oscimg.oschina.net/oscnet/up-004bb74a9d5648d949d9549219c677f568f.png" width=450 height=300><h2 id="什么是MSS"><a href="#什么是MSS" class="headerlink" title="什么是MSS"></a>什么是MSS</h2><p>MSS（Max Segment Size）：仅指 TCP 承载数据，不包含 TCP 头部的大小，参见 RFC879</p><h2 id="MSS-选择目的"><a href="#MSS-选择目的" class="headerlink" title="MSS 选择目的"></a>MSS 选择目的</h2><ul><li>尽量每个 Segment 报文段携带更多的数据，以减少头部空间占用比率 </li><li>防止 Segment 被某个设备的 IP 层基于 MTU 拆分<blockquote><p>s IP层基于MTU的数据拆分是效率极差的，一个报文段丢失，所有的报文段都要重传</p></blockquote></li></ul><h2 id="MSS默认大小"><a href="#MSS默认大小" class="headerlink" title="MSS默认大小"></a>MSS默认大小</h2><blockquote><p>s 默认 MSS:536 字节(默认 MTU576 字节，20 字节 IP 头部，20 字节 TCP 头部)</p></blockquote><h2 id="MSS在什么时候使用"><a href="#MSS在什么时候使用" class="headerlink" title="MSS在什么时候使用"></a>MSS在什么时候使用</h2><blockquote><p>s 握手阶段协商 MSS 这个在TCP三次握手的文章中已经提及过了！</p></blockquote><h2 id="MSS-分类"><a href="#MSS-分类" class="headerlink" title="MSS 分类"></a>MSS 分类</h2><ul><li><strong>发送方最大报文段:</strong> <blockquote><p>SMSS:SENDER MAXIMUM SEGMENT SIZE</p></blockquote></li><li><strong>接收方最大报文段:</strong> <blockquote><p>RMSS:RECEIVER MAXIMUM SEGMENT SIZE</p></blockquote></li></ul><h2 id="在TCP常用选项中可以看到【MSS】的选项"><a href="#在TCP常用选项中可以看到【MSS】的选项" class="headerlink" title="在TCP常用选项中可以看到【MSS】的选项"></a>在TCP常用选项中可以看到【MSS】的选项</h2><image src="https://oscimg.oschina.net/oscnet/up-c1229634eb30eaa7391516cbee75258c9e1.png" width=750 height=420><h2 id="TCP流与报文段在数据传输中的状态"><a href="#TCP流与报文段在数据传输中的状态" class="headerlink" title="TCP流与报文段在数据传输中的状态"></a>TCP流与报文段在数据传输中的状态</h2><image src="https://oscimg.oschina.net/oscnet/up-1a0015bf7b4d8481a4e624b0920bbb43917.png" width=450 height=620><p>从上图可以看到，左边客户端在发送字节流数据给到右边客户端，客户端发送一个连续的字节流，会在TCP层按照MSS大小规定进行拆分成多个小的报文段，分别传送到另一个客户端或者其他的接收端；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MSS产生的背景&quot;&gt;&lt;a href=&quot;#MSS产生的背景&quot; class=&quot;headerlink&quot; title=&quot;MSS产生的背景&quot;&gt;&lt;/a&gt;MSS产生的背景&lt;/h2&gt;&lt;p&gt;我们都知道TCP协议是运输在传输层的协议，它是面向【字节流】的传输协议；&lt;br&gt;它的上层，应</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2021-07-04T08:31:42.000Z</published>
    <updated>2021-07-04T08:53:09.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="握手🤝的目的"><a href="#握手🤝的目的" class="headerlink" title="握手🤝的目的"></a>握手🤝的目的</h2><ul><li>同步Sequence序列号<blockquote><p>i 初始化序<br>列号ISN （Inital Sequence Number）</p></blockquote></li><li>交换TCP通讯的参数<blockquote><p>i 比如最大报文段参数（MSS）、窗口比例因子（Window）、选择性确认（SACK）、制定校验和算法；</p></blockquote></li></ul><h2 id="三次握手握手过程"><a href="#三次握手握手过程" class="headerlink" title="三次握手握手过程"></a>三次握手握手过程</h2><image src="https://oscimg.oschina.net/oscnet/up-7ee7a8388d0fc3798344cad07f585bf7961.png" width=500 height=300><p>TCP三次握手的大致流程图如上👆  </p><p>使用tcpdump抓包分析三次🤝握手报文中Seq和Ack的变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump  port 80 -c 3 -S</span><br></pre></td></tr></table></figure><p><img src="https://sjwx.easydoc.xyz/47754217/files/kmov1k44.png" alt="image.png">  </p><h3 id="第一次握手🤝"><a href="#第一次握手🤝" class="headerlink" title="第一次握手🤝"></a>第一次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [S], seq 3800409106, win 29200, options [mss 1460,sackOK,TS val 839851765 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure><p>客户端upay访问服务端80端口，发送一个「 seq=3800409106 」 ，同时标志位SYN=1，声明此次握手是要建立连接；</p><h3 id="第二次握手🤝"><a href="#第二次握手🤝" class="headerlink" title="第二次握手🤝"></a>第二次握手🤝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP 100.100.15.23.http &gt; upay.60734: Flags [S.], seq 1981710286, ack 3800409107, win 14600, options [mss 1440,nop,nop,sackOK,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure><p>第二次握手，服务端收到客户端的申请连接强求（SYN=1）之后，在服务端自己准备好的情况下，给客户端发送 「 ACK=1 SYN=1 」的确认报文，SYN=1同样也是声明此次报文是建立连接的报文请求； ack= 3800409107 也就是第一个客户端发给服务端的seq+1（ack是接收方下次期望接口报文的开始位置）</p><h3 id="第三次握手握手"><a href="#第三次握手握手" class="headerlink" title="第三次握手握手"></a>第三次握手握手</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP upay.60734 &gt; 100.100.15.23.http: Flags [.], ack 1981710287, win 229, length 0</span><br></pre></td></tr></table></figure><p>客户端收到服务器返回的确认报文，确认可以进行连接，发送「 ack = 1981710287 」的确认报文，之后就完成了三次握手，TCP的连接就创建成功了，接下来双方就可以发送数据报了；</p><h2 id="TCP连接创建构成中状态的变更"><a href="#TCP连接创建构成中状态的变更" class="headerlink" title="TCP连接创建构成中状态的变更"></a>TCP连接创建构成中状态的变更</h2><image src="https://oscimg.oschina.net/oscnet/up-d6920a59ec1cb6a738265b6f182cbdbe2ba.png" width=550 height=400><ul><li>首先客户端和服务端都是【CLOSED】状态，客户端发起连接请求之后，进入【SYN-SENT】状态，这个状态维持的时间很短，我们使用netstat去查看tcp连接状态的时候，基本上都不会看到这个状态，而服务端是在【LISTEN】状态，等待客户端的请求；</li><li>服务端收到客户端请求之后，发送「SYN ACK」确认报文，同时服务端进入【SYN-RECEIVED】状态，等待客户端的确认报文；</li><li>客户端收到服务端的同步确认请求之后，发送「ACK」确认报文，同时进入【ESTABLISHED】状态，准备后续的数据传输；</li><li>服务端收到三次握手最后的确认报文之后，进入【ESTABLISHED】状态，至此，一个TCP连接算是建立完成了，后面就是双方的通信了；</li></ul><h2 id="TCB（Transmission-Control-Block）"><a href="#TCB（Transmission-Control-Block）" class="headerlink" title="TCB（Transmission Control Block）"></a>TCB（Transmission Control Block）</h2><blockquote><p>i 保存连接使用的源端口、目的端口、目的 ip、序号、 应答序号、对方窗口大小、己方窗口大小、tcp 状态、tcp 输入/输出队列、应用层输出队 列、tcp 的重传有关变量等</p></blockquote><h2 id="TCP性能优化和安全问题"><a href="#TCP性能优化和安全问题" class="headerlink" title="TCP性能优化和安全问题"></a>TCP性能优化和安全问题</h2><image src="https://oscimg.oschina.net/oscnet/up-e99592d430e1219134af66e69aee2e6ccbd.png"  width=550 height=400 ><p>正如我们了解的TCP三次握手🤝的流程，当有大量SYN请求到达服务端时，会进入到【SYN队列】，服务端收到第二次确认报文之后，会进入【ESTABLISHED】状态，服务端操作系统内核会将连接放入到【ACCEPT】队列中，当Nginx或者Tomcat这些应用程序在调用accept（访问内核）的时候，就是在【ACCEPT】队列中取出连接进行处理；</p><blockquote><p>w 由此可见，【SYN】队列和【ACCEPT】是会影响服务器连接性能的重要因素，所以对于高并发的场景下，这两个队列一定是要设置的比较大的；</p></blockquote><h3 id="如何设置SYN队列大小"><a href="#如何设置SYN队列大小" class="headerlink" title="如何设置SYN队列大小"></a>如何设置SYN队列大小</h3><p>服务器端 SYN_RCV 状态</p><ul><li>net.ipv4.tcp_max_syn_backlog:SYN_RCVD 状态连接的最大个数</li><li>net.ipv4.tcp_synack_retries:被动建立连接时，发SYN/ACK的重试次数</li></ul><p>客户端 SYN_SENT 状态（服务端作为客户端，比如Ngnix转发等）</p><ul><li>net.ipv4.tcp_syn_retries = 6 主动建立连接时，发 SYN 的重试次数</li><li>net.ipv4.ip_local_port_range = 32768 60999 建立连接时的本地端口可用范围</li></ul><h2 id="Fast-Open机制"><a href="#Fast-Open机制" class="headerlink" title="Fast Open机制"></a>Fast Open机制</h2><image src="https://oscimg.oschina.net/oscnet/up-071f997614b36eb8b4511db0f3ba0637d70.png" width=550 height=400 ><p>TCP如何对连接的次数以及连接时间进行优化的呢？这里提到Fast Open机制；<br>比如我们有一个Http Get请求，正常的三次握手🤝到收到服务端数据需要2个RTT的时间；FastOpen做出如下优化：</p><ul><li>第一次创建连接的时候，也是要经历2个RTT时间，但是在服务端发送确认报文的时候，在报文中添加一个cookie；</li><li>等到下次客户端再需要创建请求的时候，直接将【SYN】和cookie一并带上，可以一次就创建连接，经过一个RTT客户端就可以收到服务端的数据；</li></ul><h4 id="如何Linux上打开TCP-Fast-Open"><a href="#如何Linux上打开TCP-Fast-Open" class="headerlink" title="如何Linux上打开TCP Fast Open"></a>如何Linux上打开TCP Fast Open</h4><p> net.ipv4.tcp_fastopen:系统开启 TFO 功能 </p><ul><li>0:关闭</li><li>1:作为客户端时可以使用 TFO</li><li>2:作为服务器时可以使用 TFO</li><li>3:无论作为客户端还是服务器，都可以使用 TFO</li></ul><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><h4 id="什么是SYN攻击？"><a href="#什么是SYN攻击？" class="headerlink" title="什么是SYN攻击？"></a>什么是SYN攻击？</h4><p>  正常的服务通讯都是由操作系统内核实现的请求报文来创建连接的，但是，可以人为伪造大量不同IP地址的SYN报文，也就是上面👆状态变更图中的SYN请求，但是收到服务端的ACK报文之后，却不发送对于服务端的ACK请求，也就是没有第三次挥手，这样会造成大量处于【SYN-RECEIVED】状态的TCP连接占用大量服务端资源，导致正常的连接无法创建，从而导致系统崩坏；</p><h4 id="SYN攻击如何查看"><a href="#SYN攻击如何查看" class="headerlink" title="SYN攻击如何查看"></a>SYN攻击如何查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nap | grep SYN_RECV</span><br></pre></td></tr></table></figure><blockquote><p>w 如果存在大量【SYN-RECEIVED】的连接，就是发生SYN攻击了；</p></blockquote><h4 id="如何规避SYN攻击？"><a href="#如何规避SYN攻击？" class="headerlink" title="如何规避SYN攻击？"></a>如何规避SYN攻击？</h4><ul><li><p><strong>net.core.netdev_max_backlog</strong></p><blockquote><p>接收自网卡、但未被内核协议栈处理的报文队列长度</p></blockquote></li><li><p><strong>net.ipv4.tcp_max_syn_backlog</strong></p><blockquote><p>SYN_RCVD 状态连接的最大个数</p></blockquote></li><li><p><strong>net.ipv4.tcp_abort_on_overflow</strong></p><blockquote><p>超出处理能力时，对新来的 SYN 直接回包 RST，丢弃连接</p></blockquote></li><li><p>设置SYN Timeout</p><blockquote><p>由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下，可以成倍的降低服务器的负荷。但过低的SYN Timeout设置可能会影响客户的正常访问。</p></blockquote></li><li><p>设置SYN Cookie (net.ipv4.tcp_syncookies = 1)</p><blockquote><p>就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，并记录地址信息，以后从这个IP地址来的包会被一概丢弃。这样做的结果也可能会影响到正常用户的访问。</p></blockquote></li></ul><image src="https://oscimg.oschina.net/oscnet/up-8cce8662408ffa1f5ed678be972248b92ca.png" width=800 height=350><p>当 SYN 队列满后，新的 SYN 不进入队列，计算出 cookie 再 以 SYN+ACK 中的序列号返回客户端，正常客户端发报文时， 服务器根据报文中携带的 cookie 重新恢复连接</p><blockquote><p>w 由于 cookie 占用序列号空间，导致此时所有 TCP 可选 功能失效，例如扩充窗口、时间戳等</p></blockquote><h2 id="TCP-DEFER-ACCEPT"><a href="#TCP-DEFER-ACCEPT" class="headerlink" title="TCP_DEFER_ACCEPT"></a>TCP_DEFER_ACCEPT</h2><p>这个是做什么呢？ 正如上面👆操作系统内核展示图所示，内核中维护两个队列【SYN】队列和【ACCEPT】队列，只有当收到客户端的ACK报文之后，连接会进入到【ACCEPT】，同时服务器的状态是<br>【ESTABLISHED】状态，此时操作系统并不会去激活应用进程，而是会等待，知道收到真正的data分组之后，才会激活应用进程，这是为了提高应用进程的执行效率，避免应用进程的等待；</p><blockquote><p>i TCP三次握手为什么不能是两次或者四次</p></blockquote><p>参见文章：<a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;握手🤝的目的&quot;&gt;&lt;a href=&quot;#握手🤝的目的&quot; class=&quot;headerlink&quot; title=&quot;握手🤝的目的&quot;&gt;&lt;/a&gt;握手🤝的目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;同步Sequence序列号&lt;blockquote&gt;
&lt;p&gt;i 初始化序&lt;br&gt;列号ISN</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP头部</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E5%A4%B4%E9%83%A8/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E5%A4%B4%E9%83%A8/</id>
    <published>2021-07-04T08:31:22.000Z</published>
    <updated>2021-07-04T08:47:43.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><ul><li>如何校验报文段是否损坏？ 如何CRC校验</li><li>seq和ack是如何计算的？ </li><li>tcp校验位都有那些？ 6个 分别是什么含义？</li><li>tcp如何计算首部长度？ 偏移量</li><li>TCP Retransmission 重传？ </li><li>tcp spurious retransmission 又是什么呢？ </li><li>tcp dup ack 是什么？</li><li>ack与ACK有什么区别？ 分别有什么作用？</li></ul><h2 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-d3e5715ff000040a0b18b2c9374d7e55f53.png">   </p><p>学习TCP协议首先要看一下它的报文段是如何组成的；TCP报文段组成由两部分，第一部分是报文头部，第二部分是数据部分；</p><p>先看一下报文头，也就是TCP首部的组成；</p><h3 id="16位端口"><a href="#16位端口" class="headerlink" title="16位端口"></a>16位端口</h3><p>16位端口号：告知主机该报文段是来自哪里（源端口Source Port）以及传给哪个上层协议或应用程序（目的端口Destination Port）的。<br>进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（比如DNS协议对应端口53，HTTP协议对应80，这些端口号可在/etc/services文件中找到）。  </p><h3 id="序列号（Seq）"><a href="#序列号（Seq）" class="headerlink" title="序列号（Seq）"></a>序列号（Seq）</h3><p>占32位，也就是4字节长度，序号范围自然也是是0~2^32-1。TCP是面向字节流的，TCP连接中传送的字节流中的每个字节都按顺序编号。整个要传送的字节流的起始序号必须要在连接建立时设置。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。   </p><p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。  </p><p>**这里存在一个疑问，第一次建立TCP连接的时候，网上一些博客上说seq是client随机生成的，也有的博客说是seq=1； 这里经过我抓包后，看到第一次创建TCP连接的时候，确实是1; **    </p><h3 id="确认应答号（Ack）"><a href="#确认应答号（Ack）" class="headerlink" title="确认应答号（Ack）"></a>确认应答号（Ack）</h3><p>Ack占32位，4个字节长度，表示期望收到对方下一个报文段的序号值。 用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。<br>TCP的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。  </p><p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。    </p><p>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。    </p><h3 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了TCP报文段的首部长度 ，它指出了TCP报文段的数据起始处距离TCP报文的起始处有多远。</p><blockquote><p>注意数据起始处和报文起始处的意思，上面👆已经写到，TCP报文段的组成有两部分，TCP报文首部和数据部分，偏移量记录的是报文段开始和数据开始的长度，也就是报文首部的长度；  </p></blockquote><p>一个数据偏移量 = 4 byte，由于4位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了TCP首部的最大长度。  </p><h3 id="保留Reserved"><a href="#保留Reserved" class="headerlink" title="保留Reserved"></a>保留Reserved</h3><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p><h3 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h3><p><img src="https://oscimg.oschina.net/oscnet/up-869702a0e6199a93eb3be514c04e28274a7.png"><br>标志位，一共有6个，分别占1位，共6位。 每一位的值只有 0 和 1，分别表达不同意思。 如上图是使用wireshard抓包展示截图；  </p><h4 id="ACK-Acknowlegemt-：确认序号有效"><a href="#ACK-Acknowlegemt-：确认序号有效" class="headerlink" title="ACK(Acknowlegemt)  ：确认序号有效"></a>ACK(Acknowlegemt)  ：确认序号有效</h4><blockquote><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。  </p></blockquote><h4 id="RST-Reset-：重置连接"><a href="#RST-Reset-：重置连接" class="headerlink" title="RST(Reset)：重置连接"></a>RST(Reset)：重置连接</h4><blockquote><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。 </p></blockquote><h4 id="SYN-SYNchronization-：发起了一个新连接"><a href="#SYN-SYNchronization-：发起了一个新连接" class="headerlink" title="SYN(SYNchronization)：发起了一个新连接"></a>SYN(SYNchronization)：发起了一个新连接</h4><blockquote><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p></blockquote><h4 id="PSH-Push-推送"><a href="#PSH-Push-推送" class="headerlink" title="PSH (Push): 推送"></a>PSH (Push): 推送</h4><blockquote><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。  </p></blockquote><h4 id="FIN：释放一个连接"><a href="#FIN：释放一个连接" class="headerlink" title="FIN：释放一个连接"></a>FIN：释放一个连接</h4><blockquote><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p></blockquote><h3 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h3><p>占16位。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p><blockquote><p>例如，假如确认号是701，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。  </p></blockquote><h3 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h3><p>占16位。 由发送端填充，接收端对TCP报文段执行【CRC算法】，以检验TCP报文段在传输过程中是否损坏，如果损坏这丢弃。</p><p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p><h3 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p><p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><image src="https://oscimg.oschina.net/oscnet/up-e071765090a2bbf6a9944907b288c70cd4a.png" width="400"><ul><li>每个选项开始是1字节kind字段，说明选项的类型</li><li>kind为0和1的选项，只占一个字节</li><li>其他kind后有一字节len，表示该选项总长度（包括kind和len）</li><li>kind为11，12，13表示tcp事务</li></ul><p><strong>下面是常用选项：</strong><br><image src="https://oscimg.oschina.net/oscnet/up-1043e2bd27321e5ae0bc13be398e989be3e.png" width=800 height=300></p><h3 id="MTU（最大传输单元）"><a href="#MTU（最大传输单元）" class="headerlink" title="MTU（最大传输单元）"></a>MTU（最大传输单元）</h3><p>MTU（最大传输单元）是【链路层】中的网络对数据帧的一个限制，以以太网为例，MTU 为 1500 个字节。一个IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装。IP 数据报的分片与重组是在网络层进完成的。</p><h3 id="MSS-（最大分段大小）"><a href="#MSS-（最大分段大小）" class="headerlink" title="MSS （最大分段大小）"></a>MSS （最大分段大小）</h3><p>MSS 是 TCP 里的一个概念（首部的选项字段中）。MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 协议在建立连接的时候通常要协商双方的 MSS 值，每一方都有用于通告它期望接收的 MSS 选项（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（需要减去 IP 数据包包头的大小 20Bytes 和 TCP 数据段的包头 20Bytes）所以如果用链路层以太网，MSS 的值往往为 1460。而 Internet 上标准的 MTU 为 576，那么如果不设置，则MSS的默认值就为 536 个字节。TCP报文段的分段与重组是在运输层完成的。</p><h2 id="seq和ack的计算逻辑"><a href="#seq和ack的计算逻辑" class="headerlink" title="seq和ack的计算逻辑"></a>seq和ack的计算逻辑</h2><image src="https://oscimg.oschina.net/oscnet/up-710a22f4e6b6c961662879fe2ac6000cca9.png" width=900 height=500> <h2 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/15754b4e9458">TCP协议中的seq/ack序号是如何变化的？</a><br><a href="https://www.jianshu.com/p/ef892323e68f">TCP协议详解</a><br><a href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP协议详解（一）：TCP头部结构</a><br><a href="https://blog.csdn.net/zuochao_2013/article/details/80561793">TCP和UDP报文头格式</a><br><a href="https://juejin.cn/post/6844903685563105293">TCP协议详解</a><br><a href="https://juejin.cn/post/6844904131342123022">吃透TCP协议</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;带着问题学习&quot;&gt;&lt;a href=&quot;#带着问题学习&quot; class=&quot;headerlink&quot; title=&quot;带着问题学习&quot;&gt;&lt;/a&gt;带着问题学习&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如何校验报文段是否损坏？ 如何CRC校验&lt;/li&gt;
&lt;li&gt;seq和ack是如何计算的？ &lt;/l</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-07-04T08:30:55.000Z</published>
    <updated>2021-07-04T08:47:45.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP协议学习笔记📒"><a href="#TCP协议学习笔记📒" class="headerlink" title="TCP协议学习笔记📒"></a>TCP协议学习笔记📒</h2><blockquote><p>w 下面是本人在学习TCP协议的过程中，记录的笔记，按照学习的过程从前到后整理在这里！<br>可能会有很多的知识没有罗列，只是记录的大概框架，如果有问题或错误，欢迎指正！</p></blockquote><blockquote><p><a href="doc:RGuKLdsI">1、TCP报文头部</a><br><a href="doc:OMRc4svF">2、TCP三次握手</a><br><a href="doc:MpizaHTg">3、TCP最大报文段（MSS）</a><br><a href="doc:ELxUb4mv">4、TCP超时与重传</a><br><a href="doc:wqRVLcNo">5、RTO重传计时器的计算</a><br><a href="doc:IhqiYamL">6、滑动窗口</a><br><a href="doc:HoE3w3UG">7、提升网络效率</a><br><a href="doc:N7riiaCk">8、TCP拥塞控制之慢启动</a><br><a href="doc:GQoRKrER">9、TCP拥塞控制之拥塞避免</a><br><a href="doc:y4aESoPN">10、快速重传与快速恢复</a><br><a href="doc:g1Onj7OR">11、四次挥手</a></p></blockquote><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><blockquote><p>i 敖丙Github整理的笔记 </p></blockquote><p>有大概10篇左右的文章，都是高质量的，原地址请点击着👉 <a href="https://github.com/AobingJava/JavaFamily">【Github】</a></p><blockquote><p>i 极客时间《Web协议详解与抓包实战》– 陶辉老师</p></blockquote><p>这门课程专门讲解网络协议的，包括Http/Https,TLS协议，TCP协议，IP协议等；</p><blockquote><p>i 《计算机网络 自顶向下方法》第7版</p></blockquote><p>很多名校计算机网络课程在使用的教材，非常权威！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP协议学习笔记📒&quot;&gt;&lt;a href=&quot;#TCP协议学习笔记📒&quot; class=&quot;headerlink&quot; title=&quot;TCP协议学习笔记📒&quot;&gt;&lt;/a&gt;TCP协议学习笔记📒&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;w 下面是本人在学习TCP协议的过程中，记</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/"/>
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/categories/Computer-Network/TCP/"/>
    
    
    <category term="TCP" scheme="https://github.com/geekibli/geekibli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to GeekIBLi</title>
    <link href="https://github.com/geekibli/geekibli.github.io/mywiki/index/"/>
    <id>https://github.com/geekibli/geekibli.github.io/mywiki/index/</id>
    <published>2021-07-04T07:44:33.000Z</published>
    <updated>2021-07-04T08:22:05.574Z</updated>
    
    <content type="html"><![CDATA[<p>I am geekibli;  </p><p>I come from HBU.  I like code.   😄😄😄😄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I am geekibli;  &lt;/p&gt;
&lt;p&gt;I come from HBU.  I like code.   😄😄😄😄&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Overview" scheme="https://github.com/geekibli/geekibli.github.io/categories/Overview/"/>
    
    
  </entry>
  
</feed>
