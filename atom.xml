<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-14T15:37:17.354Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>启动ELK脚本命令</title>
    <link href="http://example.com/wiki/%E5%90%AF%E5%8A%A8ELK%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/wiki/%E5%90%AF%E5%8A%A8ELK%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-14T15:37:17.000Z</published>
    <updated>2021-07-14T15:37:17.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>elasticsearch调优实践</title>
    <link href="http://example.com/wiki/elasticsearch%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-0/"/>
    <id>http://example.com/wiki/elasticsearch%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-0/</id>
    <published>2021-07-14T15:12:16.000Z</published>
    <updated>2021-07-15T03:32:07.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从性能和稳定性两方面，从linux参数调优、ES节点配置和ES使用方式三个角度入手，介绍ES调优的基本方案。当然，ES的调优绝不能一概而论，需要根据实际业务场景做适当的取舍和调整</p></blockquote><h2 id="Linux优化"><a href="#Linux优化" class="headerlink" title="Linux优化"></a>Linux优化</h2><h3 id="关闭交换分区，防止内存置换降低性能。"><a href="#关闭交换分区，防止内存置换降低性能。" class="headerlink" title="关闭交换分区，防止内存置换降低性能。"></a>关闭交换分区，防止内存置换降低性能。</h3><p>将 <code>/etc/fstab</code> 文件中包含swap的行注释掉<br><code>sed -i &#39;/swap/s/^/#/&#39; /etc/fstabswapoff -a</code></p><h3 id="磁盘挂载选项"><a href="#磁盘挂载选项" class="headerlink" title="磁盘挂载选项"></a>磁盘挂载选项</h3><p>noatime：禁止记录访问时间戳，提高文件系统读写性能<br>data=writeback： 不记录data journal，提高文件系统写入性能<br>barrier=0：barrier保证journal先于data刷到磁盘，上面关闭了journal，这里的barrier也就没必要开启了<br>nobh：关闭buffer_head，防止内核打断大块数据的IO操作<br>mount -o noatime,data=writeback,barrier=0,nobh /dev/sda /es_data</p><h3 id="对于SSD磁盘，采用电梯调度算法"><a href="#对于SSD磁盘，采用电梯调度算法" class="headerlink" title="对于SSD磁盘，采用电梯调度算法"></a>对于SSD磁盘，采用电梯调度算法</h3><p>因为SSD提供了更智能的请求调度算法，不需要内核去做多余的调整 (仅供参考)<br><code>echo noop &gt; /sys/block/sda/queue/scheduler</code></p><h2 id="ES节点配置"><a href="#ES节点配置" class="headerlink" title="ES节点配置"></a>ES节点配置</h2><p>conf/elasticsearch.yml文件：</p><h3 id="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"><a href="#适当增大写入buffer和bulk队列长度，提高写入性能和稳定性" class="headerlink" title="适当增大写入buffer和bulk队列长度，提高写入性能和稳定性"></a>适当增大写入buffer和bulk队列长度，提高写入性能和稳定性</h3><p><code>indices.memory.index_buffer_size: 15%</code><br><code>thread_pool.bulk.queue_size: 1024</code></p><h3 id="计算disk使用量时，不考虑正在搬迁的shard"><a href="#计算disk使用量时，不考虑正在搬迁的shard" class="headerlink" title="计算disk使用量时，不考虑正在搬迁的shard"></a>计算disk使用量时，不考虑正在搬迁的shard</h3><p>在规模比较大的集群中，可以防止新建shard时扫描所有shard的元数据，提升shard分配速度。<br><code>cluster.routing.allocation.disk.include_relocations: false</code></p><h2 id="三-ES使用方式"><a href="#三-ES使用方式" class="headerlink" title="三 ES使用方式"></a>三 ES使用方式</h2><h3 id="控制字段的存储选项"><a href="#控制字段的存储选项" class="headerlink" title="控制字段的存储选项"></a>控制字段的存储选项</h3><p>ES底层使用Lucene存储数据，主要包括行存（StoreFiled）、列存（DocValues）和倒排索引（InvertIndex）三部分。 大多数使用场景中，没有必要同时存储这三个部分，可以通过下面的参数来做适当调整：</p><h4 id="StoreFiled"><a href="#StoreFiled" class="headerlink" title="StoreFiled"></a>StoreFiled</h4><p>行存，其中占比最大的是source字段，它控制doc原始数据的存储。在写入数据时，ES把doc原始数据的整个json结构体当做一个string，存储为source字段。查询时，可以通过source字段拿到当初写入时的整个json结构体。 所以，如果没有取出整个原始json结构体的需求，可以通过下面的命令，在mapping中关闭source字段或者只在source中存储部分字段，数据查询时仍可通过ES的docvaluefields获取所有字段的值。<br>注意：关闭source后， update, updatebyquery, reindex等接口将无法正常使用，所以有update等需求的index不能关闭source。</p><ul><li>关闭 _source<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="source只存储部分字段"><a href="#source只存储部分字段" class="headerlink" title="_source只存储部分字段"></a>_source只存储部分字段</h4><p>通过includes指定要存储的字段或者通过excludes滤除不需要的字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;includes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;*.count&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.*&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;excludes&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;meta.description&quot;</span>,</span><br><span class="line">          <span class="string">&quot;meta.other.*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="docvalues-控制列存。"><a href="#docvalues-控制列存。" class="headerlink" title="docvalues 控制列存。"></a>docvalues 控制列存。</h4><p>ES主要使用列存来支持sorting, aggregations和scripts功能，对于没有上述需求的字段，可以通过下面的命令关闭docvalues，降低存储成本。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ndex：控制倒排索引。"><a href="#ndex：控制倒排索引。" class="headerlink" title="ndex：控制倒排索引。"></a>ndex：控制倒排索引。</h4><p>ES默认对于所有字段都开启了倒排索引，用于查询。对于没有查询需求的字段，可以通过下面的命令关闭倒排索引。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;session_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allES的一个特殊的字段"><a href="#allES的一个特殊的字段" class="headerlink" title="allES的一个特殊的字段"></a>allES的一个特殊的字段</h4><ul><li>ES把用户写入json的所有字段值拼接成一个字符串后，做分词，然后保存倒排索引，用于支持整个json的全文检索。<br>这种需求适用的场景较少，可以通过下面的命令将all字段关闭，节约存储成本和cpu开销。（ES 6.0+以上的版本不再支持_all字段，不需要设置）<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fieldnames"><a href="#fieldnames" class="headerlink" title="fieldnames"></a>fieldnames</h4>该字段用于exists查询，来确认某个doc里面有无一个字段存在。若没有这种需求，可以将其关闭。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_field_names&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启最佳压缩"><a href="#开启最佳压缩" class="headerlink" title="开启最佳压缩"></a>开启最佳压缩</h3><p>对于打开了上述_source字段的index，可以通过下面的命令来把lucene适用的压缩算法替换成 DEFLATE，提高数据压缩率。<br><code>PUT /my_index/_settings&#123;    &quot;index.codec&quot;: &quot;best_compression&quot;&#125;</code></p><h3 id="bulk批量写入"><a href="#bulk批量写入" class="headerlink" title="bulk批量写入"></a>bulk批量写入</h3><p>写入数据时尽量使用下面的bulk接口批量写入，提高写入效率。每个bulk请求的doc数量设定区间推荐为1k~1w，具体可根据业务场景选取一个适当的数量。</p><h3 id="调整translog同步策略"><a href="#调整translog同步策略" class="headerlink" title="调整translog同步策略"></a>调整translog同步策略</h3><p>默认情况下，translog的持久化策略是，对于每个写入请求都做一次flush，刷新translog数据到磁盘上。这种频繁的磁盘IO操作是严重影响写入性能的，如果可以接受一定概率的数据丢失（这种硬件故障的概率很小），可以通过下面的命令调整 translog 持久化策略为异步周期性执行，并适当调整translog的刷盘周期。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;translog&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;durability&quot;</span>: <span class="string">&quot;async&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整refresh-interval"><a href="#调整refresh-interval" class="headerlink" title="调整refresh_interval"></a>调整refresh_interval</h3><p>写入Lucene的数据，并不是实时可搜索的，ES必须通过refresh的过程把内存中的数据转换成Lucene的完整segment后，才可以被搜索。默认情况下，ES每一秒会refresh一次，产生一个新的segment，这样会导致产生的segment较多，从而segment merge较为频繁，系统开销较大。如果对数据的实时可见性要求较低，可以通过下面的命令提高refresh的时间间隔，降低系统开销。</p><p><code>PUT my_index&#123;  &quot;settings&quot;: &#123;    &quot;index&quot;: &#123;        &quot;refresh_interval&quot; : &quot;30s&quot;    &#125;  &#125;&#125;</code></p><h3 id="merge并发控制"><a href="#merge并发控制" class="headerlink" title="merge并发控制"></a>merge并发控制</h3><p>ES的一个index由多个shard组成，而一个shard其实就是一个Lucene的index，它又由多个segment组成，且Lucene会不断地把一些小的segment合并成一个大的segment，这个过程被称为merge。默认值是Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))，当节点配置的cpu核数较高时，merge占用的资源可能会偏高，影响集群的性能，可以通过下面的命令调整某个index的merge过程的并发度：</p><p><code>PUT /my_index/_settings&#123;    &quot;index.merge.scheduler.max_thread_count&quot;: 2&#125;</code></p><h3 id="写入数据不指定-id，让ES自动产生"><a href="#写入数据不指定-id，让ES自动产生" class="headerlink" title="写入数据不指定_id，让ES自动产生"></a>写入数据不指定_id，让ES自动产生</h3><p>当用户显示指定id写入数据时，ES会先发起查询来确定index中是否已经有相同id的doc存在，若有则先删除原有doc再写入新doc。这样每次写入时，ES都会耗费一定的资源做查询。如果用户写入数据时不指定doc，ES则通过内部算法产生一个随机的id，并且保证id的唯一性，这样就可以跳过前面查询id的步骤，提高写入效率。 所以，在不需要通过id字段去重、update的使用场景中，写入不指定id可以提升写入速率。基础架构部数据库团队的测试结果显示，无id的数据写入性能可能比有_id的高出近一倍，实际损耗和具体测试场景相关。</p><h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>对于数据量较大的index，一般会配置多个shard来分摊压力。这种场景下，一个查询会同时搜索所有的shard，然后再将各个shard的结果合并后，返回给用户。对于高并发的小查询场景，每个分片通常仅抓取极少量数据，此时查询过程中的调度开销远大于实际读取数据的开销，且查询速度取决于最慢的一个分片。开启routing功能后，ES会将routing相同的数据写入到同一个分片中（也可以是多个，由index.routingpartitionsize参数控制）。如果查询时指定routing，那么ES只会查询routing指向的那个分片，可显著降低调度开销，提升查询效率。 routing的使用方式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 写入PUT my_index/my_type/<span class="number">1</span>?routing=user1&#123;  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span>&#125;</span><br><span class="line"># 查询GET my_index/_search?routing=user1,user2 &#123;  <span class="attr">&quot;query&quot;</span>: &#123;    <span class="attr">&quot;match&quot;</span>: &#123;      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span>    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="为string类型的字段选取合适的存储方式"><a href="#为string类型的字段选取合适的存储方式" class="headerlink" title="为string类型的字段选取合适的存储方式"></a>为string类型的字段选取合适的存储方式</h3><h4 id="存为text类型的字段（string字段默认类型为text）："><a href="#存为text类型的字段（string字段默认类型为text）：" class="headerlink" title="存为text类型的字段（string字段默认类型为text）："></a>存为text类型的字段（string字段默认类型为text）：</h4><pre><code>做分词后存储倒排索引，支持全文检索，可以通过下面几个参数优化其存储方式： -  norms：用于在搜索时计算该doc的_score（代表这条数据与搜索条件的相关度），如果不需要评分，可以将其关闭。 - indexoptions：控制倒排索引中包括哪些信息（docs、freqs、positions、offsets）。对于不太注重score/highlighting的使用场景，可以设为 docs来降低内存/磁盘资源消耗。 - fields: 用于添加子字段。对于有sort和聚合查询需求的场景，可以添加一个keyword子字段以支持这两种功能。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;norms&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;index_options&quot;</span>: <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```    </span><br><span class="line">#### 存为keyword类型的字段</span><br><span class="line">不做分词，不支持全文检索。text分词消耗CPU资源，冗余存储keyword子字段占用存储空间。如果没有全文索引需求，只是要通过整个字段做搜索，可以设置该字段的类型为keyword，提升写入速率，降低存储成本。 设置字段类型的方法有两种：一是创建一个具体的index时，指定字段的类型；二是通过创建template，控制某一类index的字段类型。</span><br><span class="line"></span><br><span class="line">-  通过mapping指定 tags 字段为keyword类型</span><br><span class="line">```json</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li> 通过template，指定my_index*类的index，其所有string字段默认为keyword类型<br>PUT _template/my_template<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;order&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;template&quot;</span>: <span class="string">&quot;my_index*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_default_&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="attr">&quot;strings&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询时，使用query-bool-filter组合取代普通query"><a href="#查询时，使用query-bool-filter组合取代普通query" class="headerlink" title="查询时，使用query-bool-filter组合取代普通query"></a>查询时，使用query-bool-filter组合取代普通query</h3><p>默认情况下，ES通过一定的算法计算返回的每条数据与查询语句的相关度，并通过score字段来表征。但对于非全文索引的使用场景，用户并不care查询结果与查询条件的相关度，只是想精确的查找目标数据。此时，可以通过query-bool-filter组合来让ES不计算score，并且尽可能的缓存filter的结果集，供后续包含相同filter的查询使用，提高查询效率。</p><ul><li>普通查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot; : &#123; &quot;user&quot; : &quot;Kimchy&quot; &#125;   &#125;&#125;</code></li><li>query-bool-filter 加速查询<br><code>POST my_index/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123; &quot;user&quot;: &quot;Kimchy&quot; &#125;      &#125;    &#125;  &#125;&#125;</code></li></ul><h3 id="index按日期滚动，便于管理"><a href="#index按日期滚动，便于管理" class="headerlink" title="index按日期滚动，便于管理"></a>index按日期滚动，便于管理</h3><p>写入ES的数据最好通过某种方式做分割，存入不同的index。<br>常见的做法是将数据按模块/功能分类，写入不同的index，然后按照时间去滚动生成index。这样做的好处是各种数据分开管理不会混淆，也易于提高查询效率。<code>同时index按时间滚动，数据过期时删除整个index，要比一条条删除数据或deletebyquery效率高很多</code>，因为删除整个index是直接删除底层文件，而deletebyquery是查询-标记-删除。</p><p>举例说明，假如有[modulea,moduleb]两个模块产生的数据，那么index规划可以是这样的：一类index名称是modulea + {日期}，另一类index名称是module_b+ {日期}。对于名字中的日期，可以在写入数据时自己指定精确的日期，也可以通过ES的ingest pipeline中的index-name-processor实现（会有写入性能损耗）。</p><h3 id="按需控制index的分片数和副本数"><a href="#按需控制index的分片数和副本数" class="headerlink" title="按需控制index的分片数和副本数"></a>按需控制index的分片数和副本数</h3><p>分片（shard）：一个ES的index由多个shard组成，每个shard承载index的一部分数据。</p><p>副本（replica）：index也可以设定副本数（numberofreplicas），也就是同一个shard有多少个备份。对于查询压力较大的index，可以考虑提高副本数（numberofreplicas），通过多个副本均摊查询压力。</p><p>shard数量（numberofshards）设置过多或过低都会引发一些问题：shard数量过多，则批量写入/查询请求被分割为过多的子写入/查询，导致该index的写入、查询拒绝率上升；对于数据量较大的inex，当其shard数量过小时，无法充分利用节点资源，造成机器资源利用率不高 或 不均衡，影响写入/查询的效率。</p><p>对于每个index的shard数量，可以根据数据总量、写入压力、节点数量等综合考量后设定，然后根据数据增长状态定期检测下shard数量是否合理。基础架构部数据库团队的推荐方案是：</p><p>对于数据量较小（100GB以下）的index，往往写入压力查询压力相对较低，一般设置3<del>5个shard，numberofreplicas设置为1即可（也就是一主一从，共两副本） 。<br>对于数据量较大（100GB以上）的index：<br>一般把单个shard的数据量控制在（20GB</del>50GB）<br>让index压力分摊至多个节点：可通过index.routing.allocation.totalshardsper_node参数，强制限定一个节点上该index的shard数量，让shard尽量分配到不同节点上<br>综合考虑整个index的shard数量，如果shard数量（不包括副本）超过50个，就很可能引发拒绝率上升的问题，此时可考虑把该index拆分为多个独立的index，分摊数据量，同时配合routing使用，降低每个查询需要访问的shard数量。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/43437056">Elasticsearch性能优化总结</a><br><a href="https://cloud.tencent.com/developer/article/1158408">Elasticsearch调优实践</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从性能和稳定性两方面，从linux参数调优、ES节点配置和ES使用方式三个角度入手，介绍ES调优的基本方案。当然，ES的调优绝不能一概而论，需要根据实际业务场景做适当的取舍和调整&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Linux优化&quot;</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Administration and Deployment" scheme="http://example.com/categories/Elasticsearch/Administration-and-Deployment/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>修改mysql表创建时间</title>
    <link href="http://example.com/wiki/%E4%BF%AE%E6%94%B9mysql%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/"/>
    <id>http://example.com/wiki/%E4%BF%AE%E6%94%B9mysql%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/</id>
    <published>2021-07-14T13:42:53.000Z</published>
    <updated>2021-07-14T14:42:16.536Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>修改服务器时间<br><code>date -s &quot;2021-07-14 21:22:10&quot;</code></p></li><li><p>执行DDL<br><code>alter table mirror_user comment &#39;用户表&#39;;</code></p></li><li><p>服务器时间修正<br><code>ntpdate ntp1.aliyun.com</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改服务器时间&lt;br&gt;&lt;code&gt;date -s &amp;quot;2021-07-14 21:22:10&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行DDL&lt;br&gt;&lt;code&gt;alter table mirror_user comment </summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>hutool导出excel</title>
    <link href="http://example.com/wiki/hutool%E5%AF%BC%E5%87%BAexcel/"/>
    <id>http://example.com/wiki/hutool%E5%AF%BC%E5%87%BAexcel/</id>
    <published>2021-07-14T13:01:13.000Z</published>
    <updated>2021-07-14T13:42:15.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你仅需一个Java导出excel的工具，👇就可以满足你的临时需求，当然代码下面这么写肯定是不规范的，可以稍后完善！</p></blockquote><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Export方法示例"><a href="#Export方法示例" class="headerlink" title="Export方法示例"></a>Export方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(List&lt;IPData&gt; rows)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       ExcelWriter writer = ExcelUtil.getWriter(<span class="keyword">true</span>);</span><br><span class="line">       writer.renameSheet(<span class="string">&quot;所有数据&quot;</span>);     <span class="comment">//甚至sheet的名称</span></span><br><span class="line">       writer.addHeaderAlias(<span class="string">&quot;ip&quot;</span>, <span class="string">&quot;IP&quot;</span>);</span><br><span class="line">       writer.write(rows, <span class="keyword">true</span>);</span><br><span class="line">       writer.setOnlyAlias(<span class="keyword">true</span>);</span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/IP1.xlsx&quot;</span>);</span><br><span class="line">       writer.flush(fileOutputStream);</span><br><span class="line">       writer.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你仅需一个Java导出excel的工具，👇就可以满足你的临时需求，当然代码下面这么写肯定是不规范的，可以稍后完善！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="excel" scheme="http://example.com/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://example.com/wiki/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/wiki/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-14T01:55:55.000Z</published>
    <updated>2021-07-14T02:18:58.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p><code>git init </code><br><code>git add .</code><br><code>git commit -m &lt;message&gt;</code><br><code>git remote add &lt;name&gt; &lt;url&gt;</code><br><code>git push</code><br><code>git push &lt;name&gt;</code><br><code>git push --set-upstream &lt;name&gt; &lt;branch&gt;</code></p><h2 id="批量删除分支"><a href="#批量删除分支" class="headerlink" title="批量删除分支"></a>批量删除分支</h2><p>远程：<code>git branch -r| grep &#39;ss-1&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;</code><br>本地：<code>git branch -a | grep &#39;feature-re-1&#39; | xargs git branch -D</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化本地仓库&quot;&gt;&lt;a href=&quot;#初始化本地仓库&quot; class=&quot;headerlink&quot; title=&quot;初始化本地仓库&quot;&gt;&lt;/a&gt;初始化本地仓库&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git init &lt;/code&gt;&lt;br&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;b</summary>
      
    
    
    
    <category term="Develop Tools" scheme="http://example.com/categories/Develop-Tools/"/>
    
    <category term="Git" scheme="http://example.com/categories/Develop-Tools/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/wiki/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/wiki/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-13T03:44:22.000Z</published>
    <updated>2021-07-15T02:54:42.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><ul><li><p>linux 在文档中查找关键字个数<br><code>grep -o “关键字” 文档名 | wc -l </code><br><code>grep -o “关键字” 文档名 | sort | uniq -c</code></p></li><li><p>清除history记录<br><code>vim .bash_history</code><br>命令模式下（Esc之后输入:） 输入 set nu 每行数据前面显示行号<br><code>11,20d</code> 回车 11～20行的记录就被删除了<br>然后命令模式下 wq 保存退出就可以了<br>如果在此查看还是有记录，可以退出当前回话之后，再进去查看，就会不再显示删除的记录了</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用户相关&quot;&gt;&lt;a href=&quot;#用户相关&quot; class=&quot;headerlink&quot; title=&quot;用户相关&quot;&gt;&lt;/a&gt;用户相关&lt;/h2&gt;&lt;h2 id=&quot;文件相关&quot;&gt;&lt;a href=&quot;#文件相关&quot; class=&quot;headerlink&quot; title=&quot;文件相关&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Linux System" scheme="http://example.com/categories/Linux-System/"/>
    
    <category term="Common commands" scheme="http://example.com/categories/Linux-System/Common-commands/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>段合并</title>
    <link href="http://example.com/wiki/%E6%AE%B5%E5%90%88%E5%B9%B6/"/>
    <id>http://example.com/wiki/%E6%AE%B5%E5%90%88%E5%B9%B6/</id>
    <published>2021-07-08T12:57:54.000Z</published>
    <updated>2021-07-08T13:37:17.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://learnku.com/articles/41593">learnku.com</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learnku.com/articles/41593</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Getting Started" scheme="http://example.com/categories/Elasticsearch/Getting-Started/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>统计去重数据 (近似度量)</title>
    <link href="http://example.com/wiki/%E7%BB%9F%E8%AE%A1%E5%8E%BB%E9%87%8D%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/wiki/%E7%BB%9F%E8%AE%A1%E5%8E%BB%E9%87%8D%E6%95%B0%E6%8D%AE/</id>
    <published>2021-07-08T08:09:05.000Z</published>
    <updated>2021-07-08T13:21:20.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cardinality用法"><a href="#cardinality用法" class="headerlink" title="cardinality用法"></a>cardinality用法</h2><p>常用写法如下👇<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;months&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;sold&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;month&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p><code>cardinality</code> 度量是一个 <code>近似算法</code>。 它是基于 HyperLogLog++ （HLL）算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。</p><p>我们不需要理解技术细节， 但我们最好应该关注一下这个算法的 特性 ：</p><ul><li>可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）。</li><li>小的数据集精度是非常高的。</li><li>我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</li></ul><p>要配置精度，我们必须指定 <code>precision_threshold</code> 参数的值。 这个阈值定义了在何种基数水平下我们希望得到一个近乎精确的结果。参考以下示例：</p><p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;precision_threshold&quot;</span> : <span class="number">100</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ ⚠️<br><code>precision_threshold</code> 接受 0–40000 之间的数字，更大的值还是会被当作 40000 来处理 </p><p>示例会确保当字段唯一值在 100 以内时会得到非常准确的结果。尽管算法是无法保证这点的，但如果基数在阈值以下，几乎总是 100% 正确的。高于阈值的基数会开始节省内存而牺牲准确度，同时也会对度量结果带入误差。</p><p>对于指定的阈值，<code>HLL</code> 的数据结构会大概使用 <code>precision_threshold</code> * 8 字节的内存，所以就必须在牺牲内存和获得额外的准确度间做平衡。</p><p>在实际应用中， 100 的阈值可以在唯一值为百万的情况下仍然将误差维持 5% 以内</p><h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>如果想要获得唯一值的数目， 通常 需要查询整个数据集合（或几乎所有数据）。 所有基于所有数据的操作都必须迅速，原因是显然的。 <code>HyperLogLog</code> 的速度已经很快了，它只是简单的对数据做哈希以及一些位操作。</p><p>但如果速度对我们至关重要，可以做进一步的优化。 因为 HLL 只需要字段内容的哈希值，我们可以在索引时就预先计算好。 就能在查询时跳过哈希计算然后将哈希值从 <code>fielddata</code> 直接加载出来。</p><blockquote><p>预先计算哈希值只对内容很长或者基数很高的字段有用，计算这些字段的哈希值的消耗在查询时是无法忽略的。<br>  尽管数值字段的哈希计算是非常快速的，存储它们的原始值通常需要同样（或更少）的内存空间。这对低基数的字符串字段同样适用，Elasticsearch 的内部优化能够保证每个唯一值只计算一次哈希。<br>  基本上说，预先计算并不能保证所有的字段都更快，它只对那些具有高基数和/或者内容很长的字符串字段有作用。需要记住的是，预计算只是简单的将查询消耗的时间提前转移到索引时，并非没有任何代价，区别在于你可以选择在 什么时候 做这件事，要么在索引时，要么在查询时。</p></blockquote><p>创建索引时添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT /cars/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;transactions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;color&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;hash&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;murmur3&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多值字段的类型是 <code>murmur3</code> ，这是一个哈希函数。</p></blockquote><p>现在当我们执行聚合时，我们使用 <code>color.hash</code> 字段而不是 color 字段：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;distinct_colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;cardinality&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color.hash&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>cardinality</code> 度量会读取 “<code>color.hash</code>“ 里的值（预先计算的哈希值），取代动态计算原始值的哈希。</p><p>单个文档节省的时间是非常少的，但是如果你聚合一亿数据，每个字段多花费 10 纳秒的时间，那么在每次查询时都会额外增加 1 秒，如果我们要在非常大量的数据里面使用 <code>cardinality</code> ，我们可以权衡使用预计算的意义，是否需要提前计算 hash，从而在查询时获得更好的性能，做一些性能测试来检验预计算哈希是否适用于你的应用场景。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cardinality用法&quot;&gt;&lt;a href=&quot;#cardinality用法&quot; class=&quot;headerlink&quot; title=&quot;cardinality用法&quot;&gt;&lt;/a&gt;cardinality用法&lt;/h2&gt;&lt;p&gt;常用写法如下👇&lt;br&gt;&lt;code&gt;curl -X </summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>多桶排序</title>
    <link href="http://example.com/wiki/%E5%A4%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/wiki/%E5%A4%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-08T07:50:24.000Z</published>
    <updated>2021-07-08T13:21:43.551Z</updated>
    
    <content type="html"><![CDATA[<p>多值桶（ terms 、 histogram 和 date_histogram ）动态生成很多桶。 Elasticsearch 是如何决定这些桶展示给用户的顺序呢？</p><p>默认的，桶会根据 doc_count 降序排列。这是一个好的默认行为，因为通常我们想要找到文档中与查询条件相关的最大值：售价、人口数量、频率。但有些时候我们希望能修改这个顺序，不同的桶有着不同的处理方式。</p><h2 id="内置排序"><a href="#内置排序" class="headerlink" title="内置排序"></a>内置排序</h2><p>这些排序模式是桶 固有的 能力：它们操作桶生成的数据 ，比如 doc_count 。 它们共享相同的语法，但是根据使用桶的不同会有些细微差别。</p><p>让我们做一个 terms 聚合但是按 doc_count 值的升序排序：</p><p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;_count&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure><p>用关键字 _count ，我们可以按 doc_count 值的升序排序。</p><p>我们为聚合引入了一个 order 对象， 它允许我们可以根据以下几个值中的一个值进行排序：</p><ul><li>_count<br>按文档数排序。对 terms 、 histogram 、 date_histogram 有效。</li><li>_term<br>按词项的字符串值的字母顺序排序。只在 terms 内使用。</li><li>_key<br>按每个桶的键值数值排序（理论上与 _term 类似）。 只在 histogram 和 date_histogram 内使用。</li></ul><h2 id="按度量排序"><a href="#按度量排序" class="headerlink" title="按度量排序"></a>按度量排序</h2><p>有时，我们会想基于度量计算的结果值进行排序。 在我们的汽车销售分析仪表盘中，我们可能想按照汽车颜色创建一个销售条状图表，但按照汽车平均售价的升序进行排序。</p><p>我们可以增加一个度量，再指定 order 参数引用这个度量即可：</p><p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;avg&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>计算每个桶的平均售价。</p></li><li><p>桶按照计算平均值的升序排序。</p></li></ul><p>我们可以采用这种方式用任何度量排序，只需简单的引用度量的名字。不过有些度量会输出多个值。 extended_stats 度量是一个很好的例子：它输出好几个度量值。</p><p>如果我们想使用多值度量进行排序， 我们只需以关心的度量为关键词使用点式路径：<br><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;stats&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 . 符号，根据感兴趣的度量进行排序。</li></ul><h2 id="深度度量排序"><a href="#深度度量排序" class="headerlink" title="深度度量排序"></a>深度度量排序</h2><p>在前面的示例中，度量是桶的直接子节点。平均售价是根据每个 term 来计算的。 在一定条件下，我们也有可能对 更深 的度量进行排序，比如孙子桶或从孙桶。</p><p>我们可以定义更深的路径，将度量用尖括号（ &gt; ）嵌套起来，像这样： my_bucket&gt;another_bucket&gt;metric 。</p><p>需要提醒的是嵌套路径上的每个桶都必须是 单值 的。 filter 桶生成 一个单值桶：所有与过滤条件匹配的文档都在桶中。 多值桶（如：terms ）动态生成许多桶，无法通过指定一个确定路径来识别。</p><p>目前，只有三个单值桶： filter 、 global 和 reverse_nested 。让我们快速用示例说明，创建一个汽车售价的直方图，但是按照红色和绿色（不包括蓝色）车各自的方差来排序：</p><p><code>curl -X GET &quot;localhost:9200/cars/transactions/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;colors&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;histogram&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;interval&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">              <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&gt;stats.variance&quot;</span> : <span class="string">&quot;asc&quot;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;red_green_cars&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;filter&quot;</span>: &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;color&quot;</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]&#125;&#125;, </span><br><span class="line">                    <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;stats&quot;</span>: &#123;<span class="attr">&quot;extended_stats&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span>&#125;&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>按照嵌套度量的方差对桶的直方图进行排序。</p></li><li><p>因为我们使用单值过滤器 filter ，我们可以使用嵌套排序。</p></li><li><p>按照生成的度量对统计结果进行排序。</p></li></ul><p>本例中，可以看到我们如何访问一个嵌套的度量。 stats 度量是 red_green_cars 聚合的子节点，而 red_green_cars 又是 colors 聚合的子节点。 为了根据这个度量排序，我们定义了路径 red_green_cars&gt;stats.variance 。我们可以这么做，因为 filter 桶是个单值桶。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多值桶（ terms 、 histogram 和 date_histogram ）动态生成很多桶。 Elasticsearch 是如何决定这些桶展示给用户的顺序呢？&lt;/p&gt;
&lt;p&gt;默认的，桶会根据 doc_count 降序排列。这是一个好的默认行为，因为通常我们想要找到文档</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsaerch" scheme="http://example.com/tags/elasticsaerch/"/>
    
  </entry>
  
  <entry>
    <title>过滤和聚合</title>
    <link href="http://example.com/wiki/%E8%BF%87%E6%BB%A4%E5%92%8C%E8%81%9A%E5%90%88/"/>
    <id>http://example.com/wiki/%E8%BF%87%E6%BB%A4%E5%92%8C%E8%81%9A%E5%90%88/</id>
    <published>2021-07-08T07:33:26.000Z</published>
    <updated>2021-07-08T13:21:01.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤和聚合"><a href="#过滤和聚合" class="headerlink" title="过滤和聚合"></a>过滤和聚合</h2><p>聚合范围限定还有一个自然的扩展就是过滤。因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合上。</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>如果我们想找到售价在 $10,000 美元之上的所有汽车同时也为这些车计算平均售价， 可以简单地使用一个 <code>constant_score</code> 查询和 <code>filter</code> 约束：</p><p><code>GET /cars/transactions/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;gte&quot;</span>: <span class="number">10000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;single_avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从根本上讲，使用 <code>non-scoring</code> 查询和使用 <code>match</code> 查询没有任何区别。查询（包括了一个过滤器）返回一组文档的子集，聚合正是操作这些文档。使用 <code>filtering query</code> 会忽略评分，并有可能会缓存结果数据等等。</p><h2 id="过滤桶"><a href="#过滤桶" class="headerlink" title="过滤桶"></a>过滤桶</h2><p>但是如果我们只想对聚合结果过滤怎么办？ 假设我们正在为汽车经销商创建一个搜索页面， 我们希望显示用户搜索的结果，但是我们同时也想在页面上提供更丰富的信息，包括（与搜索匹配的）上个月度汽车的平均售价。</p><p>这里我们无法简单的做范围限定，因为有两个不同的条件。搜索结果必须是 ford ，但是聚合结果必须满足 ford AND sold &gt; now - 1M 。</p><p>为了解决这个问题，我们可以用一种特殊的桶，叫做 filter （注：过滤桶） 。 我们可以指定一个过滤桶，当文档满足过滤桶的条件时，我们将其加入到桶内。</p><p>查询结果如下：<br><code>GET /cars/transactions/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;recent_sales&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;filter&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;sold&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;now-1M&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;average_price&quot;</span>:&#123;</span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 过滤 桶在 查询 范围基础上应用过滤器。</p></li><li><p>avg 度量只会对 ford 和上个月售出的文档计算平均售价。</p></li></ul><p>因为 <code>filter</code> 桶和其他桶的操作方式一样，所以可以随意将其他桶和度量嵌入其中。所有嵌套的组件都会 “继承” 这个过滤，这使我们可以按需针对聚合过滤出选择部分。</p><h2 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器"></a>后过滤器</h2><p>目前为止，我们可以同时对搜索结果和聚合结果进行过滤（不计算得分的 filter 查询），以及针对聚合结果的一部分进行过滤（ filter 桶）。</p><p>我们可能会想，”只过滤搜索结果，不过滤聚合结果呢？” 答案是使用 post_filter 。</p><p>它是接收一个过滤器的顶层搜索请求元素。这个过滤器在查询 之后 执行（这正是该过滤器的名字的由来：它在查询之后 post 执行）。正因为它在查询之后执行，它对查询范围没有任何影响，所以对聚合也不会有任何影响。</p><p>我们可以利用这个行为对查询条件应用更多的过滤器，而不会影响其他的操作，就如 UI 上的各个分类面。让我们为汽车经销商设计另外一个搜索页面，这个页面允许用户搜索汽车同时可以根据颜色来过滤。颜色的选项是通过聚合获得的：</p><p><code>GET /cars/transactions/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: <span class="string">&quot;ford&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;post_filter&quot;</span>: &#123;    </span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;color&quot;</span> : <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;all_colors&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;color&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>post_filter 元素是 top-level 而且仅对命中结果进行过滤。</p></blockquote><p>查询 部分找到所有的 ford 汽车，然后用 terms 聚合创建一个颜色列表。因为聚合对查询范围进行操作，颜色列表与福特汽车有的颜色相对应。</p><p>最后， post_filter 会过滤搜索结果，只展示绿色 ford 汽车。这在查询执行过 后 发生，所以聚合不受影响。</p><p>这通常对 UI 的连贯一致性很重要，可以想象用户在界面商选择了一类颜色（比如：绿色），期望的是搜索结果已经被过滤了，而 不是 过滤界面上的选项。如果我们应用 filter 查询，界面会马上变成 只 显示 绿色 作为选项，这不是用户想要的！</p><p>⚠️ ⚠️ ⚠️</p><h2 id="性能考虑（Performance-consideration）"><a href="#性能考虑（Performance-consideration）" class="headerlink" title="性能考虑（Performance consideration）"></a>性能考虑（Performance consideration）</h2><p>当你需要对搜索结果和聚合结果做不同的过滤时，你才应该使用 post_filter ， 有时用户会在普通搜索使用 post_filter 。</p><p>不要这么做！ post_filter 的特性是在查询 之后 执行，任何过滤对性能带来的好处（比如缓存）都会完全失去。</p><p>在我们需要不同过滤时， post_filter 只与聚合一起使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择合适类型的过滤（如：搜索命中、聚合或两者兼有）通常和我们期望如何表现用户交互有关。选择合适的过滤器（或组合）取决于我们期望如何将结果呈现给用户。</p><ul><li>在 filter 过滤中的 non-scoring 查询，同时影响搜索结果和聚合结果。</li><li>filter 桶影响聚合。</li><li>post_filter 只影响搜索结果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过滤和聚合&quot;&gt;&lt;a href=&quot;#过滤和聚合&quot; class=&quot;headerlink&quot; title=&quot;过滤和聚合&quot;&gt;&lt;/a&gt;过滤和聚合&lt;/h2&gt;&lt;p&gt;聚合范围限定还有一个自然的扩展就是过滤。因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>聚合 条形图</title>
    <link href="http://example.com/wiki/%E8%81%9A%E5%90%88-%E6%9D%A1%E5%BD%A2%E5%9B%BE/"/>
    <id>http://example.com/wiki/%E8%81%9A%E5%90%88-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</id>
    <published>2021-07-08T07:11:57.000Z</published>
    <updated>2021-07-08T13:21:13.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>嵌套桶</title>
    <link href="http://example.com/wiki/%E5%B5%8C%E5%A5%97%E6%A1%B6/"/>
    <id>http://example.com/wiki/%E5%B5%8C%E5%A5%97%E6%A1%B6/</id>
    <published>2021-07-08T07:01:16.000Z</published>
    <updated>2021-07-08T13:21:24.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两层嵌套"><a href="#两层嵌套" class="headerlink" title="两层嵌套"></a>两层嵌套</h2><p>在我们使用不同的嵌套方案时，聚合的力量才能真正得以显现。 在前例中，我们已经看到如何将一个度量嵌入桶中，它的功能已经十分强大了。</p><p>但真正令人激动的分析来自于将桶嵌套进 另外一个桶 所能得到的结果。 现在，我们想知道每个颜色的汽车制造商的分布：</p><p><code>GET /cars/transactions/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; </span><br><span class="line">               <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;make&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意前例中的 avg_price 度量仍然保持原位。</p></li><li><p>另一个聚合 make 被加入到了 color 颜色桶中。</p></li><li><p>这个聚合是 terms 桶，它会为每个汽车制造商生成唯一的桶。</p></li></ul><p>这里发生了一些有趣的事。 首先，我们可能会观察到之前例子中的 <code>avg_price</code> 度量完全没有变化，还在原来的位置。 一个聚合的每个 层级 都可以有多个度量或桶， <code>avg_price</code> 度量告诉我们每种颜色汽车的平均价格。它与其他的桶和度量相互独立。</p><p>这对我们的应用非常重要，因为这里面有很多相互关联，但又完全不同的度量需要收集。聚合使我们能够用一次数据请求获得所有的这些信息。</p><p>另外一件值得注意的重要事情是我们新增的这个 make 聚合，它是一个 <code>terms</code> 桶（嵌套在 colors 、 terms 桶内）。这意味着它会为数据集中的每个唯一组合生成（ color 、 make ）元组。</p><p>让我们看看返回的响应（为了简单我们只显示部分结果）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123; </span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>, </span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span> </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>正如期望的那样，新的聚合嵌入在每个颜色桶中。</p></li><li><p>现在我们看见按不同制造商分解的每种颜色下车辆信息。</p></li><li><p>最终，我们看到前例中的 avg_price 度量仍然维持不变。</p></li></ul><h2 id="三层嵌套"><a href="#三层嵌套" class="headerlink" title="三层嵌套"></a>三层嵌套</h2><p>让我们回到话题的原点，在进入新话题之前，对我们的示例做最后一个修改， 为每个汽车生成商计算最低和最高的价格：<br><code>GET /cars/transactions/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;avg_price&quot;</span>: &#123; <span class="attr">&quot;avg&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;make&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;make&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">                    <span class="attr">&quot;min_price&quot;</span> : &#123; <span class="attr">&quot;min&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125;, </span><br><span class="line">                    <span class="attr">&quot;max_price&quot;</span> : &#123; <span class="attr">&quot;max&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>&#125; &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们需要增加另外一个嵌套的 aggs 层级。</p></li><li><p>然后包括 min 最小度量。</p></li><li><p>以及 max 最大度量。</p></li></ul><p>得到以下输出（只显示部分结果）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;colors&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="attr">&quot;make&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;honda&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">10000</span> </span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">20000</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;bmw&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="attr">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;max_price&quot;</span>: &#123;</span><br><span class="line">                           <span class="attr">&quot;value&quot;</span>: <span class="number">80000</span></span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">32500</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有了这两个桶，我们可以对查询的结果进行扩展并得到以下信息：  </p><p>有四辆红色车。<br>红色车的平均售价是 $32，500 美元。<br>其中三辆红色车是 Honda 本田制造，一辆是 BMW 宝马制造。<br>最便宜的红色本田售价为 $10，000 美元。<br>最贵的红色本田售价为 $20，000 美元。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两层嵌套&quot;&gt;&lt;a href=&quot;#两层嵌套&quot; class=&quot;headerlink&quot; title=&quot;两层嵌套&quot;&gt;&lt;/a&gt;两层嵌套&lt;/h2&gt;&lt;p&gt;在我们使用不同的嵌套方案时，聚合的力量才能真正得以显现。 在前例中，我们已经看到如何将一个度量嵌入桶中，它的功能已经十分强大</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>聚合 高级概念</title>
    <link href="http://example.com/wiki/%E8%81%9A%E5%90%88-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/wiki/%E8%81%9A%E5%90%88-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</id>
    <published>2021-07-08T06:52:35.000Z</published>
    <updated>2021-07-08T13:21:08.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h2><p><code>桶</code> 简单来说就是满足特定条件的文档的集合：</p><ul><li>一个雇员属于 男性 桶或者 女性 桶</li><li>奥尔巴尼属于 纽约 桶</li><li>日期2014-10-28属于 十月 桶<br>当聚合开始被执行，每个文档里面的值通过计算来决定符合哪个桶的条件。如果匹配到，文档将放入相应的桶并接着进行聚合操作。</li></ul><p>桶也可以被嵌套在其他桶里面，提供层次化的或者有条件的划分方案。例如，辛辛那提会被放入俄亥俄州这个桶，而 整个 俄亥俄州桶会被放入美国这个桶。</p><p>Elasticsearch 有很多种类型的桶，能让你通过很多种方式来划分文档（<code>时间</code>、<code>最受欢迎的词</code>、<code>年龄区间</code>、<code>地理位置</code> 等等）。其实根本上都是通过同样的原理进行操作：基于条件来划分文档。</p><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>桶能让我们划分文档到有意义的集合，但是最终我们需要的是对这些桶内的文档进行一些指标的计算。分桶是一种达到目的的手段：它提供了一种给文档分组的方法来让我们可以计算感兴趣的指标。</p><p>大多数 <code>指标</code> 是简单的数学运算（例如最小值、平均值、最大值，还有汇总），这些是通过文档的值来计算。在实践中，指标能让你计算像平均薪资、最高出售价格、95%的查询延迟这样的数据。</p><h2 id="桶和指标的组合"><a href="#桶和指标的组合" class="headerlink" title="桶和指标的组合"></a>桶和指标的组合</h2><p><code>聚合</code> 是由桶和指标组成的。 聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。也有可能有一些桶嵌套在其他桶里面。例如，我们可以通过所属国家来划分文档（桶），然后计算每个国家的平均薪酬（指标）。</p><p>由于桶可以被嵌套，我们可以实现非常多并且非常复杂的聚合：</p><p>1.通过国家划分文档（桶）</p><p>2.然后通过性别划分每个国家（桶）</p><p>3.然后通过年龄区间划分每种性别（桶）</p><p>4.最后，为每个年龄区间计算平均薪酬（指标）</p><p>最后将告诉你每个 &lt;国家, 性别, 年龄&gt; 组合的平均薪酬。所有的这些都在一个请求内完成并且只遍历一次数据！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;桶&quot;&gt;&lt;a href=&quot;#桶&quot; class=&quot;headerlink&quot; title=&quot;桶&quot;&gt;&lt;/a&gt;桶&lt;/h2&gt;&lt;p&gt;&lt;code&gt;桶&lt;/code&gt; 简单来说就是满足特定条件的文档的集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个雇员属于 男性 桶或者 女性 桶&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Aggregations" scheme="http://example.com/categories/Elasticsearch/Aggregations/"/>
    
    
    <category term="elasticsaerch" scheme="http://example.com/tags/elasticsaerch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch-overview</title>
    <link href="http://example.com/wiki/elasticsearch-overview/"/>
    <id>http://example.com/wiki/elasticsearch-overview/</id>
    <published>2021-07-08T03:17:58.000Z</published>
    <updated>2021-07-08T13:15:46.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li> <a href="https://doc.codingdict.com/elasticsearch/">https://www.codingdict.com/</a></li><li> <a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></li><li> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indexing-buffer.html">https://www.elastic.co/guide/en/</a></li><li> <a href="https://elastic.blog.csdn.net/">铭毅天下</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://doc.codingdict.com/elasticsearch/&quot;&gt;htt</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Getting Started" scheme="http://example.com/categories/Elasticsearch/Getting-Started/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>关于 Elasticsearch 内存占用及分配</title>
    <link href="http://example.com/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/"/>
    <id>http://example.com/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/</id>
    <published>2021-07-08T02:39:16.000Z</published>
    <updated>2021-07-08T13:18:44.472Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 和 Lucene 对内存使用情况： </p><img src='https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/es-cache.png' width=500 height=550><p>Elasticsearch 限制的内存大小是 JAVA 堆空间的大小，不包括Lucene 缓存倒排索引数据空间。</p><p>Lucene 中的 倒排索引 segments 存储在文件中，为提高访问速度，都会把它加载到内存中，从而提高 Lucene 性能。所以建议至少留系统一半内存给Lucene。<br><code>Node Query Cache</code> (负责缓存f ilter 查询结果)，每个节点有一个，被所有 shard 共享，filter query查询结果要么是 yes 要么是no，不涉及 scores 的计算。<br>集群中每个节点都要配置，默认为：indices.queries.cache.size:10%</p><p><code>Indexing Buffer</code> 索引缓冲区，用于存储新索引的文档，当其被填满时，缓冲区中的文档被写入磁盘中的 <code>segments</code> 中。节点上所有 <code>shard</code> 共享。<br>缓冲区默认大小： indices.memory.index_buffer_size: 10%<br>如果缓冲区大小设置了百分百则 indices.memory.min_index_buffer_size 用于这是最小值，默认为 48mb。indices.memory.max_index_buffer_size 用于最大大小，无默认值。</p><p><code>segments</code><br>segments会长期占用内存，其初衷就是利用OS的cache提升性能。只有在Merge之后，才会释放掉标记为Delete的segments，释放部分内存。</p><p><code>Shard Request Cache</code> 用于缓存请求结果，但之缓存request size为0的。比如说 hits.total, aggregations 和 suggestions.<br>默认最大为indices.requests.cache.size:1%</p><p><code>Field Data Cache</code> 字段缓存重要用于对字段进行排序、聚合是使用。因为构建字段数据缓存代价昂贵，所以建议有足够的内训来存储。<br><code>Fielddata</code> 是 「 延迟 」 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中，也就不会使用大量的内存，所以可以考虑分配较小的heap给Elasticsearch。因为heap越小意味着Elasticsearch的GC会比较快，并且预留给Lucene的内存也会比较大。。<br>如果没有足够的内存保存fielddata时，Elastisearch会不断地从磁盘加载数据到内存，并剔除掉旧的内存数据。剔除操作会造成严重的磁盘I/O，并且引发大量的GC，会严重影响Elastisearch的性能。</p><p>默认情况下Fielddata会不断占用内存，直到它触发了fielddata circuit breaker。<br>fielddata circuit breaker会根据查询条件评估这次查询会使用多少内存，从而计算加载这部分内存之后，Field Data Cache所占用的内存是否会超过indices.breaker.fielddata.limit。如果超过这个值，就会触发fielddata circuit breaker，abort这次查询并且抛出异常，防止OOM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indices.breaker.fielddata.limit:60% (默认heap的60%)  (es7之后改成70%)</span><br></pre></td></tr></table></figure><p>如果设置了indices.fielddata.cache.size，当达到size时，cache会剔除旧的fielddata。</p><blockquote><p>indices.breaker.fielddata.limit 必须大于 indices.fielddata.cache.size，否则只会触发fielddata circuit breaker，而不会剔除旧的fielddata。</p></blockquote><h2 id="配置Elasticsearch堆内存"><a href="#配置Elasticsearch堆内存" class="headerlink" title="配置Elasticsearch堆内存"></a>配置Elasticsearch堆内存</h2><p>Elasticsearch默认安装后设置的内存是 <code>1GB</code>，这是远远不够用于生产环境的。<br>有两种方式修改Elasticsearch的堆内存：</p><blockquote><ol><li>设置环境变量：<code>export ES_HEAP_SIZE=10g</code> 在es启动时会读取该变量；</li><li>启动时作为参数传递给es： <code>./bin/elasticsearch -Xmx10g -Xms10g</code></li></ol></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>给es分配内存时要注意，至少要分配一半儿内存留给 Lucene。<br>分配给 es 的内存最好不要超过 32G ，因为如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。如果大于32G 每个指针占用 8字节，并且会占用更多的内存带宽，降低了cpu性能。</p><p>还有一点， 要关闭 <code>swap</code> 内存交换空间，禁用swapping。频繁的swapping 对服务器来说是致命的。<br>总结：给es JVM栈的内存最好不要超过32G，留给Lucene的内存越大越好，Lucene把所有的segment都缓存起来，会加快全文检索。</p><h2 id="关闭交换区"><a href="#关闭交换区" class="headerlink" title="关闭交换区"></a>关闭交换区</h2><p>这应该显而易见了，但仍然需要明确的写出来：把内存换成硬盘将毁掉服务器的性能，想象一下：涉及内存的操作是需要快速执行的。如果介质从内存变为了硬盘，一个10微秒的操作变成需要10毫秒。而且这种延迟发生在所有本该只花费10微秒的操作上，就不难理解为什么交换区对于性能来说是噩梦。</p><p>最好的选择是禁用掉操作系统的交换区。可以用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><p>来禁用，你可能还需要编辑 <code>/etc/fstab</code> 文件。细节可以参考你的操作系统文档。</p><p>如果实际环境不允许禁用掉 <code>swap</code>，你可以尝试降低 <code>swappiness</code>。此值控制操作系统使用交换区的积极性。这可以防止在正常情况下使用交换区，但仍允许操作系统在紧急情况下将内存里的东西放到交换区。</p><p>对于大多数Linux系统来说，这可以用 <code>sysctl</code> 值来配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 将此值配置为1会比0好，在kernal内核的某些版本中，0可能会引起OOM异常。</span></span><br></pre></td></tr></table></figure><p>最后，如果两种方法都不可用，你应该在ElasticSearch的配置中启用 <code>mlockall.file</code>。这允许JVM锁定其使用的内存，而避免被放入操作系统交换区。</p><p>在elasticsearch.yml中，做如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.mlockall: true</span><br></pre></td></tr></table></figure><h2 id="查看node节点数据"><a href="#查看node节点数据" class="headerlink" title="查看node节点数据"></a>查看node节点数据</h2><p><code>GET /_cat/nodes?v&amp;h=id,ip,port,v,master,name,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p><p><code>GET /_cat/nodes?v&amp;h=id,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size</code></p><p><code>GET /_cat/nodes?v&amp;h=id,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch 和 Lucene 对内存使用情况： &lt;/p&gt;
&lt;img src=&#39;https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Administration and Deployment" scheme="http://example.com/categories/Elasticsearch/Administration-and-Deployment/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>cross-fields跨字段查询</title>
    <link href="http://example.com/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-07-07T06:41:42.000Z</published>
    <updated>2021-07-08T13:09:24.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_cross_fields_queries.html#_cross_fields_queries">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » cross-fields 跨字段查询</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/el</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Search in Depth" scheme="http://example.com/categories/Elasticsearch/Search-in-Depth/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>copy_to参数</title>
    <link href="http://example.com/wiki/copy-to%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/wiki/copy-to%E5%8F%82%E6%95%B0/</id>
    <published>2021-07-07T06:34:42.000Z</published>
    <updated>2021-07-08T13:07:44.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/custom-all.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 自定义 _all 字段</a></li><li><a href="https://doc.codingdict.com/elasticsearch/319/">Docs » Mapping parameters（映射参数） » Mapping(映射) » copy_to（合并参数）</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/el</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Search in Depth" scheme="http://example.com/categories/Elasticsearch/Search-in-Depth/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>字符串排序与多字段</title>
    <link href="http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/"/>
    <id>http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/</id>
    <published>2021-07-07T03:05:31.000Z</published>
    <updated>2021-07-08T13:28:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p><p>你可以使用 min 和 max 排序模式（默认是 min ），但是这会导致排序以 art 或是 old ，任何一个都不是所希望的。</p><p>为了以字符串字段进行排序，这个字段应仅包含一项： 整个 not_analyzed 字符串。 但是我们仍需要 analyzed 字段，这样才能以全文进行查询</p><p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： analyzed 用于搜索， not_analyzed 用于排序</p><p>但是保存相同的字符串两次在 _source 字段是浪费空间的。 我们真正想要做的是传递一个 单字段 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 fields 参数</p><p>该参数允许你转化一个简单的映射如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为一个多字段映射如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;tweet&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;raw&quot;</span>: &#123; </span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>tweet 主字段与之前的一样: 是一个 analyzed 全文字段。</p></li><li><p>新的 tweet.raw 子字段是 not_analyzed.</p></li></ul><p>现在，至少只要我们重新索引了我们的数据，使用 tweet 字段用于搜索，<code>tweet.raw</code> 字段用于排序：<br><code>curl -X GET &quot;localhost:9200/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;tweet&quot;</span>: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="string">&quot;tweet.raw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 fine old art ， 这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Getting Started" scheme="http://example.com/categories/Elasticsearch/Getting-Started/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐系统-Overview</title>
    <link href="http://example.com/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/"/>
    <id>http://example.com/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/</id>
    <published>2021-07-07T02:08:05.000Z</published>
    <updated>2021-07-13T03:45:26.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客资料"><a href="#博客资料" class="headerlink" title="博客资料"></a>博客资料</h2><ul><li><a href="https://blog.csdn.net/qq_40027052/article/details/78733365">深度解析京东个性化推荐系统演进史</a>  </li><li><a href="https://www.cnblogs.com/liuning8023/p/5522619.html">用 Mahout 和 Elasticsearch 实现推荐系统</a></li><li><a href="https://tech.meituan.com/2015/01/22/mt-recommend-practice.html">美团推荐算法实践</a></li><li><a href="https://blog.csdn.net/love284969214/article/details/82932064">58同城推荐系统设计与实现</a></li><li><a href="http://www.360doc.com/content/16/0307/22/31263000_540328712.shtml">微博推荐系统的架构演进之路</a></li><li><a href="https://blog.csdn.net/tzs_1041218129/article/details/103331908">Flink 在小红书推荐系统中的应用</a></li><li><a href="https://www.slidestalk.com/YunQi/XiaoHongShu_BigData_Platform_Evolution">小红书大数据在推荐系统中的应用</a></li><li><a href="https://www.slidestalk.com/u223/rs_in_kuaikan">快看漫画个性化推荐探索与实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/45123018">数据仓库系列篇——唯品会大数据架构</a></li><li><a href="https://developer.aliyun.com/article/763941">推荐系统基本概念和架构</a></li><li><a href="https://bp.aliyun.com/detail/140">PAI平台搭建企业级个性化推荐系统 - Aliyun</a></li><li><a href="https://www.aliyun.com/product/bigdata/product/learn"></a></li><li><a href="https://toutiao.io/posts/35tpcy/preview">蘑菇街推荐工程实践</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;博客资料&quot;&gt;&lt;a href=&quot;#博客资料&quot; class=&quot;headerlink&quot; title=&quot;博客资料&quot;&gt;&lt;/a&gt;博客资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40027052/article/detai</summary>
      
    
    
    
    <category term="Recommend System" scheme="http://example.com/categories/Recommend-System/"/>
    
    <category term="Overview" scheme="http://example.com/categories/Recommend-System/Overview/"/>
    
    
    <category term="推荐" scheme="http://example.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>flink 提交任务</title>
    <link href="http://example.com/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-07-06T15:57:04.000Z</published>
    <updated>2021-07-07T14:25:24.237Z</updated>
    
    <content type="html"><![CDATA[<p>下面演示如何通过admin页面提交任务 👇</p><h2 id="准备task-jar"><a href="#准备task-jar" class="headerlink" title="准备task jar"></a>准备task jar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>mvn install -DskipTest</code> 可以得到相应的jar</p><h2 id="admin提交jar"><a href="#admin提交jar" class="headerlink" title="admin提交jar"></a>admin提交jar</h2><img src='https://oscimg.oschina.net/oscnet/up-6f96aa46a523c9cd32f12177775b6d6fab9.png' width=900 height=450> <p>提交完jar包之后，需要设置相关参数，这个根据自己的实际情况来设置，下面是参考样例： </p><ul><li>Enter Class : com.ibli.flink.StreamWordCount<br>也就是程序入口，我们这是写了一个main方法，如果是程序的话，可以写对应bootstrap的启动类</li><li>Program Arguments : –host localhost –port 7777 </li></ul><p>点击 <code>submit</code>  之后查看提交的任务状态</p><h2 id="查看任务"><a href="#查看任务" class="headerlink" title="查看任务"></a>查看任务</h2><img src='https://oscimg.oschina.net/oscnet/up-f11b32799d87f90c6e78732db82f191be3b.png' width=900 height=450>  <p>可以看到是有两个任务，并且都是在执行状态；<br>点击一个任务，还可以查看任务详情信息，和一些其他的信息，非常全面；</p><img src="https://oscimg.oschina.net/oscnet/up-9678050d3906aae9ccead23d02927d46851.png" width=900 height=450><h2 id="查看运行时任务列表"><a href="#查看运行时任务列表" class="headerlink" title="查看运行时任务列表"></a>查看运行时任务列表</h2><img src='https://oscimg.oschina.net/oscnet/up-da8bf04ac90ae3c16095a6ebf25175b4452.png' width=900 height=350><h2 id="查看任务管理列表"><a href="#查看任务管理列表" class="headerlink" title="查看任务管理列表"></a>查看任务管理列表</h2><img src="https://oscimg.oschina.net/oscnet/up-a85746f93dc171f3d320a17c07294682bb3.png" width=900 height=450><p>点击任务可以跳转到详情页面 👇 下面是执行日志 </p><img src= 'https://oscimg.oschina.net/oscnet/up-a11c7ccc522c77d100d57a9c2a08ec9183b.png' width=900 height=500><p>我们还可以看到任务执行的标准输出结果✅</p><img src="https://oscimg.oschina.net/oscnet/up-3d990a6318fab3a11e7336fdcd271851fda.png" width=900 height=400><h2 id="任务源数据"><a href="#任务源数据" class="headerlink" title="任务源数据"></a>任务源数据</h2><p>通过nc 输入数据，由程序读取7777端口输入流并解析数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gaolei:geekibli gaolei$ nc -lk 7777</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure><h2 id="取消任务如下"><a href="#取消任务如下" class="headerlink" title="取消任务如下"></a>取消任务如下</h2><img src='https://oscimg.oschina.net/oscnet/up-05199d86b957e0adec4e4d91390a0aebbec.png' width=900 height=400> <p>再次查看已完成任务列表 如下：</p><img src='https://oscimg.oschina.net/oscnet/up-78c97d4c4aec1641a22165735764c54b969.png' width=900 height=400>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面演示如何通过admin页面提交任务 👇&lt;/p&gt;
&lt;h2 id=&quot;准备task-jar&quot;&gt;&lt;a href=&quot;#准备task-jar&quot; class=&quot;headerlink&quot; title=&quot;准备task jar&quot;&gt;&lt;/a&gt;准备task jar&lt;/h2&gt;&lt;figure cla</summary>
      
    
    
    
    <category term="Apache Flink" scheme="http://example.com/categories/Apache-Flink/"/>
    
    
    <category term="flink" scheme="http://example.com/tags/flink/"/>
    
  </entry>
  
</feed>
