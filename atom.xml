<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-27T12:13:40.572Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty实现简易RPC调用</title>
    <link href="http://example.com/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93RPC%E8%B0%83%E7%94%A8/</id>
    <published>2021-07-27T12:01:08.000Z</published>
    <updated>2021-07-27T12:13:40.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Netty手写一个RPC简易远程调用"><a href="#基于Netty手写一个RPC简易远程调用" class="headerlink" title="基于Netty手写一个RPC简易远程调用"></a>基于Netty手写一个RPC简易远程调用</h1><p><img src="https://oscimg.oschina.net/oscnet/up-b813c676214fc02b6f107ca7f6133a635fb.png">    </p><h2 id="抽象协议"><a href="#抽象协议" class="headerlink" title="抽象协议"></a>抽象协议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class InvokerProtocol implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    // 基于二进制流调用协议</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类名</span><br><span class="line">     */</span><br><span class="line">    private String className;</span><br><span class="line">    /**</span><br><span class="line">     * 方法名</span><br><span class="line">     */</span><br><span class="line">    private String methodName;</span><br><span class="line">    /**</span><br><span class="line">     * 形参</span><br><span class="line">     */</span><br><span class="line">    private Class&lt;?&gt;[] params;</span><br><span class="line">    /**</span><br><span class="line">     * 实参</span><br><span class="line">     */</span><br><span class="line">    private Object[] values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="RpcRegistry-基于Netty实现的RPC注册中心"><a href="#RpcRegistry-基于Netty实现的RPC注册中心" class="headerlink" title="RpcRegistry 基于Netty实现的RPC注册中心"></a>RpcRegistry 基于Netty实现的RPC注册中心</h3><blockquote><p>1、 ServerBootstrap 启动8080端口，等待客户端链接；<br>2、 RegisterHandler用来处理RPC接口的发现和注册；    </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class RpcRegistry &#123;</span><br><span class="line"></span><br><span class="line">    private Integer post;</span><br><span class="line"></span><br><span class="line">    public RpcRegistry(Integer post) &#123;</span><br><span class="line">        this.post = post;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void start() &#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap server = new ServerBootstrap();</span><br><span class="line">        server.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">                        // 接受客户端请求的处理</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        //配置通用解码器</span><br><span class="line">                        int fieldLength = 4;</span><br><span class="line">                        pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, fieldLength, 0, fieldLength));</span><br><span class="line">                        pipeline.addLast(new LengthFieldPrepender(fieldLength));</span><br><span class="line">                        //对象编码器</span><br><span class="line">                        pipeline.addLast(&quot;encoder&quot;, new ObjectEncoder());</span><br><span class="line">                        pipeline.addLast(&quot;decoder&quot;, new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));</span><br><span class="line">                        pipeline.addLast(new RegisterHandler());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ChannelFuture future = server.bind(this.post).sync();</span><br><span class="line">            System.out.println(&quot;Rpc registry started in port &quot; + this.post);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new RpcRegistry(8080).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RegisterHandler-执行RPC的发现和注册"><a href="#RegisterHandler-执行RPC的发现和注册" class="headerlink" title="RegisterHandler 执行RPC的发现和注册"></a>RegisterHandler 执行RPC的发现和注册</h3><blockquote><p>1、扫描固定包下或者路径下的类;<br>2、接口为key，具体实例作为value；  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class RegisterHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 注册中心容器</span><br><span class="line">     */</span><br><span class="line">    private static final ConcurrentHashMap&lt;String, Object&gt; REGISTRY_MAP = new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; classNameList = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public RegisterHandler() &#123;</span><br><span class="line">        // 1、扫描所有需要注册的类</span><br><span class="line">        scannerClass(&quot;com.ibli.netty.rpc.provider&quot;);</span><br><span class="line">        // 执行注册</span><br><span class="line">        doRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        InvokerProtocol request = (InvokerProtocol) msg;</span><br><span class="line">        if (REGISTRY_MAP.containsKey(request.getClassName())) &#123;</span><br><span class="line">            Object provider = REGISTRY_MAP.get(request.getClassName());</span><br><span class="line">            Method method = provider.getClass().getMethod(request.getMethodName(), request.getParams());</span><br><span class="line">            result = method.invoke(provider, request.getValues());</span><br><span class="line">            ctx.write(result);</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doRegistry() &#123;</span><br><span class="line">        if (classNameList.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String className : classNameList) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                Class&lt;?&gt; i = clazz.getInterfaces()[0];</span><br><span class="line">                REGISTRY_MAP.put(i.getName(), clazz.newInstance());</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scannerClass(String packageName) &#123;</span><br><span class="line">        URL url = this.getClass().getClassLoader().getResource(packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;));</span><br><span class="line">        File dir = new File(url.getFile());</span><br><span class="line">        for (File file : dir.listFiles()) &#123;</span><br><span class="line">            if (file.isDirectory()) &#123;</span><br><span class="line">                scannerClass(packageName + &quot;.&quot; + file.getName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                classNameList.add(packageName + &quot;.&quot; + file.getName().replace(&quot;.class&quot;, &quot;&quot;).trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API以及实现"><a href="#API以及实现" class="headerlink" title="API以及实现"></a>API以及实现</h2><h3 id="RPC接口-定义一个简单的服务接口"><a href="#RPC接口-定义一个简单的服务接口" class="headerlink" title="RPC接口 定义一个简单的服务接口"></a>RPC接口 定义一个简单的服务接口</h3><blockquote><p>作为一个微服务对外暴露的API;  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IRpcService &#123;</span><br><span class="line">    int add(int a, int b);</span><br><span class="line"></span><br><span class="line">    int mul(int a, int b);</span><br><span class="line"></span><br><span class="line">    int sub(int a, int b);</span><br><span class="line"></span><br><span class="line">    int div(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC接口实现"><a href="#RPC接口实现" class="headerlink" title="RPC接口实现"></a>RPC接口实现</h3><blockquote><p>provider实现具体的接口，提供具体的服务；  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class RpcServiceImpl implements IRpcService &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int mul(int a, int b) &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sub(int a, int b) &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int div(int a, int b) &#123;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RPC调用方"><a href="#RPC调用方" class="headerlink" title="RPC调用方"></a>RPC调用方</h2><h3 id="调用RPC"><a href="#调用RPC" class="headerlink" title="调用RPC"></a>调用RPC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RpcConsumer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IRpcService rpc = RpcProxy.create(IRpcService.class);</span><br><span class="line">        System.err.println(rpc.add(1,3));</span><br><span class="line">        System.err.println(rpc.mul(3,3));</span><br><span class="line">        System.err.println(rpc.sub(14,3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RpcProxy-动态代理对象请求RPC"><a href="#RpcProxy-动态代理对象请求RPC" class="headerlink" title="RpcProxy 动态代理对象请求RPC"></a>RpcProxy 动态代理对象请求RPC</h2><blockquote><p>通过Netty Bootstrap访问8080端口；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class RpcProxy &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T create(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        MethodProxy proxy = new MethodProxy(clazz);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.isInterface() ?</span><br><span class="line">                new Class[]&#123;clazz&#125; :</span><br><span class="line">                clazz.getInterfaces();</span><br><span class="line">        T result = (T) Proxy.newProxyInstance(clazz.getClassLoader(), interfaces, proxy);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MethodProxy implements InvocationHandler &#123;</span><br><span class="line">        private Class&lt;?&gt; clazz;</span><br><span class="line"></span><br><span class="line">        public MethodProxy(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">            this.clazz = clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                return method.invoke(this, args);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return rpcInvoke(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private Object rpcInvoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line"></span><br><span class="line">            //封装请求的内容</span><br><span class="line">            InvokerProtocol msg = new InvokerProtocol();</span><br><span class="line">            msg.setClassName(this.clazz.getName());</span><br><span class="line">            msg.setMethodName(method.getName());</span><br><span class="line">            msg.setParams(method.getParameterTypes());</span><br><span class="line">            msg.setValues(args);</span><br><span class="line">            </span><br><span class="line">            final RpcProxyHandler consumerHandler = new RpcProxyHandler();</span><br><span class="line">            EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Bootstrap client = new Bootstrap();</span><br><span class="line">                client.group(group)</span><br><span class="line">                        .channel(NioSocketChannel.class)</span><br><span class="line">                        .handler(new ChannelInitializer() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            protected void initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">                                //接收课客户端请求的处理流程</span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                                int fieldLength = 4;</span><br><span class="line">                                //通用解码器设置</span><br><span class="line">                                pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, fieldLength, 0, fieldLength));</span><br><span class="line">                                //通用编码器</span><br><span class="line">                                pipeline.addLast(new LengthFieldPrepender(fieldLength));</span><br><span class="line">                                //对象编码器</span><br><span class="line">                                pipeline.addLast(&quot;encoder&quot;, new ObjectEncoder());</span><br><span class="line">                                //对象解码器</span><br><span class="line">                                pipeline.addLast(&quot;decoder&quot;, new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));</span><br><span class="line"></span><br><span class="line">                                pipeline.addLast(&quot;handler&quot;, consumerHandler);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line"></span><br><span class="line">                ChannelFuture future = client.connect(&quot;localhost&quot;, 8080).sync();</span><br><span class="line">                future.channel().writeAndFlush(msg).sync();</span><br><span class="line">                future.channel().closeFuture().sync();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return consumerHandler.getResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC调用方接受并处理调用结果"><a href="#RPC调用方接受并处理调用结果" class="headerlink" title="RPC调用方接受并处理调用结果"></a>RPC调用方接受并处理调用结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RpcProxyHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private Object response;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        this.response = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getResponse() &#123;</span><br><span class="line">        return this.response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Netty手写一个RPC简易远程调用&quot;&gt;&lt;a href=&quot;#基于Netty手写一个RPC简易远程调用&quot; class=&quot;headerlink&quot; title=&quot;基于Netty手写一个RPC简易远程调用&quot;&gt;&lt;/a&gt;基于Netty手写一个RPC简易远程调用&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>netty实现简易tomcat</title>
    <link href="http://example.com/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/"/>
    <id>http://example.com/wiki/netty%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93tomcat/</id>
    <published>2021-07-27T11:54:15.000Z</published>
    <updated>2021-07-27T11:55:32.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Netty手写一个简易的Tomcat容器"><a href="#基于Netty手写一个简易的Tomcat容器" class="headerlink" title="基于Netty手写一个简易的Tomcat容器"></a>基于Netty手写一个简易的Tomcat容器</h1><p>本文主要基于传统的BIO来实现一个简单的Http请求处理过程；<br>1、Servlet请求无非就是doGet/doPost，所以我们定义抽象Servlet记忆GET/POST方法；<br>2、基于Netty API实现CS通信；<br>3、模拟Spring加载配置文件，注册请求以及控制器；  </p><p><img src="https://oscimg.oschina.net/oscnet/up-6bb2d717164854e73513f9ed1355d1844bc.png">   </p><h2 id="Netty版本"><a href="#Netty版本" class="headerlink" title="Netty版本"></a>Netty版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">4.1</span><span class="number">.6</span>.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单"><a href="#GlRequest-基于Netty-amp-HttpRequest的API操作，非常简单" class="headerlink" title="GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单"></a>GlRequest 基于Netty&amp;HttpRequest的API操作，非常简单</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlRequest</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.uri();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.method().name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getParams() &#123;</span><br><span class="line">        QueryStringDecoder decoder = <span class="keyword">new</span> QueryStringDecoder(req.uri());</span><br><span class="line">        <span class="keyword">return</span> decoder.parameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParam</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = getParams();</span><br><span class="line">        List&lt;String&gt; strings = params.get(name);</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GlResponse-基于Netty-amp-FullHttpResponse的API操作"><a href="#GlResponse-基于Netty-amp-FullHttpResponse的API操作" class="headerlink" title="GlResponse 基于Netty&amp;FullHttpResponse的API操作"></a>GlResponse 基于Netty&amp;FullHttpResponse的API操作</h2><blockquote><p>FullHttpResponse作为返回请求的主体；  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">private</span> HttpRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlResponse</span><span class="params">(ChannelHandlerContext ctx, HttpRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.req = req;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                    HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK,</span><br><span class="line">                    Unpooled.wrappedBuffer(string.getBytes(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            response.headers().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            ctx.write(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ctx.flush();</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GlServlet-定义抽象servlet，定义GET方法和POST方法"><a href="#GlServlet-定义抽象servlet，定义GET方法和POST方法" class="headerlink" title="GlServlet 定义抽象servlet，定义GET方法和POST方法"></a>GlServlet 定义抽象servlet，定义GET方法和POST方法</h2><blockquote><p>定义抽象的Servlet和doGet方法和doPost方法，具体的业务去实现自己的方法和逻辑；  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (GET.equals(request.getMethod())) &#123;</span><br><span class="line">               doGet(request, response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               doPost(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="FirstServlet-具体的业务Servlet实现抽象Servlet的方法"><a href="#FirstServlet-具体的业务Servlet实现抽象Servlet的方法" class="headerlink" title="FirstServlet 具体的业务Servlet实现抽象Servlet的方法"></a>FirstServlet 具体的业务Servlet实现抽象Servlet的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This is first servlet from NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecondServlet-具体的业务Servlet实现抽象Servlet方法"><a href="#SecondServlet-具体的业务Servlet实现抽象Servlet方法" class="headerlink" title="SecondServlet 具体的业务Servlet实现抽象Servlet方法"></a>SecondServlet 具体的业务Servlet实现抽象Servlet方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GlServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GlRequest request, GlResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response.write(<span class="string">&quot;This second request form NIO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="web-nio-properties-配置文件"><a href="#web-nio-properties-配置文件" class="headerlink" title="web-nio.properties 配置文件"></a>web-nio.properties 配置文件</h2><blockquote><p>配置请求和处理器，Spring中是通过Controller下的@XXXMapping注解去扫描并加载到工厂的；  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">servlet.one.className=com.ibli.netty.tomcat.nio.servlet.FirstServlet</span><br><span class="line">servlet.one.url=/firstServlet.<span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">servlet.two.className=com.ibli.netty.tomcat.nio.servlet.SecondServlet</span><br><span class="line">servlet.two.url=/secondServlet.<span class="keyword">do</span></span><br></pre></td></tr></table></figure><h2 id="GlTomcat"><a href="#GlTomcat" class="headerlink" title="GlTomcat"></a>GlTomcat</h2><blockquote><p>启动服务端，在网页中访问本地8080端口，输入配置文件中定义的url进行测试：  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> Properties webXml = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GlServlet&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;String, GlServlet&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GlTomcat().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat的启动入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、加载web配置文件，解析配置</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Boss线程</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// Worker线程</span></span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2、创建Netty服务端对象</span></span><br><span class="line">        ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3、 配置服务端参数</span></span><br><span class="line">        server.group(bossGroup, workGroup)</span><br><span class="line">                <span class="comment">// 配置主线程的处理逻辑</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 子线程的回调逻辑</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel client)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 处理具体的回调逻辑</span></span><br><span class="line">                        <span class="comment">// 责任链模式</span></span><br><span class="line">                        <span class="comment">//返回-编码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">                        <span class="comment">//请求-解码</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">                        <span class="comment">//用户自己的逻辑处理</span></span><br><span class="line">                        client.pipeline().addLast(<span class="keyword">new</span> GlTomcatHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 配置主线程可分配的最大线程数</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//保持长链接</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future = server.bind(<span class="keyword">this</span>.PORT).sync();</span><br><span class="line">            System.err.println(<span class="string">&quot;Gl tomcat started in pory &quot;</span> + <span class="keyword">this</span>.PORT);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     * 这其实使用了策略模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String WEB_INF = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(WEB_INF + <span class="string">&quot;web-nio.properties&quot;</span>);</span><br><span class="line">            webXml.load(fis);</span><br><span class="line">            <span class="keyword">for</span> (Object k : webXml.keySet()) &#123;</span><br><span class="line">                String key = k.toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&quot;.url&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//servlet.two.url</span></span><br><span class="line">                    String servletName = key.replaceAll(<span class="string">&quot;\\.url&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    String url = webXml.getProperty(key);</span><br><span class="line">                    <span class="comment">//servlet.two.className</span></span><br><span class="line">                    String className = webXml.getProperty(servletName + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">                    <span class="comment">//反射创建servlet实例</span></span><br><span class="line">                    <span class="comment">// load-on-startup &gt;=1 :web启动的时候初始化  0：用户请求的时候才启动</span></span><br><span class="line">                    GlServlet obj = (GlServlet) Class.forName(className).newInstance();</span><br><span class="line">                    <span class="comment">// 将url和servlet建立映射关系</span></span><br><span class="line">                    servletMapping.put(url, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlTomcatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">                HttpRequest req = (HttpRequest) msg;</span><br><span class="line">                GlRequest request = <span class="keyword">new</span> GlRequest(ctx,req);</span><br><span class="line">                GlResponse response = <span class="keyword">new</span> GlResponse(ctx,req);</span><br><span class="line">                String url = request.getUrl();</span><br><span class="line">                <span class="keyword">if</span> (servletMapping.containsKey(url))&#123;</span><br><span class="line">                    servletMapping.get(url).service(request,response);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    response.write(<span class="string">&quot;404 Not Fount&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><blockquote><p>请求 : <a href="http://localhost:8080/secoundServlet.do">http://localhost:8080/secoundServlet.do</a> 这的地址写错误  ⚠️<br><img src="https://oscimg.oschina.net/oscnet/up-4652c388dd368f575bc5c0719f68a8632df.png">  </p></blockquote><blockquote><p>请求 : <a href="http://localhost:8080/secondServlet.do">http://localhost:8080/secondServlet.do</a><br><img src="https://oscimg.oschina.net/oscnet/up-cc90b46288898bfe801e33f3a94bfab5070.png">  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Netty手写一个简易的Tomcat容器&quot;&gt;&lt;a href=&quot;#基于Netty手写一个简易的Tomcat容器&quot; class=&quot;headerlink&quot; title=&quot;基于Netty手写一个简易的Tomcat容器&quot;&gt;&lt;/a&gt;基于Netty手写一个简易的Tomcat</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
    <category term="netty" scheme="http://example.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Java位运算</title>
    <link href="http://example.com/wiki/Java%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/wiki/Java%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-07-27T11:47:25.000Z</published>
    <updated>2021-07-27T11:49:49.094Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600708864104&di=d036727b38da8177b009afc5268c3a1c&imgtype=0&src=http://t8.baidu.com/it/u=2247852322,986532796&fm=79&app=86&f=JPEG?w=1280&h=853"></p><p>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。</p><h2 id="位操作基础"><a href="#位操作基础" class="headerlink" title="位操作基础"></a>位操作基础</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p><ul><li>在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。</li><li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li><li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，      5，9这些2^i+1的数字。写成int a = 1 « i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 « i) + 1;</li><li>另外位操作还有一些复合操作符，如&amp;=、|=、 ^=、«=、»=。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">        System.out.println(a &gt;&gt; <span class="number">2</span>); <span class="comment">// -4：-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4</span></span><br><span class="line">        System.out.println(b &gt;&gt; <span class="number">2</span>); <span class="comment">// 3：15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用位操作小技巧"><a href="#常用位操作小技巧" class="headerlink" title="常用位操作小技巧"></a>常用位操作小技巧</h2><p>下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。</p><h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。下面程序将输出0到100之间的所有偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">       System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>, d = <span class="number">2</span>;</span><br><span class="line">c ^= d;</span><br><span class="line">d ^= c;</span><br><span class="line">c ^= d;</span><br><span class="line">System.out.println(<span class="string">&quot;c=&quot;</span> + c);</span><br><span class="line">System.out.println(<span class="string">&quot;d=&quot;</span> + d);</span><br></pre></td></tr></table></figure><p>可以这样理解：</p><p>第一步 a=b 即a=(ab)；<br>第二步 b=a 即b=b(ab)，由于运算满足交换律，b(ab)=bba。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值；<br>第三步 a=b 就是a=ab，由于前面二步可知a=(ab)，b=a，所以a=ab即a=(ab)a。故a会被赋上b的值；</p><h3 id="变换符号"><a href="#变换符号" class="headerlink" title="变换符号"></a>变换符号</h3><p>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)</span><br></pre></td></tr></table></figure><p>同样可以这样的将11变成-11</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 1011(二进制) –取反-&gt; 0000 0100(二进制) –加1-&gt; 1111 0101(二进制)</span><br></pre></td></tr></table></figure><p>因此变换符号只需要取反后加1即可。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(~a + <span class="number">1</span>);</span><br><span class="line">System.out.println(~b + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="求绝对值"><a href="#求绝对值" class="headerlink" title="求绝对值"></a>求绝对值</h3><p>位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)</span><br></pre></td></tr></table></figure><p>来得到6。</p><p>因此先移位来取符号位，int i = a » 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println(i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println((a ^ j) - j);</span><br></pre></td></tr></table></figure><p>注意这种方法没用任何判断表达式，而且有些笔面试题就要求这样做，因此建议读者记住该方法（_讲解过后应该是比较好记了）。</p><h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><p>筛素数法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码（注2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印100以内素数：</span></span><br><span class="line"><span class="comment">// （1）对每个素数，它的倍数必定不是素数；</span></span><br><span class="line"><span class="comment">// （2）有很多重复访问如flag[10]会在访问flag[2]和flag[5]时各访问一次；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max];</span><br><span class="line"><span class="keyword">int</span> [] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flags[m]) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags[n] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。</p><p>下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个数指定位上置1</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">e |=  <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure><p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断指定位上是0还是1</span></span><br><span class="line"><span class="keyword">if</span> ((e &amp; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) != <span class="number">0</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;指定位上为0&quot;</span>);</span><br></pre></td></tr></table></figure><p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m += <span class="number">3</span>) &#123;</span><br><span class="line">    bits[m / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (m % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出整个bits</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((bits[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        System.out.print(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.print(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001001001001001001001001001001001001001</span></span><br></pre></td></tr></table></figure><p>可以看出该数组每3个就置成了1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] flags2 = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((((flags2[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        primes[pi++] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">            flags2[n / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (n % <span class="number">32</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="位操作工具类"><a href="#位操作工具类" class="headerlink" title="位操作工具类"></a>位操作工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 位运算的常用方法封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运算数指定位置的值</span></span><br><span class="line"><span class="comment">     * 例如： 0000 1011 获取其第 0 位的值为 1, 第 2 位 的值为 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定位置的值(0 or 1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) ((source &gt;&gt; pos) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置的值置为指定值</span></span><br><span class="line"><span class="comment">     * 例: 0000 1011 需要更新为 0000 1111, 即第 2 位的值需要置为 1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     *            只能取值为 0, 或 1, 所有大于0的值作为1处理, 所有小于0的值作为0处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">setBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            source |= mask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source &amp;= (~mask);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将运算数指定位置取反值</span></span><br><span class="line"><span class="comment">     * 例： 0000 1011 指定第 3 位取反, 结果为 0000 0011; 指定第2位取反, 结果为 0000 1111</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 运算后的结果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">reverseBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> mask = (<span class="keyword">byte</span>) (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) (source ^ mask);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查运算数的指定位置是否为1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     *            需要运算的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos</span></span><br><span class="line"><span class="comment">     *            指定位置 (0&lt;=pos&lt;=7)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示指定位置值为1, false 表示指定位置值为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkBitValue</span><span class="params">(<span class="keyword">byte</span> source, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        source = (<span class="keyword">byte</span>) (source &gt;&gt;&gt; pos);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (source &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入口函数做测试</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取十进制 11 (二级制 0000 1011) 为例子</span></span><br><span class="line">        <span class="keyword">byte</span> source = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取第2位值并输出, 结果应为 0000 1011</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, getBitValue(source, i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位置为1并输出 , 结果为 75 (0100 1011)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + setBitValue(source, <span class="number">6</span>, (<span class="keyword">byte</span>) <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将第6位取反并输出, 结果应为75(0100 1011)</span></span><br><span class="line">        System.out.println(reverseBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 检查第6位是否为1，结果应为false</span></span><br><span class="line">        System.out.println(checkBitValue(source, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 输出为1的位, 结果应为 0 1 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBitValue(source, i)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BitSet类"><a href="#BitSet类" class="headerlink" title="BitSet类"></a>BitSet类</h2><p>BitSet类：大小可动态改变, 取值为true或false的位集合。用于表示一组布尔标志。 此类实现了一个按需增长的位向量。位 set 的每个组件都有一个 boolean 值。用非负的整数将 BitSet 的位编入索引。可以对每个编入索引的位进行测试、设置或者清除。通过逻辑与、逻辑或和逻辑异或操作，可以使用一个 BitSet 修改另一个 BitSet 的内容。默认情况下，set 中所有位的初始值都是 false。</p><p>每个位 set 都有一个当前大小，也就是该位 set 当前所用空间的位数。注意，这个大小与位 set 的实现有关，所以它可能随实现的不同而更改。位 set 的长度与位 set 的逻辑长度有关，并且是与实现无关而定义的。</p><p>除非另行说明，否则将 null 参数传递给 BitSet 中的任何方法都将导致 NullPointerException。 在没有外部同步的情况下，多个线程操作一个 BitSet 是不安全的。</p><p>构造函数: BitSet() or BitSet(int nbits)，默认初始大小为64。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bitIndex, <span class="keyword">boolean</span> value)</span>: 将指定索引处的位设置为指定的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> pos)</span>: 位置pos的字位设置为<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>: 将此 BitSet 中的所有位设置为 <span class="keyword">false</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cardinality</span><span class="params">()</span>: 返回此 BitSet 中设置为 <span class="keyword">true</span> 的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span>: 返回位置是pos的字位值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet other)</span>: other同该字位集进行与操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet other)</span>: other同该字位集进行或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet other)</span>: other同该字位集进行异或操作，结果作为该字位集的新值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span>: 清除此 BitSet 中所有的位,set – 用来屏蔽此 BitSet 的 BitSet</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 返回此 BitSet 表示位值时实际使用空间的位数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>: 返回此 BitSet 的“逻辑大小”：BitSet 中最高设置位的索引加 1。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>: 返回该集合Hash 码， 这个码同集合中的字位值有关。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span>: 如果other中的字位同集合中的字位相同，返回<span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span>: 克隆此 BitSet，生成一个与之相等的新 BitSet。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>: 返回此位 set 的字符串表示形式。</span></span><br></pre></td></tr></table></figure><p>例1：标明一个字符串中用了哪些字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhichChars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BitSet used = <span class="keyword">new</span> BitSet();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhichChars</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            used.set(str.charAt(i));  <span class="comment">// set bit for char</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String desc = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> size = used.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.get(i))</span><br><span class="line">                desc += (<span class="keyword">char</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> desc + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        WhichChars w = <span class="keyword">new</span> WhichChars(<span class="string">&quot;How do you do&quot;</span>);</span><br><span class="line">        System.out.println(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestThree</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm = <span class="keyword">new</span> BitSet();</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">1</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        System.out.println(bm.get(<span class="number">65</span>));</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">        bm.set(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm.isEmpty() + <span class="string">&quot;--&quot;</span> + bm.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.bit;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTestFour</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitSet bm1 = <span class="keyword">new</span> BitSet(<span class="number">7</span>);</span><br><span class="line">        System.out.println(bm1.isEmpty() + <span class="string">&quot;--&quot;</span> + bm1.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm2 = <span class="keyword">new</span> BitSet(<span class="number">63</span>);</span><br><span class="line">        System.out.println(bm2.isEmpty() + <span class="string">&quot;--&quot;</span> + bm2.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm3 = <span class="keyword">new</span> BitSet(<span class="number">65</span>);</span><br><span class="line">        System.out.println(bm3.isEmpty() + <span class="string">&quot;--&quot;</span> + bm3.size());</span><br><span class="line"> </span><br><span class="line">        BitSet bm4 = <span class="keyword">new</span> BitSet(<span class="number">111</span>);</span><br><span class="line">        System.out.println(bm4.isEmpty() + <span class="string">&quot;--&quot;</span> + bm4.size());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位操作技巧"><a href="#位操作技巧" class="headerlink" title="位操作技巧"></a>位操作技巧</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获得int型最大值</span></span><br><span class="line">System.out.println((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);<span class="comment">// 2147483647， 由于优先级关系，括号不可省略</span></span><br><span class="line">System.out.println(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));<span class="comment">// 2147483647</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 获得int型最小值</span></span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 获得long类型的最大值</span></span><br><span class="line">System.out.println(((<span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">127</span>) - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 乘以2运算</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5. 除以2运算(负奇数的运算不可用)</span></span><br><span class="line">System.out.println(<span class="number">10</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 6. 乘以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 7. 除以2的m次方</span></span><br><span class="line">System.out.println(<span class="number">16</span>&gt;&gt;<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8. 判断一个数的奇偶性</span></span><br><span class="line">System.out.println((<span class="number">10</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">System.out.println((<span class="number">9</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 9. 不用临时变量交换两个数（面试常考）</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 10. 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">System.out.println((n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>));</span><br><span class="line"><span class="comment">/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1</span></span><br><span class="line"><span class="comment">若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，</span></span><br><span class="line"><span class="comment">结果n变号并且绝对值减1，再减去-1就是绝对值 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 11. 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）</span></span><br><span class="line">System.out.println(b&amp;((a-b)&gt;&gt;<span class="number">31</span>) | a&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 12. 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）</span></span><br><span class="line">System.out.println(a&amp;((a-b)&gt;&gt;<span class="number">31</span>) | b&amp;(~(a-b)&gt;&gt;<span class="number">31</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 13. 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)</span></span><br><span class="line">System.out.println((a ^ b) &gt; <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 14. 计算2的n次方 n &gt; 0</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;(n-<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 15. 判断一个数n是不是2的幂</span></span><br><span class="line">System.out.println((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果是2的幂，n一定是100... n-1就是1111....</span></span><br><span class="line"><span class="comment">所以做与运算结果为0*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 16. 求两个整数的平均值</span></span><br><span class="line">System.out.println((a+b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17. 从低位到高位,取n的第m位</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line">System.out.println((n &gt;&gt; (m-<span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 18. 从低位到高位.将n的第m位置为1</span></span><br><span class="line">System.out.println(n | (<span class="number">1</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/*将1左移m-1位找到第m位，得到000...1...000</span></span><br><span class="line"><span class="comment">n在和这个数做或运算*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 19. 从低位到高位,将n的第m位置为0</span></span><br><span class="line">System.out.println(n &amp; ~(<span class="number">0</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/* 将1左移m-1位找到第m位，取反后变成111...0...1111</span></span><br><span class="line"><span class="comment">n再和这个数做与运算*/</span></span><br></pre></td></tr></table></figure><br>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600708864104&amp;di=d036727b38da8177b009afc5268c3a1c&amp;imgtype=0</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://example.com/wiki/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/wiki/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-07-27T11:45:12.000Z</published>
    <updated>2021-07-27T11:45:40.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础之注解机制详解"><a href="#Java基础之注解机制详解" class="headerlink" title="Java基础之注解机制详解"></a>Java基础之注解机制详解</h1><blockquote><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、<br>局部变量等进行注解。它是框架学习和设计者必须掌握的基础。</p></blockquote><h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：<br>— 生成文档，通过代码里标识的元数据生成javadoc文档。<br>— 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。<br>— 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 </p><ul><li>运行时动态处理，运行时通过代码里标识的元数据动态处理， 例如使用反射注入实例。<br>这么来说是比较抽象的，我们具体看下注解的常见分类： <ul><li><strong>Java自带的标准注解</strong>， 包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，<br>用这些注解标明后编译器就会进行检查。   </li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，<br>@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，<br>@Documented用于标明是否生成javadoc文档。 </li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。<br>接下来我们通过这个分类角度来理解注解。  </li></ul></li></ul><h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    /**</span><br><span class="line">        * 重载父类的test方法</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 被弃用的方法</span><br><span class="line">        */</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void oldMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 忽略告警</span><br><span class="line">        * </span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    public List processList() &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：   </p><ul><li>@Override：表示当前的方法定义将覆盖父类中的方法  </li><li>@Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告  </li><li>@SuppressWarnings：表示关闭编译器警告信息 我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。  </li></ul><h3 id="内置注解-Override"><a href="#内置注解-Override" class="headerlink" title="内置注解 - @Override"></a>内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。<br>这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，<br>若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。    </p><h3 id="内置注解-Deprecated"><a href="#内置注解-Deprecated" class="headerlink" title="内置注解 - @Deprecated"></a>内置注解 - @Deprecated</h3><p>这个注解的定义如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。  </p><h3 id="内置注解-SuppressWarnings"><a href="#内置注解-SuppressWarnings" class="headerlink" title="内置注解 - @SuppressWarnings"></a>内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。<br>它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p><p>// TODO</p><blockquote><p>参考资料<br><a href="https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html">https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础之注解机制详解&quot;&gt;&lt;a href=&quot;#Java基础之注解机制详解&quot; class=&quot;headerlink&quot; title=&quot;Java基础之注解机制详解&quot;&gt;&lt;/a&gt;Java基础之注解机制详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注解是JDK1.5版本开始</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://example.com/wiki/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/wiki/Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-07-27T11:39:32.000Z</published>
    <updated>2021-07-27T11:53:29.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600526897116&di=71cd9f887ed1906efa4a2dada0b8e4e3&imgtype=0&src=http://p3.ssl.cdn.btime.com/t01f09ae4245f608c22.jpg?size=980x652"></p><h2 id="1、泛型定义"><a href="#1、泛型定义" class="headerlink" title="1、泛型定义"></a>1、泛型定义</h2><blockquote><p>使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后在进行强制类型转换的代码具有更好的安全性和可读性。  –《Java核心技术》  </p></blockquote><p>泛型是在编译时期作用的；</p><p>泛型变量使用大写形式，在Java库中，一般使用变量E表示集合的元素类型，K和V表示表的关键字与值的类型。</p><h2 id="2、通配符"><a href="#2、通配符" class="headerlink" title="2、通配符"></a>2、通配符</h2><h3 id="2-1-无边界通配符"><a href="#2-1-无边界通配符" class="headerlink" title="2.1 无边界通配符"></a>2.1 无边界通配符</h3><p>无边界通配符又成为非限定通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-上边界通配符"><a href="#2-2-上边界通配符" class="headerlink" title="2.2 上边界通配符"></a>2.2 上边界通配符</h3><p>上边界通配符和下边界通配符都属于限定通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List中的类型必须是Number的子类，不然会报编译错误</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传进来的list的类型必须是Number或Number的子类才可以</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>? extends Number<br>如果限定的类型有多个，之间使用 &amp; 进行分割</p></blockquote><h3 id="2-3-下边界通配符"><a href="#2-3-下边界通配符" class="headerlink" title="2.3 下边界通配符"></a>2.3 下边界通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List的泛型是Number 添加的元素只要是Number下的类型就可以</span></span><br><span class="line">        List&lt;Number&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2L</span>);</span><br><span class="line">        list1.add(<span class="keyword">new</span> BigDecimal(<span class="number">22</span>));</span><br><span class="line">        list1.add(<span class="number">4</span>);</span><br><span class="line">        loop(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用类型必须是Number到Object之间的类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、泛型的使用"><a href="#3、泛型的使用" class="headerlink" title="3、泛型的使用"></a>3、泛型的使用</h2><blockquote><p>泛型必须先声明，再使用，不然会有编译错误；<br>泛型的声明是用过一对&lt;&gt;来完成，约定使用一个大写的字母来表示;<br>通配符不能用作返回值;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testA</span><span class="params">(T t, Test1&lt;T&gt; test1)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是传入的T:&quot;</span> + t);</span><br><span class="line">    t = test1.t;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是赋值后的T:&quot;</span> + t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要从泛型类取数据时，用extends；</li><li>要往泛型类写数据时，用super；</li><li>既要取又要写，就不用通配符（即extends与super都不用）。</li></ul><h3 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;K&gt; <span class="function">K <span class="title">test</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-泛型方法"><a href="#3-2-泛型方法" class="headerlink" title="3.2 泛型方法"></a>3.2 泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest4</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;T&gt; 代表泛型的声明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t   本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 本方法声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的泛型方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k   类中定义的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;X&gt; 本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X&gt; <span class="function">X <span class="title">aa</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (X) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法中是无法使用类中声明的泛型类型的</span></span><br><span class="line"><span class="comment">     * 可以使用在本方法中声明的泛型类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;X&gt; <span class="function">X <span class="title">bb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-泛型接口"><a href="#3-3-泛型接口" class="headerlink" title="3.3 泛型接口"></a>3.3 泛型接口</h3><p>首先看一下不使用泛型接口的Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">先定义接口，声明两个方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">aa</span><span class="params">(Integer a)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Integer <span class="title">bb</span><span class="params">(Integer b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后创建一个类来实现方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo</span> <span class="keyword">implements</span> <span class="title">IGeneric</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是没有使用泛型的接口设计，但是aa方法的操作类型相当于在接口中写死了，如果此时我们需要一个String类型的aa方法，那是不是还要在声明一个String类型的接口，然后再去实现呢，这样是不是显得代码很臃肿，代码重复；<br>所以我们可以看一下使用泛型之后是怎么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">定义泛型接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面是根据不同类型的实现类</span><br><span class="line">泛型传如Integer类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericInteger</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">aa</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">bb</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型传入String类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IGenericString</span> <span class="keyword">implements</span> <span class="title">IGenericInte</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aa</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bb</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、泛型擦除"><a href="#4、泛型擦除" class="headerlink" title="4、泛型擦除"></a>4、泛型擦除</h2><p>在虚拟机上没有泛型类型对象，所有的对象都属于普通类。Java在处理泛型类型的时候，会处理成一个相应的原始类型。  擦除类型变量，并替换为限定类型，如果没有限定类型，默认使用Object替代。如果有限定类型，并且是多个，会使用第一个限定的类型来替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenericInte</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">aa</span><span class="params">(T a)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">bb</span><span class="params">(T b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这个T是一个无限定的变量，泛型擦除之后会直接使用Object替换。<br>当然调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ....</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure><p>擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换，也就是说，编译器调用方法是其实是执行了一下两个虚拟机指令：</p><ul><li>对原始方法Pair.getFirst()方法的调用</li><li>将返回的Object类型强制转换为Employee类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">foo</span><span class="params">(T [] args)</span></span></span><br></pre></td></tr></table></figure><p>在擦除类型之后变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable T <span class="title">foo</span><span class="params">(Comparable [] args)</span></span></span><br></pre></td></tr></table></figure><p>参数类型T已经被擦除，只留下限定类型Comparable;</p><blockquote><p>总之有关Java泛型转换的事实：</p><ul><li>虚拟机没有泛型，只有普通的类和方法</li><li>所有的类型参数都用它们的限定类型替换</li><li>==桥方法被合成来保证多态==</li><li>为了保持类型安全型，必要时插入强制类型转换</li></ul></blockquote><p>第一条应该很好理解，这也是为什么会有泛型擦除这个概念，是因为JVM不能操作泛型；<br>第二条就是解释泛型如何进行类型的擦除；<br>第三条是泛型方法可能与多态的理念矛盾，所以使用桥方法来过渡或兼容；<br>第四条上面也有提到，会出现强制类型转换的情况；  </p><h2 id="5、泛型的约束与局限性"><a href="#5、泛型的约束与局限性" class="headerlink" title="5、泛型的约束与局限性"></a>5、泛型的约束与局限性</h2><p>当然泛型的设计在java中并没有那么完美，它确实可以解决代码结构重用等问题，但是也是有一些局限性，下面是我根据《Java核心技术》进行的总结：</p><h3 id="5-1-不能使用基础数据类型实例化类型参数"><a href="#5-1-不能使用基础数据类型实例化类型参数" class="headerlink" title="5.1 不能使用基础数据类型实例化类型参数"></a>5.1 不能使用基础数据类型实例化类型参数</h3><p>原因是类型擦除之后，如果使用Object原始类型，Object是无法存储基本数据类型的值。所以只能通过其包装类型声明；</p><h3 id="5-2-运行时查询类型只适用与原始类型"><a href="#5-2-运行时查询类型只适用与原始类型" class="headerlink" title="5.2 运行时查询类型只适用与原始类型"></a>5.2 运行时查询类型只适用与原始类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest5</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoTest5&lt;String&gt; demoTest5 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        DemoTest5&lt;Integer&gt; demoTest4 = <span class="keyword">new</span> DemoTest5&lt;&gt;();</span><br><span class="line">        System.err.println(demoTest4.getClass().equals(demoTest5.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demoTest4.getClass().equals(demoTest5.getClass())其实比较的是DemoTest5这个类类型，我们输出一下demoTest4.getClass()的结果看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class com.ibli.javaBase.generics.DemoTest5</span><br></pre></td></tr></table></figure><p>所以这里有一道非常经典的面试题，<a href="https://blog.csdn.net/IBLiplus/article/details/108672223">如何判断一个泛型他的具体类型是什么，这里我们可以使用反射去拿到泛型的具体类型；</a></p><h3 id="5-3-不能创造参数化类型的数组"><a href="#5-3-不能创造参数化类型的数组" class="headerlink" title="5.3 不能创造参数化类型的数组"></a>5.3 不能创造参数化类型的数组</h3><p>对于参数化类型的数组，在类型擦除之后，会变成Object[]类型，如果此时试图存储一个String类型的元素，就会抛出一个Array-StoreException异常；<br>主要目的还是处于到数组安全的保护，可以参考几篇文章:  </p><blockquote><p><a href="https://cloud.tencent.com/developer/ask/195960">1、如果Java不支持参数化类型数组，那么Arrays.asList()如何处理它们？</a><br><a href="https://blog.csdn.net/qq_41286138/article/details/105250938">2、java不能创建参数化类型的泛型数组</a><br><a href="https://www.cnblogs.com/shuilangyizu/p/5916402.html">3、java.lang.ArrayStoreException</a></p></blockquote><h3 id="5-4-Varargs警告"><a href="#5-4-Varargs警告" class="headerlink" title="5.4 Varargs警告"></a>5.4 Varargs警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例的场景，编译器会发出警告！<br>抑制这种警告的方式有两种：</p><ul><li>在调用方法上增加注解@SuppressWarnings(“unchecked”)</li><li>还可以使用@SafeVarargs注解直接标注方法<blockquote><p>参考 <a href="https://blog.csdn.net/qq_41286138/article/details/105250938">java不能创建参数化类型的泛型数组</a>  </p></blockquote></li></ul><h3 id="5-5-不能实例化类型变量"><a href="#5-5-不能实例化类型变量" class="headerlink" title="5.5 不能实例化类型变量"></a>5.5 不能实例化类型变量</h3><p>不能使用new T(..) 或则new T[…]和T.class这样的表达式的类型变量；因为类型擦除后，T变成Object，显然我们在这里并不是想要创建一个Object实例。解决办法是在调用者提供一个构造器表达式，下面是用Supplier函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T first;</span><br><span class="line">        <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cannot infer type arguments for Pair2&lt;&gt;</span></span><br><span class="line"><span class="comment">         * 当函数头返回值为Pair时,无法推断,改为Pair2后可以推断.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> c1</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">build</span><span class="params">(Class&lt;T&gt; c1)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c1.newInstance(),c1.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Supplier是一个函数接口，返回一个无参数并且返回类型为T的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMakePair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.接受Supplier&lt;T&gt;--它是一个函数式接口。表示无参数且返回类型为T的函数。</span></span><br><span class="line"><span class="comment">         * 因为不能实例化类型变量，如：</span></span><br><span class="line"><span class="comment">         * public Pair() &#123;first = new T();second = new T();&#125;</span></span><br><span class="line"><span class="comment">         * 所以最好的方式是让调用者提供一个构造器表达式.形式如下:</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> constr</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair = Pair.build(String::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(pair.getFirst().length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public void buildT()&#123;</span></span><br><span class="line"><span class="comment">         2.传统的方式是通过Class.newInstance方法来构造泛型对象.</span></span><br><span class="line"><span class="comment">         但由于细节过于复杂,T.class是不合法的.它会被擦除为Object.class.如下:</span></span><br><span class="line"><span class="comment">         Illegal class literal for the type parameter T</span></span><br><span class="line"><span class="comment">         T.class.newInstance();</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         * 3.</span></span><br><span class="line"><span class="comment">         * T.class是不合法的,但若API涉及如下</span></span><br><span class="line"><span class="comment">         * reason:因为String.class是Class&lt;String&gt;的一个实例.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Pair&lt;String&gt; pair1 = Pair.build(String.class);</span><br><span class="line">        System.out.println(pair1.getFirst().length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="5-6-不能构造泛型数组"><a href="#5-6-不能构造泛型数组" class="headerlink" title="5.6 不能构造泛型数组"></a>5.6 不能构造泛型数组</h3><p>就像不能实例化一个泛型实例一样，也不能实例化数组。数组本身也有类型，用来监控存储在JVM中的数组，这个类型会被擦除，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] foo(T[] a)&#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除，会让这个方法永远构造Comparabel[2]数组；</p><h3 id="5-7-泛型类的静态上下文中类型变量无效"><a href="#5-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="5.7 泛型类的静态上下文中类型变量无效"></a>5.7 泛型类的静态上下文中类型变量无效</h3><p>这个应该是比较好理解的，上文也提到过了，泛型类型是作用在泛型类上的，一些静态的方法或这静态的属性不能够使用泛型类的变量类型，编译器会直接报错；</p><h3 id="5-8-不能抛出或者捕获泛型类的实例"><a href="#5-8-不能抛出或者捕获泛型类的实例" class="headerlink" title="5.8 不能抛出或者捕获泛型类的实例"></a>5.8 不能抛出或者捕获泛型类的实例</h3><p>Java既不能抛出也不能捕获泛型类对象，实际上，甚至泛型类扩展Throwable都是不合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (T ex)&#123;  此处无法捕获    <span class="keyword">catch</span>必须捕获具体的异常</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在异常规范中使用类型变量是允许的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex)&#123;  </span><br><span class="line">        t.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-9-可以消除对受查异常的检查"><a href="#5-9-可以消除对受查异常的检查" class="headerlink" title="5.9 可以消除对受查异常的检查"></a>5.9 可以消除对受查异常的检查</h3><p>Java异常处理要求必须为所有的受查异常提供一个处理器，但是使用泛型，可以规避这一点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的方法，编译器会认为t是一个非受查异常;</p><h3 id="5-10-注意擦除后的冲突"><a href="#5-10-注意擦除后的冲突" class="headerlink" title="5.10 注意擦除后的冲突"></a>5.10 注意擦除后的冲突</h3><p>比如一个泛型类的equals方法，擦除之后，和Object的equals冲突；解决办法是重新命名引发错误的方法；</p><h2 id="6、泛型的继承关系"><a href="#6、泛型的继承关系" class="headerlink" title="6、泛型的继承关系"></a>6、泛型的继承关系</h2><p>如果Manage extends Employee,那么Pair&lt; Manage &gt;是Pair&lt; Employee &gt;的子类吗？ 不是的！<br>但是泛型类可以扩展或实现其他的泛型类，很典型的一个例子ArrayList:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><p>ArrayList[E]继承了AbstractList[E];</p><h2 id="对于Java泛型的一些思考"><a href="#对于Java泛型的一些思考" class="headerlink" title="对于Java泛型的一些思考"></a>对于Java泛型的一些思考</h2><blockquote><p>编译器如何推断出具体的类型？ 参考资料：<a href="https://blog.csdn.net/u011240877/article/details/53545041#%E6%93%A6%E9%99%A4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">深入理解 Java 泛型</a></p></blockquote><blockquote><p align="middle"> -------------------   他日若遂凌云志 敢笑黄巢不丈夫 ------------------- </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java泛型&quot;&gt;&lt;a href=&quot;#Java泛型&quot; class=&quot;headerlink&quot; title=&quot;Java泛型&quot;&gt;&lt;/a&gt;Java泛型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="泛型" scheme="http://example.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://example.com/wiki/Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/wiki/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2021-07-27T11:39:08.000Z</published>
    <updated>2021-07-27T11:43:17.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600431374677&di=df4d8b050b37c3dd26ebd4beaz5f8db182&imgtype=0&src=http://5b0988e595225.cdn.sohucs.com/images/20181030/e77642a513614a56bd12943124f89341.jpg"></p><blockquote><p>反向探知，在程序运行是动态的获取类的相关属性<br>这种动态获取类的内容以及动态调用对象的方法和获取属性的机制，叫做java反射机制；</p></blockquote><h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><blockquote><p>优点<br>增加了程序的灵活性，避免的固有逻辑写死到程序中<br>代码简介，提高程序的复用性</p></blockquote><blockquote><p>缺点<br>相比于直接调用，反射有比较大的性能消耗<br>内部暴露和安全隐患  （因为反射可以操作private成员变量和调用private成员方法）</p></blockquote><h3 id="反射的基本操作"><a href="#反射的基本操作" class="headerlink" title="反射的基本操作"></a>反射的基本操作</h3><h4 id="获取类对象的4种方式"><a href="#获取类对象的4种方式" class="headerlink" title="获取类对象的4种方式"></a>获取类对象的4种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 调用forName方法得到一个对象，这也是最容易想到的方式</span><br><span class="line">Class&lt;?&gt; object = Class.forName(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">// 通过实例对象调用getClass方法</span><br><span class="line">Teacher teacher = new Teacher();</span><br><span class="line">Class&lt;?&gt; objectT = teacher.getClass();</span><br><span class="line"></span><br><span class="line">// 通过类加载器的方式</span><br><span class="line">Class&lt;?&gt; loader = ClassLoader.getSystemClassLoader().loadClass(&quot;com.ibli.javaBase.reflection.User&quot;);</span><br><span class="line"></span><br><span class="line">//通过一个类.class</span><br><span class="line">Class&lt;?&gt; tt = Teacher.class;</span><br></pre></td></tr></table></figure><h4 id="基本信息操作"><a href="#基本信息操作" class="headerlink" title="基本信息操作"></a>基本信息操作</h4><table><thead><tr><th align="center">类修饰符</th><th align="center">PUBLIC</th><th align="center">PRIVATE</th><th align="center">PROTECTED</th><th align="center">STATIC</th><th align="center">FINAL</th><th align="center">SYNCHRONIZED</th><th align="center">VOLATILE</th><th align="center">TRANSIENT</th><th align="center">NATIVE</th><th align="center">INTERFACE</th><th align="center">ABSTRACT</th></tr></thead><tbody><tr><td align="center">modifiers</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td><td align="center">16</td><td align="center">32</td><td align="center">64</td><td align="center">128</td><td align="center">256</td><td align="center">512</td><td align="center">1024</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 类的修饰符 具体的值可以参考JDK API文档中的定义 返回值是int类型  public：1</span><br><span class="line">System.err.println(tt.getModifiers());</span><br><span class="line">// 包名</span><br><span class="line">System.err.println(tt.getPackage());</span><br><span class="line">// 类的名称</span><br><span class="line">System.err.println(tt.getName());</span><br><span class="line">// 父类</span><br><span class="line">System.err.println(tt.getSuperclass());</span><br><span class="line">// 类加载器</span><br><span class="line">System.err.println(tt.getClassLoader());</span><br><span class="line">// 简称</span><br><span class="line">System.err.println(tt.getSimpleName());</span><br><span class="line">// 类实现的所有的接口</span><br><span class="line">System.err.println(tt.getInterfaces().length);</span><br><span class="line">// 所有的注解类型</span><br><span class="line">System.err.println(tt.getAnnotations().length);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">package com.ibli.javaBase.reflection</span><br><span class="line">com.ibli.javaBase.reflection.Teacher</span><br><span class="line">class java.lang.Object</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Teacher</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="查看类的变量"><a href="#查看类的变量" class="headerlink" title="查看类的变量"></a>查看类的变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// User extend Person(aa,bb)</span><br><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 能够拿到类的所有的变量</span><br><span class="line">Field[] fields = obj.getDeclaredFields();</span><br><span class="line">for (Field field : fields)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;    &quot;);</span><br><span class="line"></span><br><span class="line">// 只能够拿到类的public的变量</span><br><span class="line">Field[] fields1 = obj.getFields();</span><br><span class="line">for (Field field : fields1)&#123;</span><br><span class="line">    System.out.println(field.getModifiers() + &quot; &quot; + field.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;     &quot;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 age</span><br><span class="line">2 name</span><br><span class="line">1 sex</span><br><span class="line">10 height</span><br><span class="line">    </span><br><span class="line">1 sex</span><br><span class="line">1 aa</span><br><span class="line">1 bb</span><br></pre></td></tr></table></figure><p>结论：  </p><ul><li>getDeclaredFields<br>（1）getDeclaredFields能够获取本类的所有成员变量，无论是public还是private;<br>（2）但是不能获取父类的任何属性；<br>（3）可以获取static类型的属性；</li><li>getFields<br>（1）只能够获取本类的public属性；<br>（2）能够获取父类的public属性；<br>（3）可以获取static类型的属性；  </li></ul><h4 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 设置Person中的变量aa</span><br><span class="line">Field aaField = obj.getField(&quot;aa&quot;);</span><br><span class="line">aaField.setInt(user,111);</span><br><span class="line">System.err.println(user.getAa());</span><br><span class="line"></span><br><span class="line">// 设置User私有成员变量</span><br><span class="line">Field ageField = obj.getDeclaredField(&quot;age&quot;);</span><br><span class="line">// 设置访问权限</span><br><span class="line">ageField.setAccessible(true);</span><br><span class="line">ageField.set(user,333);</span><br><span class="line">System.err.println(user.getAge());</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">333</span><br></pre></td></tr></table></figure><h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line"></span><br><span class="line">// 可以获取父类的方法</span><br><span class="line">Method[] methods = obj.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; -----  &quot;);</span><br><span class="line"></span><br><span class="line">// 获取本类中的所有方法</span><br><span class="line">Method[] methods1 = obj.getDeclaredMethods();</span><br><span class="line">for (Method method : methods1) &#123;</span><br><span class="line">    System.out.println(method.getModifiers() + &quot;  &quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot; 。。。。。。 &quot;);</span><br><span class="line">// 执行结果就不展示了</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>getDeclaredMethods<br>（1）可以获取本类中的所有方法；<br>（2）可以获取本类的静态方法</li><li>getMethods<br>（1）可以获取本类中的所有==公有==方法；<br>（2）可以获取父类中的所有==公有==方法；<br>（3）可以获取本类和父类的公有静态方法；</li></ul><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 访问私有方法</span><br><span class="line">Method sleep = obj.getDeclaredMethod(&quot;sleep&quot;);</span><br><span class="line">sleep.setAccessible(true);</span><br><span class="line">sleep.invoke(user);</span><br><span class="line"></span><br><span class="line">// 如果是静态方法，invoke第一个参数传null即可</span><br><span class="line">Method say = obj.getDeclaredMethod(&quot;say&quot;,String.class);</span><br><span class="line">say.setAccessible(true);</span><br><span class="line">say.invoke(null,&quot;hello java&quot;);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Im sleeping!</span><br><span class="line">say hello java</span><br></pre></td></tr></table></figure><h4 id="构造器的使用"><a href="#构造器的使用" class="headerlink" title="构造器的使用"></a>构造器的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;User&gt; obj = User.class;</span><br><span class="line">// 查询共有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors = obj.getConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors)&#123;</span><br><span class="line">    System.out.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以获取私有的构造器</span><br><span class="line">Constructor&lt;?&gt;[] constructors1 = obj.getDeclaredConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor : constructors1)&#123;</span><br><span class="line">    System.err.println(constructor.getModifiers() + &quot;   &quot; + constructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line"></span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br><span class="line">2   com.ibli.javaBase.reflection.User</span><br><span class="line">1   com.ibli.javaBase.reflection.User</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>getConstructors<br>（1）获得本类所有的公有构造器  </li><li>getDeclaredConstructors<br>（1）获得本类所有的构造器（public&amp;private）  </li></ul><h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用newInstance创建对象 调用无参构造器</span><br><span class="line">User user = obj.newInstance();</span><br><span class="line">// 获取构造器来实例化对象</span><br><span class="line">Constructor&lt;User&gt; constructor = obj.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">User temp = constructor.newInstance(22, &quot;java&quot;);</span><br><span class="line">System.err.println(temp.getAge() + &quot; &quot; + temp.getName());</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>22 java</p></blockquote><h3 id="反射性能为什么差"><a href="#反射性能为什么差" class="headerlink" title="反射性能为什么差"></a>反射性能为什么差</h3><blockquote><p>可以从两方面考虑，第一个是反射生成Class对象时性能差，第二是通过反射调用对象方式是的性能差；</p></blockquote><p>（1） 调用forName 本地方法<br>（2）每次newInstance 都会进行一次安全检查<br>（3）在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p><ul><li>变长参数方法导致的Object数组   </li><li>基本类型的自动装箱、拆箱  (参考资料2)</li><li>还有最重要的方法内联。</li></ul><blockquote><p>参考资料<br>(1)<a href="https://blog.csdn.net/xqlovetyj/article/details/82798864">反射为什么慢</a><br>(2)<a href="https://blog.csdn.net/Admin_Jhon/article/details/52873468?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf">关于装箱拆箱为什么会影响效率</a><br>(3)<a href="https://zhuanlan.zhihu.com/p/55630861">jvm之方法内联优化</a></p></blockquote><h3 id="反射使用的场景"><a href="#反射使用的场景" class="headerlink" title="反射使用的场景"></a>反射使用的场景</h3><ul><li>JDBC封装    </li><li>Spring IOC</li><li>jdbcTemplate</li><li>Mybatis使用大量反射</li></ul><h3 id="使用反射注意点"><a href="#使用反射注意点" class="headerlink" title="使用反射注意点"></a>使用反射注意点</h3><ul><li>在获取Field,method,construtor的时候，应尽量避免是用getDelcaredXXX(),应该传进参数获取指定的字段，方法和构造器；</li><li>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的</li></ul><blockquote><p align="middle"> ---------------------   前途浩浩荡荡 万事尽可期待。-----------------------  </p></blockquote><h3 id="反射在IOC中的应用"><a href="#反射在IOC中的应用" class="headerlink" title="反射在IOC中的应用"></a>反射在IOC中的应用</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java反射&quot;&gt;&lt;a href=&quot;#Java反射&quot; class=&quot;headerlink&quot; title=&quot;Java反射&quot;&gt;&lt;/a&gt;Java反射&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="reflect" scheme="http://example.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务特性</title>
    <link href="http://example.com/wiki/mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/wiki/mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7/</id>
    <published>2021-07-27T11:35:35.000Z</published>
    <updated>2021-07-27T11:35:35.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发编程之同步锁</title>
    <link href="http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E9%94%81/</id>
    <published>2021-07-26T14:27:05.000Z</published>
    <updated>2021-07-26T14:27:43.213Z</updated>
    
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java多线程之ThreadLocal</title>
    <link href="http://example.com/wiki/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/"/>
    <id>http://example.com/wiki/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/</id>
    <published>2021-07-26T08:28:01.000Z</published>
    <updated>2021-07-26T08:30:44.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocalMap结构"><a href="#ThreadLocalMap结构" class="headerlink" title="ThreadLocalMap结构"></a>ThreadLocalMap结构</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b45487065b90?imageView2/0/w/1280/h/960/ignore-error/1'><h2 id="ThreadLocal-set流程"><a href="#ThreadLocal-set流程" class="headerlink" title="ThreadLocal set流程"></a>ThreadLocal set流程</h2><img src='https://user-gold-cdn.xitu.io/2020/7/26/1738b454879fe57d?imageView2/0/w/1280/h/960/ignore-error/1'><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://juejin.cn/post/6854573219916021767">Java面试必问：ThreadLocal终极篇 </a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocalMap结构&quot;&gt;&lt;a href=&quot;#ThreadLocalMap结构&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocalMap结构&quot;&gt;&lt;/a&gt;ThreadLocalMap结构&lt;/h2&gt;&lt;img src=&#39;https:/</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="threadLocal" scheme="http://example.com/tags/threadLocal/"/>
    
  </entry>
  
  <entry>
    <title>基础面试题目</title>
    <link href="http://example.com/wiki/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/wiki/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2021-07-26T02:05:07.000Z</published>
    <updated>2021-07-27T11:37:52.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-String不可变"><a href="#1-String不可变" class="headerlink" title="1.String不可变"></a>1.String不可变</h2><p>String 对象的不可变性</p><p>了解了 String 对象的实现后，你有没有发现在实现代码中 String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。</p><p>我们知道类被 final 修饰代表该类不可继承，而 char[] 被 final+private 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。</p><p>Java 这样做的好处在哪里呢？</p><p>第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被恶意修改。</p><p>第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。</p><p>第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。</p><p>当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p><h3 id="2-String-和-StringBuilder、StringBuffer-的区别？"><a href="#2-String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="2.String 和 StringBuilder、StringBuffer 的区别？"></a>2.String 和 StringBuilder、StringBuffer 的区别？</h3><p><a href="https://www.cnblogs.com/weibanggang/p/9455926.html">https://www.cnblogs.com/weibanggang/p/9455926.html</a></p><h2 id="3-描述一下-JVM-加载-class-文件的原理机制？"><a href="#3-描述一下-JVM-加载-class-文件的原理机制？" class="headerlink" title="3.描述一下 JVM 加载 class 文件的原理机制？"></a>3.描述一下 JVM 加载 class 文件的原理机制？</h2><p><a href="https://www.cnblogs.com/williamjie/p/11167920.html">https://www.cnblogs.com/williamjie/p/11167920.html</a></p><h2 id="4-char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#4-char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="4.char 型变量中能不能存贮一个中文汉字，为什么？"></a>4.char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>正确答案：</p><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，</p><p>所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，</p><p>那么，这个char型变量中就不能存储这个特殊汉字。</p><p>补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节</p><h2 id="5-抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#5-抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="5.抽象类（abstract class）和接口（interface）有什么异同？"></a>5.抽象类（abstract class）和接口（interface）有什么异同？</h2><p><a href="https://blog.csdn.net/aptentity/article/details/68942916">https://blog.csdn.net/aptentity/article/details/68942916</a></p><h2 id="6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#6-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>6.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p><a href="https://blog.csdn.net/machinecat0898/article/details/80071242">https://blog.csdn.net/machinecat0898/article/details/80071242</a></p><h2 id="7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？"><a href="#7-抽象的（abstract）方法是否可同时是静态的（static）-（native），-synchronized-修饰？" class="headerlink" title="7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？"></a>7.抽象的（abstract）方法是否可同时是静态的（static）,（native）， synchronized 修饰？</h2><p> 答：都不能。<br>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。<br>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。<br>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 </p><h2 id="8-如何实现对象克隆"><a href="#8-如何实现对象克隆" class="headerlink" title="8.如何实现对象克隆"></a>8.如何实现对象克隆</h2><p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html">https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html</a></p><h2 id="9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"><a href="#9-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制" class="headerlink" title="9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"></a>9.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</h2><p><a href="https://www.cnblogs.com/aademeng/articles/11084885.html">https://www.cnblogs.com/aademeng/articles/11084885.html</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p><p>静态内部类：它是用static修饰的，在访问限制上它只能访问外部类中的static所修饰的成员变量或者是方法<br>成员内部类：成员内部类是最普通的内部类，它可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br>【注意】当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br>局部内部类：局部内部类是定义在外围类的方法中的，在访问的时候它可以直接访问外围类的所有成员！但是不能随便访问局部变量，除非这个局部变量被final修饰。<br>匿名内部类：</p><h2 id="10-Java-中的-final-关键字有哪些用法？"><a href="#10-Java-中的-final-关键字有哪些用法？" class="headerlink" title="10.Java 中的 final 关键字有哪些用法？"></a>10.Java 中的 final 关键字有哪些用法？</h2><p><a href="https://www.cnblogs.com/dotgua/p/6357951.html">https://www.cnblogs.com/dotgua/p/6357951.html</a><br>多线程下的final语义 👇<br><a href="https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B">https://www.codercc.com/backend/basic/juc/concurrent-keywords/final.html#_1-final%E7%9A%84%E7%AE%80%E4%BB%8B</a></p><ul><li>修饰变量<br>基本类型的变量，值是不可以变化的<br>引用类型的变量，引用是不可以变化的，但是可以修改引用的值<br>方法参数： 保证这个变量在这个方法中的值不会发生变化</li><li>修饰方法<br>它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它</li><li>修饰类<br>用final修饰的类是无法被继承的</li></ul><h2 id="11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#11-Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?"></a>11.Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep()方法是Thread类</p><pre><code>sleep是Thread的静态native方法,可随时调用,会使当前线程休眠,并释放CPU资源,但不会释放对象锁;</code></pre><p>wait()方法是Object类</p><pre><code>wait()方法是Object的native方法,只能在同步方法或同步代码块中使用,调用会进入休眠状态,并释放CPU资源与对象锁,需要我们调用notify/notifyAll方法唤醒指定或全部的休眠线程,再次竞争CPU资源.</code></pre><p>注意:<br>sleep(long millis)存在睡眠时间,不算特点<br>因为wait()方法存在重载wait(long timeout),即设置了等待超时时间<br>它们两个都需要再次抢夺CPU资源</p><h2 id="12-线程的-sleep-方法和-yield-方法有什么区别？"><a href="#12-线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="12.线程的 sleep()方法和 yield()方法有什么区别？"></a>12.线程的 sleep()方法和 yield()方法有什么区别？</h2><p>sleep()方法在给其他线程运行机会时不考虑线程的优先级。因此会给低优先级的线程运行的机会，而yield()方法只会给相同优先级或更高优先级的线程运行的机会。<br>线程执行sleep()方法后会转入阻塞状态，所以执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到就绪状态，所以执行yield()方法的线程有可能在进入到就绪状态后又立马被执行。</p><h2 id="13-线程的基本状态以及状态之间的关系"><a href="#13-线程的基本状态以及状态之间的关系" class="headerlink" title="13.线程的基本状态以及状态之间的关系"></a>13.线程的基本状态以及状态之间的关系</h2><img src='https://cdn.jsdelivr.net/gh/it-briefcode/it-briefcode-images/images/2020-10/15/15-58-29-0925f9fed78f11a87bbef280245e1e49-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E8%BD%AC%E6%8D%A2-6ff1d1.png' width=600 height=450>https://blog.csdn.net/zhangdongnihao/article/details/104029972https://juejin.cn/post/6885159254764814349<h2 id="14-访问修饰符-public-private-protected-以及不写（默认）时的区别？"><a href="#14-访问修饰符-public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="14.访问修饰符 public,private,protected,以及不写（默认）时的区别？"></a>14.访问修饰符 public,private,protected,以及不写（默认）时的区别？</h2><img src="https://oscimg.oschina.net/oscnet/up-07ccdf4c85f874c49b19c6201cb826dc739.png" width=600 height=280 ><h2 id="15-请说出与线程同步以及线程调度相关的方法。"><a href="#15-请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="15.请说出与线程同步以及线程调度相关的方法。"></a>15.请说出与线程同步以及线程调度相关的方法。</h2><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；<br>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；<br>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><blockquote><p>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</p></blockquote><h2 id="16-synchronized-关键字的用法？"><a href="#16-synchronized-关键字的用法？" class="headerlink" title="16.synchronized 关键字的用法？"></a>16.synchronized 关键字的用法？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncDemo.class)&#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-Java-中如何实现序列化，有什么意义？"><a href="#17-Java-中如何实现序列化，有什么意义？" class="headerlink" title="17.Java 中如何实现序列化，有什么意义？"></a>17.Java 中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p><h2 id="18-阐述-JDBC-操作数据库的步骤"><a href="#18-阐述-JDBC-操作数据库的步骤" class="headerlink" title="18.阐述 JDBC 操作数据库的步骤"></a>18.阐述 JDBC 操作数据库的步骤</h2><p>下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。<br>（1） 加载驱动。<br><code>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);</code><br>（2） 创建连接。<br><code>Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;,&quot;scott&quot;, &quot;tiger&quot;);</code><br>（3） 创建语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">&quot;select * from emp where sal between ? and ?&quot;</span>);</span><br><span class="line">ps.setint(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">ps.setint(<span class="number">2</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>（4）执行语句。<br><code>ResultSet rs = ps.executeQuery();</code><br>（5）处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">System.out.println(rs.getint(<span class="string">&quot;empno&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6） 关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(con != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p><h2 id="19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><a href="#19-Statement-和-PreparedStatement-有什么区别？哪个性能更好？" class="headerlink" title="19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？"></a>19.Statement 和 PreparedStatement 有什么区别？哪个性能更好？</h2><p>与 Statement 相比，<br>①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；<br>③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p><blockquote><p>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p></blockquote><h2 id="20-在进行数据库编程时，连接池有什么作用？"><a href="#20-在进行数据库编程时，连接池有什么作用？" class="headerlink" title="20.在进行数据库编程时，连接池有什么作用？"></a>20.在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），<code>为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销</code>，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。</p><blockquote><p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p></blockquote><h2 id="21-什么是-DAO-模式"><a href="#21-什么是-DAO-模式" class="headerlink" title="21.什么是 DAO 模式?"></a>21.什么是 DAO 模式?</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。<br>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 DataAccessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p><h2 id="22-Java-中是如何支持正则表达式操作的？"><a href="#22-Java-中是如何支持正则表达式操作的？" class="headerlink" title="22.Java 中是如何支持正则表达式操作的？"></a>22.Java 中是如何支持正则表达式操作的？</h2><p>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作。面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;北京市(朝阳区)(西城区)(海淀区)&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\()&quot;</span>);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line"><span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">System.out.println(m.group());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-String不可变&quot;&gt;&lt;a href=&quot;#1-String不可变&quot; class=&quot;headerlink&quot; title=&quot;1.String不可变&quot;&gt;&lt;/a&gt;1.String不可变&lt;/h2&gt;&lt;p&gt;String 对象的不可变性&lt;/p&gt;
&lt;p&gt;了解了 String 对</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象特征</title>
    <link href="http://example.com/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/"/>
    <id>http://example.com/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/</id>
    <published>2021-07-26T01:59:21.000Z</published>
    <updated>2021-07-26T03:46:17.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是保证软件部件具有优良的模块性的基础，封装的目标就是实现软件内部的“高内聚、低耦合”。防止程序相互依赖而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、也更为有力，面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，或者说是一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</p><p>将一个类中的成员变量全部定义为私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p><p>继承是子类自动共享父类资源（数据或者方法）的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在该编程时不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态性增强了软件的灵活性和扩展性，简单一句话理解多态的话就是，编译看左边，运行看右边</p><blockquote><p>编译看左边 – 是指 想要成功的保存,就要使用左边也就是 只能使用父类提供的功能!!如果父类中没有，那么会编译报错<br>运行看右边 – 是指 想要得到结果,就要看右边也就是 使用子类的方法体!!!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h2&gt;&lt;p&gt;封装是保证软件部件具有优良的模块性的基础，封装的目标就是实现软件内部的“高内聚、低耦合”。防止程序相互依赖而带来的变动影响。在面向对象的编程</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka-overview</title>
    <link href="http://example.com/wiki/kafka-overview/"/>
    <id>http://example.com/wiki/kafka-overview/</id>
    <published>2021-07-22T03:00:12.000Z</published>
    <updated>2021-07-23T08:48:48.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/hellozpc/article/details/105680217">kafka详细教程</a></li><li><a href="http://download.kafka-eagle.org/">Kafka 集群管理</a></li><li><a href="https://www.orchome.com/kafka/index">OrcHome kafka中文教程</a></li><li><a href="https://juejin.cn/post/6847902220667748359">面试官：说说Kafka处理请求的全流程</a></li><li><a href="https://juejin.cn/post/6844904046340341768">蘑菇街千亿级消息Kafka上云实践</a></li><li><a href="https://www.imooc.com/article/262018">kafka 集群搭建</a></li><li><a href="https://wiki.eryajf.net/pages/2953.html">kafka-2-11集群部署</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hellozpc/art</summary>
      
    
    
    
    <category term="Distributed Dir" scheme="http://example.com/categories/Distributed-Dir/"/>
    
    <category term="Kafka" scheme="http://example.com/categories/Distributed-Dir/Kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://example.com/wiki/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/wiki/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-07-21T14:01:23.000Z</published>
    <updated>2021-07-21T14:38:46.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><p>虽然Java线程池理论，以及构造线程池的各种参数，以及 Executors 提供的默认实现之前研读过，不过线上还没有发生过线程池误用引发的事故，所以有必要把这些参数再仔细琢磨一遍。</p><p>优先补充一些线程池的工作理论，有助于展开下面的内容。线程池顾名思义，就是由很多线程构成的池子，来一个任务，就从池子中取一个线程，处理这个任务。这个理解是我在第一次接触到这个概念时候的理解，虽然整体基本切入到核心，但是实际上会比这个复杂。例如线程池肯定不会无限扩大的，否则资源会耗尽；当线程数到达一个阶段，提交的任务会被暂时存储在一个队列中，如果队列内容可以不断扩大，极端下也会耗尽资源，那选择什么类型的队列，当队列满如何处理任务，都有涉及很多内容。线程池总体的工作过程如下图：</p><p>+++++++=</p><p>线程池内的线程数的大小相关的概念有两个，一个是核心池大小，还有最大池大小。如果当前的线程个数比核心池个数小，当任务到来，会优先创建一个新的线程并执行任务。当已经到达核心池大小，则把任务放入队列，为了资源不被耗尽，队列的最大容量可能也是有上限的，如果达到队列上限则考虑继续创建新线程执行任务，如果此刻线程的个数已经到达最大池上限，则考虑把任务丢弃。</p><p>在 java.util.concurrent 包中，提供了 ThreadPoolExecutor 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>既然有了刚刚对线程池工作原理对概述，这些参数就很容易理解了：</p><h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3><p> 核心池大小，既然如前原理部分所述。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用prestartAllCoreThreads方法。</p><h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3><p>池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</p><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>当线程数大于核心时，多于的空闲线程最多存活时间</p><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime 参数的时间单位。</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现Runnable接口的任务。 别看这个参数位置很靠后，但是真的很重要，因为楼主的坑就因这个参数而起，这些细节有必要仔细了解清楚。</p><h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>执行程序创建新线程时使用的工厂。</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。</p><h2 id="可选择的阻塞队列BlockingQueue详解"><a href="#可选择的阻塞队列BlockingQueue详解" class="headerlink" title="可选择的阻塞队列BlockingQueue详解"></a>可选择的阻塞队列BlockingQueue详解</h2><p>在重复一下新任务进入时线程池的执行策略：<br>如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）<br>如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。<br>主要有3种类型的BlockingQueue：</p><h3 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h3><p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p><h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p><p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p><h3 id="同步移交队列"><a href="#同步移交队列" class="headerlink" title="同步移交队列"></a>同步移交队列</h3><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p><h2 id="可选择的饱和策略RejectedExecutionHandler详解"><a href="#可选择的饱和策略RejectedExecutionHandler详解" class="headerlink" title="可选择的饱和策略RejectedExecutionHandler详解"></a>可选择的饱和策略RejectedExecutionHandler详解</h2><p>JDK主要提供了4种饱和策略供选择。4种策略都做为静态内部类在ThreadPoolExcutor中进行实现。</p><h3 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h3><p>该策略是默认饱和策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p><h3 id="DiscardPolicy抛弃策略"><a href="#DiscardPolicy抛弃策略" class="headerlink" title="DiscardPolicy抛弃策略"></a>DiscardPolicy抛弃策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，什么都不做。</p><h3 id="DiscardOldestPolicy抛弃旧任务策略"><a href="#DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="DiscardOldestPolicy抛弃旧任务策略"></a>DiscardOldestPolicy抛弃旧任务策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p><h3 id="CallerRunsPolicy调用者运行"><a href="#CallerRunsPolicy调用者运行" class="headerlink" title="CallerRunsPolicy调用者运行"></a>CallerRunsPolicy调用者运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p><h2 id="Java提供的四种常用线程池解析"><a href="#Java提供的四种常用线程池解析" class="headerlink" title="Java提供的四种常用线程池解析"></a>Java提供的四种常用线程池解析</h2><p>既然楼主踩坑就是使用了 JDK 的默认实现，那么再来看看这些默认实现到底干了什么，封装了哪些参数。简而言之 Executors 工厂方法Executors.newCachedThreadPool() 提供了无界线程池，可以进行自动线程回收；Executors.newFixedThreadPool(int) 提供了固定大小线程池，内部使用无界队列；Executors.newSingleThreadExecutor() 提供了单个后台线程。</p><p>详细介绍一下上述四种线程池。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在newCachedThreadPool中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为0，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 SynchronousQueue中进行等待，而SynchronousQueue的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲SynchronousQueue时其实已经给出了，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。因此即便SynchronousQueue一开始为空且大小为1，第一个任务也无法放入其中，因为没有线程在等待从SynchronousQueue中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码一目了然了，线程数量固定，使用无限大的队列。再次强调，楼主就是踩的这个无限大队列的坑。</p><p>4.3 newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看看ScheduledThreadPoolExecutor（）的构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor的父类即ThreadPoolExecutor，因此这里各参数含义和上面一样。值得关心的是DelayedWorkQueue这个阻塞对列，在上面没有介绍，它作为静态内部类就在ScheduledThreadPoolExecutor中进行了实现。简单的说，DelayedWorkQueue是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>首先new了一个线程数目为 1 的ScheduledThreadPoolExecutor，再把该对象传入DelegatedScheduledExecutorService中，看看DelegatedScheduledExecutorService的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor);</span><br><span class="line">            e = executor;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在看看它的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; </span><br><span class="line">           e = executor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是使用装饰模式增强了ScheduledExecutorService（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。</p><h2 id="为什么禁止使用-Executors-创建线程池"><a href="#为什么禁止使用-Executors-创建线程池" class="headerlink" title="为什么禁止使用 Executors 创建线程池?"></a>为什么禁止使用 Executors 创建线程池?</h2><img src='https://oscimg.oschina.net/oscnet/up-9d0200e116259f64c5485a1bbf0d4265c31.png'><h3 id="实验证明Executors缺陷"><a href="#实验证明Executors缺陷" class="headerlink" title="实验证明Executors缺陷"></a>实验证明Executors缺陷</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">               executor.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       <span class="comment">//do nothing &#125;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过指定JVM参数:-Xmx8m -Xms8m运行以上代码，会抛出OOM:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue. java:<span class="number">416</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor. java:<span class="number">1371</span>)</span><br><span class="line">at com.hollis.ExecutorsDemo.main(ExecutorsDemo.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>以上代码指出，ExecutorsDemo.java 的第 16 行，就是代码中的 execu- tor.execute(new SubThread());。</p><h3 id="Executors-为什么存在缺陷"><a href="#Executors-为什么存在缺陷" class="headerlink" title="Executors 为什么存在缺陷"></a>Executors 为什么存在缺陷</h3><p>通过上面的例子，我们知道了 Executors 创建的线程池存在 OOM 的风险，那 么到底是什么原因导致的呢?我们需要深入 Executors 的源码来分析一下。</p><p>其实，在上面的报错信息中，我们是可以看出蛛丝马迹的，在以上的代码中其实 已经说了，真正的导致 OOM 的其实是 LinkedBlockingQueue.offer 方法。</p><p>如果读者翻看代码的话，也可以发现，其实底层确实是通过 LinkedBlock- ingQueue 实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><p>如果读者对 Java 中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。</p><p>Java 中 的 BlockingQueue 主 要 有 两 种 实 现， 分 别 是 ArrayBlockingQ- ueue 和 LinkedBlockingQueue。</p><ul><li>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，必须设置容量。</li><li>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列，容量可以选择 进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为 Integer.MAX_ VALUE。  </li></ul><p>这里的问题就出在:不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置 LinkedBlockingQueue 的 容量的话，其默认容量将会是 Integer.MAX_VALUE。</p><p>而 newFixedThreadPool 中创建 LinkedBlockingQueue 时，并未指定容 量。此时，LinkedBlockingQueue 就是一个无边界队列，对于一个无边界队列 来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导 致内存溢出问题。</p><p>上面提到的问题主要体现在newFixedThreadPool 和 newSingleThreadExecutor 两个工厂方法上，并不是说 newCachedThreadPool 和 newScheduledThreadPool 这两个方法就安全了，这两种方式创建的最大线程数可能是 Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致 OOM。</p><h3 id="创建线程池的正确姿势"><a href="#创建线程池的正确姿势" class="headerlink" title="创建线程池的正确姿势"></a>创建线程池的正确姿势</h3><p>避免使用 Executors 创建线程池，主要是避免使用其中的默认实现，那么我们 可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的 同时，给 BlockQueue 指定容量就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util. concurrent.RejectedExecutionException，这是因为当前线程池使用的队列 是有边界队列，队列已经满了便无法继续处理新的请求。但是异常(Exception)总比 发生错误(Error)要好。</p><p>除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间 就应该想到开源类库，如 apache 和 guava 等。</p><p>作者推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">            ThreadPoolExecutor. AbortPolicy());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123; pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名 称，更加方便的出错的时候溯源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程池简介&quot;&gt;&lt;a href=&quot;#线程池简介&quot; class=&quot;headerlink&quot; title=&quot;线程池简介&quot;&gt;&lt;/a&gt;线程池简介&lt;/h2&gt;&lt;p&gt;虽然Java线程池理论，以及构造线程池的各种参数，以及 Executors 提供的默认实现之前研读过，不过线上还没有</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="ThreadPool" scheme="http://example.com/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>Java-为什么禁止把SimpleDateFormat定义成static变量?</title>
    <link href="http://example.com/wiki/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E6%88%90static%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/wiki/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E6%88%90static%E5%8F%98%E9%87%8F/</id>
    <published>2021-07-21T12:06:46.000Z</published>
    <updated>2021-07-21T13:56:32.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参照 《Java技术灵魂15问》</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在日常开发中，我们经常会用到时间，我们有很多办法在 Java 代码中获取时 间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工 具，把时间显示成我们需要的格式。</p><p>最常用的方法就是使用 SimpleDateFormat 类。这是一个看上去功能比较简单 的类，但是，一旦使用不当也有可能导致很大的问题。<br>在 Java 开发手册中，有如下明确规定:</p><img src="https://oscimg.oschina.net/oscnet/up-8b016ecefbdfc6ea675aaf7f2a0511bbc6a.png"><p>那么，本文就围绕 SimpleDateFormat 的用法、原理等来深入分析下如何以正 确的姿势使用它。</p><p>SimpleDateFormat 是 Java 提供的一个格式化和解析日期的工具类。它允许进 行格式化(日期 -&gt; 文本)、解析(文本 -&gt; 日期)和规范化。SimpleDateFormat 使 得可以选择任何用户定义的日期 - 时间格式的模式。</p><p>在 Java 中，可以使用 SimpleDateFormat 的 format 方法，将一个 Date 类型 转化成 String 类型，并且可以指定输出格式。</p><h2 id="SimpleDateFormat-用法"><a href="#SimpleDateFormat-用法" class="headerlink" title="SimpleDateFormat 用法"></a>SimpleDateFormat 用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Date转String</span></span><br><span class="line">Date data = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String dataStr = sdf.format(data);</span><br><span class="line">System.out.println(dataStr);</span><br></pre></td></tr></table></figure><p>以上代码，转换的结果是:2018-11-25 13:00:00，日期和时间格式由”日期 和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就 行了。</p><p>在 Java 中，可以使用 SimpleDateFormat 的 parse 方法，将一个 String 类型 转化成 Date 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String转Data </span></span><br><span class="line">System.out.println(sdf.parse(dataStr));</span><br></pre></td></tr></table></figure><h2 id="日期和时间模式表达方法"><a href="#日期和时间模式表达方法" class="headerlink" title="日期和时间模式表达方法"></a>日期和时间模式表达方法</h2><p>在使用 SimpleDateFormat 的时候，需要通过字母来描述时间元素，并组装成 想要的日期和时间模式。常用的时间元素和字母的对应表如下:</p><img src='https://oscimg.oschina.net/oscnet/up-80bd4dd81e9c6fb2f0fe9c3b5eae1cef2b8.png'><p>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表 示方法。</p><img src="https://oscimg.oschina.net/oscnet/up-0c95fadb15ae4ca6aedb2e8cb68ce7ec50b.png"><h2 id="输出不同时区的时间"><a href="#输出不同时区的时间" class="headerlink" title="输出不同时区的时间"></a>输出不同时区的时间</h2><p>时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置(时 角)决定时间，这就使得不同经度的地方的时间有所不同(地方时)。1863 年，首次 使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p><p>世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日 出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p><p>现今全球共分为 24 个时区。由于实用上常常 1 个国家，或 1 个省份同时跨着 2 个或更多时区，为了照顾到行政上的方便，常将 1 个国家或 1 个省份划在一起。所以 时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差 不多跨 5 个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间 为准。</p><p>由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一 样，所以，在 Java 中想要获取时间的时候，要重点关注一下时区问题。<br>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获取中国的当前 时间的原因。</p><p>那么，如何在 Java 代码中获取不同时区的时间呢? SimpleDateFormat 可以 实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>)); </span><br><span class="line">System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br></pre></td></tr></table></figure><p>以上代码，转换的结果是:2018-11-24 21:00:00 。既中国的时间是 11 月 25 日的 13 点，而美国洛杉矶时间比中国北京时间慢了 16 个小时(这还和冬夏令时有关 系，就不详细展开了)。</p><p>如果你感兴趣，你还可以尝试打印一下美国纽约时间(America/New_York)。 纽约时间是 2018-11-25 00:00:00。纽约时间比中国北京时间早了 13 个小时。</p><p>当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍 SimpleDate-Format，其他方法暂不介绍了。</p><h2 id="SimpleDateFormat-线程安全性"><a href="#SimpleDateFormat-线程安全性" class="headerlink" title="SimpleDateFormat 线程安全性"></a>SimpleDateFormat 线程安全性</h2><p>由于 SimpleDateFormat 比较常用，而且在一般情况下，一个应用中的时间显 示模式都是一样的，所以很多人愿意使用如下方式定义 SimpleDateFormat:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            simpleDateFormat.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">            System.out.println(simpleDateFormat.format(Calendar.getInstance().</span><br><span class="line">                    getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>⚠️ 这种定义方式，存在很大的安全隐患。</p><p>我们来看一段代码，以下代码使用线程池来执行时间输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个全局的SimpleDateFormat</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用ThreadFactoryBuilder定义一个线程池</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span></span><br><span class="line">                ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个线程安全的 HashSet</span></span><br><span class="line">            Set&lt;String&gt; dates = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取当前时间</span></span><br><span class="line">                Calendar calendar = Calendar.getInstance();</span><br><span class="line">                <span class="keyword">int</span> finalI = i;</span><br><span class="line">                pool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 时间增加</span></span><br><span class="line">                    calendar.add(Calendar.DATE, finalI);</span><br><span class="line">        <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                    String dateString = simpleDateFormat.format(calendar.</span><br><span class="line">                            getTime());</span><br><span class="line">                    <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                    dates.add(dateString); </span><br><span class="line">                    <span class="comment">//countDown countDownLatch.countDown();</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞，直到 countDown 数量为 0 countDownLatch.await();</span></span><br><span class="line">        <span class="comment">// 输出去重后的时间个数 System.out.println(dates.size());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码，其实比较简单，很容易理解。就是循环一百次，每次循环的时候都在 当前时间基础上增加一个天数(这个天数随着循环次数而变化)，然后把所有日期放入 一个线程安全的、带有去重功能的 Set 中，然后输出 Set 中元素个数。</p><p>正常情况下，以上代码输出结果应该是 100。但是实际执行结果是一个小于 100 的数字。</p><p>原因就是因为 SimpleDateFormat 作为一个非线程安全的类，被当做了共享变 量在多个线程中进行使用，这就出现了线程安全问题。</p><h2 id="线程不安全原因"><a href="#线程不安全原因" class="headerlink" title="线程不安全原因"></a>线程不安全原因</h2><p>通过以上代码，我们发现了在并发场景中使用 SimpleDateFormat 会有线程安 全问题。其实，JDK 文档中已经明确表明了 SimpleDateFormat 不应该用在多线程 场景中:</p><blockquote><p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><p>那么接下来分析下为什么会出现这种问题，SimpleDateFormat 底层到底是怎 么实现的?<br>我们跟一下 SimpleDateFormat 类中 format 方法的实现其实就能发现端倪。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from Format after creating a FieldDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="params"><span class="function">                                FieldDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Convert input date to time field list</span></span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = compiledPattern[i] &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> count = compiledPattern[i++] &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">255</span>) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                toAppendTo.append((<span class="keyword">char</span>)count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TAG_QUOTE_CHARS:</span><br><span class="line">                toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">                i += count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SimpleDateFormat 中的 format 方法在执行过程中，会使用一个成员变量 calendar 来保存时间。这其实就是问题的关键。</p><p>由于我们在声明 SimpleDateFormat 的时候，使用的是 static 定义的。那么 这 个 SimpleDateFormat就是一个共享变量， 随 之，SimpleDateFormat 中 的 calendar 也就可以被多个线程访问到。</p><p>假设线程 1 刚刚执行完 calendar.setTime 把时间设置成 2018-11-11，还 没等执行完，线程 2 又执行了 calendar.setTime 把时间改成了 2018-12-12。 这时候线程 1 继续往下执行，拿到的 calendar.getTime 得到的时间就是线程 2 改 过之后的。</p><p>除了 format 方法以外，SimpleDateFormat 的 parse 方法也有同样的问题。 所以，不要把 SimpleDateFormat 作为一个共享变量使用。</p><h2 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="headerlink" title="如何解决线程安全问题"></a>如何解决线程安全问题</h2><ul><li>使用局部变量<br> 不要使用static</li><li>加同步锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// 获取当前时间</span></span><br><span class="line">           Calendar calendar = Calendar.getInstance();</span><br><span class="line">           <span class="keyword">int</span> finalI = i;</span><br><span class="line">           pool.execute(() -&gt; &#123;</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                   <span class="comment">// 时间增加</span></span><br><span class="line">                   calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                   <span class="comment">// 通过 simpleDateFormat 把时间转换成字符串</span></span><br><span class="line">                   String dateString = simpleDateFormat.format(calendar.getTime()); <span class="comment">// 把字符串放入 Set 中</span></span><br><span class="line">                   dates.add(dateString);</span><br><span class="line">                   <span class="comment">//countDown</span></span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><p>其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以 只对 simpleDateFormat.format 这一行加锁，这样效率更高一些。</p><ul><li>使用 ThreadLocal<br> 第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以 得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 使用ThreadLocal定义一个全局的SimpleDateFormat */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 用法</span></span><br><span class="line">       String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure><p>用 ThreadLocal 来实现其实是有点类似于缓存的思路，每个线程都有一个独享 的对象，避免了频繁创建对象，也避免了多线程的竞争。</p><p>当然，以上代码也有改进空间，就是，其实 SimpleDateFormat 的创建过程可 以改为延迟加载。这里就不详细介绍了。</p><h2 id="使用-DateTimeFormatter"><a href="#使用-DateTimeFormatter" class="headerlink" title="使用 DateTimeFormatter"></a>使用 DateTimeFormatter</h2><p>如果是 Java8 应用，可以使用 DateTimeFormatter 代替 SimpleDateFormat， 这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析日期</span></span><br><span class="line">String dateStr = <span class="string">&quot;2016年10月25日&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">LocalDate date = LocalDate.parse(dateStr, formatter);</span><br><span class="line"><span class="comment">// 日期转换为字符串</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 hh:mm a&quot;</span>);</span><br><span class="line">String nowStr = now.format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本 文 介 绍 了 SimpleDateFormat 的 用 法，SimpleDateFormat 主 要 可 以 在 String 和 Date 之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场 景中 SimpleDateFormat 是不能保证线程安全的，需要开发者自己来保证其安全性。</p><p>主要的几个手段有改为局部变量、使用 synchronized 加锁、使用 Threadlocal 为每一个线程单独创建一个等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参照 《Java技术灵魂15问》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在日常开发中，我们经常会用到时间，</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="SimpleDateFormat" scheme="http://example.com/tags/SimpleDateFormat/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程-多线程的发展和意义</title>
    <link href="http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%84%8F%E4%B9%89/"/>
    <id>http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%84%8F%E4%B9%89/</id>
    <published>2021-07-21T11:45:01.000Z</published>
    <updated>2021-07-26T14:27:19.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程基础概念"><a href="#线程基础概念" class="headerlink" title="线程基础概念"></a>线程基础概念</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是CPU执行任务的基本单位，一个进程中包含一个或者多个线程，一个进程内的多个线程共享进程的资源，每一个线程有自己的独立内存，是线程不共享的。</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><ul><li>并行<br> 同一时刻，横向有多少个线程可以运行</li><li>并发<br> 系统和服务器同一时刻能够承受的并发线程</li></ul><h2 id="线程的特征"><a href="#线程的特征" class="headerlink" title="线程的特征"></a>线程的特征</h2><ul><li>异步（不需要等待）<br> 比如说注册之后发送验证码，验证码的过程可以异步去做不需要客户去在注册接口等待这个时间；</li><li>并行（CPU核数）   </li></ul><h2 id="Java中线程的使用"><a href="#Java中线程的使用" class="headerlink" title="Java中线程的使用"></a>Java中线程的使用</h2><ul><li>继承Thread</li><li>实现Runnalbe</li><li>实现Callable/Future</li></ul><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="title">extend</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">      b = a + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行start方法，其实是调用JVM相关的指令， thread.cpp</p><blockquote><p>java thread.start() -&gt; cpp thread.start() -&gt; os指令:create.thread    start.thread<br>操作系统层面会创建线程，线程创建之后，线程可以启动，（线程启动之后并不一定马上执行）这些线程统一有CPU调度算法来处理；决定那个线程分配给那个执行CPU；<br>CPU执行线程任务的时候，会调用run方法 -&gt; cpp run方法  -&gt; java  thread.run()</p></blockquote><img src='https://oscimg.oschina.net/oscnet/up-9147a0440e839bc9946fc87147e97b7c793.png' whith=600 height=380><p>⚠️ CompletableFuture 异步回调通知，基于Future的优化 </p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程创建，当线程中的指令执行完成之后，run（）结束 线程销毁<br>其他线程状态</p><ul><li>等待状态 （sleep join wait）</li><li>锁阻塞状态 （blocked 竞争锁失败 park）</li></ul><img src="https://oscimg.oschina.net/oscnet/up-dc87c94066283689df31680050c67edd7b1.png" width=500 height=450><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStatusDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;time waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStatusDemo.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ThreadStatusDemo.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;waitting&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockDemo(),<span class="string">&quot;block demo 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BlockDemo.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>查看线程状态</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jstack pid</span><br></pre></td></tr></table></figure><h2 id="线程如何停止"><a href="#线程如何停止" class="headerlink" title="线程如何停止"></a>线程如何停止</h2><p>interrupt() 停止线程<br>主动停止方式 -&gt; run方法执行结束<br>被动停止方式</p><p>一般中断线程是在无法控制线程的情况下，比如线程wait ， 线程sleep ， 线程while(true)<br><code>Thread.currnetThread().isInterrupted()</code></p><blockquote><p>stop方法停止线程 禁止使用 相当于kill线程 不友好</p></blockquote><p>interrupt 功能</p><ul><li>唤醒阻塞状态的线程</li><li>修改中断标志，false -&gt; true</li></ul><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程基础概念&quot;&gt;&lt;a href=&quot;#线程基础概念&quot; class=&quot;headerlink&quot; title=&quot;线程基础概念&quot;&gt;&lt;/a&gt;线程基础概念&lt;/h1&gt;&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程-Overview</title>
    <link href="http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Overview/"/>
    <id>http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Overview/</id>
    <published>2021-07-21T11:42:49.000Z</published>
    <updated>2021-07-21T12:03:41.541Z</updated>
    
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么禁止开发人员修改 serialVersionUID 字段的值?</title>
    <link href="http://example.com/wiki/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%BF%AE%E6%94%B9-serialVersionUID-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC/"/>
    <id>http://example.com/wiki/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%BF%AE%E6%94%B9-serialVersionUID-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC/</id>
    <published>2021-07-21T09:47:46.000Z</published>
    <updated>2021-07-21T10:59:36.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列化是一种对象持久化的手段。普遍应用在网络传输、RMI 等场景中。类通 过实现 java.io.Serializable 接口以启用其序列化功能。<br><a href="http://www.hollischuang.com/archives/1150">Java 对象的序列化与反序列化、深入分析 Java 的序列化与反序列化、单例与 序列化的那些事儿</a>  </p></blockquote><p>在这几篇文章中，分别介绍过了序列化涉及到的类和接口、如何自定义序列化 策略、transient 关键字和序列化的关系等，还通过学习 ArrayList 对序列化的实现源 码深入学习了序列化。并且还拓展分析了一下序列化对单例的影响等。<br>但是，还有一个知识点并未展开介绍，那就是关于 serialVersionUID 。这个 字段到底有什么用?如果不设置会怎么样?为什么《Java 开发手册》中有以下规定:</p><img src='https://oscimg.oschina.net/oscnet/up-5b1a6020460edc9c688c054bdbad957cc28.png'>   <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Serializable 和 Externalizable<br>类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接 口的类将无法进行序列化或反序列化。可序列化类的所有子类型本身都是可序列 化的。<br>如果读者看过 Serializable 的源码，就会发现，他只是一个空的接口，里 面什么东西都没有。Serializable 接口没有方法或字段，仅用于标识可序列化的 语义。但是，如果一个类没有实现这个接口，想要被序列化的话，就会抛出 java. io.NotSerializableException 异常。</p><p>它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢?<br>原因是在执行序列化的过程中，会执行到以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在进行序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果都不是则直接抛出 NotSerializableException。<br>Java 中还提供了 Externalizable 接口，也可以实现它来提供序列化能力。</p><p>Externalizable 继承自 Serializable，该接口中定义了两个抽象方法: writeExternal() 与 readExternal()。<br>当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重 写 writeExternal() 与 readExternal() 方法。否则所有变量的值都会变成默认值。</p><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可 以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><h2 id="自定义序列化策略"><a href="#自定义序列化策略" class="headerlink" title="自定义序列化策略"></a>自定义序列化策略</h2><p>在序列化过程中，如果被序列化的类中定义了 writeObject 和 readObject 方法， 虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的 序列化和反序列化。</p><p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteOb- ject 方法以及 ObjectInputStream 的 defaultReadObject 方法。<br>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程， 比如可以在序列化的过程中动态改变序列化的数值。</p><p>所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用 tran- sient 修 饰， 并 自 己 重 写 writeObject 和 readObject 方 法， 如 java.util. ArrayList 中就有这样的实现。</p><p>我们随便找几个 Java 中实现了序列化接口的类，如 String、Integer 等，我们 可以发现一个细节，那就是这些类除了实现了 Serializable 外，还定义了一个 serialVersionUID</p><img src='https://oscimg.oschina.net/oscnet/up-74a9507ed04462e44fb2b7dd941d6b00fd4.png'><p>那么，到底什么是 serialVersionUID 呢?为什么要设置这样一个字段呢?</p><h2 id="什么是-serialVersionUID"><a href="#什么是-serialVersionUID" class="headerlink" title="什么是 serialVersionUID"></a>什么是 serialVersionUID</h2><p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。我们都知道， Java 对象是保存在 JVM 的堆内存中的，也就是说，如果 JVM 堆不存在了，那么对 象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使 JVM 停机的情况下也能把对象保存 下来的方案。就像我们平时用的 U 盘一样。把 Java 对象序列化成可存储或传输的形 式(如二进制流)，比如保存在文件中。这样，当再次需要这个对象的时候，从文件中 读取出二进制流，再从二进制流中反序列化出对象。</p><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重 要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化 ID，就是我们在代码中 定义的 serialVersionUID。</p><h2 id="如果-serialVersionUID-变了会怎样"><a href="#如果-serialVersionUID-变了会怎样" class="headerlink" title="如果 serialVersionUID 变了会怎样"></a>如果 serialVersionUID 变了会怎样</h2><p>我们举个例子吧，看看如果 serialVersionUID 被修改了会发生什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Initializes The Object User1 user = new User1(); user.setName(&quot;hollis&quot;);</span></span><br><span class="line">                <span class="comment">//Write Obj to File ObjectOutputStream oos = null; try &#123;</span></span><br><span class="line">                oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">                oos.writeObject(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(</span><br><span class="line">            IOException e)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                IOUtils.closeQuietly(oos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">我们先执行以上代码，把一个 User1 对象写入到文件中。然后我们修改一下 User1 类，把 serialVersionUID 的值改为 <span class="number">2L</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后执行以下代码，把文件中的对象反序列化出来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo2</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Read Obj from File</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">                ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">                    User1 newUser = (User1) ois.readObject();</span><br><span class="line">                    System.out.println(newUser);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    IOUtils.closeQuietly(ois);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FileUtils.forceDelete(file);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">执行结果如下</span><br><span class="line">```java</span><br><span class="line">java.io.InvalidClassException: com.hollis.User1; local <span class="class"><span class="keyword">class</span> <span class="title">incompatible</span>: <span class="title">stream</span> <span class="title">classdesc</span></span></span><br><span class="line"><span class="class"><span class="title">serialVersionUID</span> </span>= <span class="number">1</span>, local <span class="class"><span class="keyword">class</span> <span class="title">serialVersionUID</span> </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现，以上代码抛出了一个 java.io.InvalidClassException，并且 指出 serialVersionUID 不一致。</p><p>这是因为，在进行反序列化时，JVM 会把传来的字节流中的 serialVersio- nUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致 的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 Invalid- CastException。</p><p>这也是《Java 开发手册》中规定，在兼容性升级中，在修改类的时候，不要 修改 serialVersionUID 的原因。除非是完全不兼容的两个版本。所以，serialVersionUID 其实是验证版本一致性的。</p><p>如果读者感兴趣，可以把各个版本的 JDK 代码都拿出来看一下，那些向下兼容 的类的 serialVersionUID 是没有变化过的。比如 String 类的 serialVersionUID一直都是 -6849794470754667710L。</p><p>但是，作者认为，这个规范其实还可以再严格一些，那就是规定:<br>如果一个类实现了 Serializable 接口，就必须手动添加一个 private static final long serialVersionUID变量，并且设置初始值。</p><h2 id="为什么要明确定一个-serialVersionUID"><a href="#为什么要明确定一个-serialVersionUID" class="headerlink" title="为什么要明确定一个 serialVersionUID"></a>为什么要明确定一个 serialVersionUID</h2><p>如果我们没有在类中明确的定义一个 serialVersionUID 的话，看看会发生什么。</p><p>尝试修改上面的 demo 代码，先使用以下类定义一个对象，该类中不定义 serialVersionUID，将其写入文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后我们修改 User1 类，向其中增加一个属性。在尝试将其从文件中读取出来， 并进行反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执 行 结 果:java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc serialVersionUID = -2986778152837257883, local class serialVersionUID = 7961728318907695402</p><p>同样，抛出了 InvalidClassException，并且指出两个 serialVersio- nUID 不同，分别是 -2986778152837257883 和 7961728318907695402。<br>从这里可以看出，系统自己添加了一个 serialVersionUID。 所以，一旦类实现了 Serializable，就建议明确的定义一个 serialVersionUID。不然在修改类的时候，就会发生异常。</p><p>serialVersionUID 有两种显示的生成方式:</p><p>一是默认的1L，比如:private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段，比如:private static final long serialVersionUID = xxxxL;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>serialVersionUID 是用来验证版本一致性的。所以在做兼容性升级的时候， 不要改变类中 serialVersionUID 的值。</p><p>如果一个类实现了 Serializable 接口，一定要记得定义 serialVersionUID，否则会发生异常。可以在 IDE 中通过设置，让他帮忙提示，并且可以一键快速生成一 个 serialVersionUID。</p><p>之所以会发生异常，是因为反序列化过程中做了校验，并且如果没有明确定义的 话，会根据类的属性自动生成一个。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="">Java技术灵魂15问</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;序列化是一种对象持久化的手段。普遍应用在网络传输、RMI 等场景中。类通 过实现 java.io.Serializable 接口以启用其序列化功能。&lt;br&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="Serializable" scheme="http://example.com/tags/Serializable/"/>
    
  </entry>
  
  <entry>
    <title>极尽HashMap底层原理</title>
    <link href="http://example.com/wiki/%E6%9E%81%E5%B0%BDHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/%E6%9E%81%E5%B0%BDHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-21T06:26:25.000Z</published>
    <updated>2021-07-21T08:11:35.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/92481037">HashMap 中的容量与扩容实现，细致入微，值的一品</a></li><li><a href="https://www.zhihu.com/search?type=content&q=hashmap">Java 8系列之重新认识HashMap 美团技术团队</a> </li></ul></blockquote><blockquote><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：<br><img src="https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png"></p><p>下面针对各个实现类的特点做一些说明：</p><p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><img src='https://pic1.zhimg.com/8db4a3bdfb238da1a1c4431d2b6e075c_b.png'><p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p><p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;美团&quot;</span>,<span class="string">&quot;小美&quot;</span>);</span><br></pre></td></tr></table></figure><p>系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下:</p><p>int threshold;             // 所能容纳的key-value对极限<br>    final float loadFactor;    // 负载因子<br>    int modCount;<br>    int size;</p><p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，<code>例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</code></p><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159]%EF%BC%8CHashtable%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%B8%BA11%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A1%B6%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hashtable%E6%89%A9%E5%AE%B9%E5%90%8E%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%BF%98%E6%98%AF%E7%B4%A0%E6%95%B0%EF%BC%89%E3%80%82HashMap%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E9%9D%9E%E5%B8%B8%E8%A7%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%8F%96%E6%A8%A1%E5%92%8C%E6%89%A9%E5%AE%B9%E6%97%B6%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81%EF%BC%8CHashMap%E5%AE%9A%E4%BD%8D%E5%93%88%E5%B8%8C%E6%A1%B6%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%97%B6%EF%BC%8C%E4%B9%9F%E5%8A%A0%E5%85%A5%E4%BA%86%E9%AB%98%E4%BD%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://blog.csdn.net/liuqiyao_01/article/details/14475159]，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考[<a href="http://blog.csdn.net/v_july_v/article/details/6105630]%E3%80%82">http://blog.csdn.net/v_july_v/article/details/6105630]。</a></p><h2 id="实现-方法"><a href="#实现-方法" class="headerlink" title="实现-方法"></a>实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p><h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度。<br><img src='https://pic2.zhimg.com/8e8203c1b51be6446cda4026eaaccf19_b.png'></p><h2 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。<br><img src='https://pic3.zhimg.com/58e67eae921e4b431782c07444af824e_b.png'></p><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><p>JDK1.8HashMap的put方法源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);                      <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;                  <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                  </span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><img src='https://pic1.zhimg.com/e5aa99e811d1814e010afa7779b759d4_b.png'><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><img src='https://pic2.zhimg.com/a285d9b2da279a18b052fe5eed69afe9_b.png'><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><img src='https://pic2.zhimg.com/b2cb057773e3d67976c535d6ef547d51_b.png'><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><img src='https://pic3.zhimg.com/544caeb82a329fa49cc99842818ed1ba_b.png'><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             <span class="keyword">return</span> oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">         newCap = oldThr;</span><br><span class="line">     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 计算新的resize上限</span></span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                         next = e.next;</span><br><span class="line">                         <span class="comment">// 原索引</span></span><br><span class="line">                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j] = loHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><img src="https://pic4.zhimg.com/fa10635a66de637fe3cbd894882ff0c7_b.png">  <p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。<br>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><img src="https://pic4.zhimg.com/d39d7eff6e8e04f98f5b53bebe2d4d7f_b.png">  <p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><img src="https://pic2.zhimg.com/5f3cf5300f041c771a736b40590fd7b1_b.png">  <p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/92481037&quot;&gt;HashMap 中的容量与扩容实现，细致入微，值的一品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.co</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch字符串查询汇总</title>
    <link href="http://example.com/wiki/elasticsearch%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/wiki/elasticsearch%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E8%AF%A2%E6%B1%87%E6%80%BB/</id>
    <published>2021-07-20T14:08:29.000Z</published>
    <updated>2021-07-20T14:16:14.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>filter<br>exists<br>fuzzy<br>ids<br>prefix<br>regexp<br>term<br>terms<br>terms_set<br>wildcard<br>text搜索 interval<br>match<br>match_bool_prefix<br>match_phrase<br>match_phrase_prefix<br>multi_match<br>common<br>query_string<br>simple_query_string</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/weixin_35143514/article/details/112607839">查询是否包含字符串_十九种Elasticsearch字符串搜索方式终极介绍</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;filter&lt;br&gt;exists&lt;br&gt;fuzzy&lt;br&gt;ids&lt;br&gt;prefix&lt;br&gt;regexp&lt;br&gt;term&lt;br&gt;terms&lt;br&gt;terms_set&lt;br&gt;wildcard&lt;br&gt;text搜索 interval&lt;br&gt;match&lt;b</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Search in Depth" scheme="http://example.com/categories/Elasticsearch/Search-in-Depth/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch 查询值前缀不包含某个字符串</title>
    <link href="http://example.com/wiki/elasticsearch-%E6%9F%A5%E8%AF%A2%E5%80%BC%E5%89%8D%E7%BC%80%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/wiki/elasticsearch-%E6%9F%A5%E8%AF%A2%E5%80%BC%E5%89%8D%E7%BC%80%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-07-20T13:48:31.000Z</published>
    <updated>2021-07-20T13:52:01.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需求 查询IP不是以11.开头的所有文档，然后获取文档访问量前100条</p></blockquote><p><code>curl -X GET &quot;localhost:9200/yj_visit_data2,yj_visit_data3/_search?pretty&quot; -u elastic:elastic -H &#39;Content-Type: application/json&#39; -d&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;11.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;prefix&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;ip&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1.&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;visitTime&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1577808000000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">1609430399000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term_article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;ip&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;min_doc_count&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;需求 查询IP不是以11.开头的所有文档，然后获取文档访问量前100条&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;curl -X GET &amp;quot;localhost:9200/yj_visit_data2,yj_visit_data</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="Administration and Deployment" scheme="http://example.com/categories/Elasticsearch/Administration-and-Deployment/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
