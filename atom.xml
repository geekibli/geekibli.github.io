<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-28T13:04:53.341Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM-Xms,Xmx和Xss</title>
    <link href="http://example.com/wiki/JVM-Xms-Xmx%E5%92%8CXss/"/>
    <id>http://example.com/wiki/JVM-Xms-Xmx%E5%92%8CXss/</id>
    <published>2021-07-28T13:04:14.000Z</published>
    <updated>2021-07-28T13:04:53.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能调优参数Xms，Xmx，Xss的含义"><a href="#性能调优参数Xms，Xmx，Xss的含义" class="headerlink" title="性能调优参数Xms，Xmx，Xss的含义"></a>性能调优参数Xms，Xmx，Xss的含义</h1><blockquote><p>s -Xss</p></blockquote><p>规定了每个线程虚拟机栈及堆栈的大小，一般情况下，256k是足够的，此配置将会影响此进程中并发线程数的大小。</p><blockquote><p>s -Xms</p></blockquote><p>表示初始化JAVA堆的大小及该进程刚创建出来的时候，他的专属JAVA堆的大小，一旦对象容量超过了JAVA堆的初始容量，JAVA堆将会自动扩容到-Xmx大小。</p><blockquote><p>s -Xmx</p></blockquote><p>表示java堆可以扩展到的最大值，在很多情况下，通常将-Xms和-Xmx设置成一样的，因为当堆不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性。</p><blockquote><p>w 堆内存分配：</p></blockquote><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/a1439775520/article/details/97787160">类似-Xms、-Xmn这些参数的含义：</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1671253445384660292&wfr=spider&for=pc">JVM三大性能调优参数Xms，Xmx，Xss的含义，你又知道多少呢</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能调优参数Xms，Xmx，Xss的含义&quot;&gt;&lt;a href=&quot;#性能调优参数Xms，Xmx，Xss的含义&quot; class=&quot;headerlink&quot; title=&quot;性能调优参数Xms，Xmx，Xss的含义&quot;&gt;&lt;/a&gt;性能调优参数Xms，Xmx，Xss的含义&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Develop-Lan/Java/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM-自定义类加载器</title>
    <link href="http://example.com/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://example.com/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2021-07-28T13:02:32.000Z</published>
    <updated>2021-07-28T13:04:59.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p>为什么要自定义加载器</p><p>原因：<br>1、存放在自定义路径上的类，需要通过自定义类加载器去加载。【注意：AppClassLoader加载classpath下的类】<br>2、类不一定从文件中加载，也可能从网络中的流中加载，这就需要自定义加载器去实现加密解密。<br>3、可以定义类的实现机制，实现类的热部署,<br>如OSGi中的bundle模块就是通过实现自己的ClassLoader实现的，<br>如tomcat实现的自定义类加载模型。</p><p>如何实现自定义加载器</p><blockquote><p>i 实现自定义类加载有以下两步：<br>1、继承ClassLoader<br>2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。<br>注意：如果要打破双亲委派机制，需要重写loadClass方法。<br>如下：是一个自定义 的类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span>  <span class="keyword">extends</span>  <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 data= loadByte(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/admin/test/&quot;</span>+name);</span><br><span class="line">            FileInputStream fi = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> len = fi.available();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fi.read(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是要加载的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类编译后的class 文件放置在/Users/admin/test/下,然后执行如下代码去加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;Demo.class&quot;</span>);</span><br><span class="line">        Object o=clazz.newInstance();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">输出:hello</span><br></pre></td></tr></table></figure><p>能不能自己写一个java.lang.String</p><p>1、代码书写后可以编译不会报错<br>2、在另一个类中加载java.lang.String，通过反射调用自己写的String类里的方法，得到结果NoSuchMethod，说明加载的还是原来的String，因为通过双亲委派机制，会把java.lang.String一直提交给启动类加载器去加载，通过他加载，加载到的永远是/lib下面的java.lang.String<br>3、在这个自己写的类中写上main方法<br>public static void main(String[] args)<br>执行main方法报错，因为这个String并不是系统的java.lang.String，所以JVM找不到main方法的签名</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_28605513/article/details/85014451">JVM:如何实现一个自定义类加载器？</a><br>原文链接：<a href="https://blog.csdn.net/qq_28605513/article/details/85014451">https://blog.csdn.net/qq_28605513/article/details/85014451</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何自定义类加载器&quot;&gt;&lt;a href=&quot;#如何自定义类加载器&quot; class=&quot;headerlink&quot; title=&quot;如何自定义类加载器&quot;&gt;&lt;/a&gt;如何自定义类加载器&lt;/h1&gt;&lt;p&gt;为什么要自定义加载器&lt;/p&gt;
&lt;p&gt;原因：&lt;br&gt;1、存放在自定义路径上的类，需要通</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Develop-Lan/Java/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式-一致性哈希算法</title>
    <link href="http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-28T13:01:05.000Z</published>
    <updated>2021-07-28T13:05:44.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。</p><h2 id="哈希指标"><a href="#哈希指标" class="headerlink" title="哈希指标"></a>哈希指标</h2><blockquote><p>i 评估一个哈希算法的优劣，有如下指标，而一致性哈希全部满足：</p></blockquote><ul><li>均衡性(Balance)：将关键字的哈希地址均匀地分布在地址空间中，使地址空间得到充分利用，这是设计哈希的一个基本特性。</li><li>单调性(Monotonicity): 单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。</li><li>分散性(Spread): 哈希经常用在分布式环境中，终端用户通过哈希函数将自己的内容存到不同的缓冲区。此时，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li><li>负载(Load): 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷</li></ul><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote><p>i 将节点通过hash映射到hash环上，理想的情况是多个节点直接分布均匀</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-ac8ab4cd06d150b14ddfe58e2cdcbdb7dff.png" ><p>当我们的对象通过hash算法分配在hash环上的时候，它是固定分配到一个节点的空间上的，当我们在BC之间插入一个节点时，仅仅会影响到BC这一段空间上的数据，而不是整个环上的数据都要跟着变化；</p><blockquote><p>i 现实情况下，节点之间可能分配不均匀</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-3a12f9634fed9d5f67debfcdd7fe22f1fae.png"><p>这和传统的hash取模一样，同样会数据倾斜的问题！</p><blockquote><p>i 虚拟节点</p></blockquote><p>这个时候虚拟节点就此诞生，下面让我们来看一下虚拟节点在一致性Hash中的作用。当我们在Hash环上新增若干个点，那么每个点之间的距离就会接近相等。按照这个思路我们可以新增若干个片/表，但是成本有限，我们通过复制多个A、B、C的副本({A1-An},{B1-Bn},{C1-Cn})一起参与计算，按照顺时针的方向进行数据分布，按照下图示意:<br><img src="https://oscimg.oschina.net/oscnet/up-88c2aef2ec993ede090695ffe78f53f999a.png"></p><p>此时A=[A,C1)&amp;[A1,C2)&amp;[A2,B4)&amp;[A3,A4)&amp;[A4,B1)；B=[B,A1)&amp;[B2,C)&amp;[B3,C3)&amp;[B4,C4)&amp;[B1,A)；C=[C1,B)&amp;[C2,B2)&amp;[C,B3)&amp;[B3,C3)&amp;[C4,A3)；由图可以看出分布点越密集，平衡性约好。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>一致性哈希算法有多种具体的实现，包括 Chord 算法，KAD 算法等，都比较复杂。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 、<a href="https://blog.csdn.net/kefengwang/article/details/81628977">一致性哈希算法的原理与实现</a><br>2、<a href="https://www.cnblogs.com/xialihua1023/p/10304932.html">浅谈一致性Hash原理及应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一致性哈希算法&quot;&gt;&lt;a href=&quot;#一致性哈希算法&quot; class=&quot;headerlink&quot; title=&quot;一致性哈希算法&quot;&gt;&lt;/a&gt;一致性哈希算法&lt;/h1&gt;&lt;p&gt;一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式-CAP理论</title>
    <link href="http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/</id>
    <published>2021-07-28T10:15:10.000Z</published>
    <updated>2021-07-28T10:15:24.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。<br>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p><img src="https://oscimg.oschina.net/oscnet/up-1d3052b25a13428857fde791eaa01c02e9b.png"><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值，即写操作之后的读操作，必须返回该值。（分为弱一致性、强一致性和最终一致性）</li><li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><h2 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h2><blockquote><p>i CA without P</p></blockquote><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p><blockquote><p>i CP without A</p></blockquote><p>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要<font color=red>牺牲用户的体验</font>，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p><blockquote><p>i AP wihtout C</p></blockquote><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><h2 id="解决方案——BASE"><a href="#解决方案——BASE" class="headerlink" title="解决方案——BASE"></a>解决方案——BASE</h2><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果。</p><p>核心思想：即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><blockquote><p>i 基本可用Basically Available</p></blockquote><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p><p>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><blockquote><p>i 软状态Soft state</p></blockquote><p>软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><blockquote><p>i 最终一致性Eventually consistent</p></blockquote><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/lixinkuan328/article/details/95535691">https://blog.csdn.net/lixinkuan328/article/details/95535691</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP-原则&quot;&gt;&lt;a href=&quot;#CAP-原则&quot; class=&quot;headerlink&quot; title=&quot;CAP 原则&quot;&gt;&lt;/a&gt;CAP 原则&lt;/h1&gt;&lt;p&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availab</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql-事务特性与实现原理</title>
    <link href="http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-28T10:13:07.000Z</published>
    <updated>2021-07-28T10:14:30.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务特性与实现原理"><a href="#事务特性与实现原理" class="headerlink" title="事务特性与实现原理"></a>事务特性与实现原理</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote><p>i 原子性(Atomicity)</p></blockquote><p>事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。</p><blockquote><p>i 一致性(Consistency)</p></blockquote><p>事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p><blockquote><p>i 隔离性(Isolation)</p></blockquote><p>并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。</p><blockquote><p>i 持久性(Durability)</p></blockquote><p>事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面<br>1.事务的并发执行<br>2.事务故障或系统故障</p><h2 id="事务实现原理"><a href="#事务实现原理" class="headerlink" title="事务实现原理"></a>事务实现原理</h2><img src="https://oscimg.oschina.net/oscnet/up-7b54f7847cee22930ec53a4058179a2b531.png" width=460 height=300><ul><li>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。</li><li>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</li></ul><h3 id="回滚日志（undo）"><a href="#回滚日志（undo）" class="headerlink" title="回滚日志（undo）"></a>回滚日志（undo）</h3><p>undo log属于 「 逻辑日志 」，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><p>undo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。</p><p>因此，undo log有两个作用：提供回滚和多个行版本控制(MVCC)。</p><h3 id="重做日志（redo）"><a href="#重做日志（redo）" class="headerlink" title="重做日志（redo）"></a>重做日志（redo）</h3><p>redo log重做日志记录的是新数据的备份，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据恢复到最新的状态。</p><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><p>MySQL中redo log刷新规则采用一种称为Checkpoint的机制（利用LSN实现），为了确保安全性，又引入double write机制。</p><h2 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h2><p>开启事务：start transaction<br>回滚事务：rollback<br>提交事务：commit</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">1、详细分析MySQL事务日志(redo log和undo log)</a><br><a href="https://www.cnblogs.com/takumicx/p/9998844.html">2、数据库事务的概念及其实现原理</a><br><a href="https://zhuanlan.zhihu.com/p/281927963">3、数据库事务实现原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务特性与实现原理&quot;&gt;&lt;a href=&quot;#事务特性与实现原理&quot; class=&quot;headerlink&quot; title=&quot;事务特性与实现原理&quot;&gt;&lt;/a&gt;事务特性与实现原理&lt;/h1&gt;&lt;h2 id=&quot;事务特性&quot;&gt;&lt;a href=&quot;#事务特性&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql-事务隔离级别</title>
    <link href="http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-07-28T10:12:49.000Z</published>
    <updated>2021-07-28T10:14:27.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。另外，这篇分布式事务不理解？一次给你讲清楚！推荐大家阅读。</p><blockquote><p>i Read Uncommitted（读取未提交内容）</p></blockquote><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><blockquote><p>i Read Committed（读取提交内容）</p></blockquote><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><blockquote><p>i Repeatable Read（可重读）</p></blockquote><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><blockquote><p>i Serializable（可串行化）</p></blockquote><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><h2 id="事务隔离级别产生的问题"><a href="#事务隔离级别产生的问题" class="headerlink" title="事务隔离级别产生的问题"></a>事务隔离级别产生的问题</h2><img src="https://oscimg.oschina.net/oscnet/up-ee3cb778a32220ff81103f9163d22f774b2.png"> <blockquote><p>w 脏读(Drity Read)</p></blockquote><p>某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，但是此时的事务B还未commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务B-&gt;rollback操作</span><br><span class="line">事务A读取到的是脏数据</span><br></pre></td></tr></table></figure><blockquote><p>w不可重复读(Non-repeatable read)</p></blockquote><p>在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，并commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务A多次读取的结果不一致</span><br></pre></td></tr></table></figure><blockquote><p>w 幻读(Phantom Read) </p></blockquote><p><font color=red >幻读和不可重复读的区别在于，幻读主要表现在数据的删除和插入，而不可重复读表现在数据的更新。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新delete price=100 这条记录，并commit</span><br><span class="line">事务A读取的price=100</span><br><span class="line">price这条记录已经不存在，但是事务A还是可以读取到</span><br></pre></td></tr></table></figure><p>1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。<br>　　2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/xiewenfeng520/article/details/99407038">1、mysql数据库的隔离级别</a><br><a href="https://blog.csdn.net/sinat_15805929/article/details/91127491">2、MYSQL数据库的四种隔离级别</a><br><a href="https://www.jianshu.com/p/c53c8ab650b5">3、MySQL幻读</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库隔离级别&quot;&gt;&lt;a href=&quot;#数据库隔离级别&quot; class=&quot;headerlink&quot; title=&quot;数据库隔离级别&quot;&gt;&lt;/a&gt;数据库隔离级别&lt;/h1&gt;&lt;p&gt;SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql-MVCC多版本并发控制</title>
    <link href="http://example.com/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2021-07-28T10:12:28.000Z</published>
    <updated>2021-07-28T10:14:35.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>MVCC在MySQL InnoDB中的实现主要是为了 「<font color=red> 提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 </font>」</p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><blockquote><p>i 当前读</p></blockquote><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><blockquote><p>i 快照读</p></blockquote><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p><p><font color=red >MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</font></p><h2 id="MVCC有什么好处，解决了什么问题"><a href="#MVCC有什么好处，解决了什么问题" class="headerlink" title="MVCC有什么好处，解决了什么问题"></a>MVCC有什么好处，解决了什么问题</h2><p>多版本并发控制（MVCC）是一种用来「 <font color=green>解决读-写冲突的无锁并发控制</font> 」，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li></ul><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的  <font color=red>3个隐式字段</font>，<font color=red>undo日志</font> ，<font color=red>Read View</font> 来实现的。所以我们先来看看这个三个point的概念</p><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><blockquote><p>w DB_TRX_ID</p></blockquote><p>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p><blockquote><p>w DB_ROLL_PTR</p></blockquote><p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><blockquote><p>w DB_ROW_ID</p></blockquote><p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p><blockquote><p>s insert undo log</p></blockquote><p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><blockquote><p>s update undo log</p></blockquote><p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><p>作者：爱情小傻蛋<br>链接：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法，<font color=red>主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护）</font>，如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本;</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/8845ddca3b23">1、MVCC多版本并发控制</a><br><a href="https://blog.csdn.net/chosen0ne/article/details/18093187">2、MVCC浅析</a><br><a href="https://database.51cto.com/art/202010/629317.htm">3、乐观锁、悲观锁和MVCC，今天让你一次搞懂</a><br><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc">4、面试官：谈谈你对Mysql的MVCC的理解？</a><br><a href="https://www.cnblogs.com/shujiying/p/11347632.html">5、Mysql中MVCC的使用及原理详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC多版本并发控制&quot;&gt;&lt;a href=&quot;#MVCC多版本并发控制&quot; class=&quot;headerlink&quot; title=&quot;MVCC多版本并发控制&quot;&gt;&lt;/a&gt;MVCC多版本并发控制&lt;/h1&gt;&lt;p&gt;MVCC，全称Multi-Version Concurrency C</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Java对象头</title>
    <link href="http://example.com/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <id>http://example.com/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/</id>
    <published>2021-07-28T09:59:59.000Z</published>
    <updated>2021-07-28T10:07:15.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><h2 id="JOL查看对象头信息"><a href="#JOL查看对象头信息" class="headerlink" title="JOL查看对象头信息"></a>JOL查看对象头信息</h2><p>在项目中引入以下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>写一个main方法，创建一个Object，然后打印对象信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><p>由此可知，new Object()在内存中占16个字节，组成部分8字节的markword+4字节的class point+4字节的对齐；</p><h2 id="Java对象在内存中的布局"><a href="#Java对象在内存中的布局" class="headerlink" title="Java对象在内存中的布局"></a>Java对象在内存中的布局</h2><image src="https://oscimg.oschina.net/oscnet/up-056ef14e62f5dfde1a5af579dabeb6e4c2a.png" width=250 height=420><ul><li>markword<blockquote><p>i 存储sync锁标志，分代年龄等一些关键信息 8字节</p></blockquote></li><li>class pointer<blockquote><p>i 指向当前对象所属类类型 4字节</p></blockquote></li></ul><p><strong>查看java命令默认带的参数命令：</strong> java -XX:+PrintCommandLineFlags -version </p><blockquote><p>-XX:InitialHeapSize=134217728<br>-XX:MaxHeapSize=2147483648<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers 压缩类指针 4字节<br>-XX:+UseCompressedOops 普通对象指针压缩 4字节<br>-XX:+UseParallelGC</p></blockquote><ul><li>instance data<blockquote><p>i 寸尺当前对象的实例数据</p></blockquote></li><li>padding<blockquote><p>i 对齐填充，当对象所占字节数不能被8整除之后，进行填充对齐。 目前的操作系统基本上都是64位的；</p></blockquote></li></ul><h2 id="顺丰面试题，new-Object-在内存中占多少个字节"><a href="#顺丰面试题，new-Object-在内存中占多少个字节" class="headerlink" title="顺丰面试题，new Object()在内存中占多少个字节"></a>顺丰面试题，new Object()在内存中占多少个字节</h2><p>1、如果创建的是空对象，没有实例数据</p><ul><li>默认开启了class pointer指针压缩<blockquote><p>w 8字节markword + 4字节class pointer + 4字节 padding</p></blockquote></li><li>如果关闭了类指针压缩<blockquote><p>w 8字节markword + 8字节class pointer</p></blockquote></li></ul><p>2、如果创建的对象有实力数据，如下对象：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person（int age , String name）</span><br></pre></td></tr></table></figure></p><ul><li>默认开启了class pointer指针压缩<blockquote><p>w 8字节markword + 4字节class pointer + 4字节int + 4字节String + 4字节padding对齐</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java对象头&quot;&gt;&lt;a href=&quot;#Java对象头&quot; class=&quot;headerlink&quot; title=&quot;Java对象头&quot;&gt;&lt;/a&gt;Java对象头&lt;/h1&gt;&lt;h2 id=&quot;JOL查看对象头信息&quot;&gt;&lt;a href=&quot;#JOL查看对象头信息&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-CAS原理和底层实现</title>
    <link href="http://example.com/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-28T09:59:17.000Z</published>
    <updated>2021-07-28T10:06:34.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS原理和底层实现"><a href="#CAS原理和底层实现" class="headerlink" title="CAS原理和底层实现"></a>CAS原理和底层实现</h1><img src="https://oscimg.oschina.net/oscnet/up-0ed0dcb929342035287eb09818f33416baa.png" width=550 height=400><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是（compare and swap） 的缩写，它能在不加锁的情况下，在多线程的环境下，保证多线程一致性的改动某一值；</p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题是一个线程在CAS比较值和原来是否相等的过程中，别的线程修改过这个值，但是又改回去了，倒置当前线程比较的时候，发现是相等的，但是，中间是被修改过的；  </p><p>添加版本号，比较值的时候同时比较版本号</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger:"></a>AtomicInteger:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe:"></a>Unsafe:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><h3 id="jdk8u-atomic-linux-x86-inline-hpp-93行"><a href="#jdk8u-atomic-linux-x86-inline-hpp-93行" class="headerlink" title="jdk8u: atomic_linux_x86.inline.hpp 93行"></a>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></h3><p>is_MP = Multi Processor  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">&quot;cmp $0, &quot;</span> #mp <span class="meta-string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="最终实现："><a href="#最终实现：" class="headerlink" title="最终实现："></a>最终实现：</h3><p>底层对应一个汇编指令「lock comxchg」，但是comxchg这条指令不是原子性的，他不能保证在比较的时候，别的线程会不会改变值；而保证线程安全的则是lock这条指令，lock这条指令在执行后面执行的时候锁定一个「北桥信号」，而不是采用纵线锁的方式；</p><h2 id="CAS在JDK中的实现"><a href="#CAS在JDK中的实现" class="headerlink" title="CAS在JDK中的实现"></a>CAS在JDK中的实现</h2><p>1、AtomitInteger<br>2、ConcurrentHashMap</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS原理和底层实现&quot;&gt;&lt;a href=&quot;#CAS原理和底层实现&quot; class=&quot;headerlink&quot; title=&quot;CAS原理和底层实现&quot;&gt;&lt;/a&gt;CAS原理和底层实现&lt;/h1&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscn</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-FutureTask原理</title>
    <link href="http://example.com/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-28T09:58:47.000Z</published>
    <updated>2021-07-28T10:06:42.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><h3 id="Future方法介绍"><a href="#Future方法介绍" class="headerlink" title="Future方法介绍"></a>Future方法介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务 可中断的方式取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断任务是否处于取消状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断异步任务是否执行完成      ==这里使用轮训的方式监听==</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到有结果返回；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到设置的时间，有结果返回，没有结果则抛出异常；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单示范Callable-amp-Future"><a href="#简单示范Callable-amp-Future" class="headerlink" title="简单示范Callable&amp;Future"></a>简单示范Callable&amp;Future</h3><p>（1）向线程池中提交任务的submit方法不是阻塞方法，而Future.get方法是一个阻塞方法<br>（2）submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果，所以一般需要使用future.isDone先判断任务是否全部执行完成，完成后再使用future.get得到结果。（也可以用get (long timeout, TimeUnit unit)方法可以设置超时时间，防止无限时间的等待）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;start call method...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main method start....&quot;</span>);</span><br><span class="line">        FutureTest futureTest = <span class="keyword">new</span> FutureTest();</span><br><span class="line">        Future1Test future1Test = <span class="keyword">new</span> Future1Test();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(future1Test);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;future not done !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(futureTest);</span><br><span class="line">        <span class="comment">// submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果</span></span><br><span class="line">        <span class="comment">// 这里先提交了future1Test，休眠了4s, futureTest休眠了3s，但是等我们get到结果的时候，是消耗的4s时间的；</span></span><br><span class="line">        System.err.println(<span class="string">&quot;cost time: &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">        System.err.println(<span class="string">&quot;future: &quot;</span> + future.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;future1: &quot;</span> + future1.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;main method end....&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main method start....</span><br><span class="line">future not done !</span><br><span class="line"><span class="comment">// 说明了第一 get()方法是阻塞，第二线程池任务都执行完成之后，按提交任务顺序get结果返回值</span></span><br><span class="line">cost time: <span class="number">4</span></span><br><span class="line">start call method...</span><br><span class="line">future: future <span class="number">2</span> test</span><br><span class="line">future1: <span class="number">1111</span></span><br><span class="line">main method end....</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>线程池执行任务有两种方式execute和submit，execute是不带返回值的，submit是有返回值的;</li><li>main方法中可以不使用线程池，可以直接创建线程，调用start方法就可以，切记只有在演示代码的时候后。手动直接创建线程的方式还是不要用，因为一旦请求变多，则会创建无数的线程，线程数大于CPU核数，进而导致CPU频繁切换上下分进行调度，性能严重下降。</li><li>而且线程的数据是存放在内存中的，会占用大量的内存，增加垃圾回收的压力。严重的会发生OOM;</li><li>异常main方法中我们使用的是Future<String> future接收异步任务执行的放回结果，但实际上Future其实是一个interface，并不能接收返回结果的，那实际我们调用future.get()是，是实例了一个FutureTask对象来接受的；</li></ul><h3 id="FutureTask讲解"><a href="#FutureTask讲解" class="headerlink" title="FutureTask讲解"></a>FutureTask讲解</h3><p>下面主要针对Future的实现类FutureTask的几个重要方法展开</p><h4 id="FutureTask继承关系"><a href="#FutureTask继承关系" class="headerlink" title="FutureTask继承关系"></a>FutureTask继承关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 下面是RunnableFuture接口的继承关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>FutureTask 重要的成员变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="comment">//任务执行结果或者任务异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="comment">//执行任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="comment">//等待节点，关联等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//state字段的内存偏移量     这个在线程池执行任务的时候进行状态判断的时候会用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="comment">//runner字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line"><span class="comment">//waiters字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br></pre></td></tr></table></figure><blockquote><p>定义任务的生命周期</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>NORMAL:指的是任务能够正常执行状态  </li><li>EXCEPTIONAL：表示任务执行异常  </li><li>CANCELLED：取消状态，之后的状态都表示任务取消或终端  </li></ul><p>下面看一下FutureTask中几个重要的方法</p><h4 id="执行结果-report方法"><a href="#执行结果-report方法" class="headerlink" title="执行结果 | report方法"></a>执行结果 | report方法</h4><blockquote><p>Returns result or throws exception for completed task.<br>主要是上报异步任务执行的结果或返回任务执行发生的异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>判断逻辑就是根据参数，也是是任务状态，根据不同的状态处理相应的逻辑。比如NORNAL状态，表示任务正常执行，直接返回结果就可以。如果状态大于CANCELLED，说明任务被取消或终端，会抛出CancellationException()；如果不是异常状态，则抛出ExecutionException；</p><h4 id="任务执行-run"><a href="#任务执行-run" class="headerlink" title="任务执行 |   run()"></a>任务执行 |   run()</h4><blockquote><p>执行异步任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果状态 state 不是 NEW，或者设置 runner 值失败</span></span><br><span class="line">     <span class="comment">// 表示有别的线程在此之前调用 run 方法，并成功设置了 runner 值</span></span><br><span class="line">     <span class="comment">// 保证了只有一个线程可以运行 try 代码块中的代码。</span></span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">             !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//以上state值变更的由CAS操作保证原子性</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="comment">//只有c不为null且状态state为NEW的情况</span></span><br><span class="line">         <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="keyword">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//调用callable的call方法，并获得返回结果</span></span><br><span class="line">                 result = c.call();</span><br><span class="line">                 <span class="comment">//运行成功</span></span><br><span class="line">                 ran = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="keyword">null</span>;</span><br><span class="line">                 ran = <span class="keyword">false</span>;</span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 <span class="comment">//设置结果</span></span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">         <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">         runner = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">         <span class="comment">// leaked interrupts</span></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">             handlePossibleCancellationInterrupt(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心逻辑就是调用Callable的call方法，==result=c.call();== 并且对任务执行的结果或异常信息进行处理；</p><h4 id="获取结果-get-throws-InterruptedException-ExecutionException"><a href="#获取结果-get-throws-InterruptedException-ExecutionException" class="headerlink" title="获取结果 | get() throws InterruptedException, ExecutionException"></a>获取结果 | get() throws InterruptedException, ExecutionException</h4><blockquote><p>获取异步任务执行的结果或异常信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法执行两个操作：  </p><ul><li>判断任务的状态,如果没有执行完成，调用awaitDone方法</li><li>任务完成，调用我们上面说的report方法，返回任务执行结果</li></ul><h4 id="任务阻塞-awaitDone-boolean-timed-long-nanos"><a href="#任务阻塞-awaitDone-boolean-timed-long-nanos" class="headerlink" title="任务阻塞 | awaitDone(boolean timed, long nanos)"></a>任务阻塞 | awaitDone(boolean timed, long nanos)</h4><blockquote><p>等到任务执行完成 也是get方法阻塞特性的关键所在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// CPU轮转</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果线程中断了，将线程移除等待队列，抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 如果任务状态大于完成，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务完成，但是返回值outcome还没有设置，可以先让出线程执行权，让其他线程执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">// 下面是任务还没有执行完成的状态，将线程添加到等待队列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="comment">// 判断get方法是否设置了超时时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 如果超出设置的时间，线程移除等到队列</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有设置超时时间，线程直接阻塞，直到任务完成</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>主要执行步骤：</p><ul><li>判断线程是否被中断，如果被中断了，就从等待的线程栈中移除该等待节点，然后抛出中断异常 </li><li>读取state,判断任务是否已经完成，如果已经完成或者任务已经取消，此时调用get方法的线程不会阻塞，会直接获取到结果或者拿到异常信息；  </li><li>如果s == COMPLETING，说明任务已经结束，但是结果还没有保存到outcome中，==此时线程让出执行权，给其他线程先执行；==   </li><li>如果任务没有执行完成，则需要创建等待节点，等待插入到阻塞队列  </li><li>判断queued，这里是将c中创建节点q加入队列头。使用Unsafe的CAS方法，对waiters进行赋值，waiters也是一个WaitNode节点，相当于队列头，或者理解为队列的头指针。通过WaitNode可以遍历整个阻塞队列  </li><li>然后判断超时时间，时间是在调用get方法的时候传输进来的，如果有超时时间，则设置超时时间，如果超出时间，则将线程移除等待队列；如果没有设置时间，则直接阻塞线程；  </li></ul><h4 id="取消任务-cancel-boolean-mayInterruptIfRunning"><a href="#取消任务-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="取消任务 |  cancel(boolean mayInterruptIfRunning)"></a>取消任务 |  cancel(boolean mayInterruptIfRunning)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param</span> mayInterruptIfRunning 是否中断</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在状态还为NEW的时候，根据参数中的是否允许传递，</span></span><br><span class="line"><span class="comment">     * 将状态流转到INTERRUPTING或者CANCELLED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 必须将栈顶CAS为null，否则重读栈顶并重试。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历并唤醒栈中节点对应的线程。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将next域置为null，这样对GC友好。</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; </span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * done方法是暴露给子类的一个钩子方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个方法在ExecutorCompletionService.QueueingFuture中的override实现是把结果加到阻塞队列里。</span></span><br><span class="line"><span class="comment">     * CompletionService谁用谁知道，奥秘全在这。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * callable置为null主要为了减少内存开销,</span></span><br><span class="line"><span class="comment">     * 更多可以了解JVM memory footprint相关资料。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    callable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable-amp-Future使用场景"><a href="#Callable-amp-Future使用场景" class="headerlink" title="Callable&amp;Future使用场景"></a>Callable&amp;Future使用场景</h3><ul><li>异步任务需要拿到返回值</li><li>多线程并发调用，顺序组装返回值，一些并发框架中会看到相应体现</li><li>还有一些分布式任务调度的场景，远程调用需要回填执行结果</li><li>还有很多通信框架中都有体现</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p>(1) <a href="https://blog.csdn.net/qq_34562093/article/details/90209520">future.get方法阻塞问题的解决，实现按照任务完成的先后顺序获取任务的结果</a><br>(2) <a href="https://blog.csdn.net/luofenghan/article/details/78596950#%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java多线程引发的性能问题以及调优策略</a><br>(3) <a href="https://www.jianshu.com/p/55221d045f39">可取消的异步任务——FutureTask用法及解析</a><br>(4) <a href="https://www.cnblogs.com/micrari/p/7374513.html">FutureTask源码解读</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FutureTask&quot;&gt;&lt;a href=&quot;#FutureTask&quot; class=&quot;headerlink&quot; title=&quot;FutureTask&quot;&gt;&lt;/a&gt;FutureTask&lt;/h1&gt;&lt;h3 id=&quot;Future方法介绍&quot;&gt;&lt;a href=&quot;#Future方法介绍&quot;</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-join方法原理解析</title>
    <link href="http://example.com/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-28T09:58:22.000Z</published>
    <updated>2021-07-28T10:06:45.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">join重载方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> join()</span><br><span class="line"><span class="number">2</span> join(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line"><span class="number">3</span> join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br></pre></td></tr></table></figure><h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//        t.join();</span></span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上将t.join();注释掉，执行的一种可能结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">main thread end... </span><br><span class="line">join thread demo</span><br><span class="line"></span><br><span class="line">还有可能是这种结果：</span><br><span class="line">main thread start... </span><br><span class="line">join thread demo</span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure><p>但是把注释去掉，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure><p>这是一个非常简单的demo,效果是显而易见的。当main线程去调用t.join()是，会将自己当前线程阻塞，等到t线程执行完成到达完结状态，main线程才可以继续执行。  </p><p>我们看一下join()设置超时时间的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程睡眠4s</span></span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">null</span>;</span><br><span class="line">        System.err.println(strings.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 但是主线程join的超时时间是1s</span></span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br><span class="line">Exception in thread <span class="string">&quot;ibli joinTest ...&quot;</span> java.lang.NullPointerException</span><br><span class="line">at com.ibli.threadTest.api.JoinDemo.run(JoinDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上面的执行结果可以看到，子线程设置了4s的超时时间，但是主线程在1秒超时后，并没有等待子线程执行完毕，就被唤醒执行后续操作了；这样的预期是否符合你的预期呢？<br>下面我们按照join的源码去分析吧！</p></blockquote><h3 id="join方法原理"><a href="#join方法原理" class="headerlink" title="join方法原理"></a>join方法原理</h3><p>下面是join的原理图</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5386b2aaabd43cab4b0f042e0270118~tplv-k3u1fbpfcp-zoom-1.image?imageView2/2/w/480/h/480/q/85/interlace/1" width = "400" height = "500" div align=right /><blockquote><p>join()源码</p></blockquote><p>首先会调用join(0)方法，其实是join的重载方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是join的核心实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先校验参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果join方法没有参数，则相当于直接调用wait方法</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是isAlive方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个本地方法，作用是判断当前的线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。</p><ul><li><p>这里有一个点要注意，join为什么阻塞的是主线程，而不是子线程呢？  </p></li><li><p>不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p></li><li><p>其实join()方法的核心在于wait(),在主线程中调用t.join()相当于在main方法中添加 new JoinDemo().wait();是一样的效果；在这里只不过是wait方法写在了子线程的方法中。  </p></li><li><p>再次重申一遍，join方法的作用是在主线程阻塞，等在子线程执行完之后，由子线程唤醒主线程，再继续执行主线程调用t.join()方法之后的逻辑。</p></li></ul><blockquote><p>那么主线程是在什么情况下知道要继续执行呢？就是上面说的，主线程其实是由join的子线程在执行完成之后调用的notifyAll()方法，来唤醒等待的线程。怎么证明呢？</p></blockquote><p>其实大家可以去翻看JVM的源码实现，Thread.cpp文件中，有一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">  <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">  <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用ensure_join方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">  <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">&quot;java thread object must exist&quot;</span>);</span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">  <span class="comment">// to complete once we&#x27;ve done the notify_all below</span></span><br><span class="line">  <span class="comment">//这里是清除native线程，这个操作会导致isAlive()方法返回false</span></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  <span class="comment">// 在这里唤醒等待的线程</span></span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM的代码中，线程执行结束的最终调用了lock.notify_all(thread)方法来唤醒所有处于等到的线程</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>比如我们使用Callable执行异步任务，需要在主线程处理任务的返回值时，可以调用join方法；</li><li>还有一些场景希望线程之间顺序执行的；</li></ul><h2 id="join-方法与sleep-的比较"><a href="#join-方法与sleep-的比较" class="headerlink" title="join()方法与sleep()的比较"></a>join()方法与sleep()的比较</h2><p>我们先说一下sleep方法：</p><ul><li>让当前线程休眠指定时间。</li><li>休眠时间的准确性依赖于系统时钟和CPU调度机制。</li><li>不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进- 入到当前同步块或者同步方法中的。</li><li>可通过调用interrupt()方法来唤醒休眠线程。</li><li>sleep是静态方法，可以在任何地方调用</li></ul><p>相比与sleep方法<br>sleep是静态方法，而且sleep的线程不是放锁资源，而join方法是对象方法，并且在等待的过程中会释放掉对象锁；</p><blockquote><p>关于join方法会释放对象锁，那到底是释放的那个对象的锁呢，可以参照 <a href="https://www.cnblogs.com/lwmp/p/11805440.html">关于join() 是否会释放锁的一些思考</a> </p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.iteye.com/blog/uule-1101994">1、Java多线程中join方法的理解</a><br><a href="https://blog.csdn.net/weichi7549/article/details/108449618">2、Thread.join的作用和原理</a><br><a href="https://www.jianshu.com/p/fc51be7e5bc0">3、Thread.join的作用和原理</a></p></blockquote><blockquote><p>d <p align="middle">山脚太拥挤 我们更高处见。</p></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;join方法&quot;&gt;&lt;a href=&quot;#join方法&quot; class=&quot;headerlink&quot; title=&quot;join方法&quot;&gt;&lt;/a&gt;join方法&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://example.com/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-28T09:57:51.000Z</published>
    <updated>2021-07-28T10:07:49.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="首先需要思考什么是JMM，以及为什么会有JMM。"><a href="#首先需要思考什么是JMM，以及为什么会有JMM。" class="headerlink" title="首先需要思考什么是JMM，以及为什么会有JMM。"></a>首先需要思考什么是JMM，以及为什么会有JMM。</h2><blockquote><p>Java Memory Model简称JMM, 是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。(可能在术语上与Java运行时内存分布有歧义，后者指堆、方法区、线程栈等内存区域)。</p></blockquote><p> <strong>JMM规范的内容</strong>  </p><ul><li>1.所有变量存储在主内存  </li><li>2.主内存是虚拟机内存的一部分</li><li>3.每条线程有自己的工作内存</li><li>4.线程的工作内存保存变量的主内存副本</li><li>5.线程对变量的操作必须在工作内存中进行</li><li>6.不同线程之间无法直接访问对方工作内存中的变量</li><li>7.线程间变量值的传递均需要通过主内存来完成</li></ul><p>JMM并不是一个客观存在的东西，它实际是为了规范Java虚拟机制定到一套标准。那为什么需要这套标准呢？ </p><p> 其实我们都知道JVM是运行在操作系统之上的。而目前的操作系统都是基于冯诺伊曼设置的计算机系统体系来的。CPU是计算机中用来执行控制和计算的核心组建，<br>所有的计算任务全部在CPU中完成，但是我们的所有变量的数据全部存储在主内存中。CPU在执行计算时，需要去主内存加载数据，CPU执行运算的速度极快，<br>这就设计一个CPU执行速度和数据加载速度不一致的问题。   </p><img src= "https://user-gold-cdn.xitu.io/2018/2/7/1616dcd4cfc4f98c?imageView2/0/w/1280/h/960/ignore-error/1" width = "400" height = "500" />      <p> 在操作系统级别解决这个问题的办法是引入了CPU缓存。每个CPU都有自己私有的L1缓存和L2缓存，当执行计算时，会优先去CPU自己的缓存中寻找数据，<br>没有的话才会重新加载内存数据。这种方式一定程度上解决了CPU计算和数据加载不一致的问题。    </p><p><strong>但是也会引入一个新的问题，就是数据一致性问题。</strong>  </p><h2 id="缓存一致性与MESI协议"><a href="#缓存一致性与MESI协议" class="headerlink" title="缓存一致性与MESI协议"></a>缓存一致性与MESI协议</h2><p><strong>首先看一下什么是MESI协议</strong>  </p><blockquote><p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），<br>用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p></blockquote><ul><li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li><li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li><li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li><li>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。</li></ul><p>如何解决缓存一致性问题呢？<br><img src="http://www.wowotech.net/content/uploadfile/201411/e35f2f4793d734a566d1d230d1b83b4620141114112002.gif">  </p><p>如上图所示，共享变量是存储在主内存Memory中，在CPU计算时，每一个CPU都有改变量的独立拷贝，每个CPU可以去读取甚至修改共享变量的值，<br>但是为了保证数据的一致性，一个CPU modify了变量的值，需要通知其他的CPU这个变量的最新值是什么。那么可以怎么做呢。</p><ul><li><p>在初始状态，每个CPU还没有加载共享变量，所有每一个CPU的缓存行的状态都是invalid；  </p></li><li><p>当CPU0去使用这个共享变量的时候，首先去自己的缓存中查找，肯定是缓存不命中的，也就是cache miss,这个时候去主内存Memory中去加载，<br>当共享变量的值加载到CPU0的缓存后，CPU缓存行状态变成shared,也就是共享状态；  </p></li><li><p>如果这个时候有其他的CPU也读取了共享变量的值，它们的cache line 的状态同样也是shared共享状态；此时一个CPU如果修改共享变量的值，<br>而没有通知其他的CPU,就会造成缓存一致性问题；</p></li><li><p>当CPU0尝试去修改共享变量的值时，它会发出一个read invalidate命令，同时CPU0的缓存行状态设置为exclusive(独占),<br>同时将其他加载了这个共享变量的cacheline的状态设置为invalid。通俗一点就是CPU0独占的这个变量的缓存行，其他的CPU缓存的共享变量都失效了； </p></li><li><p>CPU0接下来修改共享变量的值，它会将cacheline的状态修改为modified,其实也是独占共享变量的cacheline，<br>只不过是此时缓存行的数据和主内存Memory的数据不一致的，而exclusive虽然也是独占状态，但是共享变量的值是一样的，<br>modified的值需要write back到Memory中去的，而exclusive是不需要的； </p></li><li><p>在cacheline没有替换出CPU0的cache之前，当有其他CPU来读取共享变量，此时肯定是cache miss ,因为CPU0的modify操作已经将它的缓存失效了。<br>如果CPU0的状态是modified状态，它必须响应其他CPU的读操作，会告知其他CPU主内存的数据是dirty data。所以其他的CPU的状态可能会变成shared。<br>如果CPU0还没有write back操作，其他的CPU状态还是invalid状态。</p></li></ul><h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>正如上面所描述的，在CPU0进行共享变量的修改，会同步修改其他CPU的cacheline状态为invalid，这个操作是和共享变量的写操作同步进行的，因此共享变量的写操作的性能是非常差的。在修改其他的CPU cacheline状态时，CPU0其实是处于阻塞状态的。所以为了优化这个问题，提出了Store Buffer的解决方案。</p><p><img src="http://www.wowotech.net/content/uploadfile/201411/a872a1863fec02585bb786a5c382d3eb20141114112005.gif"></p><p>这样的话，写操作不必等到cacheline被加载，而是直接写到store buffer中，然后去执行后续的操作。由于是store buffer相当于是异步处理，<br>在这里可能会出现因为并发执行导致的执行执行交叉问题，具体解决方法是依赖于内存屏障。<br>具体可以参考这篇文章：<a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html">Linux内核同步机制之（三）：memory barrier</a>  </p><h3 id="Invalidate-Queue"><a href="#Invalidate-Queue" class="headerlink" title="Invalidate Queue"></a>Invalidate Queue</h3><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。<br>为了解决上面两个问题，引进了失效队列（invalidate queue）。处理失效的工作如下：</p><p><img src="http://www.wowotech.net/content/uploadfile/201411/46e1bbd0ba094941caf23050e1db2d2d20141114112008.gif"></p><ul><li>收到失效消息时，放到失效队列中去。</li><li>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。</li><li>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens- before原则"></a>happens- before原则</h2><blockquote><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：    </p></blockquote><p>1、单线程每个操作，happen-before于该线程中任意后续操作；<br>2、volatile写happen-before与后续对这个变量的读；<br>3、synchronized解锁happen-before后续对这个锁的加锁；<br>4、final变量的写happen-before于final域对象的读，happen-before后续对final变量的读；<br>5、传递性规则，A先于B，B先于C，那么A一定先于C发生；  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;首先需要思考什么是JMM，以及为什么会有JMM。&quot;&gt;&lt;a href=&quot;#首先需要思</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-synchronzied底层原理</title>
    <link href="http://example.com/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-28T09:57:19.000Z</published>
    <updated>2021-07-28T10:07:06.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronzied底层原理"><a href="#synchronzied底层原理" class="headerlink" title="synchronzied底层原理"></a>synchronzied底层原理</h1><h2 id="synchronzied四个层级实现"><a href="#synchronzied四个层级实现" class="headerlink" title="synchronzied四个层级实现"></a>synchronzied四个层级实现</h2><ul><li>Java代码 通过添加synchronzied给对象或者方法或者代码块</li><li>字节码层级通过一组 MONITORENTER/MONITOREXIT指令</li><li>JVM层级：锁升级过程</li><li>汇编执行通过 lock comxchg指令保证原子操作</li></ul><p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db <span class="string">&quot;Hello&quot;</span>, <span class="number">0xA</span></span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, <span class="number">1</span> ;文件描述符<span class="number">1</span> std_out</span><br><span class="line">    mov eax, <span class="number">4</span> ;write函数系统调用号 <span class="number">4</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">    mov ebx, <span class="number">0</span></span><br><span class="line">    mov eax, <span class="number">1</span> ;exit函数系统调用号</span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><p>优化后的synchronized如下👇：</p><h2 id="Java层级"><a href="#Java层级" class="headerlink" title="Java层级"></a>Java层级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Object object = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">          System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">    <span class="comment">// parameter  args</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L2 L3 L2 <span class="keyword">null</span></span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 13 L4</span></span><br><span class="line"><span class="function">    NEW java/lang/Object</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/lang/Object.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L5</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">16</span> L6</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    DUP</span><br><span class="line">    ASTORE <span class="number">2</span></span><br><span class="line">    MONITORENTER</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">17</span> L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    INVOKESTATIC org/openjdk/jol/info/ClassLayout.parseInstance (Ljava/lang/Object;)Lorg/openjdk/jol/info/ClassLayout;</span><br><span class="line">    INVOKEVIRTUAL org/openjdk/jol/info/ClassLayout.toPrintable ()Ljava/lang/String;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">18</span> L7</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L1</span><br><span class="line">    GOTO L8</span><br><span class="line">   L2</span><br><span class="line">   FRAME FULL [[Ljava/lang/String; java/lang/Object java/lang/Object] [java/lang/Throwable]</span><br><span class="line">    ASTORE <span class="number">3</span></span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    MONITOREXIT</span><br><span class="line">   L3</span><br><span class="line">    ALOAD <span class="number">3</span></span><br><span class="line">    ATHROW</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">19</span> L8</span><br><span class="line">   FRAME CHOP <span class="number">1</span></span><br><span class="line">    RETURN</span><br><span class="line">   L9</span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L4 L9 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE object Ljava/lang/Object; L5 L9 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>i 主要通过MONITORENTER 和 MONITOREXIT 两个字节码指令控制加锁过程</p></blockquote><h2 id="JVM层级"><a href="#JVM层级" class="headerlink" title="JVM层级"></a>JVM层级</h2><p>通过锁升级过程实现加锁；<br>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁 自适应锁）-&gt; 重量级锁<br>锁升级过程可以查看 <a href="doc:rjG4EIhi">锁升级过程</a>  复制理解</p><h2 id="汇编指令级别"><a href="#汇编指令级别" class="headerlink" title="汇编指令级别"></a>汇编指令级别</h2><p>linux操作系统安装hsdis插件，查看java代码的汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    static volatile int i = 0;</span><br><span class="line">    </span><br><span class="line">    public static void n() &#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void m() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    publics static void main(String[] args) &#123;</span><br><span class="line">        for(int j=0; j&lt;1000_000; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</span><br></pre></td></tr></table></figure><ul><li>C1 Compile Level 1 (一级优化)</li><li>C2 Compile Level 2 (二级优化)</li></ul><blockquote><p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronzied底层原理&quot;&gt;&lt;a href=&quot;#synchronzied底层原理&quot; class=&quot;headerlink&quot; title=&quot;synchronzied底层原理&quot;&gt;&lt;/a&gt;synchronzied底层原理&lt;/h1&gt;&lt;h2 id=&quot;synchronz</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-锁消除和锁膨胀</title>
    <link href="http://example.com/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/"/>
    <id>http://example.com/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/</id>
    <published>2021-07-28T09:57:00.000Z</published>
    <updated>2021-07-28T10:06:28.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h1><h2 id="锁消除-（lock-eliminate）"><a href="#锁消除-（lock-eliminate）" class="headerlink" title="锁消除 （lock eliminate）"></a>锁消除 （lock eliminate）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p><h2 id="锁粗化-（lock-coarsening）"><a href="#锁粗化-（lock-coarsening）" class="headerlink" title="锁粗化 （lock coarsening）"></a>锁粗化 （lock coarsening）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p><a href="https://www.zhihu.com/question/63859501">https://www.zhihu.com/question/63859501</a></p><p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;锁消除和锁粗化&quot;&gt;&lt;a href=&quot;#锁消除和锁粗化&quot; class=&quot;headerlink&quot; title=&quot;锁消除和锁粗化&quot;&gt;&lt;/a&gt;锁消除和锁粗化&lt;/h1&gt;&lt;h2 id=&quot;锁消除-（lock-eliminate）&quot;&gt;&lt;a href=&quot;#锁消除-（lock-eli</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-锁升级过程</title>
    <link href="http://example.com/wiki/Java-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/wiki/Java-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-28T09:56:39.000Z</published>
    <updated>2021-07-28T10:06:23.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><h2 id="使用JOL查看加锁之后的对象信息"><a href="#使用JOL查看加锁之后的对象信息" class="headerlink" title="使用JOL查看加锁之后的对象信息"></a>使用JOL查看加锁之后的对象信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           f0 b8 d0 <span class="number">0f</span> (<span class="number">11110000</span> <span class="number">10111000</span> <span class="number">11010000</span> <span class="number">00001111</span>) (<span class="number">265337072</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">70</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">01110000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">28672</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><blockquote><p>w 锁升级过程： new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p></blockquote><image src="https://oscimg.oschina.net/oscnet/up-2f555289640d34755ca4288ab080906554b.png" width=750 height=450> <p><strong>自旋锁什么时候升级为重量级锁？</strong></p><p><strong>为什么有自旋锁还需要重量级锁？</strong></p><blockquote><p>i 自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗<br>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p></blockquote><p><strong>偏向锁是否一定比自旋锁效率高？</strong></p><blockquote><p>i 不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁<br>JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开</p></blockquote><h3 id="synchronized优化的过程和markword息息相关"><a href="#synchronized优化的过程和markword息息相关" class="headerlink" title="synchronized优化的过程和markword息息相关"></a>synchronized优化的过程和markword息息相关</h3><p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p><ol><li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p></li><li><p>o.hashCode()<br>001 + hashcode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>little endian big endian </p><p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p></li><li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure></li><li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p></li><li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p></li><li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p></li><li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p></li></ol><p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)<br>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p><p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p><blockquote><p>i <strong>轻量级锁重量级锁的hashCode存在与什么地方？</strong><br>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p></blockquote><p>关于epoch: (不重要)</p><blockquote><p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p><p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p><p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p></blockquote><p>没错，我就是厕所所长</p><p>加锁，指的是锁定对象</p><p>锁升级的过程</p><p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p><p>现代版本进行了优化</p><p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p><p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p><p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p><p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p><p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;锁升级&quot;&gt;&lt;a href=&quot;#锁升级&quot; class=&quot;headerlink&quot; title=&quot;锁升级&quot;&gt;&lt;/a&gt;锁升级&lt;/h1&gt;&lt;h2 id=&quot;使用JOL查看加锁之后的对象信息&quot;&gt;&lt;a href=&quot;#使用JOL查看加锁之后的对象信息&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM-strace</title>
    <link href="http://example.com/wiki/JVM-strace/"/>
    <id>http://example.com/wiki/JVM-strace/</id>
    <published>2021-07-28T09:52:23.000Z</published>
    <updated>2021-07-28T09:52:41.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="strace-命令查看操作系统日志"><a href="#strace-命令查看操作系统日志" class="headerlink" title="strace 命令查看操作系统日志"></a>strace 命令查看操作系统日志</h1><p><code>strace -ff -o out java ***.class</code></p><p>-ff : 跟踪进程下所有线程用到的系统命令<br>-o : 将跟踪的操作系统日志输出</p><blockquote><p>i 下面查看JDK1.8下，BIO模式都有哪些系统命令的执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.io.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 2:55 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SockerIo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        Socket client = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = client.getInputStream();</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        <span class="comment">// 读阻塞</span></span><br><span class="line">        System.err.println(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>i 服务端</p></blockquote><p>1、<code>javac SockerIo.java</code> 得到SockerIo.class<br>然后，使用strace启动java程序👇：<br>2、<code>strace -ff -0 out java SockerIo</code><br>得到如下日志：<br><img src="https://oscimg.oschina.net/oscnet/up-924f13a6df8c2ce97e13019329008fb4a84.png"></p><blockquote><p>i 客户端使用nc连接9090端口，然后请求数据</p></blockquote><p><code>nc 127.0.0.1 9090</code>  发送如下数据</p><img src="https://oscimg.oschina.net/oscnet/up-4b7b364f021786bd9bdf4f40135da3b4a8d.png"><blockquote><p>strace查看日志</p></blockquote><p>查看主线程日志：<br><img src="https://oscimg.oschina.net/oscnet/up-291f9a1018a2d288b88a5c2e43666d5d47e.png"><br>如上图，👆文件最大的是主线程日志：</p><img src="https://oscimg.oschina.net/oscnet/up-c306b9f94e3d0a3582b049d3c4769b4f5ec.png"><p>根据上面👆strace命令跟踪的日志可以看到，JDK1.8下的BIO的多路复用器是使用的「poll」</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;strace-命令查看操作系统日志&quot;&gt;&lt;a href=&quot;#strace-命令查看操作系统日志&quot; class=&quot;headerlink&quot; title=&quot;strace 命令查看操作系统日志&quot;&gt;&lt;/a&gt;strace 命令查看操作系统日志&lt;/h1&gt;&lt;p&gt;&lt;code&gt;stra</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Develop-Lan/Java/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-NIO核心组件--channel</title>
    <link href="http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-channel/"/>
    <id>http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-channel/</id>
    <published>2021-07-28T09:51:42.000Z</published>
    <updated>2021-07-28T09:55:18.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO核心组件-Channel"><a href="#NIO核心组件-Channel" class="headerlink" title="NIO核心组件 - Channel"></a>NIO核心组件 - Channel</h1><h2 id="SocketChannel-和-ServerSocketChannel"><a href="#SocketChannel-和-ServerSocketChannel" class="headerlink" title="SocketChannel 和 ServerSocketChannel"></a>SocketChannel 和 ServerSocketChannel</h2><p>学习此部分可以对比Socket和ServerSocket</p><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketServer01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocketChannel 支持阻塞/非阻塞</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 设置成非阻塞。默认阻塞true</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 循环监听客户端连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有客户端连接，则返回一个socketChannel实例，否则socketChannel=null</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                <span class="comment">// 代码执行到此处，说明有客户端链接</span></span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 读取客户端发送的数据，并输出</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.err.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                    <span class="comment">// 将数据在写会客户端</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    socketChannel.write(buffer);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//验证客户端 socketChannel设置成false时，从服务端read数据的操作变成非阻塞的</span></span><br><span class="line">                    <span class="comment">//ByteBuffer buffer = ByteBuffer.allocate(1024);</span></span><br><span class="line">                    <span class="comment">//buffer.put(&quot;this is server!&quot;);</span></span><br><span class="line">                    <span class="comment">//buffer.flip();</span></span><br><span class="line">                    <span class="comment">//socketChannel.write(buffer);</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    System.err.println(<span class="string">&quot;no client&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 默认阻塞IO true</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// finishConnect的主要作用就是确认通道连接已建立，方便后续IO操作（读写）不会因连接没建立而导致NotYetConnectedException异常。</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel.isConnectionPending()) &#123;</span><br><span class="line">                <span class="comment">// finishConnect一直阻塞到connect建立完成</span></span><br><span class="line">                socketChannel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            </span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">int</span> r = socketChannel.read(byteBuffer); <span class="comment">// 非阻塞方法 byteBuffer的数据还是上面put的</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;get msg:&#123;&#125;&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server no back&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NIO核心组件-Channel&quot;&gt;&lt;a href=&quot;#NIO核心组件-Channel&quot; class=&quot;headerlink&quot; title=&quot;NIO核心组件 - Channel&quot;&gt;&lt;/a&gt;NIO核心组件 - Channel&lt;/h1&gt;&lt;h2 id=&quot;SocketCha</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-NIO核心组件--selector</title>
    <link href="http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-selector/"/>
    <id>http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-selector/</id>
    <published>2021-07-28T09:51:30.000Z</published>
    <updated>2021-07-28T09:55:37.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>1、select选择器会告诉客户端哪些连接有数据要读取，但是读取的操作还是用户自己触发的，这种叫做「同步」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ibli.javaBase.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> gaolei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 4:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMultiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.err.println(<span class="string">&quot;server started ....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// selector.select() 调用系统内核的select</span></span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 从多路复用器中选择有效的key</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        acceptHandle(key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        readHandle(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel client = ssc.accept();</span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class="line">        System.err.println(<span class="string">&quot;client arrived &quot;</span> + client.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            read = client.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务端读到的数据，再写一遍给到客户端</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// client 发生错误 或者断开 read == -1</span></span><br><span class="line">                <span class="comment">// 导致空转 最终CPU达到100%</span></span><br><span class="line">                client.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>i 上面的写法是一个selector既担任boss又担任worker </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多路复用器&quot;&gt;&lt;a href=&quot;#多路复用器&quot; class=&quot;headerlink&quot; title=&quot;多路复用器&quot;&gt;&lt;/a&gt;多路复用器&lt;/h1&gt;&lt;h2 id=&quot;select&quot;&gt;&lt;a href=&quot;#select&quot; class=&quot;headerlink&quot; title=&quot;s</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-NIO核心组件--buffer</title>
    <link href="http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-buffer/"/>
    <id>http://example.com/wiki/Java-NIO%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-buffer/</id>
    <published>2021-07-28T09:51:10.000Z</published>
    <updated>2021-07-28T09:55:15.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buffer-读写"><a href="#Buffer-读写" class="headerlink" title="Buffer 读写"></a>Buffer 读写</h1><h2 id="NIO之Buffer"><a href="#NIO之Buffer" class="headerlink" title="NIO之Buffer"></a>NIO之Buffer</h2><p>Buffer作为NIO三大核心组件之一，本质上是一块可以写入数据，以及从中读取数据的内存，实际上也是一个byte[]数据,只是在NIO中被封装成了NIO Buffer对象<br>并提供了一组方法来访问这个内存块。</p><h3 id="下面是一个简单的Demo"><a href="#下面是一个简单的Demo" class="headerlink" title="下面是一个简单的Demo"></a>下面是一个简单的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个text.txt文件，生成一个新的text1.txt文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNioDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">        FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">// 声明缓冲区大小为1024字节</span></span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 从通道中读取数据</span></span><br><span class="line">        inChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">// 读模式切换为写模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//把缓冲区的数据写到通道</span></span><br><span class="line">        outChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 数据写完之后清空全部缓冲区</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="comment">//关闭文件流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; 执行结果：生成/Users/gaolei/Desktop/text1.txt文件  </span><br><span class="line"></span><br><span class="line">**Buffer进行数据读写操作的一般步骤**  </span><br><span class="line"><span class="number">1</span>、写入数据到Buffer  </span><br><span class="line"><span class="number">2</span>、调用flip()方法  </span><br><span class="line"><span class="number">3</span>、从Buffer中读取数据  </span><br><span class="line"><span class="number">4</span>、调用clear()方法或者compact()方法  </span><br><span class="line"></span><br><span class="line">&gt; clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### Buffer三个核心的属性  </span><br><span class="line">- capacity 容量 与buffer处在什么模式无关</span><br><span class="line">- position 游标位置 指向下一个存放/读取数据的位置 范围（<span class="number">0</span> ～ capacity–<span class="number">1</span>）</span><br><span class="line">- limit </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 读写操作中Buffer三大属性的变化</span><br><span class="line">初始状态  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;    </span><br><span class="line">第一次读取数据  </span><br><span class="line">position处于起始位置，limit和capacity都处于结尾  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-41b47d9e54d58c7b39caf9e514fc9b5261f.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">第二次读取数据  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-07f3d1aa1f886b592b386cd4d846810911d.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">当写数据的时候，需要调用flip方法： </span><br><span class="line">当将Buffer从写模式切换到读模式，position会被重置为<span class="number">0.</span> 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。  </span><br><span class="line">当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）     </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-b9323701bbb34a6c12f61d5ac2652ab7eeb.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line">Clear方法  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://oscimg.oschina.net/oscnet/up-71f90dfd671f80eb9f6142f135b7c2dfc92.png&quot;</span>  height=<span class="string">&quot;230&quot;</span> width=<span class="string">&quot;395&quot;</span>&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JAVA NIO下的Buffer分类</span><br><span class="line">- ByteBuffer</span><br><span class="line">- MappedByteBuffer</span><br><span class="line">- CharBuffer</span><br><span class="line">- DoubleBuffer</span><br><span class="line">- FloatBuffer</span><br><span class="line">- IntBuffer</span><br><span class="line">- LongBuffer</span><br><span class="line">- ShortBuffer</span><br><span class="line">&gt; Java基本类型除了布尔类型，都有其对应的Buffer </span><br><span class="line"></span><br><span class="line">### ByteBuffer使用</span><br><span class="line">&gt; 下面以ByteBuffer为例子看一下Buffer如何使用</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 创建一个byteBuffer，设置容量为1024字节</span></span><br><span class="line">ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>1、如下代码，其实调用了new HeapByteBuffer(capacity, capacity)来创建一个buffer  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2、创建了buffer之后要往里面写数据，除了上面从channel中读取数据之外，还可以调用put方法,如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">byteBuffer.put(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>3、如果写将buffer中的数据写出去，必须先调用flap方法</p><blockquote><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p></blockquote><p>4、将数据写到通道中 inChannel.write(buf);</p><p>5、数据写出到通道之后，要将缓存清空，一般调用clear方法<br><strong>clear方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//position将被设回0</span></span><br><span class="line">       position = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//limit被设置成 capacity的值</span></span><br><span class="line">       limit = capacity;</span><br><span class="line">       mark = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。<br><strong>compact方法</strong><br>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//compact()方法将所有未读的数据拷贝到Buffer起始处。</span></span><br><span class="line">        System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">        <span class="comment">//position设到最后一个未读元素正后面</span></span><br><span class="line">        position(remaining());</span><br><span class="line">        <span class="comment">//limit属性设置成capacity</span></span><br><span class="line">        limit(capacity());</span><br><span class="line">        discardMark();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">现在Buffer准备好写数据了，但是不会覆盖未读的数据 </span><br></pre></td></tr></table></figure><h3 id="零拷贝原理"><a href="#零拷贝原理" class="headerlink" title="零拷贝原理"></a>零拷贝原理</h3><p>– 零拷贝，第一次接触零拷贝是在kafka的数据存储部分–<br>IO流程：<br><img src="https://oscimg.oschina.net/oscnet/up-f5a9accbd021cfe41414ca72391b3889049.png"  height="230" width="395"><br>内存映射缓冲区<br><img src="https://oscimg.oschina.net/oscnet/up-a7a80d3426d1497bcaa69f30789718db0ee.png"  height="230" width="395"><br>比普通IO操作文件快很多，甚至比channel还要快很多。<br>因为避免了很多系统调用（System.read System.write）。减少了内核缓冲区的数据拷贝到用户缓冲区。</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      FileChannel in = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">      FileChannel out = FileChannel.open(Paths.get(<span class="string">&quot;/Users/gaolei/Desktop/text1.txt&quot;</span>), StandardOpenOption.READ, StandardOpenOption.CREATE, StandardOpenOption.WRITE);</span><br><span class="line">      MappedByteBuffer inBuffer = in.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, in.size());</span><br><span class="line">      MappedByteBuffer outBuffer = out.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, in.size());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inBuffer.limit()];</span><br><span class="line">      inBuffer.get(bytes);</span><br><span class="line">      outBuffer.put(bytes);</span><br><span class="line">      in.close();</span><br><span class="line">      out.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://oscimg.oschina.net/oscnet/up-ec7269566091c2f389749849ad734972de6.png"><br>普通的网络IO拷贝流程<br>1、首先系统从磁盘上拷贝文件到内核空间缓冲区<br>2、然后在内核空间拷贝数据到用户空间<br>3、第三次，用户缓冲区再将数据拷贝到内核部分的socket缓冲<br>4、内核在将存储在socket缓冲区的数据拷贝并发送到网卡缓冲区<br>以上一个常规的网络IO经历了4次数据拷贝；  </p><p>设置缓冲区的意义在于提升性能，当用户空间仅仅需要一小部分数据的时候，操作系统会在磁盘上读取一块数据方法内核缓冲区，这个叫做局部性原理。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6209218a39ae427544247f1b3937b4043cc.png"><br>零拷贝减去了内核空间数据到用户空间数据的拷贝，从而提升IO性能。假设读取的文件很大，操作系统需要读取磁盘大量数据到内核空间，<br>这时候内核缓冲区的作用是很难体现的。因为如果用户空间需要少量数据的时候是可以直接在内核空间获取的（局部性原理）。正式因为有了零拷贝，<br>操作系统在磁盘读取数据之后，可以直接发送到网卡缓冲区，从而大大提升IO性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Buffer-读写&quot;&gt;&lt;a href=&quot;#Buffer-读写&quot; class=&quot;headerlink&quot; title=&quot;Buffer 读写&quot;&gt;&lt;/a&gt;Buffer 读写&lt;/h1&gt;&lt;h2 id=&quot;NIO之Buffer&quot;&gt;&lt;a href=&quot;#NIO之Buffer&quot; cla</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-NIO</title>
    <link href="http://example.com/wiki/Java-NIO/"/>
    <id>http://example.com/wiki/Java-NIO/</id>
    <published>2021-07-28T09:50:38.000Z</published>
    <updated>2021-07-28T09:55:00.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><blockquote><p>w Java NIO 对于Java BIO的优化</p></blockquote><h2 id="Java-非阻塞IO"><a href="#Java-非阻塞IO" class="headerlink" title="Java 非阻塞IO"></a>Java 非阻塞IO</h2><blockquote><p>及时不使用线程池，也可以处理多个客户端请求</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ServerSocketChannel ss = ServerSocketChannel.open();</span><br><span class="line">    ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">    ss.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        SocketChannel client = ss.accept();</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;client is null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">            System.err.println(<span class="string">&quot;client port &quot;</span> + port);</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 串型话</span></span><br><span class="line">        <span class="comment">// 真实场景下 每一个client一个独自的buffer</span></span><br><span class="line">        <span class="keyword">for</span> (SocketChannel c : clients) &#123;</span><br><span class="line">            <span class="comment">// -1 出现空轮训 </span></span><br><span class="line">            <span class="keyword">int</span> num = c.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">                byteBuffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                System.err.println(c.socket().getPort() + <span class="string">&quot; :   &quot;</span> + b);</span><br><span class="line">                <span class="comment">// 清空 循环下一次client在使用</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上可以实现，一个线程可以处理多个客户端链接，服务端非阻塞接收，接收之后，读取数据也是非阻塞的；</p></blockquote><blockquote><p>i NIO的非阻塞是操作系统内部实现的，底层调用了linux内核的accept函数</p></blockquote><blockquote><p>d Java的NIO有什么弊端</p></blockquote><ul><li>服务端还是会进行空转</li><li>不管有没有客户端连接建立，服务端都要不断执行accept方法</li><li>不管客户端连接有没有传输数据，都会执行一遍read操作</li></ul><blockquote><p>资源浪费问题</p></blockquote><p>还是会存在C10k的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class=&quot;headerlink&quot; title=&quot;Java NIO&quot;&gt;&lt;/a&gt;Java NIO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;w Java NIO 对于Java BIO的优化&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="IO" scheme="http://example.com/categories/Develop-Lan/Java/IO/"/>
    
    
  </entry>
  
</feed>
