<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-26T11:59:27.668Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文搞懂高并发性能指标：QPS、TPS、RT、吞吐量</title>
    <link href="http://example.com/wiki/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"/>
    <id>http://example.com/wiki/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/</id>
    <published>2021-08-26T11:41:56.000Z</published>
    <updated>2021-08-26T11:59:27.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><p>Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。</p><p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。</p><p>PV（page view）即页面浏览量，通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。网页浏览数是评价网站流量最常用的指标之一，简称为PV。</p><p>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 。</p><p>每天300w PV 的在单台机器上，这台机器需要多少QPS？</p><p><code>( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)。</code></p><p>一般需要达到139QPS，因为是峰值。(200万pv才有100峰值qps)</p><h2 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h2><p>TPS：Transactions Per Second（每秒传输的事务处理个数），即服务器每秒处理的事务数。</p><p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p><p>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p><h2 id="RT（响应时长）"><a href="#RT（响应时长）" class="headerlink" title="RT（响应时长）"></a>RT（响应时长）</h2><p>响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。</p><p>响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。</p><p>直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。</p><p>由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。</p><p>所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p><p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。</p><p>对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的</p><h2 id="Load（系统负载）"><a href="#Load（系统负载）" class="headerlink" title="Load（系统负载）"></a>Load（系统负载）</h2><p>Linux的Load(系统负载)，是一个让新手不太容易了解的概念。load的就是一定时间内计算机有多少个active_tasks，也就是说是计算机的任务执行队列的长度，cpu计算的队列。</p><p>top/uptime等工具默认会显示1分钟、5分钟、15分钟的平均Load。</p><p>具体来说，平均Load是指，在特定的一段时间内统计的正在CPU中运行的(R状态)、正在等待CPU运行的、处于不可中断睡眠的(D状态)的任务数量的平均值。</p><p>最后，说一下CPU使用率和Load的关系吧。如果主要是CPU密集型的程序在运行(If CPU utilization is near 100 percent (user + nice + system), the workload sampled is CPU-bound.)，</p><p>那么CPU利用率高，Load一般也会比较高。而I/O密集型的程序在运行，</p><p>可能看到CPU的%user, %system都不高，%iowait可能会有点高，这时的Load通常比较高。</p><p>同理，程序读写慢速I/O设备(如磁盘、NFS)比较多时，Load可能会比较高，而CPU利用率不一定高。这种情况，还经常发生在系统内存不足并开始使用swap的时候，Load一般会比较高，而CPU使用率并不高。</p><h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>页面访问次数：Page View</p><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p>访客数（去重复）：Unique Visitor</p><h2 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h2><p>并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。</p><p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。</p><ol><li>QPS（TPS）：（Query Per Second）每秒钟request/事务 数量</li><li>并发数： 系统同时处理的request/事务数</li><li>响应时间： 一般取平均响应时间</li></ol><p>理解了上面三个要素的意义之后，就能推算出它们之间的关系：</p><ul><li><strong>QPS（TPS）= 并发数/平均响应时间</strong></li><li><strong>并发数 = QPS*平均响应时间</strong></li></ul><h2 id="最佳线程数、QPS、RT"><a href="#最佳线程数、QPS、RT" class="headerlink" title="最佳线程数、QPS、RT"></a>最佳线程数、QPS、RT</h2><p><strong>1、单线程QPS公式：QPS=1000ms/RT</strong><br>对同一个系统而言，支持的线程数越多，QPS越高。假设一个RT是80ms,则可以很容易的计算出QPS,QPS = 1000/80 = 12.5<br>多线程场景，如果把服务端的线程数提升到2，那么整个系统的QPS则为 2*（1000/80） = 25, 可见QPS随着线程的增加而线性增长，那QPS上不去就加线程呗，听起来很有道理，公司也说的通，但是往往现实并非如此。</p><p><strong>2、最佳线程数量</strong><br>刚好消耗完服务器的瓶颈资源的临界线程数，公式如下<br>最佳线程数量=（（线程等待时间+线程cpu时间）/ 线程cpu时间）* cpu数量<br>特性：</p><ul><li>在达到最佳线程数的时候，线程数量继续递增，则QPS不变，而响应时间变长，持续递增线程数量，则QPS开始下降。</li><li>每个系统都有其最佳线程数量，但是不同状态下，最佳线程数量是会变化的。</li><li>瓶颈资源可以是CPU,可以是内存，可以是锁资源，IO资源：超过最佳线程数-导致资源的竞争，超过最佳线程数-响应时间递增。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;QPS&quot;&gt;&lt;a href=&quot;#QPS&quot; class=&quot;headerlink&quot; title=&quot;QPS&quot;&gt;&lt;/a&gt;QPS&lt;/h2&gt;&lt;p&gt;Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所</summary>
      
    
    
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="性能指标" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-基本架构及原理</title>
    <link href="http://example.com/wiki/MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-26T03:51:47.000Z</published>
    <updated>2021-08-26T03:53:20.235Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826115314566.png" alt="image-20210826115314566"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826115314566.png&quot; alt=&quot;image-20210826115314566&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>用了那么久MySQL，我竟然不知道ICP</title>
    <link href="http://example.com/wiki/MySQL-%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8ICP/"/>
    <id>http://example.com/wiki/MySQL-%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8ICP/</id>
    <published>2021-08-26T03:37:16.000Z</published>
    <updated>2021-08-26T10:34:17.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用了那么久MySQL，我竟然不知道ICP"><a href="#用了那么久MySQL，我竟然不知道ICP" class="headerlink" title="用了那么久MySQL，我竟然不知道ICP"></a>用了那么久MySQL，我竟然不知道ICP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开启ICP，如果部分WHERE条件能使用索引中的字段，MySQL Server 会把这部分下推到存储引擎层，存储引擎通过索引过滤，把满足的行从表中读取出。ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数。</p><p>ICP 优化的全称是 Index Condition Pushdown Optimization 。</p><p>ICP 优化适用于 MySQL 利用索引从表里检索数据的场景。</p><hr><p>经过学习了ICP之后我大概对ICP有了初步的理解 👇</p><h3 id="关闭ICP情况下的查询流程"><a href="#关闭ICP情况下的查询流程" class="headerlink" title="关闭ICP情况下的查询流程"></a>关闭ICP情况下的查询流程</h3><p>禁用ICP，存储引擎会通过遍历索引定位基表中的行，然后返回给MySQL Server层，再去为这些数据行进行WHERE后的条件的过滤。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826183031500.png" alt="image-20210826183031500"></p><h3 id="开启ICP之后的执行流程"><a href="#开启ICP之后的执行流程" class="headerlink" title="开启ICP之后的执行流程"></a>开启ICP之后的执行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826183050694.png" alt="image-20210826183050694"></p><p>一开始我对于 <strong>ICP只能使用于二级索引，而不能用于主键索引</strong>这一限制不太理解。那是因为我没有该明白ICP到底是干什么的？</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826171730637.png" alt="image-20210826171730637"></p><p>我们这边用一些别人的图方便理解。</p><p><strong>ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数。</strong></p><p>这是ICP的关键目的，为什么能减少引擎对于基表的访问呢？因为ICP在引擎层执行了额外的过滤和筛选，使得大量的无效数据查询基表。</p><p>因为是二级索引，需要根据主键id去获取到整行的数据。</p><hr><h2 id="ICP-原理"><a href="#ICP-原理" class="headerlink" title="ICP 原理"></a>ICP 原理</h2><p>以 InnoDB 表为例。</p><p>在不启用 ICP 的情况下利用二级索引查找数据的过程：</p><ol><li>用二级索引查找数据的主键；</li><li>用主键回表读取完整的行记录；</li><li>利用 where 语句的条件对行记录进行过滤。</li></ol><p>启用 ICP 的情况下利用二级索引查找数据的过程为：</p><ol><li>用二级索引查找数据的主键；</li><li>如果二级索引记录的元组里的列出现在 where 条件里，那么对元组进行过滤；</li><li>对索引元组的主键回表读取完整的行记录；</li><li>利用 where 语句的剩余条件对行记录进行过滤；</li></ol><p>ICP 适用的一个隐含前提是二级索引必须是组合索引、且在使用索引进行扫描时只能采用最左前缀匹配原则。组合索引后面的列出现在 where 条件里，因此可以先过滤索引元组、从而减少回表读的数量。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>对于组合索引 <code>INDEX (zipcode, lastname, firstname)</code>，下面的 SQL 根据最左前缀原则，只能使用到索引的第一列 <code>zipcode</code>，索引的另一列 <code>lastname</code> 出现在 where 条件里，可以采用 ICP 对索引的元组进行过滤，即应用 <code>lastname LIKE &#39;%etrunia%&#39;</code> 条件；然后再回表读取完成的行记录，再对行记录应用 <code>address LIKE &#39;%Main Street%&#39;</code> 条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people</span><br><span class="line"><span class="keyword">WHERE</span> zipcode<span class="operator">=</span><span class="string">&#x27;95054&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%etrunia%&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%Main Street%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="ICP使用限制"><a href="#ICP使用限制" class="headerlink" title="ICP使用限制"></a>ICP使用限制</h3><p>1 当sql需要全表访问时,ICP的优化策略可用于range, ref, eq_ref, ref_or_null 类型的访问数据方法 。</p><p>2 支持InnoDB和MyISAM表。</p><p>3 ICP只能用于二级索引，不能用于主索引。</p><p>4 并非全部where条件都可以用ICP筛选。<br>  如果where条件的字段不在索引列中,还是要读取整表的记录到server端做where过滤。</p><p>5 ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</p><p>6 5.6 版本的不支持分表的ICP 功能，5.7 版本的开始支持。</p><p>7 当sql 使用覆盖索引时，不支持ICP 优化方法。</p><h2 id="如何查看是否开启了ICP"><a href="#如何查看是否开启了ICP" class="headerlink" title="如何查看是否开启了ICP"></a>如何查看是否开启了ICP</h2><p><code>show variables like &#39;optimizer_switch&#39;;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index_merge<span class="operator">=</span><span class="keyword">on</span>,index_merge_union<span class="operator">=</span><span class="keyword">on</span>,index_merge_sort_union<span class="operator">=</span><span class="keyword">on</span>,index_merge_intersection<span class="operator">=</span><span class="keyword">on</span>,engine_condition_pushdown<span class="operator">=</span><span class="keyword">on</span>,index_condition_pushdown<span class="operator">=</span><span class="keyword">on</span>,mrr<span class="operator">=</span><span class="keyword">on</span>,mrr_cost_based<span class="operator">=</span><span class="keyword">on</span>,block_nested_loop<span class="operator">=</span><span class="keyword">on</span>,batched_key_access<span class="operator">=</span>off,materialization<span class="operator">=</span><span class="keyword">on</span>,semijoin<span class="operator">=</span><span class="keyword">on</span>,loosescan<span class="operator">=</span><span class="keyword">on</span>,firstmatch<span class="operator">=</span><span class="keyword">on</span>,duplicateweedout<span class="operator">=</span><span class="keyword">on</span>,subquery_materialization_cost_based<span class="operator">=</span><span class="keyword">on</span>,use_index_extensions<span class="operator">=</span><span class="keyword">on</span>,condition_fanout_filter<span class="operator">=</span><span class="keyword">on</span>,derived_merge<span class="operator">=</span><span class="keyword">on</span>,use_invisible_indexes<span class="operator">=</span>off,skip_scan<span class="operator">=</span><span class="keyword">on</span>,hash_join<span class="operator">=</span><span class="keyword">on</span>,subquery_to_derived<span class="operator">=</span>off,prefer_ordering_index<span class="operator">=</span><span class="keyword">on</span>,hypergraph_optimizer<span class="operator">=</span>off,derived_condition_pushdown<span class="operator">=</span><span class="keyword">on</span></span><br></pre></td></tr></table></figure><h2 id="什么是二级索引"><a href="#什么是二级索引" class="headerlink" title="什么是二级索引"></a>什么是二级索引</h2><h3 id="1、一级索引"><a href="#1、一级索引" class="headerlink" title="1、一级索引"></a>1、一级索引</h3><p>索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。</p><h3 id="2、二级索引"><a href="#2、二级索引" class="headerlink" title="2、二级索引"></a>2、二级索引</h3><p>二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg">https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg</a></p><p><a href="https://mp.weixin.qq.com/s/Vv1gNLh1aLCLDJfEYXvr-g">https://mp.weixin.qq.com/s/Vv1gNLh1aLCLDJfEYXvr-g</a></p><p><a href="https://blog.51cto.com/qhd2004/1870996?source=drt">https://blog.51cto.com/qhd2004/1870996?source=drt</a></p><p><a href="https://blog.csdn.net/thesprit/article/details/112989674">二级索引检索过程</a></p><p><a href="https://zhuanlan.zhihu.com/p/137647823">https://zhuanlan.zhihu.com/p/137647823</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用了那么久MySQL，我竟然不知道ICP&quot;&gt;&lt;a href=&quot;#用了那么久MySQL，我竟然不知道ICP&quot; class=&quot;headerlink&quot; title=&quot;用了那么久MySQL，我竟然不知道ICP&quot;&gt;&lt;/a&gt;用了那么久MySQL，我竟然不知道ICP&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-InnoDB架构</title>
    <link href="http://example.com/wiki/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E7%BA%A7%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E7%BA%A7%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-26T02:12:37.000Z</published>
    <updated>2021-08-26T10:51:05.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Innodb架构"><a href="#Innodb架构" class="headerlink" title="Innodb架构"></a>Innodb架构</h1><p>存储引擎是MySQL非常重要的组成部分，它直接影响了一个数据库的性能，是MySQL的绝对核心。</p><p>下面是InnoDB的结构图 👇</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826101756286.png" alt="image-20210826101756286"></p><p>从上面第二张图可以看到，InnoDB 主要分为两大块：</p><ul><li>InnoDB In-Memory Structures</li><li>InnoDB On-Disk Structures</li></ul><p>内存和磁盘，让我们先从内存开始。</p><h2 id="In-Memory-Structures内存模块"><a href="#In-Memory-Structures内存模块" class="headerlink" title="In-Memory Structures内存模块"></a>In-Memory Structures内存模块</h2><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>正如之前提到的，<font color=blue>MySQL 不会直接去修改磁盘的数据，因为这样做太慢了</font>，MySQL 会先改内存，然后记录 redo log，等有空了再刷磁盘，如果内存里没有数据，就去磁盘 load。</p><p>而这些数据存放的地方，就是 Buffer Pool。</p><p>我们平时开发时，会用 redis 来做缓存，缓解数据库压力，其实 MySQL 自己也做了一层类似缓存的东西。</p><p>MySQL 是以「页」（page）为单位从磁盘读取数据的，Buffer Pool 里的数据也是如此，实际上，Buffer Pool 是<code>a linked list of pages</code>，一个以页为元素的链表。</p><p>为什么是链表？因为和缓存一样，它也需要一套淘汰算法来管理数据。Buffer Pool 采用基于 LRU（least recently used） 的算法来管理内存。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826102246153.png" alt="image-20210826102246153"></p><p><strong>B+树中一个节点为一页或页的倍数最为合适</strong>。为什么呢？</p><p>因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。</p><p>如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。</p><p>所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。</p><ul><li><strong>各个数据页</strong>可以组成一个<strong>双向链表</strong></li><li>而<strong>每个数据页中的记录</strong>又可以组成一个<strong>单向</strong>链表</li><li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键</strong>查找某条记录的时候可以在页目录中使用<strong>二分法快速定位</strong>到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以<strong>其他列</strong>(非主键)作为搜索条件：只能从最小记录开始<strong>依次遍历单链表中的每条记录</strong>。</li></ul><p>所以说，如果我们写 select * from user where username=’小明’ 这样没有进行任何优化的sql语句，默认会这样做：</p><ul><li>定位到记录所在的页</li><li>需要遍历双向链表，找到所在的页</li><li>从所在的页内中查找相应的记录</li><li> 由于不是根据主键查询，只能遍历所在页的单链表了</li></ul><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a><strong>Change Buffer</strong></h3><p>change buffer存放在Buffer Pool中。</p><p>上面提到过，如果内存里没有对应「页」的数据，MySQL 就会去把数据从磁盘里 load 出来，如果每次需要的「页」都不同，或者不是相邻的「页」，那么每次 MySQL 都要去 load，这样就很慢了。</p><p>于是如果 MySQL 发现你要修改的页，不在内存里，就把你要对页的修改，先记到一个叫 Change Buffer 的地方，同时记录 redo log，然后再慢慢把数据 load 到内存，load 过来后，再把 Change Buffer 里记录的修改，应用到内存（Buffer Pool）中，这个动作叫做 <strong>merge</strong>；而把内存数据刷到磁盘的动作，叫 <strong>purge</strong>：</p><ul><li><strong>merge：Change Buffer -&gt; Buffer Pool</strong></li><li><strong>purge：Buffer Pool -&gt; Disk</strong></li></ul><h3 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a><strong>Adaptive Hash Index</strong></h3><p>MySQL 索引，不管是在磁盘里，还是被 load 到内存后，都是 B+ 树，B+ 树的查找次数取决于树的深度。你看，数据都已经放到内存了，还不能“一下子”就找到它，还要“几下子”，这空间牺牲的是不是不太值得？</p><p>尤其是那些频繁被访问的数据，每次过来都要走 B+ 树来查询，这时就会想到，我用一个指针把数据的位置记录下来不就好了？</p><p>这就是「自适应哈希索引」（Adaptive Hash Index）。自适应，顾名思义，MySQL 会自动评估使用自适应索引是否值得，如果观察到建立哈希索引可以提升速度，则建立。</p><h3 id="Redo-log-buffer"><a href="#Redo-log-buffer" class="headerlink" title="Redo log buffer"></a>Redo log buffer</h3><p>Redo log buffer里面存储了数据修改所产生的redo log。</p><h2 id="On-Disk-Structures-磁盘模块"><a href="#On-Disk-Structures-磁盘模块" class="headerlink" title="On-Disk Structures 磁盘模块"></a>On-Disk Structures 磁盘模块</h2><p>磁盘里有什么呢？除了表结构定义和索引，还有一些为了高性能和高可靠而设计的角色，比如 redo log、undo log、Change Buffer，以及 Doublewrite Buffer 等等.</p><h3 id="Tablespaces表空间"><a href="#Tablespaces表空间" class="headerlink" title="Tablespaces表空间"></a><strong>Tablespaces表空间</strong></h3><p>Tablespaces 分为五种：</p><ul><li>The System Tablespace</li><li>File-Per-Table Tablespaces</li><li>General Tablespace</li><li>Undo Tablespaces</li><li>Temporary Tablespaces</li></ul><p>其中，我们平时创建的表的数据，可以存放到 The System Tablespace 、File-Per-Table Tablespaces、General Tablespace 三者中的任意一个地方，具体取决于你的配置和创建表时的 sql 语句。</p><h3 id="Doublewrite-Buffer"><a href="#Doublewrite-Buffer" class="headerlink" title="Doublewrite Buffer"></a><strong>Doublewrite Buffer</strong></h3><p><strong>如果说 Change Buffer 是提升性能，那么 Doublewrite Buffer 就是保证数据页的可靠性。</strong></p><p>怎么理解呢？</p><p>前面提到过，MySQL 以「页」为读取和写入单位，一个「页」里面有多行数据，写入数据时，MySQL 会先写内存中的页，然后再刷新到磁盘中的页。</p><p>这时问题来了，假设在某一次从内存刷新到磁盘的过程中，一个「页」刷了一半，突然操作系统或者 MySQL 进程奔溃了，这时候，内存里的页数据被清除了，而磁盘里的页数据，刷了一半，处于一个中间状态，不尴不尬，可以说是一个「不完整」，甚至是「坏掉的」的页。</p><p>有同学说，不是有 Redo Log 么？其实这个时候 Redo Log 也已经无力回天，Redo Log 是要在磁盘中的页数据是正常的、没有损坏的情况下，才能把磁盘里页数据 load 到内存，然后应用 Redo Log。而如果磁盘中的页数据已经损坏，是无法应用 Redo Log 的。</p><p>所以，MySQL 在刷数据到磁盘之前，要先把数据写到另外一个地方，也就是 Doublewrite Buffer，写完后，再开始写磁盘。Doublewrite Buffer 可以理解为是一个备份（recovery），万一真的发生 crash，就可以利用 Doublewrite Buffer 来修复磁盘里的数据。</p><h3 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h3><p>对于主键顺序插入的数据，插入速度很快，因为数据页的存放是按照主键顺序存放的。但是对于非聚集的且不是唯一的索引，数据的插入不是连续的，所以需要离散的访问非聚集索引页，随机读取的存在会导致插入操作性能下降。</p><p>MySQL 的插入缓冲，在非聚集索引的插入或更新时，不直接插入到索引页，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；如果不在，不会去读数据，而是先放入到一个insert buffer对象中，然后再以一定的频率和情况进行 insert buffer 和 辅助索引页子节点合并操作，这是通常能将多个插入合并到一个操作中，这就大大提高了对于非聚集索引插入的性能。</p><h3 id="使用Insert-Buffer的场景"><a href="#使用Insert-Buffer的场景" class="headerlink" title="使用Insert Buffer的场景"></a>使用Insert Buffer的场景</h3><p>1、索引是辅助索引</p><p>2、索引不是唯一的</p><p>因为在插入时，数据库并不去查找插入记录的唯一性，否则就需要离散的读取数据，这使 insert buffer 失去了意义。</p><h3 id="风险点"><a href="#风险点" class="headerlink" title="风险点"></a>风险点</h3><p>如果数据库宕机时还有大量的缓存没合并到实际的索引中去，恢复这些数据可能需要很长的时间</p><h3 id="flush-neighbor-page"><a href="#flush-neighbor-page" class="headerlink" title="flush neighbor page"></a>flush neighbor page</h3><p>当刷新一个脏页时，Innodb存储引擎会 检测该页所在区的所有页，如果是脏页，那么一起进行刷新</p><h2 id="innodb-fast-shutdown参数"><a href="#innodb-fast-shutdown参数" class="headerlink" title="innodb_fast_shutdown参数"></a>innodb_fast_shutdown参数</h2><p>innodb_fast_shutdown参数有三个值 如下👇</p><p>0 表示mysql数据库关闭时，innodb需要完成所有的full purge 和 merge insert buffer，并将所有的脏页刷新会磁盘。耗时长</p><p>1 默认值，表示不需要完成 full purge 和 merge insert buffer 操作，但是在缓冲池中的一些数据还是会刷新会磁盘。</p><p>2 表示不完成 full purge 和 merge insert buffer 操作，也不刷新脏页，而是将日志都写入日志。这样不会有任何的事务丢失，但是下次数据库启动时，需要进行恢复操作</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>InnoDB 是多线程模型，不同的后台线程处理不同的任务。</p><h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><p>核心线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、Undo页的回收。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210826112203051.png" alt="image-20210826112203051"></p><h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p>InnoDB 使用AIO处理IO请求，提高数据库性能，IO Thread负责这些请求的回调。</p><p>IO Thread 包括write/read/insert buffer/log io thread</p><h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p>事务被提交后，其使用的undolog可能不再需要，需要 purge thread来回收已经使用并分配的undo页</p><h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p>减轻原Master Thrad 的工作及对于用户查询线程的阻塞，进一步提供InnoDB存储引擎的性能</p><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><h3 id="什么是checkpoint"><a href="#什么是checkpoint" class="headerlink" title="什么是checkpoint"></a>什么是checkpoint</h3><p>页面操作先在内存缓冲区，再刷新到磁盘，如果刷新磁盘时发生的宕机，那么数据将丢失。为了解决这个文件，当前事务数据库普遍使用 write ahead log策略，即事务提交时，先写重做日志，再修改页。这样即使宕机，也可以通过重做日志来完成数据的恢复。但是重做日志没有redis的redo功能，对于运行时间较长或者提交较大的重做日志恢复是非常耗时的，所以需要 CheckPoint 解决</p><h3 id="Checkpoint-解决的问题"><a href="#Checkpoint-解决的问题" class="headerlink" title="Checkpoint 解决的问题"></a>Checkpoint 解决的问题</h3><p>1、缓冲池不够用时 ，将脏页刷新到磁盘</p><p>2、重做日志不可用时，刷新脏页</p><p>3、数据库只需要到checkpoint后的日志进行恢复，缩短数据库的恢复时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Innodb架构&quot;&gt;&lt;a href=&quot;#Innodb架构&quot; class=&quot;headerlink&quot; title=&quot;Innodb架构&quot;&gt;&lt;/a&gt;Innodb架构&lt;/h1&gt;&lt;p&gt;存储引擎是MySQL非常重要的组成部分，它直接影响了一个数据库的性能，是MySQL的绝对核心</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-索引</title>
    <link href="http://example.com/wiki/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/wiki/MySQL-%E7%B4%A2%E5%BC%95/</id>
    <published>2021-08-25T06:48:18.000Z</published>
    <updated>2021-08-26T11:19:01.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中支持的索引"><a href="#MySQL中支持的索引" class="headerlink" title="MySQL中支持的索引"></a>MySQL中支持的索引</h1><p>之前问过存储引擎是数据库层面的还是数据表层面的？</p><p>那么现在也同样问一个问题，索引是存储引擎层面的还是服务器层面实现的？答案是存储引擎层面的。 </p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p><p>我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><p>1、可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。</p><p>2、通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</p><p>3、被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</p><h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><p>1、索引会占据磁盘空间</p><p>2、索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。</p><p><font color=blue>一个表最多可以创建多少个索引？</font> 16个</p><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>索引列中的值必须是唯一的，不允许有空值。InnoDB下强烈推荐使用数值类型的自增主键。这个和b+数的排序有关。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列中的值必须是唯一的，但是允许为空值。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。</p><h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><p>MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><p>在MyISAM存储引擎中，主键索引上存储的是数据在磁盘上的地址。</p><p>在InnoDB存储引擎中，主键索引上存储的就是整行数据。</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>在MyISAM存储引擎中，辅助索引其实和主键索引一样，也是存储的数据的磁盘地址。区别在主键索引的键值必须唯一，而辅助索引的键值可以重复。</p><p>在InnoDB存储引擎中，辅助索引存储的是数据的主键。查到主键之后，在根据主键值查找主键索引上存储的数据。</p><p>这会发生一种现象叫<strong>回表</strong>，会增加性能消耗，解决这种问题的方法就是 <strong>覆盖索引</strong>，也就是把要查询的字段也添加到索引中。</p><h3 id="跳跃索引"><a href="#跳跃索引" class="headerlink" title="跳跃索引"></a>跳跃索引</h3><p>一般情况下，如果表users有复合索引idx_status_create_time，我们都知道，单独用create_time去查询，MySQL优化器是不走索引，所以还需要再创建一个单列索引idx_create_time。用过Oracle的同学都知道，是可以走索引跳跃扫描（Index Skip Scan），在MySQL 8.0也实现Oracle类似的索引跳跃扫描，在优化器选项也可以看到skip_scan=on。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span> optimizer_switch             <span class="operator">|</span>use_invisible_indexes<span class="operator">=</span>off,skip_scan<span class="operator">=</span><span class="keyword">on</span>,hash_join<span class="operator">=</span><span class="keyword">on</span> <span class="operator">|</span></span><br></pre></td></tr></table></figure><p><strong>适合复合索引前导列唯一值少，后导列唯一值多的情况，如果前导列唯一值变多了，则MySQL CBO不会选择索引跳跃扫描，取决于索引列的数据分表情况。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id, user_id，status, phone <span class="keyword">from</span> users <span class="keyword">where</span> create_time <span class="operator">&gt;=</span><span class="string">&#x27;2021-01-02 23:01:00&#x27;</span> <span class="keyword">and</span> create_time <span class="operator">&lt;=</span> <span class="string">&#x27;2021-01-03 23:01:00&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> users <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> idx_status_create_time          <span class="operator">|</span> idx_status_create_time <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">15636</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="keyword">for</span> <span class="keyword">skip</span> scan<span class="operator">|</span></span><br></pre></td></tr></table></figure><p>也可以通过 <code>optimizer_switch=&#39;skip_scan=off&#39;</code>来关闭索引跳跃扫描特性。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h2><p>B树有什么特点呢？</p><p>1、所有的键值分布在整棵树上面</p><p>2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能接近于二分查找</p><p>3、每个节点最多拥有m个子树，根节点至少有2个子树，分支节点至少拥有m / 2个子树（除根节点和叶子节点都是分支节点）</p><p>4、所有叶子节点都在同一层，每个节点最多可以有m - 1个key，并且按照升序排序</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825145448549.png" alt="image-20210825145448549"></p><p>B Tree 指的是 Balance Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><h3 id="图例说明"><a href="#图例说明" class="headerlink" title="图例说明"></a>图例说明</h3><p>1、每个节点占据一个磁盘块，一个节点上有两个升序排序的关键字K和三个指向子树节点的指针P，指针P存储子节点所在的磁盘块的地址。</p><p>2、两个关键字K划分三个范围域对应三个指针指向子树的数据范围</p><h3 id="查找关键字的过程"><a href="#查找关键字的过程" class="headerlink" title="查找关键字的过程"></a>查找关键字的过程</h3><p>1、根据根节点查找磁盘块1，读入到内存（第一次磁盘IO）</p><p>2、比较关键字K22在（K25，K50）区间，找到磁盘块1的P2指针</p><p>3、根据磁盘块1的P2指针找到磁盘块3，读到内存（第二次磁盘IO）</p><p>4、继续比较K32,锁定在K30,K38之间，找到磁盘3的P2指针</p><p>5、根据磁盘块2的P2指针锁定磁盘块8，读到内存（第三次磁盘IO）</p><p>6、在磁盘块8的关键字列表中找到关键字K32</p><h3 id="B树的缺点"><a href="#B树的缺点" class="headerlink" title="B树的缺点"></a>B树的缺点</h3><p>1、每个节点都存储key和数据，而数据一般又会占用相对较多的空间，这样导致每个节点锁存储的关键字数量较少，最终导致树的高度比较高</p><p>2、当数据量较大的时候，由于树的高度比较深，造成查询的性能极差</p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p><strong>思考一下问题🤔</strong></p><p>为什么MySQL使用B+Tree这种数据结构来作为索引结构呢？</p><p>为什么不使用二叉树呢？为什么不使用B Tree呢？</p><h3 id="B-树的特点"><a href="#B-树的特点" class="headerlink" title="B+树的特点"></a>B+树的特点</h3><p><strong>B+ Tree 是 B 树的一种变形，它是基于 B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。</strong></p><p>1、B+ 树有两种类型的节点：内部节点（也称索引节点）和叶子节点，内部节点就是非叶子节点，内部节点不存储数据，只存储索引，相对于B树，每个节点可以存储更多的节点。这样可以大大降低树的高度，同时把数据范围数据都存在叶子节点。</p><p>2、内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。</p><p>3、叶子节点两两指针互相链接（符合磁盘的预读特性），顺序查询性能更高。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825150633224.png" alt="image-20210825150633224"></p><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><ul><li>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li><li>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</li><li>可以指定多个列作为索引列，多个索引列共同组成键。</li><li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li></ul><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h2 id="全文索引-1"><a href="#全文索引-1" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h2><p>1、索引不支持表达式</p><p>2、在需要使用多个字段作为查询条件的时候，可以使用多列索引，注意最左匹配原则</p><p>3、索引列的顺序要注意，区分度大的列写在索引的前面，效率会比较高</p><p>4、前缀索引，对于Blog，Text之类的大字段，必须使用前缀索引，只索引开始的部分字符，前缀长度的选取需要根据索引选择性来确定。</p><p>5、覆盖索引，查询的字段尽量保存在索引，避免回表。</p><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><p><strong>为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效？</strong></p><p>如果一个表比较小，那么显然直接遍历表比走索引要快（因为需要回表）。</p><p>⚠️注：首先，要注意这个答案隐含的条件是查询的数据不是索引的构成部分，否也不需要回表操作。其次，查询条件也不是主键，否则可以直接从聚簇索引中拿到数据。</p><p><a href="https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg">https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL中支持的索引&quot;&gt;&lt;a href=&quot;#MySQL中支持的索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL中支持的索引&quot;&gt;&lt;/a&gt;MySQL中支持的索引&lt;/h1&gt;&lt;p&gt;之前问过存储引擎是数据库层面的还是数据表层面的？&lt;/p&gt;
&lt;p&gt;那么</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-存储引擎</title>
    <link href="http://example.com/wiki/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/wiki/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-08-25T06:19:10.000Z</published>
    <updated>2021-08-25T06:47:19.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>MySQL支持很多种存储引擎 👇</strong></p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825143434715.png" style="zoom:50%;" /><p><font color=blue> <strong>有一个面试题：存储引擎是数据库级别的还是数据表级别的？</strong></font></p><p>看上图应该就知道了吧！ <strong>数据表</strong>级别的</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。</p><p>InnoDB 采用 <strong>MVCC 来支持高并发</strong>，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。</p><p>主索引是<strong>聚簇索引</strong>，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。</p><p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的<strong>可预测性读</strong>（局部性原理），能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><p>InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。</p><p>支持行级锁，间隙锁。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括<strong>压缩表、空间数据索引</strong>等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="InnoDB-和-MyISAM-的比较"><a href="#InnoDB-和-MyISAM-的比较" class="headerlink" title="InnoDB 和 MyISAM 的比较"></a>InnoDB 和 MyISAM 的比较</h3><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>索引：InnoDB支持聚簇索引，MyISAM支持非聚簇索引</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825144111190.png" alt="image-20210825144111190"></p><p>由上图可以看出，InnoDB的叶子节点存储的是数据，而MyISAM的叶子节点存放的是数据所在的地址。</p><p>InnoDB是通过B+树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，则会选择一个唯一键，如果也没有唯一键，则会自动生成一个6位数的row_id作为主键</p><p>如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，通过主键索引找到对应的记录，此过程称之为回表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MySQL支持很多种存储引擎 👇&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.j</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL系列合集</title>
    <link href="http://example.com/wiki/MySQL%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/wiki/MySQL%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/</id>
    <published>2021-08-25T06:18:51.000Z</published>
    <updated>2021-08-26T12:07:35.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术目录"><a href="#技术目录" class="headerlink" title="技术目录"></a>技术目录</h3><p>MySQL基础知识</p><p>MySQL系统架构</p><p>QueryCache是什么，为什么MySQL8废弃了？</p><p>MySQL支持的存储引擎（InnoDB&amp;MyISAM）</p><p>InnoDB底层结构以及原理</p><p>MySQL事务级别以及实现原理</p><p>MySQL性能调优</p><p>MySQL支持的索引</p><p>MySQL中的各种锁你都知道吗</p><p>为什么有MVCC，解决了什么问题</p><p>数据库主从原理以及实现</p><p>分库分表原理以及实战</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/AobingJava/JavaFamily">https://github.com/AobingJava/JavaFamily</a></p><h3 id="优美结构图"><a href="#优美结构图" class="headerlink" title="优美结构图"></a>优美结构图</h3><p><a href="https://www.processon.com/mindmap/6127055f6376896024deffae">https://www.processon.com/mindmap/6127055f6376896024deffae</a></p><p><a href="https://www.processon.com/view/5e4a00f7e4b0369b9163d2c8?fromnew=1">https://www.processon.com/view/5e4a00f7e4b0369b9163d2c8?fromnew=1</a></p><p><a href="https://www.processon.com/view/60af54f21e08531e9c899e74?fromnew=1">https://www.processon.com/view/60af54f21e08531e9c899e74?fromnew=1</a></p><p><a href="https://www.processon.com/view/60c167ac0e3e7468f4c4de93?fromnew=1">https://www.processon.com/view/60c167ac0e3e7468f4c4de93?fromnew=1</a></p><p><a href="https://www.processon.com/view/609bd4041e08533e429e6a42?fromnew=1">https://www.processon.com/view/609bd4041e08533e429e6a42?fromnew=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;技术目录&quot;&gt;&lt;a href=&quot;#技术目录&quot; class=&quot;headerlink&quot; title=&quot;技术目录&quot;&gt;&lt;/a&gt;技术目录&lt;/h3&gt;&lt;p&gt;MySQL基础知识&lt;/p&gt;
&lt;p&gt;MySQL系统架构&lt;/p&gt;
&lt;p&gt;QueryCache是什么，为什么MySQL8废弃了？&lt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Key过期监听器</title>
    <link href="http://example.com/wiki/Redis-Key%E8%BF%87%E6%9C%9F%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://example.com/wiki/Redis-Key%E8%BF%87%E6%9C%9F%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2021-08-25T03:40:30.000Z</published>
    <updated>2021-08-25T04:10:01.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一个需求，我在某平台发布了一片文章，需要判断这片文章在发布之后，10min，30min，1h，3h，1d，3d时间点的点赞数量和关注数量，但是呢，平台没有提供信息统计的功能，那么只能我定期去查看。</p><p>那么如何实现这个功能或者需求呢？</p><p>当时首先想到的是定时任务轮训，这种方式其实比较简单，就是搂数据库，判断时间就完事了，同时记录这片文章定时任务执行了多少次，超过一定次数之后，设置标志位，那么下次就不需要筛选这些文章了。</p><p>但是这种方式的缺点很明显，首先定时任务执行的频率改如何设置呢，应该是最小时间10min。也就是每10min搂一次库，查出来的数据，再去执行业务逻辑。当数据量很大的时候，这个定时任务就会显得比较重了。</p><p>于是我想到了基于事件触发的方式去解决这个问题，比如延时队列，redis过期策略啊等等，应该有很多。</p><p>这里说到延时队列，为什么我没有用JDK自带的DelayQueue呢，毕竟这些数据都是放在内存中，还是解决不了内存的问题。</p><p>还有通过redis的sort set数据结果来做的方式，score存的是时间戳，这种方式其实要比直接搂数据库要好的多。</p><p>最后我选择使用redis过期监听策略来实现这个需求，各位大佬们有什么别的方案呢？</p><h2 id="redis过期监听"><a href="#redis过期监听" class="headerlink" title="redis过期监听"></a>redis过期监听</h2><h3 id="首先设置一下redis的通知事件"><a href="#首先设置一下redis的通知事件" class="headerlink" title="首先设置一下redis的通知事件"></a>首先设置一下redis的通知事件</h3><p>需要设置redis配置文件 <code>notify-keyspace-events Ex</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For instance <span class="keyword">if</span> keyspace events notification is enabled, and a client</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> performs a DEL operation on key <span class="string">&quot;foo&quot;</span> stored <span class="keyword">in</span> the Database 0, two</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  $     String commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l     List commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s     Set commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  h     Hash commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  z     Sorted <span class="built_in">set</span> commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  e     Evicted events (events generated when a key is evicted <span class="keyword">for</span> maxmemory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  t     Stream commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d     Module key <span class="built_in">type</span> events</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  m     Key-miss events (Note: It is not included <span class="keyword">in</span> the <span class="string">&#x27;A&#x27;</span> class)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  A     Alias <span class="keyword">for</span> g<span class="variable">$lshzxetd</span>, so that the <span class="string">&quot;AKE&quot;</span> string means all the events</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        (Except key-miss events <span class="built_in">which</span> are excluded from <span class="string">&#x27;A&#x27;</span> due to their</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         unique nature).</span></span><br></pre></td></tr></table></figure><p>或者使用命令 <code>CONFIG set notify-keyspace-events Ex</code></p><h3 id="Springboot-集成redis"><a href="#Springboot-集成redis" class="headerlink" title="Springboot 集成redis"></a>Springboot 集成redis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">RedisTemplate&lt;String, T&gt; <span class="title">getRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, T&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate stringRedisTemplate = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        stringRedisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisScript&lt;Boolean&gt; <span class="title">hitMaxScript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Boolean&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;scripts/hitmax.lua&quot;</span>)));</span><br><span class="line">        redisScript.setResultType(Boolean.class);</span><br><span class="line">        <span class="keyword">return</span> redisScript;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        container.setTaskExecutor(executor());</span><br><span class="line">        Topic topic = <span class="keyword">new</span> PatternTopic(RedisKeyExpirationListener.LISTENER_PATTERN);</span><br><span class="line">        container.addMessageListener(<span class="keyword">new</span> RedisKeyExpirationListener(), topic);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;V-Thread&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义监听器重写onMessage方法"><a href="#自定义监听器重写onMessage方法" class="headerlink" title="自定义监听器重写onMessage方法"></a>自定义监听器重写onMessage方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LISTENER_PATTERN = <span class="string">&quot;__key*@*__:*&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;触发监听器。。。。。。&quot;</span>);</span><br><span class="line">        String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        String channel = <span class="keyword">new</span> String(message.getChannel());</span><br><span class="line">        System.out.println(<span class="string">&quot;onMessage &gt;&gt; &quot;</span>+String.format(<span class="string">&quot;channel: %s, body: %s, bytes: %s&quot;</span>,channel,body,<span class="keyword">new</span> String(pattern)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825120806260.png" alt="image-20210825120806260"></p><p><strong>项目控制台：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825120841859.png" alt="image-20210825120841859"></p><p>⚠️ 监听key过期时间是不能获取key的value的，因为这个时间是key过期才触发的，所以我们把关键信息放到key上就行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有一个需求，我在某平台发布了一片文章，需要判断这片文章在发布之后，10min，30min，1h，3h，1d，3d时间点的点赞数量和关注数量，</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Web开发基础-Servlet</title>
    <link href="http://example.com/wiki/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-Servlet/"/>
    <id>http://example.com/wiki/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-Servlet/</id>
    <published>2021-08-24T08:00:44.000Z</published>
    <updated>2021-08-24T10:00:32.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是servlet"><a href="#1、什么是servlet" class="headerlink" title="1、什么是servlet"></a>1、什么是servlet</h2><p><strong>什么是Serlvet？</strong></p><p>Servlet其实就是一个<strong>遵循Servlet开发的java类</strong>。Serlvet是<strong>由服务器调用的</strong>，<strong>运行在服务器端</strong>。</p><p>我们编写java程序想要在网上实现 聊天、发帖、这样一些的交互功能，<strong>普通的java技术是非常难完成的</strong>。sun公司就提供了Serlvet这种技术供我们使用。</p><h2 id="2、servlet生命周期"><a href="#2、servlet生命周期" class="headerlink" title="2、servlet生命周期"></a>2、servlet生命周期</h2><p><strong>Servlet生命周期可分为5个步骤</strong></p><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。 destroy()只有在Tomcat关闭的时候才会被调用。</strong></li></ul><h2 id="3、servlet调用流程"><a href="#3、servlet调用流程" class="headerlink" title="3、servlet调用流程"></a>3、servlet调用流程</h2><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210824161820602.png" alt="image-20210824161820602"></p><h2 id="4、Servlet是单例的"><a href="#4、Servlet是单例的" class="headerlink" title="4、Servlet是单例的"></a>4、Servlet是单例的</h2><h3 id="4-1-为什么Servlet是单例的"><a href="#4-1-为什么Servlet是单例的" class="headerlink" title="4.1 为什么Servlet是单例的"></a>4.1 为什么Servlet是单例的</h3><p><strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会<strong>驻留在内存中，为后续的请求做服务，直到服务器关闭</strong>。</p><h3 id="4-2-每次访问请求对象和响应对象都是新的"><a href="#4-2-每次访问请求对象和响应对象都是新的" class="headerlink" title="4.2 每次访问请求对象和响应对象都是新的"></a>4.2 每次访问请求对象和响应对象都是新的</h3><p>对于<strong>每次访问请求</strong>，Servlet引擎都会<strong>创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两<strong>个对象作为参数传递给它调用的Servlet的service()方法</strong>，<strong>service方法再根据请求方式分别调用doXXX方法</strong>。</p><h3 id="4-3-线程安全问题"><a href="#4-3-线程安全问题" class="headerlink" title="4.3 线程安全问题"></a>4.3 线程安全问题</h3><p>当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p><p>原则：</p><ol><li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li><li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</li></ol><h2 id="5、ServletConfig对象"><a href="#5、ServletConfig对象" class="headerlink" title="5、ServletConfig对象"></a>5、ServletConfig对象</h2><h3 id="5-1-ServletConfig对象有什么用？"><a href="#5-1-ServletConfig对象有什么用？" class="headerlink" title="5.1 ServletConfig对象有什么用？"></a>5.1 ServletConfig对象有什么用？</h3><blockquote><p>通过此对象可以读取web.xml中配置的初始化参数。</p></blockquote><p>现在问题来了，<strong>为什么我们要把参数信息放到web.xml文件中呢</strong>？我们可以直接在程序中都可以定义参数信息，<strong>搞到web.xml文件中又有什么好处呢</strong>？</p><p>好处就是：<strong>能够让你的程序更加灵活</strong>【更换需求，更改配置文件web.xml即可，程序代码不用改】</p><h3 id="5-2-获取web-xml文件配置的参数信息"><a href="#5-2-获取web-xml文件配置的参数信息" class="headerlink" title="5.2 获取web.xml文件配置的参数信息"></a>5.2 获取web.xml文件配置的参数信息</h3><p>为Demo1这个Servlet配置一个参数，参数名是name，值是zhongfucheng</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>zhongfucheng.web.Demo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>zhongfucheng<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Servlet中获取ServletConfig对象，通过ServletConfig对象获取在web.xml文件配置的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletConfig config = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">String name = config.getInitParameter(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="6、ServletContext对象"><a href="#6、ServletContext对象" class="headerlink" title="6、ServletContext对象"></a>6、ServletContext对象</h2><h3 id="6-1-什么是ServletContext对象？"><a href="#6-1-什么是ServletContext对象？" class="headerlink" title="6.1 什么是ServletContext对象？"></a>6.1 什么是ServletContext对象？</h3><p>当Tomcat启动的时候，就会创建一个ServletContext对象。它<strong>代表着当前web站点</strong></p><h3 id="6-2-ServletContext有什么用？"><a href="#6-2-ServletContext有什么用？" class="headerlink" title="6.2 ServletContext有什么用？"></a>6.2 ServletContext有什么用？</h3><ol><li>ServletContext既然代表着当前web站点，那么<strong>所有Servlet都共享着一个ServletContext对象</strong>，所以<strong>Servlet之间可以通过ServletContext实现通讯</strong>。</li><li>ServletConfig获取的是配置的是单个Servlet的参数信息，<strong>ServletContext可以获取的是配置整个web站点的参数信息</strong></li><li><strong>利用ServletContext读取web站点的资源文件</strong></li><li>实现Servlet的转发【用ServletContext转发不多，主要用request转发】</li></ol><h2 id="7、什么是会话技术"><a href="#7、什么是会话技术" class="headerlink" title="7、什么是会话技术"></a>7、什么是会话技术</h2><blockquote><p>基本概念: 指用户开一个浏览器，<strong>访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话</strong>.</p></blockquote><h3 id="7-1-什么是Cookie"><a href="#7-1-什么是Cookie" class="headerlink" title="7.1 什么是Cookie"></a>7.1 什么是Cookie</h3><blockquote><p>Cookie是由W3C组织提出，最早由netscape社区发展的一种机制</p></blockquote><ul><li>网页之间的<strong>交互是通过HTTP协议传输数据的，</strong>而Http协议是<strong>无状态的协议</strong>。无状态的协议是什么意思呢？<strong>一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接</strong>。</li><li>服务器无法确认用户的信息，于是乎，W3C就提出了：<strong>给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息</strong>。通行证就是Cookie</li></ul><h4 id="7-11-Cookie的流程"><a href="#7-11-Cookie的流程" class="headerlink" title="7.11 Cookie的流程"></a>7.11 Cookie的流程</h4><p>浏览器访问服务器，<strong>如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器</strong>。</p><h4 id="7-1-2-Cookie-API"><a href="#7-1-2-Cookie-API" class="headerlink" title="7.1.2 Cookie API"></a>7.1.2 Cookie API</h4><ul><li>Cookie类用于创建一个Cookie对象</li><li>response接口中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段</li><li>request接口中定义了一个getCookies方法，它用于获取客户端提交的Cookie</li></ul><p><strong>常用的Cookie方法：</strong></p><ul><li>public Cookie(String name,String value)</li><li>setValue与getValue方法</li><li>setMaxAge与getMaxAge方法</li><li>setPath与getPath方法</li><li>setDomain与getDomain方法</li><li>getName方法</li></ul><h4 id="7-1-3-cookie使用方式"><a href="#7-1-3-cookie使用方式" class="headerlink" title="7.1.3 cookie使用方式"></a>7.1.3 cookie使用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhongfucheng&quot;</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;我已经向浏览器发送了一个Cookie&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-1-4-Cookie不可跨域名性"><a href="#7-1-4-Cookie不可跨域名性" class="headerlink" title="7.1.4 Cookie不可跨域名性"></a>7.1.4 Cookie不可跨域名性</h4><ul><li>很多人在初学的时候可能有一个疑问：在访问Servlet的时候浏览器<strong>是不是把所有的Cookie都带过去给服务器</strong>，<strong>会不会修改了别的网站的Cookie</strong></li><li>答案是否定的。Cookie具有不可跨域名性。浏览器判断<strong>一个网站是否能操作另一个网站的Cookie的依据是域名</strong>。所以一般来说，<strong>当我访问baidu的时候，浏览器只会把baidu颁发的Cookie带过去，而不会带上google的Cookie。</strong></li></ul><h4 id="7-1-5-Cookie的有效期"><a href="#7-1-5-Cookie的有效期" class="headerlink" title="7.1.5 Cookie的有效期"></a>7.1.5 Cookie的有效期</h4><p><strong>Cookie的有效期是通过setMaxAge()来设置的</strong>。</p><ul><li>如果MaxAge为<strong>正数</strong>，<strong>浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆网站时该Cookie就有效</strong>【不论关闭了浏览器还是电脑】</li><li>如果MaxAge为<strong>负数</strong>，<strong>Cookie是临时性的，仅在本浏览器内有效</strong>，关闭浏览器Cookie就失效了，Cookie不会写到硬盘中。Cookie默认值就是-1。这也就为什么在我第一个例子中，如果我没设置Cookie的有效期，在硬盘中就找不到对应的文件。</li><li>如果MaxAge为<strong>0</strong>，则表示<strong>删除该Cookie</strong>。Cookie机制没有提供删除Cookie对应的方法，把MaxAge设置为0等同于删除Cookie</li></ul><h4 id="7-1-6-Cookie的域名"><a href="#7-1-6-Cookie的域名" class="headerlink" title="7.1.6 Cookie的域名"></a>7.1.6 Cookie的域名</h4><p>Cookie的<strong>domain属性决定运行访问Cookie的域名。domain的值规定为“.域名”</strong></p><p>Cookie的隐私安全机制决定Cookie是不可跨域名的。也就是说<a href="http://www.baidu.com和www.google.com之间的cookie是互不交接的.**即使是同一级域名,不同二级域名也不能交接**./">www.baidu.com和www.google.com之间的Cookie是互不交接的。**即使是同一级域名，不同二级域名也不能交接**。</a></p><h3 id="7-2-什么是Session"><a href="#7-2-什么是Session" class="headerlink" title="7.2 什么是Session"></a>7.2 什么是Session</h3><p>Session 是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是Session。</p><h4 id="7-2-1-为什么要使用Session技术？"><a href="#7-2-1-为什么要使用Session技术？" class="headerlink" title="7.2.1 为什么要使用Session技术？"></a>7.2.1 为什么要使用Session技术？</h4><p><strong>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，Cookie只能存储字符串。】。</strong></p><h4 id="7-2-2-Session-API"><a href="#7-2-2-Session-API" class="headerlink" title="7.2.2 Session API"></a>7.2.2 Session API</h4><ul><li>long getCreationTime();【获取Session被创建时间】</li><li><strong>String getId();【获取Session的id】</strong></li><li>long getLastAccessedTime();【返回Session最后活跃的时间】</li><li>ServletContext getServletContext();【获取ServletContext对象】</li><li><strong>void setMaxInactiveInterval(int var1);【设置Session超时时间】</strong></li><li><strong>int getMaxInactiveInterval();【获取Session超时时间】</strong></li><li><strong>Object getAttribute(String var1);【获取Session属性</strong>】</li><li>Enumeration getAttributeNames();【获取Session所有的属性名】</li><li><strong>void setAttribute(String var1, Object var2);【设置Session属性】</strong></li><li><strong>void removeAttribute(String var1);【移除Session属性】</strong></li><li><strong>void invalidate();【销毁该Session】</strong></li><li>boolean isNew();【该Session是否为新的】</li></ul><h4 id="7-2-3-session作为域对象"><a href="#7-2-3-session作为域对象" class="headerlink" title="7.2.3 session作为域对象"></a>7.2.3 session作为域对象</h4><p>Session有着request和ServletContext类似的方法。其实<strong>Session也是一个域对象</strong>。Session作为一种记录浏览器状态的机制，<strong>只要Session对象没有被销毁，Servlet之间就可以通过Session对象实现通讯</strong></p><p>一般来讲，当我们要存进的是<strong>用户级别的数据就用Session</strong>，那什么是用户级别呢？<strong>只要浏览器不关闭，希望数据还在，就使用Session来保存</strong>。</p><h4 id="7-2-4-session生命周期"><a href="#7-2-4-session生命周期" class="headerlink" title="7.2.4 session生命周期"></a>7.2.4 session生命周期</h4><p><strong>Session的生命周期和有效期</strong></p><ul><li><p>Session在用户<strong>第一次访问服务器Servlet，jsp等动态资源就会被自动创建，Session对象保存在内存里</strong>，这也就为什么上面的例子可以<strong>直接使用request对象获取得到Session对象</strong>。</p></li><li><p>如果访问HTML,IMAGE等静态资源Session不会被创建。</p></li><li><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，无论<strong>是否对Session进行读写，服务器都会认为Session活跃了一次</strong>。</p></li><li><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。<strong>为了防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除，这个时间也就是Session的超时时间</strong>。</p></li><li><p>Session的超时时间默认是30分钟，有三种方式可以对Session的超时时间进行修改</p><p>1、修改tomcat的web.xml</p><p>2、修改项目的web.xml</p><p>3、<code>httpSession.setMaxInactiveInterval(60);</code></p></li></ul><h3 id="7-3-Session和Cookie的区别"><a href="#7-3-Session和Cookie的区别" class="headerlink" title="7.3 Session和Cookie的区别"></a>7.3 Session和Cookie的区别</h3><ul><li><p><strong>从存储方式上比较</strong></p></li><li><ul><li>Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。</li><li>Session可以存储任何类型的数据，可以把Session看成是一个容器</li></ul></li><li><p><strong>从隐私安全上比较</strong></p></li><li><ul><li><strong>Cookie存储在浏览器中，对客户端是可见的</strong>。信息容易泄露出去。如果使用Cookie，最好将Cookie加密</li><li><strong>Session存储在服务器上，对客户端是透明的</strong>。不存在敏感信息泄露问题。</li></ul></li><li><p><strong>从有效期上比较</strong></p></li><li><ul><li>Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的</li><li><strong>Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。</strong></li></ul></li><li><p><strong>从对服务器的负担比较</strong></p></li><li><ul><li>Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。</li><li>Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。</li></ul></li><li><p><strong>从浏览器的支持上比较</strong></p></li><li><ul><li>如果浏览器禁用了Cookie，那么Cookie是无用的了！</li><li>如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。</li></ul></li><li><p><strong>从跨域名上比较</strong></p></li><li><ul><li>Cookie可以设置domain属性来实现跨域名</li><li>Session只在当前的域名内有效，不可跨域名</li></ul></li></ul><h2 id="8、forward和redirect的区别"><a href="#8、forward和redirect的区别" class="headerlink" title="8、forward和redirect的区别"></a>8、forward和redirect的区别</h2><h3 id="8-1-实际发生位置不同，地址栏不同"><a href="#8-1-实际发生位置不同，地址栏不同" class="headerlink" title="8.1 实际发生位置不同，地址栏不同"></a>8.1 <strong>实际发生位置不同，地址栏不同</strong></h3><p>1、转发是发生在服务器的<br>2、转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。<br>3、重定向是发生在浏览器的 - 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象</p><h3 id="8-2-用法不同"><a href="#8-2-用法不同" class="headerlink" title="8.2 用法不同"></a>8.2 用法不同</h3><p>很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： <strong>给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上</strong></p><p><code>request.getRequestDispatcher(&quot;/资源名 URI&quot;).forward(request,response)</code><br>转发时”/“代表的是本应用程序的根目录【zhongfucheng】<br><code>response.send(&quot;/web应用/资源名 URI&quot;); </code><br>重定向时”/“代表的是webapps目录  </p><h3 id="8-3-能够去往的URL的范围不一样"><a href="#8-3-能够去往的URL的范围不一样" class="headerlink" title="8.3 能够去往的URL的范围不一样"></a>8.3 能够去往的URL的范围不一样</h3><p>转发是服务器跳转只能去往当前web应用的资源<br>重定向是服务器跳转，可以去往任何的资源</p><h3 id="8-4-传递数据的类型不同"><a href="#8-4-传递数据的类型不同" class="headerlink" title="8.4 传递数据的类型不同"></a>8.4 传递数据的类型不同</h3><p>转发的request对象可以传递各种类型的数据，包括对象<br>重定向只能传递字符串</p><h3 id="8-5-跳转的时间不同"><a href="#8-5-跳转的时间不同" class="headerlink" title="8.5 跳转的时间不同"></a>8.5 跳转的时间不同</h3><p>转发时：执行到跳转语句时就会立刻跳转<br>重定向：整个页面执行完之后才执行跳转</p><p><strong>那么转发(forward)和重定向(redirect)使用哪一个？</strong></p><p>根据上面说明了转发和重定向的区别也可以很容易概括出来<strong>。转发是带着转发前的请求的参数的。重定向是新的请求</strong>。</p><h3 id="8-6-典型的应用场景："><a href="#8-6-典型的应用场景：" class="headerlink" title="8.6 典型的应用场景："></a>8.6 典型的应用场景：</h3><ol><li>转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变</li><li>重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了</li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484755&idx=7&sn=fb35232f3c15e2b4336498ac9f8804f1&chksm=ebd74452dca0cd44942721a159088a2f286d4e5c5f2bcdc7e264f0dccc8f9928d66858e475d4###rd">Servlet第六篇【Session介绍、API、生命周期、应用、与Cookie区别】(修订版)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是servlet&quot;&gt;&lt;a href=&quot;#1、什么是servlet&quot; class=&quot;headerlink&quot; title=&quot;1、什么是servlet&quot;&gt;&lt;/a&gt;1、什么是servlet&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是Serlvet？&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>服务发现的基本原理</title>
    <link href="http://example.com/wiki/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-24T06:30:25.000Z</published>
    <updated>2021-08-24T06:33:06.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6844903580999090183">https://juejin.cn/post/6844903580999090183</a></p><p><a href="https://blog.didispace.com/consul-service-discovery-exp/">使用Consul做服务发现的若干姿势</a></p><p><a href="https://laravelacademy.org/post/21214">注册中心篇（三）：Consul 服务发现的底层实现</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903580999090183&quot;&gt;https://j</summary>
      
    
    
    
    
    <category term="服务发现" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM-性能调优</title>
    <link href="http://example.com/wiki/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://example.com/wiki/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-08-23T02:13:43.000Z</published>
    <updated>2021-08-23T02:16:21.575Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p><a href="https://mikechen.cc/3321.html">JVM性能调优的6大步骤，及关键调优参数详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mikechen.cc/3321.html&quot;&gt;JVM性能调优的6大步骤，及关键调优参数详解&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Arthas-Java诊断神器</title>
    <link href="http://example.com/wiki/Arthas-Java%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/"/>
    <id>http://example.com/wiki/Arthas-Java%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/</id>
    <published>2021-08-20T08:28:32.000Z</published>
    <updated>2021-08-20T10:02:17.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Arthas-Java诊断神器"><a href="#Arthas-Java诊断神器" class="headerlink" title="Arthas-Java诊断神器"></a>Arthas-Java诊断神器</h2><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820172620815.png" alt="image-20210820172620815" style="zoom:50%;"/><p>官方文档地址 👉    <a href="https://arthas.aliyun.com/doc/index.html#">https://arthas.aliyun.com/doc/index.html#</a></p><h3 id="1-安装arthas"><a href="#1-安装arthas" class="headerlink" title="1. 安装arthas"></a>1. 安装arthas</h3><p><code>wget https://arthas.aliyun.com/arthas-boot.jar </code></p><p><code>java -jar arthas-boot.jar --target-ip 0.0.0.0</code></p><p>如果你的机器没有任何java进程在运行，会提示如下错误 👇</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820165717792.png" alt="image-20210820165717792"></p><p><strong>正常启动如下：</strong></p><p>⚠️ 由于我们仅仅启动了一个java进程，所有这里就只有一个。输入1回车即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820165953801.png" alt="image-20210820165953801"></p><p><strong>42423就是我们的java进程号</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820170112574.png" alt="image-20210820170112574"></p><h3 id="2-查看JVM信息"><a href="#2-查看JVM信息" class="headerlink" title="2. 查看JVM信息"></a>2. 查看JVM信息</h3><h4 id="2-1-sysprop"><a href="#2-1-sysprop" class="headerlink" title="2.1 sysprop"></a>2.1 sysprop</h4><p><code>sysprop</code> 可以打印所有的System Properties信息。</p><p>也可以指定单个key： <code>sysprop java.version</code></p><p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p><p>可以设置新的value： <code>sysprop testKey testValue</code></p><h4 id="2-2-sysenv"><a href="#2-2-sysenv" class="headerlink" title="2.2 sysenv"></a>2.2 sysenv</h4><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p><h4 id="2-3-jvm"><a href="#2-3-jvm" class="headerlink" title="2.3 jvm"></a>2.3 jvm</h4><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p><h4 id="2-4-dashboard"><a href="#2-4-dashboard" class="headerlink" title="2.4 dashboard"></a>2.4 dashboard</h4><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><p>输入 <code>Q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><h3 id="3-查看线程相关"><a href="#3-查看线程相关" class="headerlink" title="3. 查看线程相关"></a>3. 查看线程相关</h3><h4 id="3-1-查看线程列表"><a href="#3-1-查看线程列表" class="headerlink" title="3.1 查看线程列表"></a>3.1 查看线程列表</h4><p><code>thread</code> </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820163125277.png" alt="image-20210820163125277"></p><h4 id="3-2-查看线程栈信息"><a href="#3-2-查看线程栈信息" class="headerlink" title="3.2 查看线程栈信息"></a>3.2 <strong>查看线程栈信息</strong></h4><p><code>thread 18</code> </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820163518891.png" alt="image-20210820163518891"></p><h4 id="3-3-查看5秒内的CPU使用率top-n线程栈"><a href="#3-3-查看5秒内的CPU使用率top-n线程栈" class="headerlink" title="3.3 查看5秒内的CPU使用率top n线程栈"></a>3.3 查看5秒内的CPU使用率top n线程栈</h4><p><code>thread -n 3 -i 5000 </code></p><h4 id="3-4-查找线程是否有阻塞"><a href="#3-4-查找线程是否有阻塞" class="headerlink" title="3.4 查找线程是否有阻塞"></a>3.4 查找线程是否有阻塞</h4><p><code>thread -b</code></p><h3 id="4-sc-sm-查看已加载的类"><a href="#4-sc-sm-查看已加载的类" class="headerlink" title="4. sc/sm 查看已加载的类"></a>4. sc/sm 查看已加载的类</h3><p>下面介绍Arthas里查找已加载类的命令。</p><h3 id="4-1-sc-查找到所有JVM已经加载到的类"><a href="#4-1-sc-查找到所有JVM已经加载到的类" class="headerlink" title="4.1 sc 查找到所有JVM已经加载到的类"></a>4.1 sc 查找到<strong>所有JVM已经加载到的类</strong></h3><p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p><p><code>sc javax.servlet.Filter</code></p><p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p><p><code>sc -d javax.servlet.Filter</code></p><p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p><p><code>sc *StringUtils</code></p><h3 id="4-2-sm-查找类的具体函数"><a href="#4-2-sm-查找类的具体函数" class="headerlink" title="4.2 sm 查找类的具体函数"></a>4.2 sm 查找类的<strong>具体函数</strong></h3><p><code>sm java.math.RoundingMode</code></p><p>通过<code>-d</code>参数可以打印函数的具体属性：</p><p><code>sm -d java.math.RoundingMode</code></p><p>也可以查找特定的函数，比如查找构造函数：</p><p><code>sm java.math.RoundingMode &lt;init&gt;</code></p><h3 id="5-Jad反编译"><a href="#5-Jad反编译" class="headerlink" title="5. Jad反编译"></a>5. Jad反编译</h3><p>可以通过 <code>jad</code> 命令来反编译代码：</p><p><code>jad com.example.demo.arthas.user.UserController</code></p><p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p><p><code>jad --source-only com.example.demo.arthas.user.UserController</code></p><h3 id="6-Ognl动态代码"><a href="#6-Ognl动态代码" class="headerlink" title="6. Ognl动态代码"></a>6. Ognl动态代码</h3><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p><h4 id="6-1-调用static函数"><a href="#6-1-调用static函数" class="headerlink" title="6.1 调用static函数"></a>6.1 调用static函数</h4><p><code>ognl &#39;@java.lang.System@out.println(&quot;hello ognl&quot;)&#39;</code></p><p>可以检查<code>Terminal</code>里的进程输出，可以发现打印出了<code>hello ognl</code>。</p><h4 id="6-2-查找UserController的ClassLoader"><a href="#6-2-查找UserController的ClassLoader" class="headerlink" title="6.2 查找UserController的ClassLoader"></a>6.2 查找UserController的ClassLoader</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><p><code>$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</code></p><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter<span class="variable">$Slf4jLocationAwareLog</span>],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4 id="6-3-获取静态类的静态字段"><a href="#6-3-获取静态类的静态字段" class="headerlink" title="6.3 获取静态类的静态字段"></a>6.3 获取静态类的静态字段</h4><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><h4 id="6-4-执行多行表达式，赋值给临时变量，返回一个List"><a href="#6-4-执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="6.4 执行多行表达式，赋值给临时变量，返回一个List"></a>6.4 执行多行表达式，赋值给临时变量，返回一个List</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="6-5-更多"><a href="#6-5-更多" class="headerlink" title="6.5 更多"></a>6.5 更多</h4><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h3 id="7-Watch查看命令"><a href="#7-Watch查看命令" class="headerlink" title="7. Watch查看命令"></a>7. Watch查看命令</h3><h4 id="7-1-如何使用"><a href="#7-1-如何使用" class="headerlink" title="7.1 如何使用"></a>7.1 如何使用</h4><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, throwExp&#125;&#39;</code></p><p>执行完之后，会阻塞，此时如果有请求进来，发生一场的话，就会看到异常信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820171343673.png" alt="image-20210820171343673"></p><p>如果想把获取到的结果展开，可以用<code>-x</code>参数：</p><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, throwExp&#125;&#39; -x 2</code></p><h4 id="7-2-返回值表达式"><a href="#7-2-返回值表达式" class="headerlink" title="7.2 返回值表达式"></a>7.2 返回值表达式</h4><p>在上面的例子里，第三个参数是<code>返回值表达式</code>，它实际上是一个<code>ognl</code>表达式，它支持一些内置对象：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><p>你可以利用这些内置对象来组成不同的表达式。比如返回一个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * &#x27;&#123;params[0], target, returnObj&#125;&#x27;</span><br></pre></td></tr></table></figure><p>更多参考： <a href="https://arthas.aliyun.com/doc/advice-class.html">https://arthas.aliyun.com/doc/advice-class.html</a></p><h4 id="7-3-条件表达式"><a href="#7-3-条件表达式" class="headerlink" title="7.3 条件表达式"></a>7.3 条件表达式</h4><p><code>watch</code>命令支持在第4个参数里写条件表达式，比如：</p><p><code>watch com.example.demo.arthas.user.UserController * returnObj &#39;params[0] &gt; 100&#39;</code></p><p>当访问 <code>localhost:80/user/1</code>时，<code>watch</code>命令没有输出</p><p>当访问<code>localhost:80/user/101</code>时，<code>watch</code>会打印出结果。</p><h4 id="7-4-当异常时捕获"><a href="#7-4-当异常时捕获" class="headerlink" title="7.4 当异常时捕获"></a>7.4 当异常时捕获</h4><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><p><code>watch com.example.demo.arthas.user.UserController * &quot;&#123;params[0],throwExp&#125;&quot; -e</code></p><h4 id="7-5-按照耗时进行过滤"><a href="#7-5-按照耗时进行过滤" class="headerlink" title="7.5 按照耗时进行过滤"></a>7.5 按照耗时进行过滤</h4><p>watch命令支持按请求耗时进行过滤，比如：</p><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, returnObj&#125;&#39; &#39;#cost&gt;200&#39;</code></p><h3 id="8-热更新代码"><a href="#8-热更新代码" class="headerlink" title="8. 热更新代码"></a>8. 热更新代码</h3><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost/user/0">http://localhost/user/0</a> ，会返回500异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//localhost/user/0</span></span><br><span class="line">&#123;<span class="string">&quot;timestamp&quot;</span>:<span class="number">1550223186170</span>,<span class="string">&quot;status&quot;</span>:<span class="number">500</span>,<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Internal Server Error&quot;</span>,<span class="string">&quot;exception&quot;</span>:<span class="string">&quot;java.lang.IllegalArgumentException&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;id &lt; 1&quot;</span>,<span class="string">&quot;path&quot;</span>:<span class="string">&quot;/user/0&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4 id="8-1-jad反编译UserController"><a href="#8-1-jad反编译UserController" class="headerlink" title="8.1 jad反编译UserController"></a>8.1 jad反编译UserController</h4><p><strong>在arthas中执行jad命令 👇</strong></p><p><code>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</code></p><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>在【 机器 】上然后用vim来编辑<code>/tmp/UserController.java</code>：</p><p><code>vim /tmp/UserController.java</code></p><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-sc查找加载UserController的ClassLoader"><a href="#8-2-sc查找加载UserController的ClassLoader" class="headerlink" title="8.2 sc查找加载UserController的ClassLoader"></a>8.2 sc查找加载UserController的ClassLoader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br><span class="line">$ sc -d *UserController | grep classLoaderHash</span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 <code>springbootLaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>记下classLoaderHash，后面需要使用它。在这里，它是 <code>1be6f5c3</code>。</p><h4 id="8-3-mc编译java文件"><a href="#8-3-mc编译java文件" class="headerlink" title="8.3 mc编译java文件"></a>8.3 mc编译java文件</h4><p>编译java文件，类似于javac。</p><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>或者<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br><span class="line">$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820172201737.png" alt="image-20210820172201737"></p><h4 id="8-4-redefine加载class文件"><a href="#8-4-redefine加载class文件" class="headerlink" title="8.4 redefine加载class文件"></a>8.4 redefine加载class文件</h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h4 id="8-5-热修改代码结果"><a href="#8-5-热修改代码结果" class="headerlink" title="8.5 热修改代码结果"></a>8.5 热修改代码结果</h4><p><code>redefine</code>成功之后，再次访问 <code>localhost:80/user/0</code> ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-Exit-Stop"><a href="#9-Exit-Stop" class="headerlink" title="9. Exit/Stop"></a>9. Exit/Stop</h3><h4 id="9-1-reset"><a href="#9-1-reset" class="headerlink" title="9.1 reset"></a>9.1 reset</h4><p>Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 <code>reset</code> 命令，可以清除掉这些增强代码。</p><h4 id="9-2-退出Arthas"><a href="#9-2-退出Arthas" class="headerlink" title="9.2 退出Arthas"></a>9.2 退出Arthas</h4><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p><p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p><h4 id="9-3-彻底退出Arthas"><a href="#9-3-彻底退出Arthas" class="headerlink" title="9.3 彻底退出Arthas"></a>9.3 彻底退出Arthas</h4><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p><p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p><h3 id="10-arthas-boot支持的参数"><a href="#10-arthas-boot支持的参数" class="headerlink" title="10. arthas-boot支持的参数"></a>10. arthas-boot支持的参数</h3><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p><h4 id="10-1-允许外部访问"><a href="#10-1-允许外部访问" class="headerlink" title="10.1 允许外部访问"></a>10.1 允许外部访问</h4><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p><p><code>java -jar arthas-boot.jar --target-ip</code></p><h4 id="10-2-列出所有的版本"><a href="#10-2-列出所有的版本" class="headerlink" title="10.2 列出所有的版本"></a>10.2 列出所有的版本</h4><p><code>java -jar arthas-boot.jar --versions</code></p><p>使用指定版本：</p><p><code>java -jar arthas-boot.jar --use-version 3.1.0</code></p><h4 id="10-3-只侦听Telnet端口，不侦听HTTP端口"><a href="#10-3-只侦听Telnet端口，不侦听HTTP端口" class="headerlink" title="10.3 只侦听Telnet端口，不侦听HTTP端口"></a>10.3 只侦听Telnet端口，不侦听HTTP端口</h4><p><code>java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</code></p><h4 id="10-4-打印运行的详情"><a href="#10-4-打印运行的详情" class="headerlink" title="10.4 打印运行的详情"></a>10.4 打印运行的详情</h4><p><code>java -jar arthas-boot.jar -v</code></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820164916567.png" alt="image-20210820164916567"></p><h3 id="11-Web-Console"><a href="#11-Web-Console" class="headerlink" title="11. Web Console"></a>11. Web Console</h3><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820173816512.png" alt="image-20210820173816512"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Arthas-Java诊断神器&quot;&gt;&lt;a href=&quot;#Arthas-Java诊断神器&quot; class=&quot;headerlink&quot; title=&quot;Arthas-Java诊断神器&quot;&gt;&lt;/a&gt;Arthas-Java诊断神器&lt;/h2&gt;&lt;img src=&quot;https://cdn</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-只出现一次的数字</title>
    <link href="http://example.com/wiki/LeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/wiki/LeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2021-08-19T13:12:54.000Z</published>
    <updated>2021-08-19T13:17:19.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4<br>相关标签<br>位运算</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>仅仅出现一个，很显然，这个数和前后都不一样，然后特殊判断一下头部和尾部就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">2</span>] != nums[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; nums[i - <span class="number">2</span>] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析二"><a href="#分析二" class="headerlink" title="分析二"></a>分析二</h2><p>使用异或运算，将所有值进行异或<br>异或运算，相异为真，相同为假，所以<code> a^a = 0 ;0^a = a</code><br>因为异或运算 满足交换律 <code>a^b^a = a^a^b = b </code>所以数组经过异或运算，单独的值就剩下了</p><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/?discussion=Mo9fKT">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/?discussion=Mo9fKT</a></p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reduce = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            reduce =  reduce ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;只出现一次的数字&quot;&gt;&lt;a href=&quot;#只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;只出现一次的数字&quot;&gt;&lt;/a&gt;只出现一次的数字&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/leetbook/read</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-存在重复元素</title>
    <link href="http://example.com/wiki/LeetCode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/wiki/LeetCode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-08-19T12:57:35.000Z</published>
    <updated>2021-08-19T13:04:26.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a></p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><p>示例 1:</p><p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p><p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p><p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>1、双重循环是很容易想到，但是会超出时间限制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、先排序，然后判断相邻两个元素是否相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;存在重复元素&quot;&gt;&lt;a href=&quot;#存在重复元素&quot; class=&quot;headerlink&quot; title=&quot;存在重复元素&quot;&gt;&lt;/a&gt;存在重复元素&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/leetbook/read/top-int</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-买卖股票的最佳时机II</title>
    <link href="http://example.com/wiki/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://example.com/wiki/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2021-08-19T12:35:49.000Z</published>
    <updated>2021-08-19T12:41:01.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a></p><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: <code>prices = [7,1,5,3,6,4]</code><br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:</p><p>输入: <code>prices = [1,2,3,4,5]</code><br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p><p>输入: <code>prices = [7,6,4,3,1]</code><br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>⏰提示：</p><p><code>1 &lt;= prices.length &lt;= 3 * 104</code><br><code>0 &lt;= prices[i] &lt;= 104</code></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>[7,1,5,3,6,4]</code><br><code>[1,2,3,4,5]</code></p><p>其实规律很简单，就比较当天和前一天的大小关系就好了，一次循环就下来了。</p><p>一开始想的比较复杂，用的指针滑动，比如1，2，3，4，5这种，一开始想的是 <code>5 - 1</code> ，其实 1 + 1 + 1 + 1就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [7,1,5,3,6,4]</span></span><br><span class="line">        <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                count += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;买卖股票的最佳时机II&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/l</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-删除排序数组中的重复项</title>
    <link href="http://example.com/wiki/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://example.com/wiki/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2021-08-19T11:28:03.000Z</published>
    <updated>2021-08-19T11:52:25.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a></p><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 </p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 3 * 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按升序排列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假如输入 <code>[0,0,1,1,1,2,2,3,3,4]</code></p><p>最终的结果应该是<code>[0,1,2,3,4,2,2,3,3,4]</code></p><p><strong>count</strong> 变量用来存储不重复数组的个数</p><p><strong>offset</strong> 作为当前游标记录判断之后不重复的数据的位置</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210819194952616.png" style="zoom:33%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[offset] = nums[i];</span><br><span class="line">            offset++;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除排序数组中的重复项&quot;&gt;&lt;/a&gt;删除排序数组中的重复项&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/l</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁🔒</title>
    <link href="http://example.com/wiki/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%F0%9F%94%92/"/>
    <id>http://example.com/wiki/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%F0%9F%94%92/</id>
    <published>2021-08-19T07:17:31.000Z</published>
    <updated>2021-08-19T07:32:53.269Z</updated>
    
    <content type="html"><![CDATA[<p>乐观锁和悲观锁</p><h3 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h3><blockquote><p><strong>表锁</strong>： 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</p></blockquote><p>表锁按照数据操作可以分成两种：</p><ul><li>表读锁（Table Read Lock）</li><li>表写锁（Table Write Lock</li></ul><p>读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁</p><p>读写阻塞：当前用户在读数据，其他的用户<strong>不能修改当前用户读的数据</strong>，会加锁！</p><p>写写阻塞：当前用户在修改数据，其他的用户<strong>不能修改当前用户正在修改的数据</strong>，会加锁！</p><blockquote><p><strong>行锁</strong>： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</p></blockquote><p>InnoDB实现了以下<strong>两种</strong>类型的行锁。</p><ul><li><p>共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>也叫做<strong>读锁</strong>：读锁是<strong>共享</strong>的，多个客户可以<strong>同时读取同一个</strong>资源，但<strong>不允许其他客户修改</strong>。</p></li><li><p>排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p></li><li><p>也叫做<strong>写锁</strong>：写锁是排他的，<strong>写锁会阻塞其他的写锁和读锁</strong>。</p></li></ul><p>另外，<strong>为了允许行锁和表锁共存，实现多粒度锁机制</strong>，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li><li>意向锁也是数据库隐式帮我们做了，<strong>不需要程序员操心</strong>！</li></ul><p>⚠️ <strong>InnoDB行锁和表锁都支持</strong>！<font color=red><strong>MyISAM只支持表锁</strong>！</font></p><h3 id="innoDB什么时候会使用到行锁？"><a href="#innoDB什么时候会使用到行锁？" class="headerlink" title="innoDB什么时候会使用到行锁？"></a>innoDB什么时候会使用到行锁？</h3><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN###rd">数据库两大神器【索引和锁】</a></p><p><a href="https://geekibli.github.io/wiki/mysql%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">基于数据表乐观锁实现分布式锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乐观锁和悲观锁&lt;/p&gt;
&lt;h3 id=&quot;表锁和行锁&quot;&gt;&lt;a href=&quot;#表锁和行锁&quot; class=&quot;headerlink&quot; title=&quot;表锁和行锁&quot;&gt;&lt;/a&gt;表锁和行锁&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;表锁&lt;/strong&gt;： 开销小，加锁快；不</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能调优</title>
    <link href="http://example.com/wiki/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://example.com/wiki/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-08-19T06:06:45.000Z</published>
    <updated>2021-08-19T08:25:08.529Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、使用【-覆盖索引-】避免回表锁造成的时间消耗"><a href="#1、使用【-覆盖索引-】避免回表锁造成的时间消耗" class="headerlink" title="1、使用【 覆盖索引 】避免回表锁造成的时间消耗"></a>1、使用【 覆盖索引 】避免回表锁造成的时间消耗</h5><p>1、查询语句的时候避免使用select * </p><p>2、创建索引添加适当的列避免回表</p><h5 id="2、使用【-联合索引-】区分度比较高的列放到前面"><a href="#2、使用【-联合索引-】区分度比较高的列放到前面" class="headerlink" title="2、使用【 联合索引 】区分度比较高的列放到前面"></a>2、使用【 联合索引 】区分度比较高的列放到前面</h5><p>注意联合索引的最左匹配原则</p><h5 id="3、对索引进行函数计算或者表达式计算会导致索引失效-🔒"><a href="#3、对索引进行函数计算或者表达式计算会导致索引失效-🔒" class="headerlink" title="3、对索引进行函数计算或者表达式计算会导致索引失效 🔒"></a>3、对索引进行函数计算或者表达式计算会导致索引失效 🔒</h5><h5 id="4、利用子查询优化超多分页场景"><a href="#4、利用子查询优化超多分页场景" class="headerlink" title="4、利用子查询优化超多分页场景"></a>4、利用子查询优化超多分页场景</h5><h5 id="5、explain命令查询执行计划-show-profile查询执行的性能消耗"><a href="#5、explain命令查询执行计划-show-profile查询执行的性能消耗" class="headerlink" title="5、explain命令查询执行计划 show profile查询执行的性能消耗"></a>5、explain命令查询执行计划 show profile查询执行的性能消耗</h5><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484461&idx=2&sn=5469534e2f370aba86c3a24a2ff52b70&chksm=ebd7452cdca0cc3ad456d695a78f48e72c245f85b4afb210fb7b62218e89785d964d72ec4891&token=620000779&lang=zh_CN&scene=21###wechat_redirect">面试前必须知道的MySQL命令【expalin】 -3y</a></p><h5 id="6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间"><a href="#6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间" class="headerlink" title="6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间"></a>6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间</h5><h5 id="7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch"><a href="#7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch" class="headerlink" title="7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch"></a>7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch</h5><h5 id="8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据"><a href="#8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据" class="headerlink" title="8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据"></a>8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据</h5><h5 id="9、读写瓶颈问题"><a href="#9、读写瓶颈问题" class="headerlink" title="9、读写瓶颈问题"></a>9、读写瓶颈问题</h5><p>9.1 如果是单库的情况下，可以考虑读写分离，提升读/写的性能</p><p>9.2 主从结构下还是存在瓶颈的话，可以考虑分库分表</p><p>注意 分库分表下的id尽量保证递增</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1、使用【-覆盖索引-】避免回表锁造成的时间消耗&quot;&gt;&lt;a href=&quot;#1、使用【-覆盖索引-】避免回表锁造成的时间消耗&quot; class=&quot;headerlink&quot; title=&quot;1、使用【 覆盖索引 】避免回表锁造成的时间消耗&quot;&gt;&lt;/a&gt;1、使用【 覆盖索引 】避免</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>kafka-基础知识</title>
    <link href="http://example.com/wiki/kafka-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/wiki/kafka-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-08-18T12:05:29.000Z</published>
    <updated>2021-08-18T12:14:58.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka是什么"><a href="#kafka是什么" class="headerlink" title="kafka是什么"></a>kafka是什么</h2><h2 id="kafka运行时架构"><a href="#kafka运行时架构" class="headerlink" title="kafka运行时架构"></a>kafka运行时架构</h2><h2 id="kafka为什么能承载高并发"><a href="#kafka为什么能承载高并发" class="headerlink" title="kafka为什么能承载高并发"></a>kafka为什么能承载高并发</h2><h2 id="kafka的确认机制是什么"><a href="#kafka的确认机制是什么" class="headerlink" title="kafka的确认机制是什么"></a>kafka的确认机制是什么</h2><h2 id="kafka如何保证消息准确"><a href="#kafka如何保证消息准确" class="headerlink" title="kafka如何保证消息准确"></a>kafka如何保证消息准确</h2><p>kafka会丢消息吗？</p><p>kafka会重复消费消息吗</p><p>幂等性</p><h2 id="消息顺序消费问题"><a href="#消息顺序消费问题" class="headerlink" title="消息顺序消费问题"></a>消息顺序消费问题</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247484387&idx=1&sn=5bb2ba58776e65f53b091a4bcdb73755&chksm=fdf0ebbcca8762aadc359066ecd70274fa23ee846f9ba9114017402dcbed415f25f97d3020a6&token=1131755397&lang=zh_CN&scene=21#wechat_redirect">kafka基础知识 - yyy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kafka是什么&quot;&gt;&lt;a href=&quot;#kafka是什么&quot; class=&quot;headerlink&quot; title=&quot;kafka是什么&quot;&gt;&lt;/a&gt;kafka是什么&lt;/h2&gt;&lt;h2 id=&quot;kafka运行时架构&quot;&gt;&lt;a href=&quot;#kafka运行时架构&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事务隔离</title>
    <link href="http://example.com/wiki/Spring-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://example.com/wiki/Spring-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2021-08-18T03:10:21.000Z</published>
    <updated>2021-08-18T03:11:08.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6854573219916021767">https://juejin.cn/post/6854573219916021767</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6854573219916021767&quot;&gt;https://j</summary>
      
    
    
    
    
  </entry>
  
</feed>
