<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-31T07:53:22.140Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM-垃圾收集器</title>
    <link href="http://example.com/wiki/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/wiki/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-07-31T06:13:17.000Z</published>
    <updated>2021-07-31T07:53:22.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、什么是垃圾收集器"><a href="#1、什么是垃圾收集器" class="headerlink" title="1、什么是垃圾收集器"></a>1、什么是垃圾收集器</h1><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。 就像没有最好的算法一样，垃圾收集器也没有最好，只有最合适。我们能做的就是根据具体的应用场景选择最合适的垃圾收集器。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731155230422.png" alt="image-20210731155230422" style="zoom: 33%;" /><p>上图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p><h1 id="2、串行，并行和并发"><a href="#2、串行，并行和并发" class="headerlink" title="2、串行，并行和并发"></a>2、串行，并行和并发</h1><h2 id="2-1-串行"><a href="#2-1-串行" class="headerlink" title="2.1 串行"></a>2.1 串行</h2><p>计算机中的串行是用 Serial 表示。A 和 B 两个任务运行在一个 CPU 线程上，在 A 任务执行完之前不可以执行 B。即，在整个程序的运行过程中，仅存在一个运行上下文，即一个调用栈一个堆。程序会按顺序执行每个指令。</p><h2 id="2-2-并行"><a href="#2-2-并行" class="headerlink" title="2.2 并行"></a>2.2 并行</h2><p>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，<strong>并行性使多个程序同一时刻可在不同 CPU 上同时执行</strong>。比如，A 和 B 两个任务可以同时运行在不同的 CPU 线程上，效率较高，但受限于 CPU 线程数，如果任务数量超过了 CPU 线程数，那么每个线程上的任务仍然是顺序执行的。</p><h2 id="2-3-并发"><a href="#2-3-并发" class="headerlink" title="2.3 并发"></a>2.3 并发</h2><p>并发指多个线程在宏观(相对于较长的时间区间而言)上表现为同时执行，而实际上是轮流穿插着执行，<strong>并发的实质是一个物理 CPU 在若干道程序之间多路复用</strong>，其目的是提高有限物理资源的运行效率。 并发与并行串行并不是互斥的概念，如果是在一个CPU线程上启用并发，那么自然就还是串行的，而如果在多个线程上启用并发，那么程序的执行就可以是既并发又并行的。</p><h2 id="2-4-JVM-垃圾收集中的串行、并行和并发"><a href="#2-4-JVM-垃圾收集中的串行、并行和并发" class="headerlink" title="2.4 JVM 垃圾收集中的串行、并行和并发"></a>2.4 JVM 垃圾收集中的串行、并行和并发</h2><p>在 JVM 垃圾收集器中也涉及到如上的三个概念。</p><ul><li>串行（Serial）：使用单线程进行垃圾回收的回收器。</li><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><p>在了解了这些概念之后，我们开始具体介绍常用的垃圾收集器。</p><h1 id="3、主流的垃圾收集器"><a href="#3、主流的垃圾收集器" class="headerlink" title="3、主流的垃圾收集器"></a>3、主流的垃圾收集器</h1><h2 id="3-1-Serial收集器"><a href="#3-1-Serial收集器" class="headerlink" title="3.1 Serial收集器"></a>3.1 Serial收集器</h2><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了（新生代采用复制算法，老生代采用标志整理算法）。大家看名字就知道这个收集器是一个单线程收集器了。 它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在<code>进行垃圾收集工作的时候必须暂停其他所有的工作线程</code>（ “Stop The World” ：将用户正常工作的线程全部暂停掉），直到它收集结束。 </p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731143820628.png" alt="image-20210731143820628" style="zoom:50%;" /><p>上图中：</p><ul><li>新生代采用复制算法，Stop-The-World</li><li>老年代采用标记-整理算法，Stop-The-World</li></ul><p>当它进行GC工作的时候，虽然会造成Stop-The-World，正如每种算法都有存在的原因，该串行收集器也有存在的原因：因为简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，没有线程交互的开销，专心做GC，自然可以获得最高的单线程效率。</p><p>所以Serial收集器对于运行在client模式下的应用是一个很好的选择（到目前为止，它依然是虚拟机运行在client模式下的默认新生代收集器） 串行收集器的缺点很明显，虚拟机的开发者当然也是知道这个缺点的，所以一直都在缩减Stop The World的时间。 在后续的垃圾收集器设计中停顿时间在不断缩短（但是仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）</p><h3 id="3-1-1-特点"><a href="#3-1-1-特点" class="headerlink" title="3.1.1 特点"></a>3.1.1 特点</h3><ul><li>针对新生代的收集器；</li><li>采用复制算法；</li><li>单线程收集；</li><li>进行垃圾收集时，必须暂停所有工作线程，直到完成； 即会”Stop The World”；</li></ul><h3 id="3-1-2-应用场景"><a href="#3-1-2-应用场景" class="headerlink" title="3.1.2 应用场景"></a>3.1.2 应用场景</h3><ul><li><code>依然是HotSpot在Client模式下默认的新生代收集器；</code></li><li>也有优于其他收集器的地方： 简单高效（与其他收集器的单线程相比）；</li><li>对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；</li><li>在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</li></ul><h3 id="3-1-3-参数设置"><a href="#3-1-3-参数设置" class="headerlink" title="3.1.3 参数设置"></a>3.1.3 参数设置</h3><p>添加该参数来显式的使用串行垃圾收集器: “-XX:+UseSerialGC”</p><h2 id="3-2-ParNew收集器"><a href="#3-2-ParNew收集器" class="headerlink" title="3.2 ParNew收集器"></a>3.2 ParNew收集器</h2><blockquote><p> Serial收集器的多线程版本-使用多条线程进行GC</p></blockquote><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 CMS收集器是一个被认为具有划时代意义的并发收集器，因此如果有一个垃圾收集器能和它一起搭配使用让其更加完美，那这个收集器必然也是一个不可或缺的部分了。 收集器的运行过程如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731144404779.png" alt="image-20210731144404779" style="zoom:50%;" /><h3 id="3-2-1-应用场景："><a href="#3-2-1-应用场景：" class="headerlink" title="3.2.1 应用场景："></a>3.2.1 应用场景：</h3><p>在Server模式下，ParNew收集器是一个非常重要的收集器，<strong>因为除Serial外，目前只有它能与CMS收集器配合工作</strong>； 但<font color=red>在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</font></p><h3 id="3-2-2-设置参数"><a href="#3-2-2-设置参数" class="headerlink" title="3.2.2 设置参数"></a>3.2.2 设置参数</h3><p>指定使用CMS后，会默认使用ParNew作为新生代收集: “-XX:+UseConcMarkSweepGC” 强制指定使用ParNew:<br>“-XX:+UseParNewGC” 指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相: “-XX:ParallelGCThreads”</p><h3 id="3-2-3-为什么只有ParNew能与CMS收集器配合"><a href="#3-2-3-为什么只有ParNew能与CMS收集器配合" class="headerlink" title="3.2.3 为什么只有ParNew能与CMS收集器配合"></a>3.2.3 为什么只有ParNew能与CMS收集器配合</h3><ul><li>CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>；</li><li>CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；</li><li>因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；</li></ul><h2 id="3-3-Parallel-Scavenge收集器"><a href="#3-3-Parallel-Scavenge收集器" class="headerlink" title="3.3 Parallel Scavenge收集器"></a>3.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 Parallel Scavenge收集器关注点是吞吐量（如何高效率的利用CPU）。 CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。 <strong>所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。（吞吐量：CPU用于用户代码的时间/CPU总消耗时间的比值，即=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)。比如，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。） 运行示意图：</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731144823884.png" alt="image-20210731144823884" style="zoom:50%;" /><h3 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1 特点"></a>3.3.1 特点</h3><ul><li>新生代收集器；</li><li>采用复制算法；</li><li>多线程收集；</li><li>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）；</li></ul><h3 id="3-3-2-应用场景"><a href="#3-3-2-应用场景" class="headerlink" title="3.3.2 应用场景"></a>3.3.2 应用场景</h3><ul><li>高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；</li><li>当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互；</li><li>例如，那些执行批量处理、订单处理（对账等）、工资支付、科学计算的应用程序；</li></ul><h3 id="3-3-3-设置参数"><a href="#3-3-3-设置参数" class="headerlink" title="3.3.3 设置参数"></a>3.3.3 设置参数</h3><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量：</p><ul><li>控制最大垃圾收集停顿时间 “-XX:MaxGCPauseMillis”</li><li>控制最大垃圾收集停顿时间，大于0的毫秒数； MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；因为可能导致垃圾收集发生得更频繁； 设置垃圾收集时间占总时间的比率 “-XX:GCTimeRatio”</li><li>设置垃圾收集时间占总时间的比率，0 &lt; n &lt; 100的整数； GCTimeRatio相当于设置吞吐量大小； 垃圾收集执行时间占应用程序执行时间的比例的计算方法是： 1 / (1 + n) 。 例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5% = 1/(1+19)；默认值是1% = 1/(1+99)，即n=99； 垃圾收集所花费的时间是年轻一代和老年代收集的总时间； 如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；</li></ul><h2 id="3-4-Serial-Old收集器"><a href="#3-4-Serial-Old收集器" class="headerlink" title="3.4 Serial Old收集器"></a>3.4 Serial Old收集器</h2><p>Serial收集器的老年代版本，它同样是一个单线程收集器。 它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731143820628.png" alt="image-20210731143820628" style="zoom:50%;" /><h3 id="3-4-1-特点"><a href="#3-4-1-特点" class="headerlink" title="3.4.1 特点"></a>3.4.1 特点</h3><ul><li><strong>针对老年代；</strong></li><li>采用”标记-整理-压缩”算法（Mark-Sweep-Compact）；</li><li>单线程收集；</li></ul><h3 id="3-4-2-应用场景"><a href="#3-4-2-应用场景" class="headerlink" title="3.4.2 应用场景"></a>3.4.2 应用场景</h3><ul><li>主要用于Client模式；</li><li>而在Server模式有两大用途：<br>（A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配Parallel Scavenge收集器）；<br>（B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用；</li></ul><h2 id="3-5-Parallel-Old收集器"><a href="#3-5-Parallel-Old收集器" class="headerlink" title="3.5 Parallel Old收集器"></a>3.5 Parallel Old收集器</h2><p>Parallel Scavenge收集器的老年代版本。 使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 在JDK1.6才有的。</p><h3 id="3-5-1-特点"><a href="#3-5-1-特点" class="headerlink" title="3.5.1 特点"></a>3.5.1 特点</h3><ul><li><strong>针对老年代；</strong></li><li>采用”标记-整理-压缩”算法；</li><li>多线程收集； Parallel Scavenge/Parallel Old收集器运行示意图如下</li></ul><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731145301909.png" alt="image-20210731145301909" style="zoom:50%;" /><h3 id="3-5-2-应用场景"><a href="#3-5-2-应用场景" class="headerlink" title="3.5.2 应用场景"></a>3.5.2 应用场景</h3><ul><li>JDK1.6及之后用来代替老年代的Serial Old收集器；</li><li>特别是在Server模式，多CPU的情况下； 这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge（新生代）加Parallel Old（老年代）收集器的”给力”应用组合；</li></ul><h3 id="3-5-3-设置参数"><a href="#3-5-3-设置参数" class="headerlink" title="3.5.3 设置参数"></a>3.5.3 设置参数</h3><p>指定使用Parallel Old收集器: “-XX:+UseParallelOldGC”</p><h2 id="3-6-CMS（Concurrent-Mark-Sweep）收集器"><a href="#3-6-CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="3.6 CMS（Concurrent Mark Sweep）收集器"></a>3.6 CMS（Concurrent Mark Sweep）收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。<code>它非常适合在注重用户体验的应用上使用</code>。</p><h3 id="3-6-1-特点"><a href="#3-6-1-特点" class="headerlink" title="3.6.1 特点"></a>3.6.1 特点</h3><ul><li><strong>针对老年代</strong></li><li>基于”标记-清除”算法(不进行压缩操作，会产生内存碎片)</li><li>以获取最短回收停顿时间为目标</li><li>并发收集、低停顿</li><li>需要更多的内存 CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器； 第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</li></ul><h3 id="3-6-2-应用场景"><a href="#3-6-2-应用场景" class="headerlink" title="3.6.2 应用场景"></a>3.6.2 应用场景</h3><ul><li>与用户交互较多的场景；（如常见WEB、B/S-浏览器/服务器模式系统的服务器上的应用）</li><li>希望系统停顿时间最短，注重服务的响应速度； 以给用户带来较好的体验；</li></ul><h3 id="3-6-3-CMS收集器运作过程"><a href="#3-6-3-CMS收集器运作过程" class="headerlink" title="3.6.3 CMS收集器运作过程"></a>3.6.3 CMS收集器运作过程</h3><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程可分为四个步骤：</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731145628763.png" alt="image-20210731145628763" style="zoom:50%;" /><ul><li>初始标记： 暂停所有的其他线程，初始标记仅仅标记GC Roots能直接关联到的对象，速度很快；</li><li>并发标记 并发标记就是进行GC Roots Tracing的过程； 同时开启GC和用户线程，<strong>用一个闭包结构去记录可达对象</strong>。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方；</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录（采用多线程并行执行来提升效率）；需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</li><li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫，回收所有的垃圾对象； 由于整个过程耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。 所以总体来说，CMS的内存回收是与用户线程一起“并发”执行的。</li></ul><h3 id="3-6-4参数设置"><a href="#3-6-4参数设置" class="headerlink" title="3.6.4参数设置"></a>3.6.4参数设置</h3><p>指定使用CMS收集器 “-XX:+UseConcMarkSweepGC”</p><h3 id="3-6-5-CMS收集器缺点"><a href="#3-6-5-CMS收集器缺点" class="headerlink" title="3.6.5 CMS收集器缺点"></a>3.6.5 CMS收集器缺点</h3><h4 id="3-6-5-1-对CPU资源敏感"><a href="#3-6-5-1-对CPU资源敏感" class="headerlink" title="3.6.5.1 对CPU资源敏感"></a>3.6.5.1 对CPU资源敏感</h4><p>面向并发设计的程序都对CPU资源比较敏感（并发程序的特点）。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。（在对账系统中，不适合使用CMS收集器）。 CMS的默认收集线程数量是=(CPU数量+3)/4； 当CPU数量越多，回收的线程占用CPU就少。 也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。（比如 CPU=2时，那么就启动一个线程回收，占了50%的CPU资源。） （一个回收线程会在回收期间一直占用CPU资源）</p><p>针对这种情况，曾出现了”增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）； 类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间； 但效果并不理想，JDK1.6后就官方不再提倡用户使用。</p><h4 id="3-6-5-2-无法处理浮动垃圾"><a href="#3-6-5-2-无法处理浮动垃圾" class="headerlink" title="3.6.5.2 无法处理浮动垃圾"></a>3.6.5.2 无法处理浮动垃圾</h4><p>无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败 在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；</p><p><strong>解决办法：</strong> 这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集； 也可以认为CMS所需要的空间比其他垃圾收集器大； 可以使用”-XX:CMSInitiatingOccupancyFraction”，设置CMS预留老年代内存空间； </p><h4 id="3-6-5-3-产生大量内存碎片"><a href="#3-6-5-3-产生大量内存碎片" class="headerlink" title="3.6.5.3 产生大量内存碎片"></a>3.6.5.3 产生大量内存碎片</h4><p>由于CMS是基于“标记+清除”算法来回收老年代对象的，因此长时间运行后会产生大量的空间碎片问题，可能导致新生代对象晋升到老生代失败。 由于碎片过多，将会给大对象的分配带来麻烦。因此会出现这样的情况，<strong>老年代还有很多剩余的空间，但是找不到连续的空间来分配当前对象，这样不得不提前触发一次Full GC</strong>。</p><ul><li>解决办法 使用”-XX:+UseCMSCompactAtFullCollection”和”-XX:+CMSFullGCsBeforeCompaction”，需要结合使用。</li><li>UseCMSCompactAtFullCollection “-XX:+UseCMSCompactAtFullCollection”</li></ul><p>为了解决空间碎片问题，CMS收集器提供−XX:+UseCMSCompactAlFullCollection标志，使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程； 但合并整理过程无法并发，停顿时间会变长； 默认开启（但不会进行，需要结合CMSFullGCsBeforeCompaction使用）；</p><ul><li>CMSFullGCsBeforeCompaction 由于合并整理是无法并发执行的，空间碎片问题没有了，但是有导致了连续的停顿。因此，可以使用另一个参数−XX:CMSFullGCsBeforeCompaction，表示在多少次不压缩的Full GC之后，对空间碎片进行压缩整理。 可以减少合并整理过程的停顿时间； 默认为0，也就是说每次都执行Full GC，不会进行压缩整理； 由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大；</li></ul><h3 id="3-6-6-CMS-amp-Parallel-Old"><a href="#3-6-6-CMS-amp-Parallel-Old" class="headerlink" title="3.6.6 CMS&amp;Parallel Old"></a>3.6.6 CMS&amp;Parallel Old</h3><p>总体来看，CMS与Parallel Old垃圾收集器相比，<font color=red>CMS减少了执行老年代垃圾收集时应用暂停的时间； 但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间</font>； （原因：CMS不进行内存空间整理节省了时间，但是可用空间不再是连续的了，垃圾收集也不能简单的使用指针指向下一次可用来为对象分配内存的地址了。</p><p>相反，这种情况下，需要使用可用空间列表。即，会创建一个指向未分配区域的列表，每次为对象分配内存时，会从列表中找到一个合适大小的内存区域来为新对象分配内存。这样做的结果是，<font color=red>老年代上的内存的分配比简单实用碰撞指针分配内存消耗大。</font>这也会增加年轻代垃圾收集的额外负担，因为老年代中的大部分对象是在新生代垃圾收集的时候从新生代提升为老年代的。） 当新生代对象无法分配过大对象，就会放到老年代进行分配。</p><h2 id="3-7-G1收集器"><a href="#3-7-G1收集器" class="headerlink" title="3.7 G1收集器"></a>3.7 G1收集器</h2><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation)。</p><p>G1（Garbage-First）是JDK7-u4才推出商用的收集器；<br>G1 (Garbage-First)是一款<strong>面向服务器的垃圾收集器</strong>，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。<br><strong>G1的使命是在未来替换CMS，并且在JDK1.9已经成为默认的收集器。</strong></p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731151137749.png" alt="image-20210731151137749" style="zoom:33%;" /><h3 id="3-7-1-特点"><a href="#3-7-1-特点" class="headerlink" title="3.7.1 特点"></a>3.7.1 特点</h3><h4 id="3-7-1-1-并行与并发"><a href="#3-7-1-1-并行与并发" class="headerlink" title="3.7.1.1 并行与并发"></a>3.7.1.1 并行与并发</h4><p>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731154444389.png" alt="image-20210731154444389" style="zoom:50%;" /><h4 id="3-7-1-2-分代收集"><a href="#3-7-1-2-分代收集" class="headerlink" title="3.7.1.2 分代收集"></a>3.7.1.2 分代收集</h4><p>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p><ul><li>能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；</li><li>能够采用不同方式处理不同时期的对象；</li><li>虽然保留分代概念，但Java堆的内存布局有很大差别；</li><li>将整个堆划分为多个大小相等的独立区域（Region）；</li><li>新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；</li></ul><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731151108695.png" alt="image-20210731151108695" style="zoom:50%;" /><h3 id="3-7-2-空间整合"><a href="#3-7-2-空间整合" class="headerlink" title="3.7.2 空间整合"></a>3.7.2 空间整合</h3><p>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p><ul><li>从整体看，是基于标记-整理算法；</li><li>从局部（两个Region间）看，是基于复制算法；<br>这是一种类似火车算法的实现；<br>不会产生内存碎片，有利于长时间运行；</li></ul><blockquote><p>（火车算法是分代收集器所用的算法，目的是在成熟对象空间中提供限定时间的渐进收集。在后面一篇中会专门介绍）</p></blockquote><h3 id="3-7-3-可预测的停顿"><a href="#3-7-3-可预测的停顿" class="headerlink" title="3.7.3 可预测的停顿"></a>3.7.3 可预测的停顿</h3><p>这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型。可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒。在低停顿的同时实现高吞吐量。</p><h3 id="3-7-4-G1收集器延伸"><a href="#3-7-4-G1收集器延伸" class="headerlink" title="3.7.4 G1收集器延伸"></a>3.7.4 G1收集器延伸</h3><h4 id="3-7-4-1-为什么G1可以实现可预测停顿"><a href="#3-7-4-1-为什么G1可以实现可预测停顿" class="headerlink" title="3.7.4.1 为什么G1可以实现可预测停顿"></a>3.7.4.1 为什么G1可以实现可预测停顿</h4><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731154741680.png" alt="image-20210731154741680" style="zoom:50%;" /><p>可以有计划地避免在Java堆的进行全区域的垃圾收集； G1收集器将内存分大小相等的独立区域（Region），新生代和老年代概念保留，但是已经不再物理隔离。 G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表； 每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）； 这就保证了在有限的时间内可以获取尽可能高的收集效率；</p><h4 id="3-7-4-2-一个对象被不同区域引用的问题"><a href="#3-7-4-2-一个对象被不同区域引用的问题" class="headerlink" title="3.7.4.2 一个对象被不同区域引用的问题"></a>3.7.4.2 一个对象被不同区域引用的问题</h4><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ 在其他的分代收集器，也存在这样的问题（而G1更突出）：回收新生代也不得不同时扫描老年代？ 这样的话会降低Minor GC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描： 每个Region都有一个对应的Remembered Set； 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）； 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中； 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set； 就可以保证不进行全局扫描，也不会有遗漏。</p><h3 id="3-7-5-应用场景"><a href="#3-7-5-应用场景" class="headerlink" title="3.7.5 应用场景"></a>3.7.5 应用场景</h3><ul><li><strong>面向服务端应用，针对具有大内存、多处理器的机器；</strong></li><li>最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （实践：对账系统中将CMS垃圾收集器修改为G1，降低对账时间20秒以上）</li></ul><blockquote><p>具体什么情况下应用G1垃圾收集器比CMS好，可以参考以下几点（但不是绝对）： 超过50％的Java堆被活动数据占用； 对象分配频率或年代的提升频率变化很大； GC停顿时间过长（长于0.5至1秒）； 建议： 如果现在采用的收集器没有出现问题，不用急着去选择G1； 如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS只有需要实际场景测试才知道。（如果使用G1后发现性能还没有使用CMS好，那么还是选择CMS比较好）</p></blockquote><h3 id="3-7-6-设置参数"><a href="#3-7-6-设置参数" class="headerlink" title="3.7.6 设置参数"></a>3.7.6 设置参数</h3><p>可以通过下面的参数，来设置一些G1相关的配置。 指定使用G1收集器： “-XX:+UseG1GC”</p><p>当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45： “-XX:InitiatingHeapOccupancyPercent”</p><p>为G1设置暂停时间目标，默认值为200毫秒： “-XX:MaxGCPauseMillis”</p><p>设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region: “-XX:G1HeapRegionSize”</p><p>新生代最小值，默认值5%: “-XX:G1NewSizePercent”</p><p>新生代最大值，默认值60%: “-XX:G1MaxNewSizePercent”</p><p>设置STW期间，并行GC线程数: “-XX:ParallelGCThreads”</p><p>设置并发标记阶段，并行执行的线程数: “-XX:ConcGCThreads”</p><p>G1在标记过程中，每个区域的对象活性都被计算，在回收时候，就可以根据用户设置的停顿时间，选择活性较低的区域收集，这样既能保证垃圾回收，又能保证停顿时间，而且也不会降低太多的吞吐量。Remark（重新标记）阶段新算法的运用，以及收集过程中的压缩，都弥补了CMS不足。 引用Oracle官网的一句话：“G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS)”。 G1计划作为并发标记-清除收集器(CMS)的长期替代品</p><h1 id="4、如何选择垃圾收集器"><a href="#4、如何选择垃圾收集器" class="headerlink" title="4、如何选择垃圾收集器"></a>4、如何选择垃圾收集器</h1><p>垃圾收集器主要可以分为如下三大类：</p><ul><li><strong>串行收集器</strong>：Serial和Serial Old<br>只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。</li><li><strong>并行收集器</strong>[<strong>吞吐量优先</strong>]：Parallel Scanvenge和Parallel Old<br>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场景 。</li><li><strong>并发收集器</strong>[<strong>停顿时间优先</strong>]：CMS和G1。<br>用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。 适用于对时间有要求的场景，比如Web应用。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/142273073">https://zhuanlan.zhihu.com/p/142273073</a></p><p><a href="https://juejin.cn/post/6844903877024677901">https://juejin.cn/post/6844903877024677901</a></p><p><a href="https://juejin.cn/post/6844904159817236494">面试官：你对JVM垃圾收集器了解吗？13连问你是否抗的住！</a></p><p><a href="https://juejin.cn/post/6874060477031579661#heading-32">https://juejin.cn/post/6874060477031579661#heading-32</a></p><p><a href="https://juejin.cn/post/6844904041080684552">https://juejin.cn/post/6844904041080684552</a></p><p><a href="https://juejin.cn/post/6844904159817236494#heading-14">https://juejin.cn/post/6844904159817236494#heading-14</a></p><p><a href="https://juejin.cn/post/6844903892774289421#heading-20">https://juejin.cn/post/6844903892774289421#heading-20</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、什么是垃圾收集器&quot;&gt;&lt;a href=&quot;#1、什么是垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;1、什么是垃圾收集器&quot;&gt;&lt;/a&gt;1、什么是垃圾收集器&lt;/h1&gt;&lt;p&gt;如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾回收机制</title>
    <link href="http://example.com/wiki/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/wiki/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-07-30T11:49:33.000Z</published>
    <updated>2021-07-31T06:15:06.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>垃圾回收总体思路：</strong></p><p>1、什么是垃圾回收，为什么需要垃圾回收；</p><p>2、回收的到底是什么？由谁来回收谁？</p><p>3、回收的判断标准是什么</p><p>4、什么时候回收，回收的种类和流程是怎样的</p><p>5、在哪些地方进行回收</p><hr><h1 id="1-什么是垃圾回收"><a href="#1-什么是垃圾回收" class="headerlink" title="1. 什么是垃圾回收"></a>1. 什么是垃圾回收</h1><p>任何语言在运行过程中都会创建对象，也就意味着需要在内存中为这些对象在内存中分配空间，在这些对象失去使用的意义的时候，需要释放掉这些内容，保证内存能够提供给新的对象使用。<strong>对于对象内存的释放就是垃圾回收机制，也叫做gc</strong>。</p><p>对于java开发者来说gc是一个双刃剑，一方面，java程序员在开发程序的时候不需要像开发C++那样手动分配对象的内存，还要在合适的时机手动释放，一定程度地降低了java程序员的开发难度。另一方面，虚拟机可以帮助程序开发人员管理内存，如果程序员不了解虚拟机垃圾回收的原理，很容易引起OOM，造成服务的崩溃和系统的宕机；</p><h1 id="2、对象如何判活"><a href="#2、对象如何判活" class="headerlink" title="2、对象如何判活"></a>2、对象如何判活</h1><p>对象存活表示的是当前对象是否还在被使用，没有被使用的对象我们可以称其为已经“死亡”，如果对象依然在被使用，我们称其为“存活”状态，对象是否被使用则是通过对象的引用进行判断的。而垃圾回收机制就是负责将已经死亡的对象进行清理。</p><p><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生</strong>，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作。<code>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的</code>，因此这几个区域的内存分配和回收都具备确定性，在这几个区域不需要过多的考虑回收的问题，当方法结束或者线程结束的时候，内存自然就跟着回收了。</p><p>Java堆则和上述三种区域不同，Java中一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，而**只有当<code>Java程序运行时我们才能知道哪些对象会被创建**</code>，所以堆中的内存分配和回收都是<code>动态</code>进行的，因此垃圾收集器所关注的也是这部分的内存。</p><p>垃圾回收器在对堆进行回收前，第一件事情就是要判断堆中的对象哪些是依旧在使用的，哪些已经不可能再被使用了。这里的判断主要有两种方式，第一种是引用计数算法，第二种是可达性分析算法。</p><h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p>引用计数算法给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的。这种算法实现简单，判定效率也很高，<font color=red>但是它难以解决对象之间循环引用的问题</font>，例如对象A和对象B相互引用了对方，而A和B都没有在被使用了，但这两个对象却也不会被垃圾回收器回收。</p><h2 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h2><p>主流的判断方法则是使用可达性分析算法来判断对象是否存活。这个算法需要选择一些对象作为“GC Roots”，每次都通过这些roots节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots不存在引用链的时候，则证明这个对象是不可用的。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730201240815.png" alt="image-20210730201240815" style="zoom:50%;" /><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><p>1、虚拟机栈中引用的对象<br>2、方法区中类静态属性引用的对象<br>3、方法区中常量引用的对象<br>4、本地方法栈中JNI（即Native方法）引用的对象</p><p>可达性分析算法中根据GC Roots找引用链，存在两个主要的问题。</p><p>一个是可作为GC Roots的节点主要在全局性的引用（例如常量或者类静态属性）于上下文(例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，将会消耗很多的时间。</p><p>还有一个问题是GC停顿，可达性分析必须确保在整个的分析过程中，执行系统就像被冻结在某个时间节点，整个分析过程中对象的引用关系不能发生变化，这样才能保证分析结果的准确性，因此在进行GC时，需要停顿所有的Java线程。（Stop The World）</p><h2 id="3-3-对象两次标记判活"><a href="#3-3-对象两次标记判活" class="headerlink" title="3.3 对象两次标记判活"></a>3.3 对象两次标记判活</h2><p>即使在可达性分析算法中不可达的对象，也并非是”非死不可“的，这时候它们暂时处于”缓刑“阶段，<em><strong>要宣告一个对象死亡，至少要经历两次标记过程</strong></em>：</p><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法(当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行“)。</p><p>如果一个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里的执行是指由虚拟机去触发这个方法，但并不一定会等待该方法执行完毕（为了避免finalize方法中出现类似死循环都操作，导致内存无法被回收，同时导致F-Queue队列中的其他对象一直处于等待状态）。</p><p>当执行完finalze()方法后，GC将会对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()方法中又重新获得了引用，对象将会被移出对列并且继续存活，如果对象依旧存在于队列中并且被进行第二次标记，对象将被GC回收。</p><p>需要注意的是任何一个对象的finalize()方法只会执行一次，如果第一次通过finalize()方法救活了对象，那么第二次相同的方法就会失效。同时由于finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此应当尽量避免使用finalize()方法。</p><h1 id="3-对象引用分类"><a href="#3-对象引用分类" class="headerlink" title="3. 对象引用分类"></a>3. 对象引用分类</h1><p>JDK1.2以前，Java中引用的定义很传统，如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义下的对象只存在两种状态，被引用和未被引用状态。但有些对象我们希望当内存存够的时候能够保留这些对象，当内存不足的时候则能够对这些对象进行清理，这一类对象则无法使用这种传统的定义来表示。</p><p>JDK1.2之后，Java对引用进行了扩充，将引用分为<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>四种，这四种引用的强度依次逐渐减弱。</p><h2 id="3-1-强引用"><a href="#3-1-强引用" class="headerlink" title="3.1 强引用"></a>3.1 强引用</h2><p>就是指在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。即使内存不足时，垃圾回收器也不会回收强引用的对象，而是会直接抛出<code>OutOfMemoryError</code>异常。如果想让强引用对象被回收，可以手动设置obj = null;来实现。</p><h2 id="3-2-软引用"><a href="#3-2-软引用" class="headerlink" title="3.2 软引用"></a>3.2 软引用</h2><p>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在内存足够的时候，是不会回收软引用的对象的，而在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果软引用回收后依然内存不足，则会抛出OutOfMemoryError异常。在JDK1.2之后，提供了SoftReference类来实现软引用。<code>软引用可以用来实现缓存技术。</code></p><h2 id="3-3-弱引用"><a href="#3-3-弱引用" class="headerlink" title="3.3 弱引用"></a>3.3 弱引用</h2><p>弱引用和软引用一样用来描述非必须的对象，但是它的强度比软引用更弱一些，被<code>弱引用关联的对象只能生存到下一次垃圾收集发生之前</code>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了<code>WeakReference</code>类来实现弱引用。</p><h2 id="3-4-虚引用"><a href="#3-4-虚引用" class="headerlink" title="3.4 虚引用"></a>3.4 虚引用</h2><p>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p><h1 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4.垃圾回收算法"></a>4.垃圾回收算法</h1><p><em>垃圾收集算法的目的是在已经明确了哪些内存块需要回收以后，如何高效的回收这些内存空间。</em></p><h2 id="4-1-标记清除算法"><a href="#4-1-标记清除算法" class="headerlink" title="4.1 标记清除算法"></a>4.1 标记清除算法</h2><p><strong>标记-清除算法</strong>采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203128783.png" alt="image-20210730203128783" style="zoom:50%;" /><p>标记清除算法主要有两个不足之处：一个是效率问题，标记和清除两个过程的效率都不高；另一个问题是空间问题，标记清除之后会造成内存空间中存在大量的内存碎片，空间碎片太多时，当要分配一片大内存空间时可能会找不到合适的连续内存空间进行分配，从而触发另一次垃圾收集动作。</p><h2 id="4-2-标记复制算法"><a href="#4-2-标记复制算法" class="headerlink" title="4.2 标记复制算法"></a>4.2 标记复制算法</h2><p>该算法的提出是为了克服<strong>句柄的开销</strong>和<strong>解决堆碎片</strong>的垃圾回收。建立在存活对象少，垃圾对象多的前提下。此算法<code>每次只处理正在使用中的对象</code>，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现碎片问题。但缺点也是很明显，就是需要两倍内存空间。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203413207.png" alt="image-20210730203413207" style="zoom:50%;" /><p>它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p><p>现在的商业虚拟机都会<code>采用这种算法来回收新生代</code>，根据统计新生代中98%的对象都是“朝夕生死”的，因此对于新生代的回收不用按照1:1的比例来进行内存划分，可以将内存划分为一块Eden区域和两块Survivor空间，每次使用时都选择Eden区域和一块Survivor区域进行内存分配。<em><strong>当回收时，将Eden区域和Survivor区域中还存活的对象全部移动到另一块Survivor区域，然后清理掉Eden区域和刚刚使用的Survivor区域。</strong></em></p><p><em><strong>HotSpot虚拟机中Eden和Survivor的比例是1:8</strong></em>，<em><strong>即每次都有90%的内存空间在进行使用，只有10%的内存空间被浪费了。</strong></em>当然，如果每次内存都有98%被回收，那么每次被移动到另一块Survivor区域的内存只有2%，这样是没有任何问题的，但是如果移动到另一块Survivor区域的内存超过了10%，就需要依赖其他的内存（这里指老年代）进行分配担保了（将多出的对象分配到老年代）。</p><h2 id="4-3-标记整理算法"><a href="#4-3-标记整理算法" class="headerlink" title="4.3 标记整理算法"></a>4.3 标记整理算法</h2><p> 此算法是结合了“标记-清除”和“复制算法”两个算法的优点。避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730203709050.png" alt="image-20210730203709050" style="zoom:50%;" /><p>标记-整理算法的标记过程和标记-清除算法的标记过程一致，但是在标记完以后，标记-整理算法会将所有存活的对象都移动到一端，然后再进行清除。<strong>这种算法适用于老年代</strong>，因为老年代的对象存活率都会比较高，如果像之前一样进行复制移动，将会产生大量的复制操作导致效率变低，同时每次都会存活下大量对象导致需要很多的内存空间来进行分配担保。</p><h2 id="4-4-分代收集算法"><a href="#4-4-分代收集算法" class="headerlink" title="4.4 分代收集算法"></a>4.4 分代收集算法</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210731141452995.png" alt="image-20210731141452995" style="zoom:50%;" /><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法根据对象存活周期的不同将内存划分为几块，一般是把Java堆划分位新生代和老年代。新生代中每次都会有大批对象死去，只有少量对象存活，因此可以选用复制算法。</p><p>老年代每次都会有大量对象存活，因此选择标记-清理或者标记-整理算法来进行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;垃圾回收总体思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、什么是垃圾回收，为什么需要垃圾回收；&lt;/p&gt;
&lt;p&gt;2、回收的到底是什么？由谁来回收谁？&lt;/p&gt;
&lt;p&gt;3、回收的判断标准是什么&lt;/p&gt;
&lt;p&gt;4、什么时候回收，回收的种类和流程是怎样的&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-对象创建</title>
    <link href="http://example.com/wiki/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    <id>http://example.com/wiki/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/</id>
    <published>2021-07-30T06:42:55.000Z</published>
    <updated>2021-07-30T08:46:15.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-对象创建方式"><a href="#1-对象创建方式" class="headerlink" title="1.对象创建方式"></a>1.对象创建方式</h2><p>Java中有一下几种方式创建对象：</p><table><thead><tr><th><strong>方式</strong></th><th><strong>实质</strong></th></tr></thead><tbody><tr><td>使用new关键</td><td>调用无参或有参构造器函数创建</td></tr><tr><td>使用Class的newInstance方法</td><td>调用无参或有参构造器函数创建，且需要是publi的构造函数</td></tr><tr><td>使用Constructor类的newInstance方法</td><td>调用有参和私有private构造器函数创建，实用性更广</td></tr><tr><td>使用Clone方法</td><td>不调用任何参构造器函数，且对象需要实现Cloneable接口并实现其定义的clone方法，且默认为浅复制</td></tr><tr><td>第三方库Objenesis</td><td>利用了asm字节码技术，动态生成Constructor对象</td></tr></tbody></table><h2 id="2、对象创建过程"><a href="#2、对象创建过程" class="headerlink" title="2、对象创建过程"></a>2、对象创建过程</h2><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730153219366.png" alt="image-20210730153219366"></p><h3 id="2-1-类的加载"><a href="#2-1-类的加载" class="headerlink" title="2.1 类的加载"></a>2.1 类的加载</h3><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="2-2-分配内存"><a href="#2-2-分配内存" class="headerlink" title="2.2 分配内存"></a>2.2 分配内存</h3><p>类的加载检查通过后，接下来是为新生对象分配内存。但类加载完成后所需的内存大小就已经完全确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配内存有两种方式：</p><ul><li><strong>指针碰撞（Bump the Pointer）</strong>：假设java堆中内存是绝对规整的，所有用过得内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪到一段与对象大小相等的距离</li><li><strong>空闲列表（Free List）</strong>：如果java堆中的内存并不是完整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由java堆是否完整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理（标记-整理）功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>还有一个问题需要考虑，在虚拟机中对象频繁的创建（即使是修改一个指针所指的位置），在并发情况下会带来线程安全的问题。作为虚拟机来说，必须保证线程安全，所有虚拟机采用两种方式保证线程安全：</p><ul><li><strong>CAS+失败重试</strong>：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</li><li><strong>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</strong>：为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB的内存已用尽时，在采用上述的CAS进行内存分配</li></ul><h3 id="2-3-初始化零值"><a href="#2-3-初始化零值" class="headerlink" title="2.3 初始化零值"></a>2.3 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，<code>程序能访问到这些字段的数据类型所对应的零值</code>。</p><h3 id="2-4-设置对象头"><a href="#2-4-设置对象头" class="headerlink" title="2.4 设置对象头"></a>2.4 设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p><h3 id="2-5-执行Init方法"><a href="#2-5-执行Init方法" class="headerlink" title="2.5 执行Init方法"></a>2.5 执行Init方法</h3><p>在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从 Java 程序的视⻆来看，对象创建才刚开始， <code>&lt;init&gt;</code> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏ <code>&lt;init&gt;</code>⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。</p><h2 id="3-对象在内存布局"><a href="#3-对象在内存布局" class="headerlink" title="3.对象在内存布局"></a>3.对象在内存布局</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730160335842.png" alt="image-20210730160335842" style="zoom:33%;" /><p><code>对象头(Header)</code>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h2 id="4-对象访问"><a href="#4-对象访问" class="headerlink" title="4. 对象访问"></a>4. 对象访问</h2><p>建⽴对象就是为了使⽤对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问⽅式有虚拟机实现⽽定，⽬前主流的访问⽅式有使⽤句柄和直接指针两种：</p><h3 id="4-1-句柄访问"><a href="#4-1-句柄访问" class="headerlink" title="4.1 句柄访问"></a>4.1 句柄访问</h3><p> 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730160814175.png" alt="image-20210730160814175" style="zoom:50%;" /><h3 id="4-2-直接指针"><a href="#4-2-直接指针" class="headerlink" title="4 .2 直接指针"></a>4 .2 直接指针</h3><p> 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730161006154.png" alt="image-20210730161006154" style="zoom:50%;" /><p>这两种对象访问⽅式各有优势。使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。</p><h2 id="5、对象内存分配"><a href="#5、对象内存分配" class="headerlink" title="5、对象内存分配"></a>5、对象内存分配</h2><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730164126810.png" alt="image-20210730164126810" style="zoom:50%;" /><p>Java内存体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：<strong>给对象分配内存</strong>和<strong>回收分配给对象的内存</strong>。</p><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区域，如果启动了本地线程分配缓冲，将按线程优先分配在TLAB上。<code>少数情况下也可能直接分配在老年代中</code>。具体的分配规则取决于垃圾收集器的类型以及虚拟机中参数的配置。但是有几条最普遍的内存分配规则如下：</p><h3 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a>5.1 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区进行分配。当Eden区没有足够内存进行分配时，虚拟机将会发起一次Minor GC。</p><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h3><p>所谓大对象，是指需要大量连续存储空间的Java对象，最典型的大对象就是那种很长的字符串或者数组。大对象对虚拟机分配来说是一个坏消息，经常出现大对象会导致虚拟机需要经常调用GC来为这些大对象整理出足够的连续空间。</p><h3 id="5-3长期存活的对象将进入老年代"><a href="#5-3长期存活的对象将进入老年代" class="headerlink" title="5.3长期存活的对象将进入老年代"></a>5.3长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代。为了做到这一点，虚拟机给每一个对象定义了一个对象年龄计数器。如果对象在Eden出生并且经过了第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1。对象在Survivor区域中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）对象将会被晋身到老年代中。</p><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h3><p>为了能够更好的适应不同程序的内存状况，虚拟机并不是每次都要等到对象的年龄到达阈值才将对象移动到老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等待年龄增长。</p><h3 id="5-6-空间分配担保"><a href="#5-6-空间分配担保" class="headerlink" title="5.6 空间分配担保"></a>5.6 空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代中最大可用的连续空间是否大于新生代所有对象空间综合，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次GC是有风险的；如果小于，或者设置不允许，那这时将改为进行一次Full GC。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-对象创建方式&quot;&gt;&lt;a href=&quot;#1-对象创建方式&quot; class=&quot;headerlink&quot; title=&quot;1.对象创建方式&quot;&gt;&lt;/a&gt;1.对象创建方式&lt;/h2&gt;&lt;p&gt;Java中有一下几种方式创建对象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存结构</title>
    <link href="http://example.com/wiki/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/wiki/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-30T03:53:42.000Z</published>
    <updated>2021-07-30T07:34:46.274Z</updated>
    
    <content type="html"><![CDATA[<p>作为程序员，最常接触到Java虚拟机的部分应该是内存结构这一部分了，同样这一部分的内容很多，面试也是最常被问到的。虽然JDK已经发布了16版本，但是国内大部分企业都还在使用JDK8。 今天学习一下虚拟机的运行时数据区的组成和各个组件的功能。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730144621195.png" alt="image-20210730144621195" style="zoom:50%;" /><p>JDK8官方网站文档链接 – 》 <a href="https://docs.oracle.com/javase/8/docs/index.html">JDK</a></p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些数据区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户的启动和结束而建立和销毁。</p><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730141548126.png" alt="image-20210730141548126"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register），它是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的模型概念中，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。</p></blockquote><p>由于Java虚拟机的多线程是通过线程轮流切换处理器执行时间的方式实现的，在任何一个确定的时刻，一个处理器的一个核只会执行一条线程中的指令，因此，<font color=red>为了线程切换后能够恢复到正确的执行位置，每一条线程都需要拥有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储</font>，这类内存区域称为“线程私有”的内存，即如上图所示，每一个线程都会拥有自己的一块内存区域。</p><p>程序计数器在执行本地方法时（例如调用C语言代码）计数器值为空，其他时候则是指向正在执行的虚拟机字节码指令的地址。</p><p>程序计数器是在Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域，因为Java程序计数器它所需要存储的内容仅仅就是下一个需要待执行的命令的地址，其所需内存是创建时即可只晓的，不需要后期进行扩容等其他的操作。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stacks），<font color=red>Java虚拟机栈也是线程私有的,它的生命周期与线程相同</font>。Java每个方法在执行的同时都会创建一个栈帧用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至方法执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>虚拟机栈中局部变量表部分与Java对象内存分配关系密切，局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，该类型可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他于此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>局部变量表中，64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用一个。<code>局部变量表所需的内存空间在编译期间完成分配</code>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；<br>如果虚拟机栈可以动态拓展，如果拓展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈作用类似，它们之间的区别是虚拟机栈为虚拟机执行Java方法，而本地方法栈则为虚拟机执行Native方法服务。有些虚拟机会将本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会抛出StackOverflowErro和OutOfMemoryError异常。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap），对于大多数的应用来说，Java堆是虚拟机所管理的最大的一块内存。<code>Java堆是被所有的线程所共享的，在虚拟机启动时创建</code>。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存的（Java虚拟机规范中描述为所有的对象实例和数组都要在堆上分配内存）。</p><p><strong>Java堆是垃圾收集器管理的主要区域</strong>，因此很多时候也被称为GC堆。从内存回收的角度来看，由于现在收集器基本都是采用分代算法收集器，所以Java堆中还可以细分为：新生代和老年代；再细致一点可以分为Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>根据Java虚拟机规范，<em><strong>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可</strong></em>，在实现时既可以是固定大小的，也可以是可拓展的，当前主流的虚拟机都是按照可拓展来实现的。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出OutOfMemoryError异常。</p><p>在 Java 中，堆被划分成两个不同的区域：<strong>新生代 ( Young )<strong>、</strong>老年代 ( Old )<strong>。</strong>新生代 ( Young )</strong> 又被划分为三个区域：<strong>Eden</strong>、**From Survivor(S0)<strong>、</strong>To Survivor(S1)**。如图所示：</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730150932873.png" alt="image-20210730150932873" style="zoom: 30%;" /><p>这样划分的目的是为了使JVM能够更好的管理内存中的对象，包括内存的分配以及回收。  而新生代按eden和两个survivor的分法，是为了</p><ul><li>有效空间增大，eden+1个survivor；</li><li>有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其挪到老年代中，即只需扫描其中一个survivor。如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放。</li><li>两个Survivor区可解决内存碎片化</li></ul><h3 id="堆栈相关参数"><a href="#堆栈相关参数" class="headerlink" title="堆栈相关参数"></a>堆栈相关参数</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-Xms</td><td>堆内存初始大小，单位m、g</td></tr><tr><td>-Xmx</td><td>堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td>-Xmn</td><td>年轻代内存初始大小</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小，即JVM栈的大小</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值</td></tr><tr><td>-XX:NewSzie(-Xns)</td><td>年轻代内存初始大小,可以缩写-Xns</td></tr><tr><td>-XX:MaxNewSize(-Xmx)</td><td>年轻代内存最大允许大小，可以缩写-Xmx</td></tr><tr><td>-XX:SurvivorRatio</td><td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td></tr><tr><td>-XX:MinHeapFreeRatio</td><td>GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。</td></tr><tr><td>-XX:MaxHeapFreeRatio</td><td>预估堆内存是堆大小动态调控的重要选项之一。堆内存预估最大值一定小于或等于固定最大值(-Xmx指定的数值)。前者会根据使用情况动态调大或缩小，以提高GC回收的效率，默认70%</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄，设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td></tr><tr><td>-XX:InitialTenuringThreshold</td><td>可以设定老年代阀值的初始值</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td></tr></tbody></table><blockquote><p><strong>Note：</strong> 每次GC 后会调整堆的大小，为了<strong>防止动态调整带来的性能损耗</strong>，一般设置-<strong>Xms、-Xmx 相等</strong>。</p></blockquote><p>新生代的三个设置参数：-Xmn，-XX:NewSize，-XX:NewRatio的优先级：<br> （1）.最高优先级：  -XX:NewSize=1024m和-XX:MaxNewSize=1024m<br> （2）.次高优先级：  -Xmn1024m  （默认等效效果是：-XX:NewSize==-XX:MaxNewSize==1024m）<br> （3）.最低优先级：-XX:NewRatio=2<br> 推荐使用的是-Xmn参数，原因是这个参数很简洁，相当于一次性设定NewSize和MaxNewSIze，而且两者相等。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与Java堆一样，是线程共享的，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。<code>类加载的信息和数据就放在方法区。</code></p><p>Java虚拟机规范堆方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的内存回收成绩比较令人难以满意，尤其时类型卸载，条件相当苛刻，但是这个区域的内存回收也是必要的。</p><p>根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了类的版本、字段、方法、接口等描述信息以外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量池放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范所定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。</p><p>直接内存虽然不会受到Java堆大小的限制，但是受到本机总内存大小以及处理器寻址空间的限制，如果忽略了直接内存，当各个区域内存总和大于服务器内存时，将会导致动态拓展时出现OutOfMemoryError异常。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5</a></p><p><a href="https://blog.csdn.net/qq_21122519/article/details/94408118">https://blog.csdn.net/qq_21122519/article/details/94408118</a></p><p><a href="https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1">https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为程序员，最常接触到Java虚拟机的部分应该是内存结构这一部分了，同样这一部分的内容很多，面试也是最常被问到的。虽然JDK已经发布了16版本，但是国内大部分企业都还在使用JDK8。 今天学习一下虚拟机的运行时数据区的组成和各个组件的功能。&lt;/p&gt;
&lt;img src=&quot;ht</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-深入理解Java虚拟机</title>
    <link href="http://example.com/wiki/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://example.com/wiki/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2021-07-30T02:35:12.000Z</published>
    <updated>2021-07-30T08:25:55.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h2><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730150029336.png" alt="image-20210730150029336"></p><h2 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h2><ul><li><a href="https://geekibli.github.io/wiki/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">Java内存结构</a> </li><li><a href="https://geekibli.github.io/wiki/JVM-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/">Java对象创建</a></li><li><a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></li><li>类加载机制</li><li>垃圾回收机制</li><li>垃圾收集器</li><li>虚拟机调优</li></ul><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://blog.csdn.net/qq_21122519/article/details/94408118">JAVA虚拟机概述</a><br><a href="http://c.biancheng.net/view/3677.html">Java虚拟机（JVM）工作原理</a><br><a href="https://juejin.cn/post/6844903892774289421">推荐收藏系列：一文理解JVM虚拟机（内存、垃圾回收、性能优化）解决面试中遇到问题</a><br><a href="https://juejin.cn/post/6981790758290358302">Java虚拟机内存管理和性能调优</a><br><a href="https://juejin.cn/post/6844903494063751175">重读 JVM</a><br><a href="https://juejin.cn/post/6986594521752535053">【2021最新版】JVM面试题总结（87道题含答案解析）</a><br><a href="https://www.pdai.tech/md/java/jvm/java-jvm-classload.html">JVM 基础 - Java 类加载机制</a><br><a href="https://juejin.cn/post/6981643053396131853">JVM知识点整理</a><br><a href="https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1">https://www.processon.com/view/5ec5d7c60791290fe0768668?fromnew=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM结构图&quot;&gt;&lt;a href=&quot;#JVM结构图&quot; class=&quot;headerlink&quot; title=&quot;JVM结构图&quot;&gt;&lt;/a&gt;JVM结构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/code-xiaozhuang/</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程-深入理解volatile</title>
    <link href="http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/"/>
    <id>http://example.com/wiki/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/</id>
    <published>2021-07-29T08:25:05.000Z</published>
    <updated>2021-07-29T12:27:03.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h1><p>正确理解volatile</p><blockquote><p>多级cache结构 -&gt; 缓存一致性协议（MESI）-&gt; store buffer和invalidate queue -&gt; 内存屏障</p></blockquote><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>volatile的可见性依赖于Java内存模型。 可以参见之前的文章  👉 <a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></p><p><code>Java内存模型(JavaMemoryModel)</code>描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。</p><p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p><p><code>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量</code>。</p><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729170756502.png" alt="image-20210729170756502" style="zoom:35%;" /><p>volatile实现可见性</p><p>每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写会了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。</p><p>volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。</p><p>至于其他线程是如何更新缓存行中的数据以及其他线程的缓存行是如何失效的，可以参见之前的文章。 <a href="https://geekibli.github.io/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></p><h3 id="嗅探机制"><a href="#嗅探机制" class="headerlink" title="嗅探机制"></a>嗅探机制</h3><p>在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。</p><p>由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而<strong>嗅探是实现缓存一致性的常见机制</strong>。</p><p><strong>嗅探机制工作原理</strong>：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。</p><p>注意：</p><blockquote><p>基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。</p></blockquote><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p><strong>什么是指令重排序</strong>?</p><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p><p>【源代码】 -&gt; 【编译器优化重排序】-&gt; 【指令集并行重排序】-&gt; 【内存系统重排序】-&gt; 【最终执行指令序列】</p><p>一般重排序可以分为如下三种：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li></ul><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。</p><p>为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p><table><thead><tr><th align="center"><strong>内存屏障</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">StoreStore 屏障</td><td align="left">禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td align="center">StoreLoad 屏障</td><td align="left">防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td align="center">LoadLoad 屏障</td><td align="left">禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td align="center">LoadStore 屏障</td><td align="left">禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p><p><strong>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</strong></p><h3 id="volatile在DCL的应用"><a href="#volatile在DCL的应用" class="headerlink" title="volatile在DCL的应用"></a>volatile在DCL的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p><h3 id="一次性安全发布"><a href="#一次性安全发布" class="headerlink" title="一次性安全发布"></a>一次性安全发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>theFlooble</code> 引用不是 volatile 类型，<code>doWork()</code> 中的代码在解除对 <code>theFlooble</code> 的引用时，将会得到一个不完全构造的 <code>Flooble</code>。</p><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p><h2 id="无法保证原子性"><a href="#无法保证原子性" class="headerlink" title="无法保证原子性"></a>无法保证原子性</h2><p>所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p><p>在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 volatile 修饰的变量是<strong>线程不安全的</strong>。</p><p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 AtomicInteger）。</p><p>这里特别说一下，对任意单个使用 volatile 修饰的变量的读 / 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p><h1 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h1><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p><p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制。</p><p>volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</p><p>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</p><p>2、volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供<strong>原子性和互斥性</strong>。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</p><p>3、volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p><p>4、volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</p><p>5、volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</p><p>6、volatile可以使得long和double的赋值是原子的。</p><p>7、volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</p><hr><p><strong>参考资料</strong></p><p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时</a></p><p><a href="https://juejin.cn/post/6844903520760496141">面试官最爱的volatile关键字</a></p><p><a href="https://juejin.cn/post/6844903959107207175">一文吃透Volatile，征服面试官</a></p><p><a href="https://www.cnblogs.com/lidl/archive/2012/06/25/2561431.html">java语言的线程安全volatile用法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;volatile特性&quot;&gt;&lt;a href=&quot;#volatile特性&quot; class=&quot;headerlink&quot; title=&quot;volatile特性&quot;&gt;&lt;/a&gt;volatile特性&lt;/h1&gt;&lt;p&gt;正确理解volatile&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多级cac</summary>
      
    
    
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-synchronized关键字剖析</title>
    <link href="http://example.com/wiki/Java-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/wiki/Java-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</id>
    <published>2021-07-29T05:37:27.000Z</published>
    <updated>2021-07-29T07:56:57.965Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于synchronized关键字的文章，是当时听马士兵老师的公开课时记录的一些关键笔记📒 <a href="https://geekibli.github.io/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">链接🔗</a></p><p>下面我们还是要学习和总结一下synchronized</p><h2 id="synchronized-特性"><a href="#synchronized-特性" class="headerlink" title="synchronized 特性"></a>synchronized 特性</h2><ul><li>有序性<br><code>as-if-serial</code></li></ul><p>不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的，还有就是有数据依赖的也是不能重排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure><p>这两段是怎么都不能重排序的，b的值依赖a的值，a如果不先赋值，那就为空了。</p><ul><li>可见性<br>主要依靠Java内存模型实现</li><li>原子性<br>通过汇编指令控制</li><li>可重入<br>synchronized锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了</li><li>不可中断<br>不可中断就是指，一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断。<br>值得一提的是，Lock的tryLock方法是可以被中断的。</li></ul><h2 id="了解对象头"><a href="#了解对象头" class="headerlink" title="了解对象头"></a>了解对象头</h2><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>在64位的虚拟机中：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729145750638.png" alt="image-20210729145750638"></p><p><strong>32位虚拟机中：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729145831606.png" alt="image-20210729145831606"></p><p><strong>可以参见之前的文章</strong>  👉  <a href="https://geekibli.github.io/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/">Java对象头</a></p><h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><p>之前的文章已经在 <code>Java代码</code>、<code>字节码</code>、<code>JVM级别</code>和<code>汇编指令</code>四个级别介绍了synchronzied的实现。<br>JDK对synchronzied不断的优化，大家熟悉的锁升级过程，其实就是在源码里面，调用了不同的实现去获取获取锁，失败就调用更高级的实现，最后升级完成。</p><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729144552761.png" alt="image-20210729144552761"></p><p>升级方向：【 无锁 】 -&gt; 【 偏向锁 】-&gt; 【 轻量级锁 】-&gt; 【 重量级锁 】</p><p>Tip：<font color=red>切记这个升级过程是不可逆的</font>；</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>对象头是由 Mark Word 和 Class pointer 组成，锁争夺也就是对象头指向的Monitor对象的争夺，一旦有线程持有了这个对象，标志位修改为1，就进入偏向模式，同时会把这个线程的ID记录在对象的Mark Word中。</p><p>这个过程是采用了<code>CAS</code>乐观锁操作的，每次同一线程进入，虚拟机就不进行任何同步的操作了，对标志位+1就好了，不同线程过来，CAS会失败，也就意味着获取锁失败。</p><p>偏向锁在1.6之后是默认开启的，1.5中是关闭的，需要手动开启参数是xx:-UseBiasedLocking=false。</p><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。</p><p>当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。<code>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</code></p><p>偏向锁是指当一段同步代码<strong>一直被同一个线程所访问</strong>时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。<code>轻量级锁的获取及释放依赖多次 CAS 原子指令</code>，而<code>偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令</code>即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，<code>线程是不会主动释放偏向锁的。</code></p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果<code>线程不处于活动状态</code>，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><p><strong>偏向锁关闭，或者多个线程竞争偏向锁怎么办呢？</strong></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>还是跟Mark Work 相关，如果这个对象是无锁的，jvm就会在当前线程的栈帧中建立一个叫<code>锁记录（Lock Record）</code>的空间，用来存储锁对象的Mark Word 拷贝，然后把Lock Record中的owner指向当前对象。</p><p>JVM接下来会利用CAS尝试把对象原本的Mark Word 更新会Lock Record的指针，成功就说明加锁成功，改变锁标志位，执行相关同步操作。</p><p>如果失败了，就会判断当前对象的Mark Word是否指向了当前线程的栈帧，是则表示当前的线程已经持有了这个对象的锁，否则说明被其他线程持有了，继续锁升级，修改锁的状态，之后等待的线程也阻塞。</p><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>轻量级锁的获取主要由两种情况：<br>① 当关闭偏向锁功能时；<br>② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</p><p>一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。这里要明确一下什么是锁竞争：</p><blockquote><p>如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p></blockquote><img src='https://img-blog.csdnimg.cn/20200606123648335.png' width=600 height=650><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>我不是在上面提到了Linux系统的用户态和内核态的切换很耗资源，其实就是线程的等待唤起过程，那怎么才能减少这种消耗呢？</p><p>自旋，过来的现在就不断自旋，防止线程被挂起，一旦可以获取资源，就直接尝试成功，直到超出阈值，自旋锁的默认大小是10次，-XX：PreBlockSpin可以修改。</p><p>自旋都失败了，那就升级为重量级的锁，像1.5的一样，等待唤起咯。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729151704773.png" alt="image-20210729151704773" style="zoom:33%;" /><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p><ul><li>如果在同一个锁对象上，自旋等待之前成功获得过的锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，因此允许自旋等待持续相对更长的时间。</li><li>相反的，如果对于某个锁，自旋很少成功获得过，那么以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li></ul><p><strong>自适应自旋解决的是“锁竞争时间不确定”的问题</strong>。JVM很难感知确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资</p><p>大家在看ObjectMonitor源码的时候，会发现Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，对应的线程就是park()和upark()。<br>这个操作涉及用户态和内核态的转换了，这种切换是很耗资源的，所以知道为啥有自旋锁这样的操作了吧，按道理类似死循环的操作更费资源才是对吧？其实不是，大家了解一下就知道了。</p><blockquote><p>那用户态和内核态又是啥呢？</p></blockquote><img src='https://oscimg.oschina.net/oscnet/up-3d168748d90e18da228ce8f55a9cc4a6cc4.png' width=300 height=300><p>Linux系统的体系结构分为用户空间（应用程序的活动空间）和内核。我们所有的程序都在用户空间运行，进入用户运行状态也就是（用户态），但是很多操作可能涉及内核运行，比如涉及到I/O，我们就会进入内核运行状态（内核态）。</p><p>这个过程是很复杂的，也涉及很多值的传递，我简单概括下流程：</p><ul><li>用户态把一些数据放到寄存器，或者创建对应的堆栈，表明需要操作系统提供的服务。</li><li>用户态执行系统调用（系统调用是操作系统的最小功能单位）。</li><li>CPU切换到内核态，跳到对应的内存指定的位置执行指令。</li><li>系统调用处理器去读取我们先前放到内存的数据参数，执行程序的请求。</li><li>调用完成，操作系统重置CPU为用户态返回结果，并执行下个指令。</li></ul><p>所以大家一直说，1.6之前是重量级锁，没错，但是他重量的本质，是ObjectMonitor调用的过程，以及Linux内核的复杂运行机制决定的，大量的系统资源消耗，所以效率才低。<br>还有两种情况也会发生内核态和用户态的切换：异常事件和外围设备的中断 大家也可以了解下。</p><blockquote><p>普通的IO读写也会涉及到用户态和内核的切换，但是为了提升IO 的性能，操作系统可以通过 <code>零拷贝</code> 来实现，Redis和Kafka,还有netty的底层IO模型都存在零拷贝。</p></blockquote><h3 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h3><p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729150936860.png" alt="image-20210729150936860"></p><h2 id="synchronized和Lock对比"><a href="#synchronized和Lock对比" class="headerlink" title="synchronized和Lock对比"></a>synchronized和Lock对比</h2><p>我们先看看他们的区别：</p><ul><li>synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API。</li><li>synchronized会自动释放锁，而Lock必须手动释放锁。</li><li>synchronized是不可中断的，Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li></ul><p>两者一个是JDK层面的一个是JVM层面的，我觉得最大的区别其实在，我们是否需要丰富的api，还有一个我们的场景。</p><blockquote><p><strong>比如我现在是滴滴，我早上有打车高峰，我代码使用了大量的synchronized，有什么问题？锁升级过程是不可逆的，过了高峰我们还是重量级的锁，那效率是不是大打折扣了？这个时候你用Lock是不是很好？</strong></p></blockquote><h2 id="synchronized使用注意事项"><a href="#synchronized使用注意事项" class="headerlink" title="synchronized使用注意事项"></a>synchronized使用注意事项</h2><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。</p><blockquote><p> <strong>使用Synchronized有哪些要注意的？</strong></p></blockquote><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul><blockquote><p><strong>synchronized是公平锁吗？</strong></p></blockquote><p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，不过这种抢占的方式可以预防饥饿。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/bakari/p/5520860.html">Linux探秘之用户态与内核态</a></p><p><a href="https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ">傻瓜三歪让我教他「零拷贝」</a></p><p><a href="https://www.jianshu.com/p/8c255b942535">偏向锁、轻量级锁、重量级锁、自旋锁、自适应自旋锁</a></p><p><a href="https://www.cnblogs.com/mingyueyy/p/13054296.html">关于 锁的四种状态与锁升级过程 图文详解</a></p><p><a href="https://mp.weixin.qq.com/s/2ka1cDTRyjsAGk_-ii4ngw">死磕Synchronized底层实现</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前写过一篇关于synchronized关键字的文章，是当时听马士兵老师的公开课时记录的一些关键笔记📒 &lt;a href=&quot;https://geekibli.github.io/wiki/Java-synchronzied%E5%BA%95%E5%B1%82%E5%8E%9</summary>
      
    
    
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式-秒杀系统设计</title>
    <link href="http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-07-29T03:03:58.000Z</published>
    <updated>2021-07-29T03:48:33.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀系统的挑战"><a href="#秒杀系统的挑战" class="headerlink" title="秒杀系统的挑战"></a>秒杀系统的挑战</h1><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>秒杀活动的特点就是短时间内聚集大量请求瞬时到达服务端，此时数据库已经无法支撑如此大数据量的请求了。单个的数据库QPS仅有几百，你可能会想，那我是不是可以部署一个数据库集群呢，在数据库集群前使用Nginx分发，将负载平均分摊到每一个数据库不就可以了吗。<br>这种方式一定程度上是可以的，但是国内真正的互联网大厂肯定不是这样做的，在高并发的情况下完全可以使用内存操作来代替访问数据库，比如Redis集群。在网络带宽允许的情况下，Redis的集群的系统吞吐量肯定和数据库集群不是一个量级的，这里要查几十倍几百倍。</p><h2 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h2><p>超卖最直接的后果就是可能会对公司造成直接的经济损失。防止超卖是秒杀系统必须要保证的一点。超卖的解决办法就是加锁，保证在高并发的情况下库存可以正常的正确的扣减。</p><h2 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h2><h3 id="产品层策略"><a href="#产品层策略" class="headerlink" title="产品层策略"></a>产品层策略</h3><p>秒杀器一般下单和购买及其迅速，根据购买记录可以甄别出一部分。可以通过校验码达到一定的方法，这就要求校验码足够安全，不被破解，采用的方式有：秒杀专用验证码，电视公布验证码，秒杀答题。</p><h3 id="前端控制"><a href="#前端控制" class="headerlink" title="前端控制"></a>前端控制</h3><p>除此之外前段可以添加点击次数限制，点击一定次数之后，将按钮置灰色，或者在js层级进行控制，用户看到的是每次都点击成功了，但是仅仅发起一次服务端请求；</p><h3 id="后端控制"><a href="#后端控制" class="headerlink" title="后端控制"></a>后端控制</h3><ul><li>添加消息队列，消息执行一定数量时，队列后续的消息不在执行</li><li>后端架构按照模块拆分，用户不同的请求分散转发到各个模块的服务器，负载均衡</li><li>数据库分库分表（分片策略）和redis集群</li><li>升级服务器带宽，压力测试，保证系统吞吐量</li><li>过载保护，限流，请求拒绝和服务降级</li></ul><h2 id="链接加盐"><a href="#链接加盐" class="headerlink" title="链接加盐"></a>链接加盐</h2><p>链接加盐一定程度上可以保护恶意攻击，比如下单接口，如果暴露之后，就会存在恶意攻击，一个用户下了几百个单的情况或者一个IP下了很多单子，类似与黄牛抢票之后再去售卖。</p><h1 id="秒杀系统架构图（参考）"><a href="#秒杀系统架构图（参考）" class="headerlink" title="秒杀系统架构图（参考）"></a>秒杀系统架构图（参考）</h1><img src='https://oscimg.oschina.net/oscnet/up-a6fa908f7ee0f098a7a7eb4965dd282124b.png'><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/KWb3POodisbOEsQVblsoGw"> 敖丙带你设计【秒杀系统】</a><br><a href="https://mp.weixin.qq.com/s/z2S1EjWQDwKm5Ud36IenNw">《吊打面试官》系列-秒杀系统设计</a><br><a href="https://cloud.tencent.com/developer/article/1520361">这是我读过写得最好的【秒杀系统架构】分析与实战！</a><br><a href="https://www.infoq.cn/article/ypqschsrdsk8bv5nhny4">这一次，彻底弄懂“秒杀系统”</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;秒杀系统的挑战&quot;&gt;&lt;a href=&quot;#秒杀系统的挑战&quot; class=&quot;headerlink&quot; title=&quot;秒杀系统的挑战&quot;&gt;&lt;/a&gt;秒杀系统的挑战&lt;/h1&gt;&lt;h2 id=&quot;高并发&quot;&gt;&lt;a href=&quot;#高并发&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM-Xms,Xmx和Xss</title>
    <link href="http://example.com/wiki/JVM-Xms-Xmx%E5%92%8CXss/"/>
    <id>http://example.com/wiki/JVM-Xms-Xmx%E5%92%8CXss/</id>
    <published>2021-07-28T13:04:14.000Z</published>
    <updated>2021-07-30T08:33:40.342Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730163232526.png" alt="image-20210730163232526" style="zoom:47%;" /><h1 id="性能调优参数Xms，Xmx，Xss的含义"><a href="#性能调优参数Xms，Xmx，Xss的含义" class="headerlink" title="性能调优参数Xms，Xmx，Xss的含义"></a>性能调优参数Xms，Xmx，Xss的含义</h1><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>规定了每个线程虚拟机栈及堆栈的大小，一般情况下，256k是足够的，此配置将会影响此进程中并发线程数的大小。</p><h3 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h3><p>表示初始化JAVA堆的大小及该进程刚创建出来的时候，他的专属JAVA堆的大小，一旦对象容量超过了JAVA堆的初始容量，JAVA堆将会自动扩容到-Xmx大小。</p><h3 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h3><p>表示java堆可以扩展到的最大值，在很多情况下，通常将-Xms和-Xmx设置成一样的，因为当堆不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性。</p><h3 id="堆内存分配："><a href="#堆内存分配：" class="headerlink" title="堆内存分配："></a>堆内存分配：</h3><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br>非堆内存分配：<br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>-Xmn2G：设置年轻代大小为2G。<br>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/a1439775520/article/details/97787160">类似-Xms、-Xmn这些参数的含义：</a><br>2、<a href="https://baijiahao.baidu.com/s?id=1671253445384660292&wfr=spider&for=pc">JVM三大性能调优参数Xms，Xmx，Xss的含义，你又知道多少呢</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210730163232526.png&quot; alt=&quot;image-20210730163232526&quot; style=&quot;zoom:</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Develop-Lan/Java/JVM/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-自定义类加载器</title>
    <link href="http://example.com/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://example.com/wiki/JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2021-07-28T13:02:32.000Z</published>
    <updated>2021-07-28T15:18:55.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p>为什么要自定义加载器</p><p>原因：<br>1、存放在自定义路径上的类，需要通过自定义类加载器去加载。【注意：AppClassLoader加载classpath下的类】<br>2、类不一定从文件中加载，也可能从网络中的流中加载，这就需要自定义加载器去实现加密解密。<br>3、可以定义类的实现机制，实现类的热部署,<br>如OSGi中的bundle模块就是通过实现自己的ClassLoader实现的，<br>如tomcat实现的自定义类加载模型。</p><p>如何实现自定义加载器</p><blockquote><p>实现自定义类加载有以下两步：<br>1、继承ClassLoader<br>2、重写findClass，在findClass里获取类的字节码，并调用ClassLoader中的defineClass方法来加载类，获取class对象。<br>注意：如果要打破双亲委派机制，需要重写loadClass方法。<br>如下：是一个自定义 的类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span>  <span class="keyword">extends</span>  <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 data= loadByte(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/admin/test/&quot;</span>+name);</span><br><span class="line">            FileInputStream fi = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> len = fi.available();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fi.read(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是要加载的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类编译后的class 文件放置在/Users/admin/test/下,然后执行如下代码去加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;Demo.class&quot;</span>);</span><br><span class="line">        Object o=clazz.newInstance();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">输出:hello</span><br></pre></td></tr></table></figure><p>能不能自己写一个java.lang.String</p><p>1、代码书写后可以编译不会报错<br>2、在另一个类中加载java.lang.String，通过反射调用自己写的String类里的方法，得到结果NoSuchMethod，说明加载的还是原来的String，因为通过双亲委派机制，会把java.lang.String一直提交给启动类加载器去加载，通过他加载，加载到的永远是/lib下面的java.lang.String<br>3、在这个自己写的类中写上main方法<br>public static void main(String[] args)<br>执行main方法报错，因为这个String并不是系统的java.lang.String，所以JVM找不到main方法的签名</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_28605513/article/details/85014451">JVM:如何实现一个自定义类加载器？</a><br>原文链接：<a href="https://blog.csdn.net/qq_28605513/article/details/85014451">https://blog.csdn.net/qq_28605513/article/details/85014451</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何自定义类加载器&quot;&gt;&lt;a href=&quot;#如何自定义类加载器&quot; class=&quot;headerlink&quot; title=&quot;如何自定义类加载器&quot;&gt;&lt;/a&gt;如何自定义类加载器&lt;/h1&gt;&lt;p&gt;为什么要自定义加载器&lt;/p&gt;
&lt;p&gt;原因：&lt;br&gt;1、存放在自定义路径上的类，需要通</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Develop-Lan/Java/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分布式-一致性哈希算法</title>
    <link href="http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-28T13:01:05.000Z</published>
    <updated>2021-07-28T15:18:55.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。</p><h2 id="哈希指标"><a href="#哈希指标" class="headerlink" title="哈希指标"></a>哈希指标</h2><blockquote><p>评估一个哈希算法的优劣，有如下指标，而一致性哈希全部满足：</p></blockquote><ul><li>均衡性(Balance)：将关键字的哈希地址均匀地分布在地址空间中，使地址空间得到充分利用，这是设计哈希的一个基本特性。</li><li>单调性(Monotonicity): 单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。</li><li>分散性(Spread): 哈希经常用在分布式环境中，终端用户通过哈希函数将自己的内容存到不同的缓冲区。此时，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li><li>负载(Load): 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷</li></ul><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote><p>将节点通过hash映射到hash环上，理想的情况是多个节点直接分布均匀</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-ac8ab4cd06d150b14ddfe58e2cdcbdb7dff.png" ><p>当我们的对象通过hash算法分配在hash环上的时候，它是固定分配到一个节点的空间上的，当我们在BC之间插入一个节点时，仅仅会影响到BC这一段空间上的数据，而不是整个环上的数据都要跟着变化；</p><blockquote><p>现实情况下，节点之间可能分配不均匀</p></blockquote><img src="https://oscimg.oschina.net/oscnet/up-3a12f9634fed9d5f67debfcdd7fe22f1fae.png"><p>这和传统的hash取模一样，同样会数据倾斜的问题！</p><blockquote><p>虚拟节点</p></blockquote><p>这个时候虚拟节点就此诞生，下面让我们来看一下虚拟节点在一致性Hash中的作用。当我们在Hash环上新增若干个点，那么每个点之间的距离就会接近相等。按照这个思路我们可以新增若干个片/表，但是成本有限，我们通过复制多个A、B、C的副本({A1-An},{B1-Bn},{C1-Cn})一起参与计算，按照顺时针的方向进行数据分布，按照下图示意:<br><img src="https://oscimg.oschina.net/oscnet/up-88c2aef2ec993ede090695ffe78f53f999a.png"></p><p>此时A=[A,C1)&amp;[A1,C2)&amp;[A2,B4)&amp;[A3,A4)&amp;[A4,B1)；B=[B,A1)&amp;[B2,C)&amp;[B3,C3)&amp;[B4,C4)&amp;[B1,A)；C=[C1,B)&amp;[C2,B2)&amp;[C,B3)&amp;[B3,C3)&amp;[C4,A3)；由图可以看出分布点越密集，平衡性约好。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>一致性哈希算法有多种具体的实现，包括 Chord 算法，KAD 算法等，都比较复杂。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 、<a href="https://blog.csdn.net/kefengwang/article/details/81628977">一致性哈希算法的原理与实现</a><br>2、<a href="https://www.cnblogs.com/xialihua1023/p/10304932.html">浅谈一致性Hash原理及应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一致性哈希算法&quot;&gt;&lt;a href=&quot;#一致性哈希算法&quot; class=&quot;headerlink&quot; title=&quot;一致性哈希算法&quot;&gt;&lt;/a&gt;一致性哈希算法&lt;/h1&gt;&lt;p&gt;一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负</summary>
      
    
    
    
    <category term="Distributed Dir" scheme="http://example.com/categories/Distributed-Dir/"/>
    
    <category term="theory" scheme="http://example.com/categories/Distributed-Dir/theory/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式-CAP理论</title>
    <link href="http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/</id>
    <published>2021-07-28T10:15:10.000Z</published>
    <updated>2021-07-28T15:18:55.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。<br>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p><img src="https://oscimg.oschina.net/oscnet/up-1d3052b25a13428857fde791eaa01c02e9b.png"><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值，即写操作之后的读操作，必须返回该值。（分为弱一致性、强一致性和最终一致性）</li><li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><h2 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h2><blockquote><p>CA without P</p></blockquote><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p><blockquote><p>CP without A</p></blockquote><p>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要<font color=red>牺牲用户的体验</font>，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p><blockquote><p>AP wihtout C</p></blockquote><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><h2 id="解决方案——BASE"><a href="#解决方案——BASE" class="headerlink" title="解决方案——BASE"></a>解决方案——BASE</h2><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果。</p><p>核心思想：即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><blockquote><p>基本可用Basically Available</p></blockquote><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p><p>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><blockquote><p>软状态Soft state</p></blockquote><p>软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><blockquote><p>最终一致性Eventually consistent</p></blockquote><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="https://blog.csdn.net/lixinkuan328/article/details/95535691">https://blog.csdn.net/lixinkuan328/article/details/95535691</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP-原则&quot;&gt;&lt;a href=&quot;#CAP-原则&quot; class=&quot;headerlink&quot; title=&quot;CAP 原则&quot;&gt;&lt;/a&gt;CAP 原则&lt;/h1&gt;&lt;p&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availab</summary>
      
    
    
    
    <category term="Distributed Dir" scheme="http://example.com/categories/Distributed-Dir/"/>
    
    <category term="theory" scheme="http://example.com/categories/Distributed-Dir/theory/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-事务特性与实现原理</title>
    <link href="http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-28T10:13:07.000Z</published>
    <updated>2021-07-28T15:18:55.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务特性与实现原理"><a href="#事务特性与实现原理" class="headerlink" title="事务特性与实现原理"></a>事务特性与实现原理</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote><p>原子性(Atomicity)</p></blockquote><p>事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。</p><blockquote><p>一致性(Consistency)</p></blockquote><p>事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p><blockquote><p>隔离性(Isolation)</p></blockquote><p>并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。</p><blockquote><p>持久性(Durability)</p></blockquote><p>事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面<br>1.事务的并发执行<br>2.事务故障或系统故障</p><h2 id="事务实现原理"><a href="#事务实现原理" class="headerlink" title="事务实现原理"></a>事务实现原理</h2><img src="https://oscimg.oschina.net/oscnet/up-7b54f7847cee22930ec53a4058179a2b531.png" width=460 height=300><ul><li>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏。</li><li>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</li></ul><h3 id="回滚日志（undo）"><a href="#回滚日志（undo）" class="headerlink" title="回滚日志（undo）"></a>回滚日志（undo）</h3><p>undo log属于 「 逻辑日志 」，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><p>undo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。</p><p>因此，undo log有两个作用：提供回滚和多个行版本控制(MVCC)。</p><h3 id="重做日志（redo）"><a href="#重做日志（redo）" class="headerlink" title="重做日志（redo）"></a>重做日志（redo）</h3><p>redo log重做日志记录的是新数据的备份，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据恢复到最新的状态。</p><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><p>MySQL中redo log刷新规则采用一种称为Checkpoint的机制（利用LSN实现），为了确保安全性，又引入double write机制。</p><h2 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h2><p>开启事务：start transaction<br>回滚事务：rollback<br>提交事务：commit</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">1、详细分析MySQL事务日志(redo log和undo log)</a><br><a href="https://www.cnblogs.com/takumicx/p/9998844.html">2、数据库事务的概念及其实现原理</a><br><a href="https://zhuanlan.zhihu.com/p/281927963">3、数据库事务实现原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务特性与实现原理&quot;&gt;&lt;a href=&quot;#事务特性与实现原理&quot; class=&quot;headerlink&quot; title=&quot;事务特性与实现原理&quot;&gt;&lt;/a&gt;事务特性与实现原理&lt;/h1&gt;&lt;h2 id=&quot;事务特性&quot;&gt;&lt;a href=&quot;#事务特性&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-事务隔离级别</title>
    <link href="http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/wiki/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-07-28T10:12:49.000Z</published>
    <updated>2021-07-28T15:19:02.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。另外，这篇分布式事务不理解？一次给你讲清楚！推荐大家阅读。</p><blockquote><p>Read Uncommitted（读取未提交内容）</p></blockquote><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><blockquote><p>Read Committed（读取提交内容）</p></blockquote><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><blockquote><p>Repeatable Read（可重读）</p></blockquote><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><blockquote><p>Serializable（可串行化）</p></blockquote><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><h2 id="事务隔离级别产生的问题"><a href="#事务隔离级别产生的问题" class="headerlink" title="事务隔离级别产生的问题"></a>事务隔离级别产生的问题</h2><img src="https://oscimg.oschina.net/oscnet/up-ee3cb778a32220ff81103f9163d22f774b2.png"> <blockquote><p>脏读(Drity Read)</p></blockquote><p>某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，但是此时的事务B还未commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务B-&gt;rollback操作</span><br><span class="line">事务A读取到的是脏数据</span><br></pre></td></tr></table></figure><blockquote><p>不可重复读(Non-repeatable read)</p></blockquote><p>在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新update price=120，并commit</span><br><span class="line">事务A读取的price=120</span><br><span class="line">事务A多次读取的结果不一致</span><br></pre></td></tr></table></figure><blockquote><p>幻读(Phantom Read) </p></blockquote><p><font color=red >幻读和不可重复读的区别在于，幻读主要表现在数据的删除和插入，而不可重复读表现在数据的更新。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务A第一次读取到price=100</span><br><span class="line">同时事务B更新delete price=100 这条记录，并commit</span><br><span class="line">事务A读取的price=100</span><br><span class="line">price这条记录已经不存在，但是事务A还是可以读取到</span><br></pre></td></tr></table></figure><p>1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。<br>　　2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/xiewenfeng520/article/details/99407038">1、mysql数据库的隔离级别</a><br><a href="https://blog.csdn.net/sinat_15805929/article/details/91127491">2、MYSQL数据库的四种隔离级别</a><br><a href="https://www.jianshu.com/p/c53c8ab650b5">3、MySQL幻读</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库隔离级别&quot;&gt;&lt;a href=&quot;#数据库隔离级别&quot; class=&quot;headerlink&quot; title=&quot;数据库隔离级别&quot;&gt;&lt;/a&gt;数据库隔离级别&lt;/h1&gt;&lt;p&gt;SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql-MVCC多版本并发控制</title>
    <link href="http://example.com/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/wiki/Mysql-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2021-07-28T10:12:28.000Z</published>
    <updated>2021-07-28T15:19:20.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>MVCC在MySQL InnoDB中的实现主要是为了 「<font color=red> 提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读 </font>」</p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><blockquote><p>当前读</p></blockquote><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><blockquote><p>快照读</p></blockquote><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p><p><font color=red >MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</font></p><h2 id="MVCC有什么好处，解决了什么问题"><a href="#MVCC有什么好处，解决了什么问题" class="headerlink" title="MVCC有什么好处，解决了什么问题"></a>MVCC有什么好处，解决了什么问题</h2><p>多版本并发控制（MVCC）是一种用来「 <font color=green>解决读-写冲突的无锁并发控制</font> 」，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li></ul><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的  <font color=red>3个隐式字段</font>，<font color=red>undo日志</font> ，<font color=red>Read View</font> 来实现的。所以我们先来看看这个三个point的概念</p><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><blockquote><p>DB_TRX_ID</p></blockquote><p>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p><blockquote><p>DB_ROLL_PTR</p></blockquote><p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><blockquote><p>DB_ROW_ID</p></blockquote><p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引<br>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p><blockquote><p>insert undo log</p></blockquote><p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><blockquote><p>update undo log</p></blockquote><p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法，<font color=red>主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护）</font>，如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本;</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/8845ddca3b23">1、MVCC多版本并发控制</a><br><a href="https://blog.csdn.net/chosen0ne/article/details/18093187">2、MVCC浅析</a><br><a href="https://database.51cto.com/art/202010/629317.htm">3、乐观锁、悲观锁和MVCC，今天让你一次搞懂</a><br><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc">4、面试官：谈谈你对Mysql的MVCC的理解？</a><br><a href="https://www.cnblogs.com/shujiying/p/11347632.html">5、Mysql中MVCC的使用及原理详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC多版本并发控制&quot;&gt;&lt;a href=&quot;#MVCC多版本并发控制&quot; class=&quot;headerlink&quot; title=&quot;MVCC多版本并发控制&quot;&gt;&lt;/a&gt;MVCC多版本并发控制&lt;/h1&gt;&lt;p&gt;MVCC，全称Multi-Version Concurrency C</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/DataBase/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java对象头</title>
    <link href="http://example.com/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <id>http://example.com/wiki/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4/</id>
    <published>2021-07-28T09:59:59.000Z</published>
    <updated>2021-07-28T15:19:02.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><h2 id="JOL查看对象头信息"><a href="#JOL查看对象头信息" class="headerlink" title="JOL查看对象头信息"></a>JOL查看对象头信息</h2><p>在项目中引入以下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>写一个main方法，创建一个Object，然后打印对象信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><p>由此可知，new Object()在内存中占16个字节，组成部分8字节的markword+4字节的class point+4字节的对齐；</p><h2 id="Java对象在内存中的布局"><a href="#Java对象在内存中的布局" class="headerlink" title="Java对象在内存中的布局"></a>Java对象在内存中的布局</h2><image src="https://oscimg.oschina.net/oscnet/up-056ef14e62f5dfde1a5af579dabeb6e4c2a.png" width=250 height=420><ul><li>markword<blockquote><p>存储sync锁标志，分代年龄等一些关键信息 8字节</p></blockquote></li><li>class pointer<blockquote><p>指向当前对象所属类类型 4字节</p></blockquote></li></ul><p><strong>查看java命令默认带的参数命令：</strong> java -XX:+PrintCommandLineFlags -version </p><blockquote><p>-XX:InitialHeapSize=134217728<br>-XX:MaxHeapSize=2147483648<br>-XX:+PrintCommandLineFlags<br>-XX:+UseCompressedClassPointers 压缩类指针 4字节<br>-XX:+UseCompressedOops 普通对象指针压缩 4字节<br>-XX:+UseParallelGC</p></blockquote><ul><li>instance data<blockquote><p>寸尺当前对象的实例数据</p></blockquote></li><li>padding<blockquote><p>对齐填充，当对象所占字节数不能被8整除之后，进行填充对齐。 目前的操作系统基本上都是64位的；</p></blockquote></li></ul><h2 id="顺丰面试题，new-Object-在内存中占多少个字节"><a href="#顺丰面试题，new-Object-在内存中占多少个字节" class="headerlink" title="顺丰面试题，new Object()在内存中占多少个字节"></a>顺丰面试题，new Object()在内存中占多少个字节</h2><p>1、如果创建的是空对象，没有实例数据</p><ul><li>默认开启了class pointer指针压缩<blockquote><p>8字节markword + 4字节class pointer + 4字节 padding</p></blockquote></li><li>如果关闭了类指针压缩<blockquote><p>8字节markword + 8字节class pointer</p></blockquote></li></ul><p>2、如果创建的对象有实力数据，如下对象：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person（int age , String name）</span><br></pre></td></tr></table></figure></p><ul><li>默认开启了class pointer指针压缩<blockquote><p>8字节markword + 4字节class pointer + 4字节int + 4字节String + 4字节padding对齐</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java对象头&quot;&gt;&lt;a href=&quot;#Java对象头&quot; class=&quot;headerlink&quot; title=&quot;Java对象头&quot;&gt;&lt;/a&gt;Java对象头&lt;/h1&gt;&lt;h2 id=&quot;JOL查看对象头信息&quot;&gt;&lt;a href=&quot;#JOL查看对象头信息&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-CAS原理和底层实现</title>
    <link href="http://example.com/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/wiki/Java-CAS%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-28T09:59:17.000Z</published>
    <updated>2021-07-28T14:58:28.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS原理和底层实现"><a href="#CAS原理和底层实现" class="headerlink" title="CAS原理和底层实现"></a>CAS原理和底层实现</h1><img src="https://oscimg.oschina.net/oscnet/up-0ed0dcb929342035287eb09818f33416baa.png" width=550 height=400><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是（compare and swap） 的缩写，它能在不加锁的情况下，在多线程的环境下，保证多线程一致性的改动某一值；</p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题是一个线程在CAS比较值和原来是否相等的过程中，别的线程修改过这个值，但是又改回去了，倒置当前线程比较的时候，发现是相等的，但是，中间是被修改过的；  </p><p>添加版本号，比较值的时候同时比较版本号</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger:"></a>AtomicInteger:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe:"></a>Unsafe:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><h3 id="jdk8u-atomic-linux-x86-inline-hpp-93行"><a href="#jdk8u-atomic-linux-x86-inline-hpp-93行" class="headerlink" title="jdk8u: atomic_linux_x86.inline.hpp 93行"></a>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></h3><p>is_MP = Multi Processor  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">&quot;cmp $0, &quot;</span> #mp <span class="meta-string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="最终实现："><a href="#最终实现：" class="headerlink" title="最终实现："></a>最终实现：</h3><p>底层对应一个汇编指令「lock comxchg」，但是comxchg这条指令不是原子性的，他不能保证在比较的时候，别的线程会不会改变值；而保证线程安全的则是lock这条指令，lock这条指令在执行后面执行的时候锁定一个「北桥信号」，而不是采用纵线锁的方式；</p><h2 id="CAS在JDK中的实现"><a href="#CAS在JDK中的实现" class="headerlink" title="CAS在JDK中的实现"></a>CAS在JDK中的实现</h2><p>1、AtomitInteger<br>2、ConcurrentHashMap</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS原理和底层实现&quot;&gt;&lt;a href=&quot;#CAS原理和底层实现&quot; class=&quot;headerlink&quot; title=&quot;CAS原理和底层实现&quot;&gt;&lt;/a&gt;CAS原理和底层实现&lt;/h1&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscn</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-FutureTask原理</title>
    <link href="http://example.com/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/Java-FutureTask%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-28T09:58:47.000Z</published>
    <updated>2021-07-28T14:58:31.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><h3 id="Future方法介绍"><a href="#Future方法介绍" class="headerlink" title="Future方法介绍"></a>Future方法介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务 可中断的方式取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断任务是否处于取消状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断异步任务是否执行完成      ==这里使用轮训的方式监听==</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到有结果返回；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取异步线程的执行结果，如果没有执行完成，则一直阻塞到设置的时间，有结果返回，没有结果则抛出异常；</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单示范Callable-amp-Future"><a href="#简单示范Callable-amp-Future" class="headerlink" title="简单示范Callable&amp;Future"></a>简单示范Callable&amp;Future</h3><p>（1）向线程池中提交任务的submit方法不是阻塞方法，而Future.get方法是一个阻塞方法<br>（2）submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果，所以一般需要使用future.isDone先判断任务是否全部执行完成，完成后再使用future.get得到结果。（也可以用get (long timeout, TimeUnit unit)方法可以设置超时时间，防止无限时间的等待）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;start call method...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main method start....&quot;</span>);</span><br><span class="line">        FutureTest futureTest = <span class="keyword">new</span> FutureTest();</span><br><span class="line">        Future1Test future1Test = <span class="keyword">new</span> Future1Test();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(future1Test);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;future not done !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Future&lt;Integer&gt; future1 = executorService.submit(futureTest);</span><br><span class="line">        <span class="comment">// submit提交多个任务时，只有所有任务都完成后，才能使用get按照任务的提交顺序得到返回结果</span></span><br><span class="line">        <span class="comment">// 这里先提交了future1Test，休眠了4s, futureTest休眠了3s，但是等我们get到结果的时候，是消耗的4s时间的；</span></span><br><span class="line">        System.err.println(<span class="string">&quot;cost time: &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">        System.err.println(<span class="string">&quot;future: &quot;</span> + future.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;future1: &quot;</span> + future1.get());</span><br><span class="line">        System.err.println(<span class="string">&quot;main method end....&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main method start....</span><br><span class="line">future not done !</span><br><span class="line"><span class="comment">// 说明了第一 get()方法是阻塞，第二线程池任务都执行完成之后，按提交任务顺序get结果返回值</span></span><br><span class="line">cost time: <span class="number">4</span></span><br><span class="line">start call method...</span><br><span class="line">future: future <span class="number">2</span> test</span><br><span class="line">future1: <span class="number">1111</span></span><br><span class="line">main method end....</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>线程池执行任务有两种方式execute和submit，execute是不带返回值的，submit是有返回值的;</li><li>main方法中可以不使用线程池，可以直接创建线程，调用start方法就可以，切记只有在演示代码的时候后。手动直接创建线程的方式还是不要用，因为一旦请求变多，则会创建无数的线程，线程数大于CPU核数，进而导致CPU频繁切换上下分进行调度，性能严重下降。</li><li>而且线程的数据是存放在内存中的，会占用大量的内存，增加垃圾回收的压力。严重的会发生OOM;</li><li>异常main方法中我们使用的是Future<String> future接收异步任务执行的放回结果，但实际上Future其实是一个interface，并不能接收返回结果的，那实际我们调用future.get()是，是实例了一个FutureTask对象来接受的；</li></ul><h3 id="FutureTask讲解"><a href="#FutureTask讲解" class="headerlink" title="FutureTask讲解"></a>FutureTask讲解</h3><p>下面主要针对Future的实现类FutureTask的几个重要方法展开</p><h4 id="FutureTask继承关系"><a href="#FutureTask继承关系" class="headerlink" title="FutureTask继承关系"></a>FutureTask继承关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 下面是RunnableFuture接口的继承关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>FutureTask 重要的成员变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="comment">//任务执行结果或者任务异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="comment">//执行任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="comment">//等待节点，关联等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//state字段的内存偏移量     这个在线程池执行任务的时候进行状态判断的时候会用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="comment">//runner字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line"><span class="comment">//waiters字段的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br></pre></td></tr></table></figure><blockquote><p>定义任务的生命周期</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>NORMAL:指的是任务能够正常执行状态  </li><li>EXCEPTIONAL：表示任务执行异常  </li><li>CANCELLED：取消状态，之后的状态都表示任务取消或终端  </li></ul><p>下面看一下FutureTask中几个重要的方法</p><h4 id="执行结果-report方法"><a href="#执行结果-report方法" class="headerlink" title="执行结果 | report方法"></a>执行结果 | report方法</h4><blockquote><p>Returns result or throws exception for completed task.<br>主要是上报异步任务执行的结果或返回任务执行发生的异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>判断逻辑就是根据参数，也是是任务状态，根据不同的状态处理相应的逻辑。比如NORNAL状态，表示任务正常执行，直接返回结果就可以。如果状态大于CANCELLED，说明任务被取消或终端，会抛出CancellationException()；如果不是异常状态，则抛出ExecutionException；</p><h4 id="任务执行-run"><a href="#任务执行-run" class="headerlink" title="任务执行 |   run()"></a>任务执行 |   run()</h4><blockquote><p>执行异步任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果状态 state 不是 NEW，或者设置 runner 值失败</span></span><br><span class="line">     <span class="comment">// 表示有别的线程在此之前调用 run 方法，并成功设置了 runner 值</span></span><br><span class="line">     <span class="comment">// 保证了只有一个线程可以运行 try 代码块中的代码。</span></span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">             !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//以上state值变更的由CAS操作保证原子性</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="comment">//只有c不为null且状态state为NEW的情况</span></span><br><span class="line">         <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="keyword">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//调用callable的call方法，并获得返回结果</span></span><br><span class="line">                 result = c.call();</span><br><span class="line">                 <span class="comment">//运行成功</span></span><br><span class="line">                 ran = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="keyword">null</span>;</span><br><span class="line">                 ran = <span class="keyword">false</span>;</span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 <span class="comment">//设置结果</span></span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">         <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">         runner = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">         <span class="comment">// leaked interrupts</span></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">             handlePossibleCancellationInterrupt(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心逻辑就是调用Callable的call方法，==result=c.call();== 并且对任务执行的结果或异常信息进行处理；</p><h4 id="获取结果-get-throws-InterruptedException-ExecutionException"><a href="#获取结果-get-throws-InterruptedException-ExecutionException" class="headerlink" title="获取结果 | get() throws InterruptedException, ExecutionException"></a>获取结果 | get() throws InterruptedException, ExecutionException</h4><blockquote><p>获取异步任务执行的结果或异常信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法执行两个操作：  </p><ul><li>判断任务的状态,如果没有执行完成，调用awaitDone方法</li><li>任务完成，调用我们上面说的report方法，返回任务执行结果</li></ul><h4 id="任务阻塞-awaitDone-boolean-timed-long-nanos"><a href="#任务阻塞-awaitDone-boolean-timed-long-nanos" class="headerlink" title="任务阻塞 | awaitDone(boolean timed, long nanos)"></a>任务阻塞 | awaitDone(boolean timed, long nanos)</h4><blockquote><p>等到任务执行完成 也是get方法阻塞特性的关键所在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// CPU轮转</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果线程中断了，将线程移除等待队列，抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 如果任务状态大于完成，则直接返回；</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务完成，但是返回值outcome还没有设置，可以先让出线程执行权，让其他线程执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">// 下面是任务还没有执行完成的状态，将线程添加到等待队列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="comment">// 判断get方法是否设置了超时时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 如果超出设置的时间，线程移除等到队列</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有设置超时时间，线程直接阻塞，直到任务完成</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>主要执行步骤：</p><ul><li>判断线程是否被中断，如果被中断了，就从等待的线程栈中移除该等待节点，然后抛出中断异常 </li><li>读取state,判断任务是否已经完成，如果已经完成或者任务已经取消，此时调用get方法的线程不会阻塞，会直接获取到结果或者拿到异常信息；  </li><li>如果s == COMPLETING，说明任务已经结束，但是结果还没有保存到outcome中，==此时线程让出执行权，给其他线程先执行；==   </li><li>如果任务没有执行完成，则需要创建等待节点，等待插入到阻塞队列  </li><li>判断queued，这里是将c中创建节点q加入队列头。使用Unsafe的CAS方法，对waiters进行赋值，waiters也是一个WaitNode节点，相当于队列头，或者理解为队列的头指针。通过WaitNode可以遍历整个阻塞队列  </li><li>然后判断超时时间，时间是在调用get方法的时候传输进来的，如果有超时时间，则设置超时时间，如果超出时间，则将线程移除等待队列；如果没有设置时间，则直接阻塞线程；  </li></ul><h4 id="取消任务-cancel-boolean-mayInterruptIfRunning"><a href="#取消任务-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="取消任务 |  cancel(boolean mayInterruptIfRunning)"></a>取消任务 |  cancel(boolean mayInterruptIfRunning)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param</span> mayInterruptIfRunning 是否中断</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在状态还为NEW的时候，根据参数中的是否允许传递，</span></span><br><span class="line"><span class="comment">     * 将状态流转到INTERRUPTING或者CANCELLED。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 必须将栈顶CAS为null，否则重读栈顶并重试。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历并唤醒栈中节点对应的线程。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将next域置为null，这样对GC友好。</span></span><br><span class="line">                q.next = <span class="keyword">null</span>; </span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * done方法是暴露给子类的一个钩子方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个方法在ExecutorCompletionService.QueueingFuture中的override实现是把结果加到阻塞队列里。</span></span><br><span class="line"><span class="comment">     * CompletionService谁用谁知道，奥秘全在这。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * callable置为null主要为了减少内存开销,</span></span><br><span class="line"><span class="comment">     * 更多可以了解JVM memory footprint相关资料。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    callable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable-amp-Future使用场景"><a href="#Callable-amp-Future使用场景" class="headerlink" title="Callable&amp;Future使用场景"></a>Callable&amp;Future使用场景</h3><ul><li>异步任务需要拿到返回值</li><li>多线程并发调用，顺序组装返回值，一些并发框架中会看到相应体现</li><li>还有一些分布式任务调度的场景，远程调用需要回填执行结果</li><li>还有很多通信框架中都有体现</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p>(1) <a href="https://blog.csdn.net/qq_34562093/article/details/90209520">future.get方法阻塞问题的解决，实现按照任务完成的先后顺序获取任务的结果</a><br>(2) <a href="https://blog.csdn.net/luofenghan/article/details/78596950#%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java多线程引发的性能问题以及调优策略</a><br>(3) <a href="https://www.jianshu.com/p/55221d045f39">可取消的异步任务——FutureTask用法及解析</a><br>(4) <a href="https://www.cnblogs.com/micrari/p/7374513.html">FutureTask源码解读</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FutureTask&quot;&gt;&lt;a href=&quot;#FutureTask&quot; class=&quot;headerlink&quot; title=&quot;FutureTask&quot;&gt;&lt;/a&gt;FutureTask&lt;/h1&gt;&lt;h3 id=&quot;Future方法介绍&quot;&gt;&lt;a href=&quot;#Future方法介绍&quot;</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-join方法原理解析</title>
    <link href="http://example.com/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/wiki/Java-join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-28T09:58:22.000Z</published>
    <updated>2021-07-28T14:58:35.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">join重载方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> join()</span><br><span class="line"><span class="number">2</span> join(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line"><span class="number">3</span> join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br></pre></td></tr></table></figure><h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//        t.join();</span></span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上将t.join();注释掉，执行的一种可能结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">main thread end... </span><br><span class="line">join thread demo</span><br><span class="line"></span><br><span class="line">还有可能是这种结果：</span><br><span class="line">main thread start... </span><br><span class="line">join thread demo</span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure><p>但是把注释去掉，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br></pre></td></tr></table></figure><p>这是一个非常简单的demo,效果是显而易见的。当main线程去调用t.join()是，会将自己当前线程阻塞，等到t线程执行完成到达完结状态，main线程才可以继续执行。  </p><p>我们看一下join()设置超时时间的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;join thread demo &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程睡眠4s</span></span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">null</span>;</span><br><span class="line">        System.err.println(strings.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread start... &quot;</span>);</span><br><span class="line">        Runnable r = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;ibli joinTest ...&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 但是主线程join的超时时间是1s</span></span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;main thread end... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread start... </span><br><span class="line">join thread demo </span><br><span class="line">main thread end... </span><br><span class="line">Exception in thread <span class="string">&quot;ibli joinTest ...&quot;</span> java.lang.NullPointerException</span><br><span class="line">at com.ibli.threadTest.api.JoinDemo.run(JoinDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上面的执行结果可以看到，子线程设置了4s的超时时间，但是主线程在1秒超时后，并没有等待子线程执行完毕，就被唤醒执行后续操作了；这样的预期是否符合你的预期呢？<br>下面我们按照join的源码去分析吧！</p></blockquote><h3 id="join方法原理"><a href="#join方法原理" class="headerlink" title="join方法原理"></a>join方法原理</h3><p>下面是join的原理图</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5386b2aaabd43cab4b0f042e0270118~tplv-k3u1fbpfcp-zoom-1.image?imageView2/2/w/480/h/480/q/85/interlace/1" width = "400" height = "500" div align=right /><blockquote><p>join()源码</p></blockquote><p>首先会调用join(0)方法，其实是join的重载方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是join的核心实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先校验参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果join方法没有参数，则相当于直接调用wait方法</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是isAlive方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个本地方法，作用是判断当前的线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。</p><ul><li><p>这里有一个点要注意，join为什么阻塞的是主线程，而不是子线程呢？  </p></li><li><p>不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p></li><li><p>其实join()方法的核心在于wait(),在主线程中调用t.join()相当于在main方法中添加 new JoinDemo().wait();是一样的效果；在这里只不过是wait方法写在了子线程的方法中。  </p></li><li><p>再次重申一遍，join方法的作用是在主线程阻塞，等在子线程执行完之后，由子线程唤醒主线程，再继续执行主线程调用t.join()方法之后的逻辑。</p></li></ul><blockquote><p>那么主线程是在什么情况下知道要继续执行呢？就是上面说的，主线程其实是由join的子线程在执行完成之后调用的notifyAll()方法，来唤醒等待的线程。怎么证明呢？</p></blockquote><p>其实大家可以去翻看JVM的源码实现，Thread.cpp文件中，有一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">  <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">  <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用ensure_join方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">  <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">&quot;java thread object must exist&quot;</span>);</span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">  <span class="comment">// to complete once we&#x27;ve done the notify_all below</span></span><br><span class="line">  <span class="comment">//这里是清除native线程，这个操作会导致isAlive()方法返回false</span></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  <span class="comment">// 在这里唤醒等待的线程</span></span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM的代码中，线程执行结束的最终调用了lock.notify_all(thread)方法来唤醒所有处于等到的线程</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>比如我们使用Callable执行异步任务，需要在主线程处理任务的返回值时，可以调用join方法；</li><li>还有一些场景希望线程之间顺序执行的；</li></ul><h2 id="join-方法与sleep-的比较"><a href="#join-方法与sleep-的比较" class="headerlink" title="join()方法与sleep()的比较"></a>join()方法与sleep()的比较</h2><p>我们先说一下sleep方法：</p><ul><li>让当前线程休眠指定时间。</li><li>休眠时间的准确性依赖于系统时钟和CPU调度机制。</li><li>不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进- 入到当前同步块或者同步方法中的。</li><li>可通过调用interrupt()方法来唤醒休眠线程。</li><li>sleep是静态方法，可以在任何地方调用</li></ul><p>相比与sleep方法<br>sleep是静态方法，而且sleep的线程不是放锁资源，而join方法是对象方法，并且在等待的过程中会释放掉对象锁；</p><blockquote><p>关于join方法会释放对象锁，那到底是释放的那个对象的锁呢，可以参照 <a href="https://www.cnblogs.com/lwmp/p/11805440.html">关于join() 是否会释放锁的一些思考</a> </p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.iteye.com/blog/uule-1101994">1、Java多线程中join方法的理解</a><br><a href="https://blog.csdn.net/weichi7549/article/details/108449618">2、Thread.join的作用和原理</a><br><a href="https://www.jianshu.com/p/fc51be7e5bc0">3、Thread.join的作用和原理</a></p></blockquote><blockquote><p>d <p align="middle">山脚太拥挤 我们更高处见。</p></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;join方法&quot;&gt;&lt;a href=&quot;#join方法&quot; class=&quot;headerlink&quot; title=&quot;join方法&quot;&gt;&lt;/a&gt;join方法&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://example.com/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/wiki/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-28T09:57:51.000Z</published>
    <updated>2021-07-30T08:36:12.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM?"></a>什么是JMM?</h2><p>Java Memory Model简称JMM, 是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。(可能在术语上与Java运行时内存分布有歧义，后者指堆、方法区、线程栈等内存区域)。</p><p> <strong>JMM规范的内容</strong>  </p><ul><li>所有变量存储在主内存  </li><li>主内存是虚拟机内存的一部分</li><li>每条线程有自己的工作内存</li><li>线程的工作内存保存变量的主内存副本</li><li>线程对变量的操作必须在工作内存中进行</li><li>不同线程之间无法直接访问对方工作内存中的变量</li><li>线程间变量值的传递均需要通过主内存来完成</li></ul><p>JMM并不是一个客观存在的东西，它实际是为了<strong>规范Java虚拟机制定到一套标准</strong>。那为什么需要这套标准呢？ </p><p>其实我们都知道JVM是运行在操作系统之上的。而目前的操作系统都是基于冯诺伊曼设置的计算机系统体系来的。CPU是计算机中用来执行控制和计算的核心组件。</p><p>所有的计算任务全部在CPU中完成，但是我们的所有变量的数据全部存储在主内存中。CPU在执行计算时，需要去主内存加载数据，CPU执行运算的速度极快，这就设计一个CPU执行速度和数据加载速度不一致的问题。   </p><img src= "https://user-gold-cdn.xitu.io/2018/2/7/1616dcd4cfc4f98c?imageView2/0/w/1280/h/960/ignore-error/1" width = "300" height = "400" align=center /><p> 在操作系统级别解决这个问题的办法是引入了CPU缓存。每个CPU都有自己私有的L1缓存和L2缓存，当执行计算时，会优先去CPU自己的缓存中寻找数据，没有的话才会重新加载内存数据。这种方式一定程度上解决了CPU计算和数据加载不一致的问题。    </p><p><strong>但是也会引入一个新的问题，就是数据一致性问题。</strong>  </p><h2 id="缓存一致性与MESI协议"><a href="#缓存一致性与MESI协议" class="headerlink" title="缓存一致性与MESI协议"></a>缓存一致性与MESI协议</h2><blockquote><p>首先看一下什么是MESI协议</p></blockquote><p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），<br>用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p><ul><li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li><li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li><li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li><li>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。</li></ul><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729160558598.png" alt="image-20210729160558598" style="zoom:40%;" />      <p>如何解决缓存一致性问题呢？</p><p>如上图所示，共享变量是存储在主内存Memory中，在CPU计算时，每一个CPU都有改变量的独立拷贝，每个CPU可以去读取甚至修改共享变量的值，但是为了保证数据的一致性，一个CPU modify了变量的值，需要通知其他的CPU这个变量的最新值是什么。那么可以怎么做呢。</p><p>1、在初始状态，每个CPU还没有加载共享变量，所有每一个CPU的缓存行的状态都是invalid；  </p><p>2、当CPU0去使用这个共享变量的时候，首先去自己的缓存中查找，肯定是缓存不命中的，也就是cache miss,这个时候去主内存Memory中去加载，当共享变量的值加载到CPU0的缓存后，CPU缓存行状态变成shared,  也就是共享状态；  </p><p>3、如果这个时候有其他的CPU也读取了共享变量的值，它们的cache line 的状态同样也是shared共享状态；此时一个CPU如果修改共享变量的值，而没有通知其他的CPU,就会造成缓存一致性问题；</p><p>4、当CPU0尝试去修改共享变量的值时，它会发出一个read invalidate命令，同时CPU0的缓存行状态设置为exclusive(独占),同时将其他加载了这个共享变量的cacheline的状态设置为invalid。通俗一点就是CPU0独占的这个变量的缓存行，其他的CPU缓存的共享变量都失效了； </p><p>5、CPU0接下来修改共享变量的值，它会将cacheline的状态修改为modified,其实也是独占共享变量的cacheline，<br>只不过是此时缓存行的数据和主内存Memory的数据不一致的，而exclusive虽然也是独占状态，但是共享变量的值是一样的，modified的值需要write back到Memory中去的，而exclusive是不需要的； </p><p>6、在cacheline没有替换出CPU0的cache之前，当有其他CPU来读取共享变量，此时肯定是cache miss ,因为CPU0的modify操作已经将它的缓存失效了。如果CPU0的状态是modified状态，它必须响应其他CPU的读操作，会告知其他CPU主内存的数据是dirty data。所以其他的CPU的状态可能会变成shared。如果CPU0还没有write back操作，其他的CPU状态还是invalid状态。</p><h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>正如上面所描述的，在CPU0进行共享变量的修改，会同步修改其他CPU的cacheline状态为invalid，这个操作是和共享变量的写操作同步进行的，因此共享变量的写操作的性能是非常差的。在修改其他的CPU cacheline状态时，CPU0其实是处于阻塞状态的。所以为了优化这个问题，提出了Store Buffer的解决方案。</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729161714758.png" alt="image-20210729161714758" style="zoom:33%;" /><p>这样的话，写操作不必等到cacheline被加载，而是直接写到store buffer中，然后去执行后续的操作。由于是store buffer相当于是异步处理，在这里可能会出现因为并发执行导致的执行执行交叉问题，具体解决方法是依赖于内存屏障。  </p><p>具体可以参考这篇文章：<a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html">Linux内核同步机制之（三）：memory barrier</a>  </p><h3 id="Invalidate-Queue"><a href="#Invalidate-Queue" class="headerlink" title="Invalidate Queue"></a>Invalidate Queue</h3><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。为了解决上面两个问题，引进了失效队列（invalidate queue）。</p><p>处理失效的工作如下：</p><img src="https://cdn.jsdelivr.net/gh/code-xiaozhuang/image@main/gao/image-20210729161824400.png" alt="image-20210729161824400" style="zoom:33%;" /><ul><li>收到失效消息时，放到失效队列中去。</li><li>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。</li><li>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens- before原则"></a>happens- before原则</h2><blockquote><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：    </p></blockquote><p>1、单线程每个操作，happen-before于该线程中任意后续操作；<br>2、volatile写happen-before与后续对这个变量的读；<br>3、synchronized解锁happen-before后续对这个锁的加锁；<br>4、final变量的写happen-before于final域对象的读，happen-before后续对final变量的读；<br>5、传递性规则，A先于B，B先于C，那么A一定先于C发生；  </p><blockquote><p><a href="https://www.processon.com/view/5c8b0978e4b0c996d363dcbc?fromnew=1">https://www.processon.com/view/5c8b0978e4b0c996d363dcbc?fromnew=1</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;什么是JMM&quot;&gt;&lt;a href=&quot;#什么是JMM&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Develop Lan" scheme="http://example.com/categories/Develop-Lan/"/>
    
    <category term="Java" scheme="http://example.com/categories/Develop-Lan/Java/"/>
    
    <category term="多线程与并发" scheme="http://example.com/categories/Develop-Lan/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
