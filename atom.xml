<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-18T06:14:30.636Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入学习jvm（图灵-诸葛）</title>
    <link href="http://example.com/wiki/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0jvm%EF%BC%88%E5%9B%BE%E7%81%B5-%E8%AF%B8%E8%91%9B%EF%BC%89/"/>
    <id>http://example.com/wiki/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0jvm%EF%BC%88%E5%9B%BE%E7%81%B5-%E8%AF%B8%E8%91%9B%EF%BC%89/</id>
    <published>2022-01-13T09:20:49.000Z</published>
    <updated>2022-01-18T06:14:30.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-从JDK源码剖析类加载机制"><a href="#1-从JDK源码剖析类加载机制" class="headerlink" title="1. 从JDK源码剖析类加载机制"></a>1. 从JDK源码剖析类加载机制</h1><h2 id="1-1-为什么需要类加载？"><a href="#1-1-为什么需要类加载？" class="headerlink" title="1.1 为什么需要类加载？"></a>1.1 为什么需要类加载？</h2><p>我们编写的程序代码都是存放在磁盘上面的，在程序运行时，需要把我们的class文件加载到内存，这就是为什么需要类加载。</p><h2 id="1-2-java代码到底是怎么运行的呢"><a href="#1-2-java代码到底是怎么运行的呢" class="headerlink" title="1.2 java代码到底是怎么运行的呢"></a>1.2 java代码到底是怎么运行的呢</h2><p>下面是一个普通的类，我们平时都会定义的，那么他们是怎么加载的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123; <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下这个类的main方法是如何运行的吧 👇</p><img src="https://oscimg.oschina.net/oscnet/up-10964428d2deadcb19af7dea03f8b40fe4a.png" style="zoom:50%;" /><ul><li>java程序会调用底层的jvm类库文件中的函数来创建java虚拟机（C++中实现）</li><li>jvm启动之后创建一个引导类加载实例（也就是我们说的类加载器中的BootstartClassLoader）</li><li>C++调用java代码创建jvm启动器，<code>sun.misc.Launcher</code>该类来创建其他的类加载器（ExtClassLoader, AppClassLoader）</li><li>类加载器都创建完成之后，这些类加载器就可以到指定路径下面去加载类信息了，至于加载到哪里（方法区）后面再说</li><li>当类加载都完成之后（当然这里还有很多其他的细节），调用启动类的main方法执行java程序</li></ul><h2 id="1-3-类加载过程是什么？"><a href="#1-3-类加载过程是什么？" class="headerlink" title="1.3 类加载过程是什么？"></a>1.3 类加载过程是什么？</h2><p>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt; 使用 &gt;&gt; 卸载</p><h3 id="1-3-1-类加载的流程图"><a href="#1-3-1-类加载的流程图" class="headerlink" title="1.3.1 类加载的流程图"></a>1.3.1 类加载的流程图</h3><img src="https://oscimg.oschina.net/oscnet/up-e1d5215968dd20b4c65191197b08b8470f9.png" style="zoom:50%;" /><h3 id="1-3-2-加载"><a href="#1-3-2-加载" class="headerlink" title="1.3.2 加载"></a>1.3.2 加载</h3><p>加载:在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><h4 id="1-3-2-1-如何验证类在用到的时候才会加载"><a href="#1-3-2-1-如何验证类在用到的时候才会加载" class="headerlink" title="1.3.2.1 如何验证类在用到的时候才会加载"></a>1.3.2.1 如何验证类在用到的时候才会加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicLoad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load TestDynamicLoad************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load test************&quot;</span>);</span><br><span class="line">         B b = <span class="keyword">null</span>; <span class="comment">//B不会加载，除非这里执行 new B()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*************load A************&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*************initial A************&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*************load B************&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*************initial B************&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*************load TestDynamicLoad************</span><br><span class="line">*************load A************</span><br><span class="line">*************initial A************</span><br><span class="line">*************load test************</span><br></pre></td></tr></table></figure><h3 id="1-3-3-验证"><a href="#1-3-3-验证" class="headerlink" title="1.3.3 验证"></a>1.3.3 验证</h3><p>验证:校验字节码文件的正确性</p><h4 id="1-3-3-1-验证的目的是什么？"><a href="#1-3-3-1-验证的目的是什么？" class="headerlink" title="1.3.3.1 验证的目的是什么？"></a>1.3.3.1 验证的目的是什么？</h4><ul><li>校验字节码格式等信息是否正确，是否符合字节码规范</li><li>保护jvm</li></ul><h3 id="1-3-4-准备"><a href="#1-3-4-准备" class="headerlink" title="1.3.4 准备"></a>1.3.4 准备</h3><p>给类的静态变量分配内存，并赋予默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final修饰的是静态变量，直接赋值，而static修饰的变量，则在准备阶段赋予默认值。</span><br></pre></td></tr></table></figure><h3 id="1-3-5-解析"><a href="#1-3-5-解析" class="headerlink" title="1.3.5 解析"></a>1.3.5 解析</h3><p>将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用。</p><h4 id="1-3-5-1-什么是静态链接｜动态链接？"><a href="#1-3-5-1-什么是静态链接｜动态链接？" class="headerlink" title="1.3.5.1 什么是静态链接｜动态链接？"></a>1.3.5.1 什么是静态链接｜动态链接？</h4><p>像类信息是确定的，这种属于静态符号。</p><p>方法可能会设计到多态，不确定，只能动态运行时确定，运行时才能确定内存中的位置。</p><h3 id="1-3-6-初始化"><a href="#1-3-6-初始化" class="headerlink" title="1.3.6 初始化"></a>1.3.6 初始化</h3><p>对类的静态变量初始化为指定的值，执行静态代码块，构造函数。</p><h3 id="1-3-6-1-初始化顺序"><a href="#1-3-6-1-初始化顺序" class="headerlink" title="1.3.6.1 初始化顺序"></a>1.3.6.1 初始化顺序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;superclass static ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;superclass constructor ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;childclass static ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;childclass constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">superclass <span class="keyword">static</span> ...</span><br><span class="line">childclass <span class="keyword">static</span> ...</span><br><span class="line">superclass constructor ...</span><br><span class="line">childclass constructor</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>静态初始化块优先加载</li><li>构造器函数再加载</li><li>父类加载优先子类</li></ul><h2 id="1-4-类加载器"><a href="#1-4-类加载器" class="headerlink" title="1.4 类加载器"></a>1.4 类加载器</h2><h3 id="1-4-1-类加载器种类"><a href="#1-4-1-类加载器种类" class="headerlink" title="1.4.1 类加载器种类"></a>1.4.1 类加载器种类</h3><ul><li><p>引导类加载器： bootstarpClassLoader (C++中实现) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等</span><br></pre></td></tr></table></figure></li><li><p>扩展类加载器： static class ExtClassLoader extends URLClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</span><br></pre></td></tr></table></figure></li><li><p>应用程序类加载器： static class AppClassLoader extends URLClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类</span><br></pre></td></tr></table></figure></li><li><p>自定义类加载器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责加载用户自定义路径下的类包</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-1-1-如何验证加载的path"><a href="#1-4-1-1-如何验证加载的path" class="headerlink" title="1.4.1.1 如何验证加载的path"></a>1.4.1.1 如何验证加载的path</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.class.getClassLoader());</span><br><span class="line">System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">System.out.println(User.class.getClassLoader().getClass().getName());</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure><p><code>String.class.getClassLoader()</code> 为什么是null呢？</p><p>因为String是jdk原生的类，在加载必须需要引导类加载器来加载，而引导类加载器是在C++中定义的，所以java代码中肯定拿不到。</p><p>如何证明呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道ExtClassLoader的父加载器是BootstarpClassLoader，这里在初始化ExtClassLoader的时候，设置父加载器的时候传的值是null。</p><h3 id="1-4-2-类加载器之间的关系"><a href="#1-4-2-类加载器之间的关系" class="headerlink" title="1.4.2 类加载器之间的关系"></a>1.4.2 类加载器之间的关系</h3><ul><li>ExtClassLoader 是 AppClassLoader 的父加载器，而不是父类！</li><li>自定义类加载器的父加载器是 AppClassLoader</li></ul><h3 id="1-4-3-类加载器什么时候创建的"><a href="#1-4-3-类加载器什么时候创建的" class="headerlink" title="1.4.3 类加载器什么时候创建的"></a>1.4.3 类加载器什么时候创建的</h3><p>上面已经提到，在C++程序创建了引导类加载器之后，或创建java的Launcher类，在构造这个类的时候，创建的ExtClassLoader和AppClassLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Launcher是单例的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandlerFactory factory = <span class="keyword">new</span> Launcher.Factory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandler fileHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-双亲委派机制"><a href="#1-5-双亲委派机制" class="headerlink" title="1.5 双亲委派机制"></a>1.5 双亲委派机制</h2><img src="https://oscimg.oschina.net/oscnet/up-3f17f266b143eaf2705ce60de4d09324e1f.png" style="zoom:50%;" /><h3 id="1-5-1-什么是双亲委派？"><a href="#1-5-1-什么是双亲委派？" class="headerlink" title="1.5.1 什么是双亲委派？"></a>1.5.1 什么是双亲委派？</h3><p>这里类加载其实就有一个双亲委派机制，加载某个类时会先判断是否已经加载过，如果已经加载过，直接返回，如果没加载过，先委托父加载器寻找目标类，父加载器找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的 类加载路径中查找并载入目标类。 </p><p>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器， 应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。 </p><p><strong>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载。</strong></p><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader 的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下:</p><ul><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器;如果有父加载器，则由父加 载器加载(即调用parent.loadClass(name, false);).或者是调用bootstrap类加载器来加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name); </span><br><span class="line">          <span class="comment">// 如果已经加载了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果父加载器不是null，由上层加载器负责加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果没有加载过，则去当前加载器的执行路径下寻找</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-为什么需要双亲委派？"><a href="#1-5-2-为什么需要双亲委派？" class="headerlink" title="1.5.2 为什么需要双亲委派？"></a>1.5.2 为什么需要双亲委派？</h3><ul><li>沙箱安全机制:自己写的java.lang.String.class类不会被加载，这样便可以防止核心</li><li>API库被随意篡改 避免类的重复加载:当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li></ul><h4 id="1-5-2-1-自定义的-java-lang-String能否被加载"><a href="#1-5-2-1-自定义的-java-lang-String能否被加载" class="headerlink" title="1.5.2.1 自定义的 java.lang.String能否被加载"></a>1.5.2.1 自定义的 java.lang.String能否被加载</h4><p>肯定是不能加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><p>为什么提示的是找不到main方法这个错误呢？</p><p>因为类加载加载的String类根本就不是我们自己定义的这个类，而是JDK的String，JDK中String的类中有没有main方法。</p><h4 id="1-5-2-2-为什么加载先是在app加载器而不是bootstrap加载器？"><a href="#1-5-2-2-为什么加载先是在app加载器而不是bootstrap加载器？" class="headerlink" title="1.5.2.2 为什么加载先是在app加载器而不是bootstrap加载器？"></a>1.5.2.2 为什么加载先是在app加载器而不是bootstrap加载器？</h4><p>因为大部分代码都是需要app加载器来加载。</p><h3 id="1-5-3-如何自定义类加载器"><a href="#1-5-3-如何自定义类加载器" class="headerlink" title="1.5.3 如何自定义类加载器"></a>1.5.3 如何自定义类加载器</h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = fis.available();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        fis.read(data);</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/export/data&quot;</span>);</span><br><span class="line">        <span class="comment">//export/data/com/ibli/jvm 几级目录，将User类的复制类User.class丢入该目录</span></span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.ibli.jvm.User&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user sout ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user sout ...</span><br><span class="line">com.ibli.jvm.MyClassLoader</span><br></pre></td></tr></table></figure><p>我现在要加载 <code>com.ibli.jvm.User</code>类，在 <code>/export/data/com/ibli/jvm</code>下有一个<code>User.class</code>。</p><p>我定义的加载器去加载的时候，上层的加载器们的各自路径下都没有这个类，所以最终肯定是由我自定义的类加载器来加载。</p><h3 id="1-5-4-如何打破双亲委派"><a href="#1-5-4-如何打破双亲委派" class="headerlink" title="1.5.4 如何打破双亲委派"></a>1.5.4 如何打破双亲委派</h3><h4 id="1-5-4-1-什么是打破双亲委派"><a href="#1-5-4-1-什么是打破双亲委派" class="headerlink" title="1.5.4.1 什么是打破双亲委派"></a>1.5.4.1 什么是打破双亲委派</h4><p>类通过子加载器加载 不用父加载器加载。</p><h4 id="1-5-4-2-如何打破"><a href="#1-5-4-2-如何打破" class="headerlink" title="1.5.4.2 如何打破"></a>1.5.4.2 如何打破</h4><p>重写loadClass方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那我们就重写一下loadClass方法，那使用父加载器的逻辑删除掉就可以了。</p><p>但是会保一个错误，找不到Object类文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.FileNotFoundException: /export/data/java/lang/Object.class (No such file or directory)</span><br><span class="line">at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">at java.io.FileInputStream.open(FileInputStream.java:<span class="number">195</span>)</span><br></pre></td></tr></table></figure><p>为什么呢？ 因为在java中所有的类都有一个公共的基类 Object，加载的时候，如果有父类，肯定优先加载父类。</p><p>如何解决这个问题呢？</p><p>我们尝试一下在 <code>/export/data/java/lang/</code>路径下添加一下这个类，再次尝试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:761)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">at com.ibli.jvm.MyClassLoader.findClass(MyClassLoader.java:32)</span><br><span class="line">at com.ibli.jvm.MyClassLoader.loadClass(MyClassLoader.java:59)</span><br></pre></td></tr></table></figure><p>依然是不可以的，这里报错信息提示的是 <code>Prohibited package name: java.lang</code>。</p><p>这是为什么呢？</p><p>这里再一次印证了上面我们提到的，JDK自己定义的类文件绝对不允许自定义加载的，这个我们自己的Object是不可能被加载的。</p><p>如何解决上面的问题呢？</p><p>这里需要对Object特殊处理一下，Object就是用AppClassLoader来加载就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;com.ibli.jvm&quot;</span>)) &#123;</span><br><span class="line">      c = Launcher.getLauncher().getClassLoader().loadClass(name);</span><br><span class="line">      <span class="comment">// 或者 c = this.getParent().loadClass(name);</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       c = findClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user sout ...</span><br><span class="line">com.ibli.jvm.MyClassLoader</span><br></pre></td></tr></table></figure><h3 id="1-5-5-Tomcat打破双亲委派？"><a href="#1-5-5-Tomcat打破双亲委派？" class="headerlink" title="1.5.5 Tomcat打破双亲委派？"></a>1.5.5 Tomcat打破双亲委派？</h3><h4 id="1-5-5-1-Tomcat-如果使用默认的双亲委派类加载机制行不行"><a href="#1-5-5-1-Tomcat-如果使用默认的双亲委派类加载机制行不行" class="headerlink" title="1.5.5.1 Tomcat 如果使用默认的双亲委派类加载机制行不行?"></a>1.5.5.1 Tomcat 如果使用默认的双亲委派类加载机制行不行?</h4><p>我们思考一下: Tomcat是个web容器， 那么它要解决什么问题:</p><ul><li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是 独立的，保证相互隔离。</li><li>部署在同一个web容器中<strong>相同的类库相同的版本</strong>可以共享。否则，如果服务器有10个应用程 序，那么要有10份相同的类库加载进虚拟机。</li><li> web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li><li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中 运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</li></ul><h4 id="1-5-5-2-Tomcat为什么不使用默认的双亲委派"><a href="#1-5-5-2-Tomcat为什么不使用默认的双亲委派" class="headerlink" title="1.5.5.2 Tomcat为什么不使用默认的双亲委派"></a>1.5.5.2 Tomcat为什么不使用默认的双亲委派</h4><p>如果tomcat使用默认的双亲委派会有哪些问题：</p><p>第一个问题，**<font color=green>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份</font>**。 </p><p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。 </p><p>第三个问题和第一个问题一样。 </p><p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢? 我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p><h4 id="1-5-5-3-tomcat类加载流程"><a href="#1-5-5-3-tomcat类加载流程" class="headerlink" title="1.5.5.3 tomcat类加载流程"></a>1.5.5.3 tomcat类加载流程</h4><p><img src="https://oscimg.oschina.net/oscnet/up-73a62d636202f492f8da71a9246c6d6639e.png"></p><p>Tomcat的几个主要类加载器:</p><ul><li><p>commonLoader: Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问; </p></li><li><p>catalinaLoader: Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见; </p></li><li><p>sharedLoader: 各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见; </p></li><li><p>WebappClassLoader:各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本， 这样实现就能加载各自的spring版本;</p></li></ul><p>从图中的委派关系中可以看出: </p><ul><li>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用， 从而实现了公有类库的共用</li><li>CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</li><li> WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader 实例之间相互隔离。 </li><li>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃: <strong><font color=red>当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例， 并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</font></strong></li></ul><p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗? 答案是:违背了。</p><p><strong><font color=blue> 很显然，tomcat 为了实现隔离性，每个 webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制。</font></strong></p><p>如何实现Tomcat的加载webapp的效果呢；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/export/data/&quot;</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.ibli.jvm.User&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/export/data1/&quot;</span>);</span><br><span class="line">        Class clazz1 = classLoader.loadClass(<span class="string">&quot;com.ibli.jvm.User&quot;</span>);</span><br><span class="line">        Object obj1 = clazz.newInstance();</span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>两个User类的文件名相同，但是编译的时候里面的sout方法输出的内容是不同的，方便区分</li><li>构建了两个加载器</li></ul><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user sout ...</span><br><span class="line">com.ibli.jvm.MyClassLoader</span><br><span class="line"></span><br><span class="line">user1 sout ...</span><br><span class="line">com.ibli.jvm.MyClassLoader</span><br></pre></td></tr></table></figure><p>这里两个加载器其实不是一个实例，注意呦！</p><p>注意:<strong>同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类 加载器也是同一个才能认为他们是同一个</strong>。</p><h1 id="2-JVM整体结构的深度剖析"><a href="#2-JVM整体结构的深度剖析" class="headerlink" title="2. JVM整体结构的深度剖析"></a>2. JVM整体结构的深度剖析</h1><h2 id="2-1-JVM整体结构图"><a href="#2-1-JVM整体结构图" class="headerlink" title="2.1 JVM整体结构图"></a>2.1 JVM整体结构图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-1cba664a7c4e0078f707899a9ee33412c3b.png"></p><p>JVM的整体结构如上面所示，主要分成3大部分：</p><ul><li>类加载子系统</li><li>运行时数据区</li><li>字节码执行引擎</li></ul><p>我们编写的程序，通过类加载子系统加载到运行时数据区，也就是内存中，然后通过字节码执行引擎来执行，这是一个简单的大体描述。其中，最为重要的也就是运行时数据区这一部分，东西非常重要，也非常多，和我们平时的优化也息息相关。</p><p>下面我们通过一个具体的实例来展开分别学习一下运行时数据区的每个部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User1 user1 = <span class="keyword">new</span> User1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123; <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h2><p>首先是虚拟机栈也叫做线程栈，其实就是之前我们经常说的，创建java线程的时候，会为每个线程在内存中存放一个单独的空间来存储线程私有的数据，其实就是线程栈。</p><p>Java虚拟机栈（Java Virtual Machine Stack）<strong>是线程私有的</strong>，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8bae23ae1d35aef8a88ea582d816340ed96.png"></p><h3 id="2-2-1-局部变量表"><a href="#2-2-1-局部变量表" class="headerlink" title="2.2.1 局部变量表"></a>2.2.1 局部变量表</h3><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><blockquote><p>对于引用类型的对象，通常的说法是，对象的实例数据存放在堆中，而线程栈中存放的是这个对象的引用，也就是栈中存放的是这个对象在堆内存中实际的内存地址。</p><p>这种说法并非十分准确，实际真是的是，栈中存储的是这个对象在C++中对应对象的地址，然后那个C++对象才是真实指向对中的地址。</p></blockquote><h4 id="2-2-1-1-局部变量表的数据怎么存储的？"><a href="#2-2-1-1-局部变量表的数据怎么存储的？" class="headerlink" title="2.2.1.1 局部变量表的数据怎么存储的？"></a>2.2.1.1 局部变量表的数据怎么存储的？</h4><p>这些数据类型在局部变量表中的存储空间以 <strong><font color=red>局部变量槽（Slot）</font></strong> 来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h4 id="2-2-1-2-Slot槽的特点"><a href="#2-2-1-2-Slot槽的特点" class="headerlink" title="2.2.1.2 Slot槽的特点"></a>2.2.1.2 Slot槽的特点</h4><ul><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照声明顺序被复制到局部变量表中的每一个slot上</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或者double类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么该对象引用this将会存放在index为0的slot处,其余的参数按照参数表顺序排列。**(非静态方法的局部变量表index=0的位置存放this指针)**</p></li><li><p>静态方法中不能引用this，是因为静态方法所对应的栈帧当中的局部变量表中不存在this</p></li></ul><h4 id="2-2-1-3-Slot槽的重复利用"><a href="#2-2-1-3-Slot槽的重复利用" class="headerlink" title="2.2.1.3 Slot槽的重复利用"></a>2.2.1.3 Slot槽的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上情况下使用slot的数量为3个,this占0号、a单独占1个槽号、c重复使用了b的槽号。</p><h3 id="2-2-2-操作数栈"><a href="#2-2-2-操作数栈" class="headerlink" title="2.2.2 操作数栈"></a>2.2.2 操作数栈</h3><h4 id="2-2-2-1-什么是操作数栈"><a href="#2-2-2-1-什么是操作数栈" class="headerlink" title="2.2.2.1 什么是操作数栈"></a>2.2.2.1 什么是操作数栈</h4><p>相对于成员变量（或属性），如果是基本数据变量，则在栈中创建，随栈销毁而销毁。对象一般在堆中创建，栈中对象句柄为堆中对象的引用。</p><blockquote><p> <strong>逃逸分析可在栈中创建对象</strong> 逃逸分析大概值的是对象永远只作用于当前方法（栈桢）的时候，对象的创建会选择直接在栈上，而不会在堆上创建。</p></blockquote><p>是一个先进后出的栈结构,只要的作用是在程序运行期间存储计算所需要的值或者临时结果</p><p>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）,某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作）比如：执行复制、交换、求和等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iconst_5 将<span class="keyword">int</span>类型常量<span class="number">5</span>压入栈</span><br><span class="line">lconst_0 将<span class="keyword">long</span>类型常量<span class="number">0</span>压入栈</span><br><span class="line">lconst_1 将<span class="keyword">long</span>类型常量<span class="number">1</span>压入栈</span><br><span class="line">fconst_0 将<span class="keyword">float</span>类型常量<span class="number">0</span>压入栈</span><br><span class="line">fconst_1 将<span class="keyword">float</span>类型常量<span class="number">1</span>压入栈</span><br><span class="line">dconst_0 将<span class="keyword">double</span>类型常量<span class="number">0</span>压入栈</span><br><span class="line">dconst_1 将<span class="keyword">double</span>类型常量<span class="number">1</span>压入栈</span><br><span class="line">bipush 将一个<span class="number">8</span>位带符号整数压入栈</span><br><span class="line">sipush 将<span class="number">16</span>位带符号整数压入栈</span><br><span class="line">ldc 把常量池中的项压入栈</span><br><span class="line">ldc_w 把常量池中的项压入栈(使用宽索引)</span><br><span class="line">ldc2_w 把常量池中<span class="keyword">long</span>类型或者<span class="keyword">double</span>类型的项压入栈(使用宽索引) 从栈中的局部变量中装载值的指令</span><br><span class="line">iload 从局部变量中装载<span class="keyword">int</span>类型值</span><br></pre></td></tr></table></figure><p>上面是一些局部变量的操作指令。</p><p>比如上面Math的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123; <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反汇编之后可以看到这个java代码对应的jvm指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: ireturn</span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-操作数栈有什么特点"><a href="#2-2-2-2-操作数栈有什么特点" class="headerlink" title="2.2.2.2 操作数栈有什么特点"></a>2.2.2.2 操作数栈有什么特点</h4><ul><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的<strong>最大深度在编译期就定义好了</strong>，保存在方法的code属性中，为max_stack的值。</p></li><li><p>栈中的任何一个元素都是可以任意的java数据类型.32bit的类型占用一个栈单位深度,64bit的类型占用两个栈深度单位</p></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</p></li></ul><h3 id="2-2-3-动态链接"><a href="#2-2-3-动态链接" class="headerlink" title="2.2.3 动态链接"></a>2.2.3 动态链接</h3><p>上面讲类加载的时候应该提到过，在解析阶段 ，会把符号引用设置成直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如main方法，就是静态符号 ，而 <code>math.compute();</code>则只能在运行时动态获取。</p><blockquote><p>这部分涉及到了java特性中的 <strong>多态</strong></p></blockquote><h4 id="2-2-3-1-什么是静态链接｜动态链接"><a href="#2-2-3-1-什么是静态链接｜动态链接" class="headerlink" title="2.2.3.1 什么是静态链接｜动态链接"></a>2.2.3.1 什么是静态链接｜动态链接</h4><ul><li><strong>静态链接</strong></li></ul><p>当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p><ul><li><strong>动态链接</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p><h4 id="2-2-3-2-什么是绑定？"><a href="#2-2-3-2-什么是绑定？" class="headerlink" title="2.2.3.2 什么是绑定？"></a>2.2.3.2 什么是绑定？</h4><p>对应的方法的绑定机制为：<strong>早起绑定</strong>（Early Binding）和<strong>晚期绑定</strong>（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h4 id="2-2-3-3-方法调用是怎么实现的"><a href="#2-2-3-3-方法调用是怎么实现的" class="headerlink" title="2.2.3.3 方法调用是怎么实现的"></a>2.2.3.3 方法调用是怎么实现的</h4><ul><li><p>普通调用指令：</p><ul><li><p>1.<code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本；</p></li><li><p>2.<code>invokespecial</code>:调用方法、私有及父类方法，解析阶段确定唯一方法版本；</p></li><li><p>3.<code>invokevirtual</code>调用所有虚方法；</p></li><li><p>4.<code>invokeinterface</code>：调用接口方法；</p></li></ul></li><li><p>动态调用指令（Java7新增）：</p><ul><li>5.<code>invokedynamic</code>：动态解析出需要调用的方法，然后执行</li></ul></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而<code>invokedynamic</code>指令则支持由用户确定方法版本。</p><p>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法；</p><p>其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）、invokeinterface指令调用的方法称称为虚方法。</p><p>如何验证上面所说的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析调用中非虚方法、虚方法的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father默认构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father show static&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father show common&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类方法，因为静态方法不能被重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son show static&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son show private&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot; 大头儿子&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">&quot; 大头儿子&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line">        <span class="comment">//invokevirtual 因为此方法声明有final 不能被子类重写，所以也认为该方法是非虚方法</span></span><br><span class="line">        showFinal();</span><br><span class="line">        <span class="comment">//虚方法如下</span></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showCommon();<span class="comment">//没有显式加super，被认为是虚方法，因为子类可能重写showCommon</span></span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface  不确定接口实现类是哪一个 需要重写</span></span><br><span class="line">        in.methodA();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后反汇编Son.class ， 得到如下字节码指令文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Son.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">ibli</span>.<span class="title">jvm</span>.<span class="title">Son</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">ibli</span>.<span class="title">jvm</span>.<span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.ibli.jvm.Son();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method com/ibli/jvm/Father.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.ibli.jvm.Son(<span class="keyword">int</span>);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class com/ibli/jvm/Son</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method show:()V</span></span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       <span class="number">7</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String Son show static</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">19</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">22</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">13</span>                 <span class="comment">// String  大头儿子</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">14</span>                 <span class="comment">// Method showStatic:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">5</span>: ldc           #<span class="number">13</span>                 <span class="comment">// String  大头儿子</span></span><br><span class="line">       <span class="number">7</span>: invokestatic  #<span class="number">15</span>                 <span class="comment">// Method com/ibli/jvm/Father.showStatic:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">10</span>: aload_0</span><br><span class="line">      <span class="number">11</span>: ldc           #<span class="number">16</span>                 <span class="comment">// String  hello!</span></span><br><span class="line">      <span class="number">13</span>: invokespecial #<span class="number">17</span>                 <span class="comment">// Method showPrivate:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">16</span>: aload_0</span><br><span class="line">      <span class="number">17</span>: invokespecial #<span class="number">18</span>                 <span class="comment">// Method com/ibli/jvm/Father.showCommon:()V</span></span><br><span class="line">      <span class="number">20</span>: aload_0</span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">19</span>                 <span class="comment">// Method showFinal:()V</span></span><br><span class="line">      <span class="number">24</span>: aload_0</span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">20</span>                 <span class="comment">// Method showCommon:()V</span></span><br><span class="line">      <span class="number">28</span>: aload_0</span><br><span class="line">      <span class="number">29</span>: invokevirtual #<span class="number">21</span>                 <span class="comment">// Method info:()V</span></span><br><span class="line">      <span class="number">32</span>: aconst_null</span><br><span class="line">      <span class="number">33</span>: astore_1</span><br><span class="line">      <span class="number">34</span>: aload_1</span><br><span class="line">      <span class="number">35</span>: invokeinterface #<span class="number">22</span>,  <span class="number">1</span>           <span class="comment">// InterfaceMethod com/ibli/jvm/MethodInterface.methodA:()V</span></span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-方法出口"><a href="#2-2-4-方法出口" class="headerlink" title="2.2.4 方法出口"></a>2.2.4 方法出口</h3><p>1.调用者（方法的调用者可能也是一个方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>2.在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称异常完成出口方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p><h2 id="2-2-程序计数器"><a href="#2-2-程序计数器" class="headerlink" title="2.2 程序计数器"></a>2.2 程序计数器</h2><p>程序计数器之前也被称为PC寄存器。</p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里 ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，<strong>这个计数器值则应为空</strong>（Undefined）。</p><p><strong><font color=red>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</font></strong></p><h2 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8bae23ae1d35aef8a88ea582d816340ed96.png"></p><p><strong>本地方法栈也是线程私有的。</strong></p><h2 id="2-4-方法区"><a href="#2-4-方法区" class="headerlink" title="2.4 方法区"></a>2.4 方法区</h2><h3 id="2-4-1-什么是方法区"><a href="#2-4-1-什么是方法区" class="headerlink" title="2.4.1 什么是方法区"></a>2.4.1 什么是方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p><h3 id="2-4-2-方法区的参数配置"><a href="#2-4-2-方法区的参数配置" class="headerlink" title="2.4.2 方法区的参数配置"></a>2.4.2 方法区的参数配置</h3><p>关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N<br>-XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。<br>-XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。</p><blockquote><p>这个跟早期jdk版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久代的初始容量。</p></blockquote><p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p><p><strong>Full GC会同时收集方法区和堆</strong></p><h2 id="2-5-堆"><a href="#2-5-堆" class="headerlink" title="2.5 堆"></a>2.5 堆</h2><h3 id="2-5-1-堆的分区结构"><a href="#2-5-1-堆的分区结构" class="headerlink" title="2.5.1 堆的分区结构"></a>2.5.1 堆的分区结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-b0c839ade955bb783a355f34bf004bdab86.png"></p><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆</p><blockquote><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。</p></blockquote><h3 id="2-5-2-为什么eden和service的配比是8-1"><a href="#2-5-2-为什么eden和service的配比是8-1" class="headerlink" title="2.5.2 为什么eden和service的配比是8:1"></a>2.5.2 为什么eden和service的配比是8:1</h3><p> 这个和垃圾回收机制有关，主要考虑到大部分对象都是“朝生暮死”，每次垃圾回收的时候，都回收 eden + 1个service区的对象，而剩余的对象移动到另一个service区。</p><p>也有一些对象因为某些原因，比如分代年龄达到15，会被移动到老年代。</p><p>这个8:1能够更大限度的利用堆的资源。</p><h3 id="2-5-3-什么是垃圾回收"><a href="#2-5-3-什么是垃圾回收" class="headerlink" title="2.5.3 什么是垃圾回收"></a>2.5.3 什么是垃圾回收</h3><p>这个下面会有专门的垃圾回收章节展开。主要是清理内存中没用的对象，是释放内存。至于判断哪些对象是“垃圾”，有引用计数法和可达性分析等。</p><p>不同分区的对象，根据它的特性也有不同的垃圾回收算法和垃圾收集器。</p><p>这里我们只需要堆是垃圾回收的主要区域，当然方法区也会进行垃圾回收。</p><h3 id="2-5-4-大名鼎鼎的STW"><a href="#2-5-4-大名鼎鼎的STW" class="headerlink" title="2.5.4 大名鼎鼎的STW"></a>2.5.4 大名鼎鼎的STW</h3><h4 id="2-5-4-1-什么是stw？"><a href="#2-5-4-1-什么是stw？" class="headerlink" title="2.5.4.1 什么是stw？"></a>2.5.4.1 什么是stw？</h4><p>Stop the world 的简称。就是在垃圾收集器进行Full GC的时候，需要暂停用户线程，对于用户来说，好像服务停止了一样。</p><p>当然这个时间是很短暂的。我们进行调优的时候，主要的目标就是为了尽量缩短STW的时间间隔和减少Young GC的次数。</p><h4 id="2-5-4-2-为什么会有stw？"><a href="#2-5-4-2-为什么会有stw？" class="headerlink" title="2.5.4.2 为什么会有stw？"></a>2.5.4.2 为什么会有stw？</h4><p>因为GC的过程中，如果还有用户线程工作的话，势必会产生新的对象，甚至新的垃圾。这样会对垃圾回收过程造成干扰，无法判断哪些是新生成的垃圾对象。</p><p><strong><font color=red>静态的对象是如何存储的？ 引用是存储在方法区的  对象实际是存储在堆的</font></strong></p><h2 id="2-6-直接内存"><a href="#2-6-直接内存" class="headerlink" title="2.6 直接内存"></a>2.6 直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。<strong>但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</strong>。</p><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="2-7-运行时错误"><a href="#2-7-运行时错误" class="headerlink" title="2.7 运行时错误"></a>2.7 运行时错误</h2><h3 id="2-7-1-OOM"><a href="#2-7-1-OOM" class="headerlink" title="2.7.1 OOM"></a>2.7.1 OOM</h3><h4 id="2-7-1-1-什么是OOM"><a href="#2-7-1-1-什么是OOM" class="headerlink" title="2.7.1.1 什么是OOM"></a>2.7.1.1 什么是OOM</h4><p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。看下关于的官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个<strong>error</strong>（注：非exception，因为这个问题已经严重到不足以被应用处理）。</p><h4 id="2-7-1-2-哪些地方会发生OOM"><a href="#2-7-1-2-哪些地方会发生OOM" class="headerlink" title="2.7.1.2 哪些地方会发生OOM"></a>2.7.1.2 哪些地方会发生OOM</h4><p>按照JVM规范，JAVA虚拟机在运行时会管理以下的内存区域：</p><ul><li>JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。</li><li>本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。</li><li>JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。</li><li>方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。</li><li>运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。</li><li>直接内存：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。</li></ul><p>程序计数器：当前线程执行的字节码的行号指示器，线程私有，按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。</p><h4 id="2-7-1-3-什么情况下会发生OOM"><a href="#2-7-1-3-什么情况下会发生OOM" class="headerlink" title="2.7.1.3 什么情况下会发生OOM"></a>2.7.1.3 什么情况下会发生OOM</h4><p><strong>内存泄露</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。</p><p><strong>内存溢出</strong>：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。</p><p><strong>超大对象</strong>：通常是一个大的数组</p><h4 id="2-7-1-4-解决办法"><a href="#2-7-1-4-解决办法" class="headerlink" title="2.7.1.4 解决办法"></a>2.7.1.4 解决办法</h4><ul><li>如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制</li><li>如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。</li><li>如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</li><li>根据业务合理配置堆内存参数</li></ul><h3 id="2-7-2-StackOverFlow"><a href="#2-7-2-StackOverFlow" class="headerlink" title="2.7.2 StackOverFlow"></a>2.7.2 StackOverFlow</h3><h4 id="2-7-2-1-什么是StackOverFlow"><a href="#2-7-2-1-什么是StackOverFlow" class="headerlink" title="2.7.2.1 什么是StackOverFlow"></a>2.7.2.1 什么是StackOverFlow</h4><p>StackOverflowError 是一个java中常出现的错误：在jvm运行时的数据区域中有一个java虚拟机栈，当执行java方法时会进行压栈弹栈的操作。在栈中会保存局部变量，操作数栈，方法出口等等。jvm规定了栈的最大深度，当执行时栈的深度大于了规定的深度，就会抛出StackOverflowError错误。</p><h4 id="2-7-2-2-哪些地方会发生StackOverFlow"><a href="#2-7-2-2-哪些地方会发生StackOverFlow" class="headerlink" title="2.7.2.2 哪些地方会发生StackOverFlow"></a>2.7.2.2 哪些地方会发生StackOverFlow</h4><ul><li>虚拟机栈/线程栈</li><li>本地方法栈</li></ul><h4 id="2-7-2-3-什么情况下会发生StackOverFlow"><a href="#2-7-2-3-什么情况下会发生StackOverFlow" class="headerlink" title="2.7.2.3 什么情况下会发生StackOverFlow"></a>2.7.2.3 什么情况下会发生StackOverFlow</h4><ul><li>无限递归循环调用（最常见）。</li><li>执行了大量方法，导致线程栈空间耗尽。</li><li>方法内声明了海量的局部变量。</li><li>native 代码有栈上分配的逻辑，并且要求的内存还不小，比如 java.net.SocketInputStream.read0 会在栈上要求分配一个 64KB 的缓存（64位 Linux）。</li></ul><h4 id="2-7-2-4-解决办法"><a href="#2-7-2-4-解决办法" class="headerlink" title="2.7.2.4 解决办法"></a>2.7.2.4 解决办法</h4><p>常见的解决方法包括以下几种：</p><ul><li>修复引发无限递归调用的异常代码， 通过程序抛出的异常堆栈，找出不断重复的代码行，按图索骥，修复无限递归 Bug。</li><li>排查是否存在类之间的循环依赖。</li><li>排查是否存在在一个类中对当前类进行实例化，并作为该类的实例变量。</li><li>通过 JVM 启动参数 -Xss 增加线程栈内存空间， 某些正常使用场景需要执行大量方法或包含大量局部变量，这时可以适当地提高线程栈空间限制，例如通过配置 -Xss2m 将线程栈空间调整为 2 mb。</li></ul><p>方法区是内存连续的吗？</p><h1 id="3-Java内存分配机制"><a href="#3-Java内存分配机制" class="headerlink" title="3.Java内存分配机制"></a>3.Java内存分配机制</h1><p>什么是逃逸分析 默认开启</p><p>什么是标量替换</p><p>对象的属性拆散 栈桢只存出属性 </p><p>对象创建分配的内存是连续的吗</p><p>上面的两个例子？？？？</p><p>大对象直接进入老年代？什么是大对象？</p><p>eden都放不下 ？有个参数去控制</p><p>为什么这么设计？</p><p>有两种垃圾收集器支持收集大对象 series parNew</p><p>长期存活的对象进入老年代？</p><p>对象动态年龄判断</p><p>如何设置jvm参数</p><p>参考因素：系统硬件参数  还要考虑压力参数 并发量</p><p>年龄动态判断机制</p><p>空间担保机制</p><p>如何判断对象是否是垃圾 </p><p>引用计数算法 以及 四种引用</p><p><a href="https://www.processon.com/view/5fb5d9e4e0b34d0d2241b8ac?fromnew=1">jvm结构</a></p><p><a href="https://www.processon.com/view/5f781d8763768906e65d5b4d?fromnew=1">JVM 深入理解Java虚拟机</a></p><p><strong><a href="https://juejin.cn/post/6935362175322030088">JVM (三)运行时数据区</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-从JDK源码剖析类加载机制&quot;&gt;&lt;a href=&quot;#1-从JDK源码剖析类加载机制&quot; class=&quot;headerlink&quot; title=&quot;1. 从JDK源码剖析类加载机制&quot;&gt;&lt;/a&gt;1. 从JDK源码剖析类加载机制&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么需要类加</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入学习并发编程（图灵-杨过）</title>
    <link href="http://example.com/wiki/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-04T03:48:18.000Z</published>
    <updated>2022-01-13T09:21:30.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h2><h3 id="2-1-volatile的作用"><a href="#2-1-volatile的作用" class="headerlink" title="2.1 volatile的作用"></a>2.1 volatile的作用</h3><p><font color=red>Volatile 只能修饰成员变量，不能修饰局部变量。</font></p><blockquote><p>1、及时可见性   </p><p>2、指令重排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jmm04_CodeAtomic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                        counter++;<span class="comment">//分三步- 读，自加，写回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ <strong>volatile无法保证原子操作</strong></p><h3 id="2-2-volatile-count-为什么会小于正确的结果？"><a href="#2-2-volatile-count-为什么会小于正确的结果？" class="headerlink" title="2.2 volatile count++为什么会小于正确的结果？"></a>2.2 volatile count++为什么会小于正确的结果？</h3><p>count++ 不是原子操作！count = count + 1;</p><ul><li>读count</li><li>计算count + 1</li><li>重新赋值count</li></ul><blockquote><p>s多个线程下可能会出现少加的情况。</p></blockquote><h4 id="2-2-1-这个数据是被丢失了呢-还是被覆盖了呢？"><a href="#2-2-1-这个数据是被丢失了呢-还是被覆盖了呢？" class="headerlink" title="2.2.1 这个数据是被丢失了呢 还是被覆盖了呢？"></a>2.2.1 这个数据是被丢失了呢 还是被覆盖了呢？</h4><p>mesi协议</p><h4 id="2-2-2-如何保证count-正确呢？"><a href="#2-2-2-如何保证count-正确呢？" class="headerlink" title="2.2.2 如何保证count++正确呢？"></a>2.2.2 如何保证count++正确呢？</h4><p>同步锁 synchronized</p><h3 id="2-3-什么是指令重排序？"><a href="#2-3-什么是指令重排序？" class="headerlink" title="2.3 什么是指令重排序？"></a>2.3 什么是指令重排序？</h3><p>在保证结果正确性的前提下，指令从内存中加载，重排序之后，可以减少内存数据加载的次数。</p><p>编译器重排  指令级重排序 执行器重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jmm05_CodeReorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    shortWait(<span class="number">10000</span>);</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">                    <span class="comment">///</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            String result = <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次 (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;）&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待一段时间，时间单位纳秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上不考虑指令重拍的情况下有几种结果呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 1, y = 0;</span><br><span class="line">x = 0, y = 1;</span><br><span class="line">x = 1, y = 1;</span><br><span class="line">x = 0, y = 0; volatile禁止指令重排序，不会出现这种情况！</span><br></pre></td></tr></table></figure><h3 id="2-4-禁止指令重排序的实现原理？"><a href="#2-4-禁止指令重排序的实现原理？" class="headerlink" title="2.4 禁止指令重排序的实现原理？"></a>2.4 禁止指令重排序的实现原理？</h3><h4 id="2-4-1-内存屏障"><a href="#2-4-1-内存屏障" class="headerlink" title="2.4.1 内存屏障"></a>2.4.1 <strong>内存屏障</strong></h4><p><img src="https://oscimg.oschina.net/oscnet/up-19f862e1ab685fc440550c90b9e3a46066b.png"></p><h3 id="2-5-指令重排有哪些现实中的例子"><a href="#2-5-指令重排有哪些现实中的例子" class="headerlink" title="2.5 指令重排有哪些现实中的例子"></a>2.5 指令重排有哪些现实中的例子</h3><h4 id="2-5-1-DCL"><a href="#2-5-1-DCL" class="headerlink" title="2.5.1 DCL"></a>2.5.1 <strong>DCL</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看汇编指令</span></span><br><span class="line"><span class="comment">     * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton myinstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重锁机制保证单例安全</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myinstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (myinstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    myinstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myinstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L8</span><br><span class="line">    LINENUMBER <span class="number">26</span> L8</span><br><span class="line">    NEW com/yg/edu/jmm/dcl/Singleton</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL com/yg/edu/jmm/dcl/Singleton.&lt;init&gt; ()V</span><br><span class="line">    PUTSTATIC com/yg/edu/jmm/dcl/Singleton.myinstance : Lcom/yg/edu/jmm/dcl/Singleton;</span><br></pre></td></tr></table></figure><p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p><blockquote><p>因为instance = new DoubleCheckLock();可以分为以下3步完成(伪代码)       </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间 </span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象 </span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null   </span></span><br></pre></td></tr></table></figure><p>由于步骤1和步骤2间可能会重排序，如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间 </span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！ instance(memory);//2.初始化对象       </span></span><br></pre></td></tr></table></figure><p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p><blockquote><p> //禁止指令重排优化 private volatile static DoubleCheckLock instance; </p></blockquote><h3 id="2-6-volatile内存语义的实现"><a href="#2-6-volatile内存语义的实现" class="headerlink" title="2.6 volatile内存语义的实现"></a>2.6 <strong>volatile内存语义的实现</strong></h3><p><img src="https://oscimg.oschina.net/oscnet/up-506a15a3e2902d645d3b418d7af730b8bc0.png"></p><p>举例来说，第二行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p><p>从上图可以看出：</p><ul><li><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li></ul></li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p><ul><li><ul><li>·在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>·在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>·在每个volatile读操作的前面插入一个LoadLoad屏障。</li><li>·在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul></li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><h3 id="2-7-synchronized能否禁止指令重排序？"><a href="#2-7-synchronized能否禁止指令重排序？" class="headerlink" title="2.7 synchronized能否禁止指令重排序？"></a>2.7 synchronized能否禁止指令重排序？</h3><p>不能</p><h3 id="2-8-如何在java代码中手动添加内存屏障？"><a href="#2-8-如何在java代码中手动添加内存屏障？" class="headerlink" title="2.8 如何在java代码中手动添加内存屏障？"></a>2.8 如何在java代码中手动添加内存屏障？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    UnsafeInstance.reflectGetUnsafe().fullFence();</span><br><span class="line">    y = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-MESI协议"><a href="#3-MESI协议" class="headerlink" title="3. MESI协议"></a>3. MESI协议</h2><h3 id="3-1-java代码是如何执行的？"><a href="#3-1-java代码是如何执行的？" class="headerlink" title="3.1 java代码是如何执行的？"></a>3.1 java代码是如何执行的？</h3><img src="https://oscimg.oschina.net/oscnet/up-5e2b4236c26b626b78e0a5c54ffd60478eb.png" style="zoom:50%;" /><h3 id="3-2-CPU是如何与内存交互的？"><a href="#3-2-CPU是如何与内存交互的？" class="headerlink" title="3.2 CPU是如何与内存交互的？"></a>3.2 CPU是如何与内存交互的？</h3><img src="https://oscimg.oschina.net/oscnet/up-da07e86004a11f1c46c1734fa59ba63daac.png" style="zoom:50%;" /><p><font color=red>CPU访问内存是通过总线，而访问总线，必须先获取总线索，而lock前缀的执行，可以获取总线锁，阻塞其他CPU进行访问。</font>这是最初的一种设计，这种方式的效率显然是很差的。</p><h3 id="3-3-MESI协议工作流程？"><a href="#3-3-MESI协议工作流程？" class="headerlink" title="3.3 MESI协议工作流程？"></a>3.3 MESI协议工作流程？</h3><img src="https://oscimg.oschina.net/oscnet/up-8b18e489f07c8be3db2b26eb2e90524ca1b.png" style="zoom:50%;" /><h3 id="3-4-什么是总线裁决？"><a href="#3-4-什么是总线裁决？" class="headerlink" title="3.4 什么是总线裁决？"></a>3.4 什么是总线裁决？</h3><p>多个cpu操作一个数据的时候，去对缓存行加锁的时候，需要总线来判断给那个cpu加锁。获取锁的缓存行变成m状态，其他的缓存行变成i状态。</p><h3 id="3-5-缓存行是几级缓存的？"><a href="#3-5-缓存行是几级缓存的？" class="headerlink" title="3.5 缓存行是几级缓存的？"></a>3.5 缓存行是几级缓存的？</h3><p>L1 Cache</p><h3 id="3-6-一个缓存行64字节装不下数据会怎样？"><a href="#3-6-一个缓存行64字节装不下数据会怎样？" class="headerlink" title="3.6 一个缓存行64字节装不下数据会怎样？"></a>3.6 一个缓存行64字节装不下数据会怎样？</h3><p><font color=red>升级成总线锁</font></p><h3 id="3-7-缓存行上加锁会影响到其他的数据吗？"><a href="#3-7-缓存行上加锁会影响到其他的数据吗？" class="headerlink" title="3.7 缓存行上加锁会影响到其他的数据吗？"></a>3.7 缓存行上加锁会影响到其他的数据吗？</h3><p>？？？</p><h3 id="3-8-MESI协议不能对寄存器失效"><a href="#3-8-MESI协议不能对寄存器失效" class="headerlink" title="3.8 MESI协议不能对寄存器失效"></a>3.8 MESI协议不能对寄存器失效</h3><p>已经加载到寄存器的指令不能失效，比如count++操作不能保证原子性</p><h3 id="3-9-MESI-数据失效之后，怎么读正确的数据呢？"><a href="#3-9-MESI-数据失效之后，怎么读正确的数据呢？" class="headerlink" title="3.9 MESI 数据失效之后，怎么读正确的数据呢？"></a>3.9 MESI 数据失效之后，怎么读正确的数据呢？</h3><p>是实时去内存中读取数据吗？ 不是的。</p><img src="https://oscimg.oschina.net/oscnet/up-c037376bafc96bbbe79db73378d27e402c2.png" style="zoom:50%;" /><ul><li>获取到lock的数据修改之后，并不是直接把数据写到缓存行中，而是写到了store buffer中。</li><li>获取lock的cpu在修改数据是，会把当前缓存行设置成m状态，同时发送一个消息到其他cpu</li><li>其他没有获取到lock的缓存行中的数据就失效了，变成i状态，同时把失效的数据放到一个队列中</li><li>当失效数据都放到缓冲队列之后，获取lock的cpu把store buffer中的数据刷到缓存行中。最后在更新到内存中。</li><li>在Cpu空闲的时候，将失效的数据在队列中清除，之前仅仅是把数据放到失效队列中，缓存行中的数据其实还在</li></ul><h3 id="3-10-happens-before原则"><a href="#3-10-happens-before原则" class="headerlink" title="3.10 happens-before原则"></a>3.10 happens-before原则</h3><p><img src="https://oscimg.oschina.net/oscnet/up-f9a3b32c0737241fdbbe79d7bf104de61b4.png"></p><h2 id="4、Synchronized关键字"><a href="#4、Synchronized关键字" class="headerlink" title="4、Synchronized关键字"></a>4、Synchronized关键字</h2><h3 id="4-1-synchronized-1-6之前和之后有什么区别"><a href="#4-1-synchronized-1-6之前和之后有什么区别" class="headerlink" title="4.1 synchronized 1.6之前和之后有什么区别"></a>4.1 synchronized 1.6之前和之后有什么区别</h3><img src="https://oscimg.oschina.net/oscnet/up-b88652d8e316f622103f29c5c917e92f5c6.png" style="zoom:50%;" /><ul><li>偏向锁只针对有一个线程加锁的情况</li><li>轻量级锁针对有少数线程竞争，但是竞争不强烈（如何定义不强烈？ 锁占用时间短，线程可交替执行）</li><li>重量级锁 依赖管程 依靠操作系统底层的互斥量Mutex, 由操作系统维护，涉及到CPU用户态和内核态的切换，比较重</li></ul><h3 id="4-2-什么是自旋锁"><a href="#4-2-什么是自旋锁" class="headerlink" title="4.2 什么是自旋锁"></a>4.2 什么是自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"><span class="keyword">do</span>....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程竞争锁资源的时候，后到的线程自旋等待正在执行的线程释放锁资源，然后自己去竞争，自旋的过程中，一直占用CPU。</p><p><font color=red>自旋锁使用于同步代码块里面执行逻辑很简单或者比较快的场景。这样另一个进程可以很快获得锁。</font></p><p><strong>自旋锁是处于性能的考虑。避免进程上下文切换，等待线程阻塞和唤醒的性能开销。</strong></p><p>自旋锁成功之后升级为轻量级锁，如果自旋次数够了依旧没有获取到锁，便升级成为重量级锁。</p><h3 id="4-3-锁升级的过程是否可逆？"><a href="#4-3-锁升级的过程是否可逆？" class="headerlink" title="4.3 锁升级的过程是否可逆？"></a><strong>4.3 锁升级的过程是否可逆？</strong></h3><p>不可逆</p><h3 id="4-4-synchronized如何使用？"><a href="#4-4-synchronized如何使用？" class="headerlink" title="4.4 synchronized如何使用？"></a>4.4 synchronized如何使用？</h3><ul><li>普通方法<ul><li>锁的是当前的对象，凡是这个实例对象相关的方法都互斥</li><li>即便这个类存在static的同步方法，不和这个实例对象相关的两个线程，不会冲突</li></ul></li><li>静态方法<ul><li>锁范围是当前类实例</li><li>注意所的范围才好弄清楚是否冲突</li><li>普通同步方法和静态同步方法不冲突，因为不是所的一个实例</li></ul></li><li>方法内部同步块<ul><li>锁的范围最小</li><li>锁实例一般是成员对象，不同成员对象的同步代码块执行不冲突</li></ul></li></ul><h3 id="4-5-synchronized底层原理是怎样的？"><a href="#4-5-synchronized底层原理是怎样的？" class="headerlink" title="4.5 synchronized底层原理是怎样的？"></a>4.5 synchronized底层原理是怎样的？</h3><p><strong>synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。</strong></p><p>synchronized加锁的方式如上已经阐述。</p><p><strong>synchronized是基于JVM</strong>内置锁实现，通过内部对象<strong>Monitor</strong>(监视器锁)实现，基于进入与退出<strong>Monitor</strong>对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的<strong>Mutex lock</strong>（互斥锁）实现，它是一个重量级锁性能较低。当然，<strong>JVM内置锁在1.5之后版本做了重大的优化，</strong>如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。</p><p><font color=red>synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置。</font></p><img src="https://oscimg.oschina.net/oscnet/up-53aba5e9abb1ea04b386b23591a04372c6a.png" style="zoom:50%;" /><h3 id="4-6什么是Monitor监视器锁？"><a href="#4-6什么是Monitor监视器锁？" class="headerlink" title="4.6什么是Monitor监视器锁？"></a>4.6什么是<strong>Monitor监视器锁</strong>？</h3><p><strong>Monitor监视器锁</strong></p><p>​    <strong>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态</strong>。Synchronized在JVM里的实现都是 <strong>基于进入和退出Monitor对象来实现方法同步和代码块同步</strong>，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><ul><li><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p></li><li><ol><li><strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li><strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</li><li><strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol></li><li><p><strong>monitorexit</strong>：执行monitorexit的线程必须是objectref所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p></li></ul><p><strong>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁</strong>；</p><p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象</strong>，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，<strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-e69029578748db53d6ce688c724f4771610.png"></p><p>从编译的结果来看，方法的同步并没有通过指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 <strong>ACC_SYNCHRONIZED</strong> 标示符。<strong>JVM就是根据该标示符来实现方法的同步的</strong>：</p><p><font color=red>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置</strong>，如果设置了，<strong>执行线程将先获取monitor</strong>，获取成功之后才能执行方法体，<strong>方法执行完后再释放monitor</strong>。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</font></p><p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度</strong>，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p><h4 id="什么是monitor？"><a href="#什么是monitor？" class="headerlink" title="什么是monitor？"></a><strong>什么是monitor？</strong></h4><p>可以把它理解为 <strong>一个同步工具</strong>，也可以描述为 <strong>一种同步机制</strong>，它通常被 <strong>描述为一个对象</strong>。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，<strong>因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。<strong>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址</strong>。在Java虚拟机（HotSpot）中，<strong>Monitor是由ObjectMonitor实现的</strong>，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，**_WaitSet 和 _EntryList<strong>，用来保存ObjectWaiter对象列表（ <strong>每个等待锁的线程都会被封装成ObjectWaiter对象</strong> ），</strong>_owner指向持有ObjectMonitor对象的线程**，当多个线程同时访问一段同步代码时：</p><ol><li>首先会进入 _EntryList 集合，<strong>当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</strong>；</li><li>若线程调用 wait() 方法，<strong>将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒</strong>；</li><li>若当前线程执行完毕，**也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)**；</li></ol><p>同时，<strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的</strong>，也是为什么Java中任意对象可以作为锁的原因，<strong>同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。监视器Monitor有两种同步方式：<strong>互斥与协作</strong>。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，<strong>监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问</strong>。</p><h3 id="4-7-对象头中锁是如何标记的？"><a href="#4-7-对象头中锁是如何标记的？" class="headerlink" title="4.7 对象头中锁是如何标记的？"></a>4.7 对象头中锁是如何标记的？</h3><p>32位虚拟机的对象头如下👇</p><p><img src="https://oscimg.oschina.net/oscnet/up-f5d9bf5e5d69b16c4201310d0401065d8b0.png"></p><h3 id="4-8-锁对象hashCode在各种状态下都存放在那里？"><a href="#4-8-锁对象hashCode在各种状态下都存放在那里？" class="headerlink" title="4.8 锁对象hashCode在各种状态下都存放在那里？"></a>4.8 锁对象hashCode在各种状态下都存放在那里？</h3><ul><li>无锁状态下hashcode存放在markword中</li><li>偏向锁调用hashcode会升级成轻量级锁</li><li>轻量级锁的hashCode存放在线程栈的Lock Record中</li><li>重量级锁的hashCode存放在Monitor中</li></ul><h3 id="4-9-验证锁标志"><a href="#4-9-验证锁标志" class="headerlink" title="4.9 验证锁标志"></a>4.9 验证锁标志</h3><p>项目中引入一下依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>打印锁对象的对象头，如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//  TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(<span class="string">&quot;a   &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    o.hashCode();</span><br><span class="line">    System.out.println(<span class="string">&quot;b    &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c   &quot;</span> + ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-一开始要sleep5-秒有什么作用？"><a href="#4-9-一开始要sleep5-秒有什么作用？" class="headerlink" title="4.9 一开始要sleep5 秒有什么作用？"></a>4.9 一开始要sleep5 秒有什么作用？</h3><p>因为jvm在启动的时候，要初始化很多的数据，会涉及到很多对象处于偏向锁。</p><ul><li>如果一开始不sleep，第一次打印是无锁状态，第二次打印，是轻量级锁，因为此时进程中可能有很多偏向锁占用CPU,这里直接升级为轻量级锁</li><li>一开始sleep，锁对象会是偏向锁的状态，然后只有一个线程竞争，第二次打印也还是偏向锁</li></ul><h3 id="4-10-什么是匿名偏向？"><a href="#4-10-什么是匿名偏向？" class="headerlink" title="4.10 什么是匿名偏向？"></a>4.10 什么是匿名偏向？</h3><h3 id="4-11-为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？"><a href="#4-11-为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？" class="headerlink" title="4.11 为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？"></a>4.11 为什么偏向锁的对象调用hashCode方法之后，会升级为轻量级锁？</h3><p>可能是因为轻量级锁的对象头markword中，没有地方存放偏向锁的标志和hashcode，而轻量级锁则由地方存储，在线程栈的Lock record中记录</p><h3 id="4-12-锁升级过程是怎样的？"><a href="#4-12-锁升级过程是怎样的？" class="headerlink" title="4.12 锁升级过程是怎样的？"></a>4.12 锁升级过程是怎样的？</h3><p><img src="https://oscimg.oschina.net/oscnet/up-c4d41493d771bf980f88488c2a928e23439.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h4><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。\</p><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p><p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认开启偏向锁</span><br><span class="line">开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line">关闭偏向锁：-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h4><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<strong>这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，</strong>因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h4><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。<strong>锁消除的依据是逃逸分析的数据支持。</strong></p><p>锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析</p><p>:-XX:+DoEscapeAnalysis 开启逃逸分析</p><p>-XX:+EliminateLocks 表示开启锁消除。</p><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p><a href="https://geekibli.github.io/wiki/Java-%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80/">Java-锁消除和锁膨胀</a></p><h3 id="4-13-什么是逃逸分析？"><a href="#4-13-什么是逃逸分析？" class="headerlink" title="4.13 什么是逃逸分析？"></a>4.13 什么是逃逸分析？</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>二、<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><p>三、分离对象或标量(基本数据类型)替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><p>是不是所有的对象和数组都会在堆内存分配空间？</p><p><strong>不一定</strong></p><p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p><p> -XX:+DoEscapeAnalysis ： 表示开启逃逸分析</p><p> -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析。</p><p>从jdk 1.7开始已经默认开启逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T0_ObjectStackAlloc</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行两种测试</span></span><br><span class="line"><span class="comment">     * 关闭逃逸分析，同时调大堆空间，避免堆内GC的发生，如果有GC信息将会被打印出来</span></span><br><span class="line"><span class="comment">     * VM运行参数：-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 开启逃逸分析</span></span><br><span class="line"><span class="comment">     * VM运行参数：-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 执行main方法后</span></span><br><span class="line"><span class="comment">     * jps 查看进程</span></span><br><span class="line"><span class="comment">     * jmap -histo 进程ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//查看执行时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cost-time &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TulingStudent <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Jit对编译时会对代码进行 逃逸分析</span></span><br><span class="line">        <span class="comment">//并不是所有对象存放在堆区，有的一部分存在线程栈空间</span></span><br><span class="line">        TulingStudent student = <span class="keyword">new</span> TulingStudent();</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingStudent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用jmap查看对象创建情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo pid</span><br></pre></td></tr></table></figure><blockquote><p><strong>逃逸分析可以节省堆空间，有利于GC</strong></p></blockquote><h2 id="5-AQS框架Lock详解"><a href="#5-AQS框架Lock详解" class="headerlink" title="5. AQS框架Lock详解"></a>5. AQS框架Lock详解</h2><h3 id="5-1-Lock的核心点"><a href="#5-1-Lock的核心点" class="headerlink" title="5.1 Lock的核心点"></a>5.1 Lock的核心点</h3><ul><li>循环 </li><li>CAS 多线程竞争锁</li><li>队列 （公平和非公平）存储阻塞的线程们</li><li>阻塞和唤醒</li></ul><h3 id="5-2-LockSupport-park-和-object-notify-有什么区别？"><a href="#5-2-LockSupport-park-和-object-notify-有什么区别？" class="headerlink" title="5.2 LockSupport.park()  和 object.notify() 有什么区别？"></a>5.2 LockSupport.park()  和 object.notify() 有什么区别？</h3><p>如果大量线程阻塞，每个线程都会有自己的线程栈，这样会占用大量的内存。可能会导致栈溢出。</p><p>LockSupport.unpark可以唤醒特定的线程，而object.notify是随机的唤醒</p><p><strong>puck有参和无参有什么区别？</strong></p><p>Puck无参数，阻塞一次</p><p>puck有参数，未被唤醒，一直阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125;,开始执行!&quot;</span>,current.getName());</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;<span class="comment">//spin 自旋</span></span><br><span class="line">                    log.info(<span class="string">&quot;准备park住当前线程：&#123;&#125;....&quot;</span>,current.getName());</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                    System.out.println(Thread.interrupted());</span><br><span class="line">                    log.info(<span class="string">&quot;当前线程&#123;&#125;已经被唤醒....&quot;</span>,current.getName());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;准备唤醒&#123;&#125;线程!&quot;</span>,t0.getName());</span><br><span class="line">            LockSupport.unpark(t0);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            t0.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-CAS是什么？"><a href="#5-3-CAS是什么？" class="headerlink" title="5.3 CAS是什么？"></a>5.3 CAS是什么？</h3><p>A: 内存中实际存储的值，B： 期望内存中的值， C: 修改之后的值</p><p>如果 A = B , 则修改；否则重新读区内存中的值，不断循环上面的过程。</p><blockquote><p>其实这个是和JMM息息相关的。<strong>整个比较并交换的操作是原子操作</strong></p></blockquote><p>在java中是用到了Unsafe类下的方法。底层其实是用到了汇编 <code>cmpxchg</code>指令</p><p>java代码演绎cas原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Juc04_Thread_Cas</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前加锁状态,记录加锁的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Juc04_Thread_Cas cas = <span class="keyword">new</span> Juc04_Thread_Cas();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-0&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(),<span class="string">&quot;t-4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求:&#123;&#125;到达预定点,准备开始抢state:)&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="keyword">if</span>(cas.compareAndSwapState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;当前请求:&#123;&#125;,抢到锁!&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;当前请求:&#123;&#125;,抢锁失败!&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException|BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue</span></span><br><span class="line"><span class="comment">     *        oldvalue:线程工作内存当中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     *        newValue:要替换的新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapState</span><span class="params">(<span class="keyword">int</span> oldValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,stateOffset,oldValue,newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(Juc04_Thread_Cas.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-什么是公平锁什么是非公平锁"><a href="#5-4-什么是公平锁什么是非公平锁" class="headerlink" title="5.4 什么是公平锁什么是非公平锁"></a>5.4 什么是公平锁什么是非公平锁</h3><ul><li>公平锁 ： 按照队列的顺序获取锁，新来的线程进入队列排队</li><li>非公平锁 ： 获取锁的时候，新来的线程也可以参与竞争锁</li></ul><blockquote><p>针对的是 <strong>新来的线程</strong>是否马上可以竞争锁资源，其实就是是否破坏了<strong>先来后到，先来先的</strong>的公平性。</p></blockquote><h3 id="5-5-在reentrantLock代码中如何体现？"><a href="#5-5-在reentrantLock代码中如何体现？" class="headerlink" title="5.5 在reentrantLock代码中如何体现？"></a>5.5 在reentrantLock代码中如何体现？</h3><p>默认非公平</p><h3 id="5-6-如何判断那个线程获取了锁？"><a href="#5-6-如何判断那个线程获取了锁？" class="headerlink" title="5.6 如何判断那个线程获取了锁？"></a>5.6 如何判断那个线程获取了锁？</h3><p>AQS的属性 <code>exclusiceOwnerThread</code>  指向当前获取锁的线程。</p><h3 id="5-7-锁到底加到了哪里，加了多少次？"><a href="#5-7-锁到底加到了哪里，加了多少次？" class="headerlink" title="5.7 锁到底加到了哪里，加了多少次？"></a>5.7 锁到底加到了哪里，加了多少次？</h3><p>AQS 的属性 int <code>status</code> = 0; 0 表示没有加锁，&gt;0 表示锁重入的次数。</p><h3 id="5-8-队列是如何创建的？"><a href="#5-8-队列是如何创建的？" class="headerlink" title="5.8 队列是如何创建的？"></a>5.8 队列是如何创建的？</h3><p>CLH队列 ： Node类型，本质是双向链表的结构 。 三个人名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">Node pre;</span><br><span class="line">Node next;</span><br><span class="line">Node head;</span><br><span class="line">Node tail;</span><br><span class="line">  Thread thread; <span class="comment">// 对线程的引用</span></span><br><span class="line">  <span class="keyword">int</span> waitStatus; <span class="comment">// 状态 信号量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>waitStatus变量的状态:</strong></p><ul><li>Init = 0 初始状态</li><li>singal = -1 <strong>下一个结点</strong>可被唤醒</li><li>cancled = 1 可能发生了异常 比如终端或者其他因素，需要被废弃掉这样的结点</li><li>condition = -2  </li><li>propagate(广播) = -3</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-743aa07d2d8916013c231dbbfaacfd623ca.png"></p><h3 id="5-9-公平锁加锁流程"><a href="#5-9-公平锁加锁流程" class="headerlink" title="5.9 公平锁加锁流程"></a>5.9 公平锁加锁流程</h3><ul><li>先判断status == 0</li><li>判断队列是否为空 （head == tail）</li><li>cas修改status = 1 &amp;&amp; exclusiveOwnerThread = curThread</li><li>如果status ！= 0  有两种情况，判断 exclusiveOwnerThread == curThread ？ 如果是curThread ， status +1 ， 如果不是，加入CLH队列</li></ul><h4 id="5-9-1-如果T0获取了锁，T1-T2…线程怎么办？"><a href="#5-9-1-如果T0获取了锁，T1-T2…线程怎么办？" class="headerlink" title="5.9.1 如果T0获取了锁，T1 T2…线程怎么办？"></a>5.9.1 如果T0获取了锁，T1 T2…线程怎么办？</h4><h5 id="5-9-1-1-尝试加入CLH队列"><a href="#5-9-1-1-尝试加入CLH队列" class="headerlink" title="5.9.1.1 尝试加入CLH队列"></a>5.9.1.1 尝试加入CLH队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 可能多线程进入</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          <span class="comment">// cas只会有一个线程修改成功</span></span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只会有一个线程进入，也就是当前线程再次获取锁的时候，所以这里没有并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以被多个线程同时调用，性能会比较高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">  <span class="comment">// 队列不是空的时候走下面</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 队列是空的时候，走这个方法</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列是空的时候，第一次想队列中添加等待的结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>为什么循环等待呢？ 要确保结点一定要添加到队列尾部</li><li><code>if (t == null) &#123; // Must initialize </code> 是什么逻辑？</li></ul><blockquote><p>第一次初始化的时候，头结点搞一个空的Node对象，然后下一次循环的时候把结点添加到尾部。</p></blockquote><p><strong>如果不循环，可能导致线程结点丢失，永远无法唤醒，但是内存空间中还存在该线程的堆栈信息。</strong></p><h5 id="5-9-1-2-加入队列后，该把线程阻塞了"><a href="#5-9-1-2-加入队列后，该把线程阻塞了" class="headerlink" title="5.9.1.2 加入队列后，该把线程阻塞了"></a>5.9.1.2 加入队列后，该把线程阻塞了</h5><p><font color=red>执行到这的话，只是把线程添加到队列中了，但是显示还没有阻塞，下面就是去阻塞的逻辑</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个结点</span></span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 如果前一个结点是头结点，并且当前线程获取成功了</span></span><br><span class="line">             <span class="comment">// 因为可能在入队前的瞬间，头结点的线程释放锁了</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 <span class="comment">// 当前获取锁的线程的node是第一个，而且是空的node，这个enq方法呼应！</span></span><br><span class="line">                  setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC 把之前的结点设置成null</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>补充：</strong>  ⚠️ ⚠️ ⚠️</p><p><code>if (p == head &amp;&amp; tryAcquire(arg)) </code></p><ul><li>如果是公平锁，则一定可以tryAcquire 获取到锁</li><li>如果是非公平锁，则 if 不一定为true</li></ul><h5 id="5-9-1-3-结点阻塞之前，还会再次尝试获取锁"><a href="#5-9-1-3-结点阻塞之前，还会再次尝试获取锁" class="headerlink" title="5.9.1.3 结点阻塞之前，还会再次尝试获取锁"></a>5.9.1.3 结点阻塞之前，还会再次尝试获取锁</h5><p>（如果是第一个结点）</p><h5 id="5-9-1-4-如果获取锁成功，设置成头结点"><a href="#5-9-1-4-如果获取锁成功，设置成头结点" class="headerlink" title="5.9.1.4 如果获取锁成功，设置成头结点"></a>5.9.1.4 如果获取锁成功，设置成头结点</h5><p><img src="https://oscimg.oschina.net/oscnet/up-3d3f02435ab216e6de2b04ac13fa4385508.png"></p><p>设置成头结点的时候，之前的头结点（肯定是个 “空结点”）断开，并且设置成null，方便GC. 然后把当前线程的Node结点设置成head结点，同时把Node设置成 “空结点”。 怎么设置的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头指针指向当前结点</li><li>把线程设置成null，因为当前线程已经获取到锁了，这里没有必要还继续占着引用</li><li>把当前结点的前指针断开（因为在enq方法里面，要阻塞的结点都是添加在tail，所以它的prev肯定是有的，这里要断开头结点）</li></ul><h5 id="5-9-1-5-如果没有获取成功，执行阻塞"><a href="#5-9-1-5-如果没有获取成功，执行阻塞" class="headerlink" title="5.9.1.5 如果没有获取成功，执行阻塞"></a>5.9.1.5 如果没有获取成功，执行阻塞</h5><ul><li><p>第一轮循环，shouldParkAfterFailedAcquire(p, node)  返回false ，修改head的waitStatus = singal = -1，下一个结点可以被唤醒</p></li><li><p>第二次循环进行阻塞操作，shouldParkAfterFailedAcquire(p, node) 返回true ， 执行parkAndCheckInterrupt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程。此时当前结点的waitStatus = 0. 和上面之前的操作一样了，等待这个线程执行的时候，又开始了上面的操作，设置head结点的waitStatus = signal = -1 等等。</p></li></ul><h4 id="5-9-2-被阻塞的线程什么时候会唤醒呢？"><a href="#5-9-2-被阻塞的线程什么时候会唤醒呢？" class="headerlink" title="5.9.2 被阻塞的线程什么时候会唤醒呢？"></a>5.9.2 被阻塞的线程什么时候会唤醒呢？</h4><p><strong>在获取锁的线程执行 <code>unlock</code> 的时候。</strong></p><p>下面是AQS的模版方法，tryRelease在子类实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先减AQS的 state</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">          <span class="comment">// h.waitStatus != 0 不能为0 在reentrantLock中，waitStatus = -1, 唤醒CLH队列下一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是tryRelease在ReentrantLock方法中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果state - 1 成功，则接下来执行唤醒操作。</p><p><strong>AQS# unparkSuccessor唤醒方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>head结点的状态肯定是 “空结点”， waitStatus 状态=-1 ，说明线程正在执行，当线程执行完成之后，在unlock的时候，再把waitStatus改成0</li><li>为什么waitStatus的状态在unlock的时候要 ‘恢复’ 成 0 呢？<ul><li>因为在非公平锁的情况下，不一定是后续结点一定能获得锁</li><li>而且node 的waitStatus的状态设置成-1是有固定方法固定的时候</li></ul></li></ul><h3 id="5-10-什么是可重入锁"><a href="#5-10-什么是可重入锁" class="headerlink" title="5.10 什么是可重入锁"></a>5.10 什么是可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.lock()</span><br><span class="line">...</span><br><span class="line">lock.lock()</span><br><span class="line">...</span><br><span class="line">lock.unlock()</span><br><span class="line">...</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><h3 id="5-11-什么是中断"><a href="#5-11-什么是中断" class="headerlink" title="5.11 什么是中断"></a>5.11 什么是中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;in thread 111&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">              <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;响应中断&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread.start();</span><br><span class="line">      System.err.println(<span class="string">&quot;before interrupt &quot;</span> + thread.isInterrupted());</span><br><span class="line">      thread.interrupt();</span><br><span class="line">      System.err.println(<span class="string">&quot;after interrupt &quot;</span> + thread.isInterrupted());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>中断的三个方法：</p><ul><li>Thread.interrupted(); 中断线程并且清除中断标记</li><li>Thread.currentThread().interrupt();  中断线程</li><li>Thread.currentThread().isInterrupted();  判断中断标记，并不清除</li></ul><blockquote><p>用户程序自己响应中断，比直接调用stop方法要友好的多</p></blockquote><h4 id="如果获取锁的线程调用了wait方法会怎样？"><a href="#如果获取锁的线程调用了wait方法会怎样？" class="headerlink" title="如果获取锁的线程调用了wait方法会怎样？"></a><strong><font color=red>如果获取锁的线程调用了wait方法会怎样？</font></strong></h4><h3 id="5-12-waitStatus-cancel-1-状态"><a href="#5-12-waitStatus-cancel-1-状态" class="headerlink" title="5.12 waitStatus = cancel = 1 状态"></a>5.12 waitStatus = cancel = 1 状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">       Node pred = node.prev;</span><br><span class="line">       <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">           node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">       <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">       <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">       Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">       <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">       <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">       node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">       <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">           compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">           <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">           <span class="keyword">int</span> ws;</span><br><span class="line">           <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">               ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">               pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node next = node.next;</span><br><span class="line">               <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   compareAndSetNext(pred, predNext, next);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               unparkSuccessor(node);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           node.next = node; <span class="comment">// help GC</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当node是cancel状态的时候，说明当前线程已经没用了，但是之前呢，已经把node添加到了队列里面了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b9d30c07b820fa121616ea71504a08148f2.png"></p><p>分成3种情况</p><ul><li>第一种，如果结点是tail, 把当前结点去掉</li><li>如果是head后面的第一个结点，那么，直接唤醒该结点后面的结点</li><li>如果是队列中间，比如图中红色的位置，则去掉就行了</li></ul><p>这里呢 还有一些细节，node的thread = null，这样方便GC, 因为线程栈也是占用内存空间的。</p><h2 id="6-AQS框架Blocking-Queue详解"><a href="#6-AQS框架Blocking-Queue详解" class="headerlink" title="6. AQS框架Blocking Queue详解"></a>6. AQS框架Blocking Queue详解</h2><p>任意时刻，无论并发多高，在单机jvm上面，同一时间，永远都只有一个线程可以进行入队和出队操作</p><h3 id="6-1-阻塞队列特性"><a href="#6-1-阻塞队列特性" class="headerlink" title="6.1 阻塞队列特性"></a>6.1 阻塞队列特性</h3><ul><li>线程安全</li><li>有界队列和无界队列</li><li>队列满 添加阻塞 队列空 读取阻塞</li></ul><h3 id="6-2-使用场景"><a href="#6-2-使用场景" class="headerlink" title="6.2 使用场景"></a>6.2 使用场景</h3><ul><li>线程池的任务队列</li><li>注册中心底层</li><li>常用语生产者和消费者</li></ul><h2 id="7-Semaphore信号量"><a href="#7-Semaphore信号量" class="headerlink" title="7. Semaphore信号量"></a>7. Semaphore信号量</h2><p>Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖AQS的状态State，是在生产当中比较常用的一个工具类。</p><h3 id="7-1-semaphoreDemo"><a href="#7-1-semaphoreDemo" class="headerlink" title="7.1 semaphoreDemo"></a>7.1 semaphoreDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(semaphore,<span class="string">&quot;yangguo+&quot;</span>+i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Semaphore semaphore,String tname)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(tname);</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">            <span class="comment">//this.setName(tname);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//semaphore.acquireUninterruptibly();</span></span><br><span class="line">                semaphore.acquire();<span class="comment">//获取公共资源</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:aquire() at time:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*if(semaphore.tryAcquire(500,TimeUnit.MILLISECONDS))&#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName()+&quot;:aquire() at time:&quot;+System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">                    Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">                    semaphore.release();//释放公共资源</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    fallback();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;降级&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0:aquire() at time:1641623552311</span><br><span class="line">Thread-1:aquire() at time:1641623552311</span><br><span class="line">Thread-3:aquire() at time:1641623557312</span><br><span class="line">Thread-2:aquire() at time:1641623557312</span><br><span class="line">Thread-4:aquire() at time:1641623562317</span><br><span class="line">Thread-5:aquire() at time:1641623562317</span><br><span class="line">Thread-6:aquire() at time:1641623567322</span><br><span class="line">Thread-7:aquire() at time:1641623567322</span><br><span class="line">Thread-8:aquire() at time:1641623572325</span><br><span class="line">Thread-9:aquire() at time:1641623572325</span><br></pre></td></tr></table></figure><h3 id="7-2-重要API"><a href="#7-2-重要API" class="headerlink" title="7.2 重要API"></a>7.2 重要API</h3><h4 id="tryAcquire-long-timeout-TimeUnit-unit"><a href="#tryAcquire-long-timeout-TimeUnit-unit" class="headerlink" title="tryAcquire(long timeout, TimeUnit unit)"></a>tryAcquire(long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire(<span class="number">500</span>,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:aquire() at time:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    semaphore.release();<span class="comment">//释放公共资源</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="semaphore-acquire"><a href="#semaphore-acquire" class="headerlink" title="semaphore.acquire();"></a>semaphore.acquire();</h3><p><strong><font color=red>之前reentrantLock blocking queue都是独占模式，而semaphore的lock则是共享的模式</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS模版方法，tryAcquireShared(arg) 在子类中有具体的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="comment">// 如果remaining &gt;= 0 通过cas进行修改</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边和独占锁的区别在于多了一个 <code>setHeadAndPropagate(node, r);</code>方法。</p><h2 id="8-CountDownLatch"><a href="#8-CountDownLatch" class="headerlink" title="8. CountDownLatch"></a>8. CountDownLatch</h2><h2 id="9-CyclicBarrier"><a href="#9-CyclicBarrier" class="headerlink" title="9. CyclicBarrier"></a>9. CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierRunner</span><span class="params">(CyclicBarrier cyclicBarrier, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index: &quot;</span> + index);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">11</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有特工到达屏障，准备开始执行秘密任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier, i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部到达屏障....1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier, i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部到达屏障....1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-CyclicBarrier-和-CountDownLatch的区别"><a href="#9-1-CyclicBarrier-和-CountDownLatch的区别" class="headerlink" title="9.1 CyclicBarrier 和 CountDownLatch的区别"></a>9.1 CyclicBarrier 和 CountDownLatch的区别</h3><ul><li>功能不一样</li><li>CyclicBarrier可复用，CountDownLatch不可复用</li><li>CyclicBarrier 和 CountDownLatch 倒过来用效果类似</li></ul><h2 id="10-Atomic类"><a href="#10-Atomic类" class="headerlink" title="10. Atomic类"></a>10. Atomic类</h2><blockquote><p> 原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。在多处理器上实现原子操作就变得有点复杂。本文让我们一起来聊一聊在Inter处理器和Java里是如何实现原子操作的。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-c4e798c80f82c9b025c51ce57f80ed88e02.png"></p><p>Atomic 底层是基于无锁化的cas算法。基于魔术类Unsafe提供的三大cas-api完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapObject</span><br><span class="line"></span><br><span class="line">compareAndSwapInt</span><br><span class="line"></span><br><span class="line">compareAndSwapLong</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于硬件原语-CMPXCHG实现原子操作cas </span></span><br></pre></td></tr></table></figure><p><strong><font color=red>基于硬件原语-CMPXCHG实现原子操作cas  在用户态就可以完成的操作，不会有切换的开销</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">  oldvalue = <span class="keyword">this</span>.getIntVolatile(var1, var2);<span class="comment">//读AtomicInteger的value值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">///valueOffset---value属性在对象内存当中的偏移量</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(AtomicInteger, valueOffset, oldvalue, oldvalue + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><h3 id="10-1-什么叫偏移量？"><a href="#10-1-什么叫偏移量？" class="headerlink" title="10.1 什么叫偏移量？"></a>10.1 <strong>什么叫偏移量？</strong></h3><p>要用cas修改某个对象属性的值-&gt;，首先要知道属性在对象的内存空间的哪个位置，必须知道属性的偏移量</p><h3 id="10-2-如何通过原子操作修改一个对象的属性"><a href="#10-2-如何通过原子操作修改一个对象的属性" class="headerlink" title="10.2 如何通过原子操作修改一个对象的属性"></a>10.2 如何通过原子操作修改一个对象的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStudentAgeUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStudentAgeUpdater</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicStudentAgeUpdater updater = <span class="keyword">new</span> AtomicStudentAgeUpdater(<span class="string">&quot;杨过&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(updater).toPrintable());</span><br><span class="line">        updater.compareAndSwapAge(<span class="number">18</span>,<span class="number">56</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的杨过年龄---&quot;</span>+updater.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicStudentAgeUpdater.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;valueOffset:---&gt;&quot;</span>+valueOffset);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compareAndSwapAge</span><span class="params">(<span class="keyword">int</span> old,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        unsafe.compareAndSwapInt(<span class="keyword">this</span>,valueOffset,old,target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>这里我们是通过 Unsafe 类去操作修改对象的属性。需要拿到这个属性的 <strong><font color=blue>偏移量</font></strong></p><img src="https://oscimg.oschina.net/oscnet/up-f55fe0652c7614bde5802d3470ecdb3cf7c.png" style="zoom:50%;" /><h3 id="10-3-如果需要原子操作的是数组，怎么办？"><a href="#10-3-如果需要原子操作的是数组，怎么办？" class="headerlink" title="10.3 如果需要原子操作的是数组，怎么办？"></a>10.3 如果需要原子操作的是数组，怎么办？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray aiArray = <span class="keyword">new</span> AtomicIntegerArray(value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//todo 原子修改数组下标0的数值</span></span><br><span class="line">        aiArray.getAndSet(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(aiArray.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">   <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-如果原子操作修改的是对象类型数组呢？"><a href="#10-4-如果原子操作修改的是对象类型数组呢？" class="headerlink" title="10.4 如果原子操作修改的是对象类型数组呢？"></a>10.4 如果原子操作修改的是对象类型数组呢？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceArrayRunner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Tuling[] ovalue = <span class="keyword">new</span> Tuling[]&#123;<span class="keyword">new</span> Tuling(<span class="number">1</span>),<span class="keyword">new</span> Tuling(<span class="number">2</span>)&#125;;</span><br><span class="line">    <span class="keyword">static</span> AtomicReferenceArray&lt;Tuling&gt; objarray = <span class="keyword">new</span> AtomicReferenceArray(ovalue);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(objarray.get(<span class="number">0</span>).getSequence());</span><br><span class="line">        objarray.set(<span class="number">0</span>,<span class="keyword">new</span> Tuling(<span class="number">3</span>));</span><br><span class="line">        System.out.println(objarray.get(<span class="number">0</span>).getSequence());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>底层原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicReferenceArray</span><span class="params">(E[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(array, array.length, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5-AtomicIntegerFieldUpdater修改对象的属性"><a href="#10-5-AtomicIntegerFieldUpdater修改对象的属性" class="headerlink" title="10.5 AtomicIntegerFieldUpdater修改对象的属性"></a>10.5 AtomicIntegerFieldUpdater修改对象的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdateRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerFieldUpdater aifu = AtomicIntegerFieldUpdater.newUpdater(Student.class,<span class="string">&quot;old&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;杨过&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(aifu.getAndIncrement(stu));</span><br><span class="line">        System.out.println(aifu.getAndIncrement(stu));</span><br><span class="line">        System.out.println(aifu.incrementAndGet(stu));</span><br><span class="line">        System.out.println(aifu.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name ,<span class="keyword">int</span> old)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Int 类型属性的偏移量不需要我们程序员自己调用api计算，AtomicIntegerFieldUpdater这个底层会自己计算。</p><h3 id="10-6-如果需要修改的属性不是integer类型的呢？"><a href="#10-6-如果需要修改的属性不是integer类型的呢？" class="headerlink" title="10.6 如果需要修改的属性不是integer类型的呢？"></a>10.6 如果需要修改的属性不是integer类型的呢？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceFieldUpdaterRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReferenceFieldUpdater atomic = AtomicReferenceFieldUpdater.newUpdater(Document.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Document document = <span class="keyword">new</span> Document(<span class="string">&quot;杨过&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(atomic.get(document));</span><br><span class="line">        atomic.getAndSet(document, <span class="string">&quot;xiaolongnv&quot;</span>);</span><br><span class="line">        System.out.println(atomic.get(document));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种方式修改</span></span><br><span class="line">        UnaryOperator&lt;String&gt; uo = s -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;UnaryOperator:--&gt;&quot;</span> + s);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;小龙女&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(atomic.getAndUpdate(document, uo));</span><br><span class="line">        System.out.println(atomic.get(document));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">        Document(String obj, <span class="keyword">int</span> v) &#123;</span><br><span class="line">            name = obj;</span><br><span class="line">            version = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>Name 属性必须是 public</li><li>Name 属性必须是 volatile</li></ul><h3 id="10-7-大名鼎鼎的ABA问题"><a href="#10-7-大名鼎鼎的ABA问题" class="headerlink" title="10.7 大名鼎鼎的ABA问题"></a>10.7 大名鼎鼎的ABA问题</h3><p>添加版本号解决ABA问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedRerenceRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedRef.getStamp(); <span class="comment">//获取当前标识别</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread()+ <span class="string">&quot;stamp=&quot;</span>+stamp + <span class="string">&quot;,初始值 a = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//等待1秒 ，以便让干扰线程执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> isCASSuccess = atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,stamp +<span class="number">1</span>);  <span class="comment">//此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;stamp=&quot;</span>+stamp + <span class="string">&quot;,CAS操作结果: &quot;</span> + isCASSuccess);</span><br><span class="line">        &#125;,<span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;stamp=&quot;</span>+atomicStampedRef.getStamp() +<span class="string">&quot;,【increment】 ,值 a= &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">            stamp = atomicStampedRef.getStamp();</span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;stamp=&quot;</span>+atomicStampedRef.getStamp() +<span class="string">&quot;,【decrement】 ,值 a= &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        main.start();</span><br><span class="line">        LockSupport.parkNanos(<span class="number">1000000</span>);</span><br><span class="line">        other.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-Unsafe类"><a href="#11-Unsafe类" class="headerlink" title="11. Unsafe类"></a>11. Unsafe类</h2><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如<strong>直接访问系统内存资源</strong>、<strong>自主管理内存资源</strong>等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p><p>但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p><p>Unsafe类为一<strong>单例</strong>实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。</p><h3 id="11-1-Unsafe-class"><a href="#11-1-Unsafe-class" class="headerlink" title="11.1 Unsafe.class"></a>11.1 Unsafe.class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class var0 = Reflection.getCallerClass();</span><br><span class="line"><span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-unsafe-堆外内存优化文件上传"><a href="#11-2-unsafe-堆外内存优化文件上传" class="headerlink" title="11.2 unsafe 堆外内存优化文件上传"></a>11.2 unsafe 堆外内存优化文件上传</h3><p><strong>Java 频繁操作文件，可能造成内存使用骤增，jvm频繁GC。</strong> <font color=red>如何优化？</font></p><ul><li><strong><font color=blue>可以使用堆外内存</font></strong>     这样可以不会影响正常业务的请求，jvm可以正常执行其他业务</li><li>堆外内存不属于jvm管，使用完之后，<strong>需要手动释放</strong>，否则容易造成内存泄漏。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateMemoryAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line">        <span class="keyword">long</span> oneHundred = <span class="number">1193123491341341234L</span>;</span><br><span class="line">        <span class="keyword">byte</span> size = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用allocateMemory分配内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> memoryAddress = unsafe.allocateMemory(size);</span><br><span class="line">        System.out.println(<span class="string">&quot;address:-&gt;&quot;</span>+memoryAddress);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将1写入到内存中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unsafe.putAddress(memoryAddress, oneHundred);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 内存中读取数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> readValue = unsafe.getAddress(memoryAddress);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;value : &quot;</span> + readValue);</span><br><span class="line"></span><br><span class="line">        unsafe.freeMemory(memoryAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-monitor对象锁"><a href="#11-3-monitor对象锁" class="headerlink" title="11.3 monitor对象锁"></a>11.3 monitor对象锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitorRunner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        unsafe.monitorEnter(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        unsafe.monitorExit(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//jvm内置锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="comment">//写逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMonitorRunner objectMonitorRunner = <span class="keyword">new</span> ObjectMonitorRunner();</span><br><span class="line">        objectMonitorRunner.method1();</span><br><span class="line">        objectMonitorRunner.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以跨方法加锁和释放锁。 </li><li>注意死锁问题</li></ul><h3 id="11-4-线程阻塞和唤醒"><a href="#11-4-线程阻塞和唤醒" class="headerlink" title="11.4 线程阻塞和唤醒"></a>11.4 线程阻塞和唤醒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadParkerRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread - is running----&quot;</span>);</span><br><span class="line">                <span class="comment">//true则会实现ms定时,false则会实现ns定时。</span></span><br><span class="line">                unsafe.park(<span class="keyword">false</span>,<span class="number">0L</span>); <span class="comment">//阻塞当前线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread is over-----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;唤醒Thread-t&quot;</span>);</span><br><span class="line">        unsafe.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中大量使用了 <code>public native void unpark(Object var1);</code> 方法；</p><h2 id="12-并发容器之ConcurrentHashMap"><a href="#12-并发容器之ConcurrentHashMap" class="headerlink" title="12. 并发容器之ConcurrentHashMap"></a>12. 并发容器之ConcurrentHashMap</h2><h3 id="12-1-重要成员属性"><a href="#12-1-重要成员属性" class="headerlink" title="12.1 重要成员属性"></a>12.1 重要成员属性</h3><ul><li>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; Hash表默认初始容量</li><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大Hash表容量</li><li>DEFAULT_LOAD_FACTOR = 0.75f；默认加载因子</li><li>TREEIFY_THRESHOLD = 8；链表转红黑树阈值</li><li>UNTREEIFY_THRESHOLD = 6；红黑树转链表阈值</li><li>MIN_TREEIFY_CAPACITY = 64；链表转红黑树时hash表最小容量阈值，达不到优先扩容。</li></ul><h3 id="12-2-hashMap底层结构"><a href="#12-2-hashMap底层结构" class="headerlink" title="12.2 hashMap底层结构"></a>12.2 hashMap底层结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8之后 数组 + 链表/红黑树</li></ul><h3 id="12-3-hashmap容量"><a href="#12-3-hashmap容量" class="headerlink" title="12.3 hashmap容量"></a>12.3 hashmap容量</h3><p>hashmap的容量，值的是数组的长度。如果不考虑hash 碰撞的情况下，hash map 存放数据量 = 数组的长度 = 容量</p><h4 id="12-3-1-容量是如何初始化的？"><a href="#12-3-1-容量是如何初始化的？" class="headerlink" title="12.3.1 容量是如何初始化的？"></a>12.3.1 容量是如何初始化的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">11</span>); <span class="comment">// 初始容量就是11 ？</span></span><br></pre></td></tr></table></figure><ul><li>必须大于设置的size</li><li>必须是2的指数幂</li><li>必须大于size</li></ul><p><strong>所以，如果我们初始化容量设置成11，实际初始化容量为16. 如果size = 17呢？ 实际初始化容量则是32；</strong></p><h4 id="12-3-2-hashmap的默认容量为什么是16？"><a href="#12-3-2-hashmap的默认容量为什么是16？" class="headerlink" title="12.3.2 hashmap的默认容量为什么是16？"></a>12.3.2 hashmap的默认容量为什么是16？</h4><ul><li>16的容量基本够用了</li><li>容量必须是2的指数倍</li></ul><h4 id="12-3-3-hashCode-可以小于0吗？"><a href="#12-3-3-hashCode-可以小于0吗？" class="headerlink" title="12.3.3 hashCode 可以小于0吗？"></a>12.3.3 hashCode 可以小于0吗？</h4><p>可以的</p><h4 id="12-3-4-容量为什么一定是2的指数次幂？"><a href="#12-3-4-容量为什么一定是2的指数次幂？" class="headerlink" title="12.3.4 容量为什么一定是2的指数次幂？"></a>12.3.4 容量为什么一定是2的指数次幂？</h4><p>在使用hashCode 计算数组下标进行 「位运算」时，<code>tab[i = (n - 1) &amp; hash])</code></p><h4 id="12-3-5-key是如何保证唯一的？"><a href="#12-3-5-key是如何保证唯一的？" class="headerlink" title="12.3.5 key是如何保证唯一的？"></a>12.3.5 key是如何保证唯一的？</h4><p>重复的覆盖</p><h3 id="12-4-什么是hash碰撞，如何解决hash碰撞？"><a href="#12-4-什么是hash碰撞，如何解决hash碰撞？" class="headerlink" title="12.4 什么是hash碰撞，如何解决hash碰撞？"></a>12.4 什么是hash碰撞，如何解决hash碰撞？</h3><img src="https://oscimg.oschina.net/oscnet/up-926da3903444e884ce10b4e9b1b001b4b33.png" style="zoom:50%;" /><p>hash碰撞，hash冲突。不同的值经过hashcode定位数组到同一个下标下。</p><ul><li>拉链法 （1.7 头部插入 1.8 尾部插入法）</li><li>开放寻址法</li></ul><h3 id="12-5-元素下表如何计算的？"><a href="#12-5-元素下表如何计算的？" class="headerlink" title="12.5 元素下表如何计算的？"></a>12.5 元素下表如何计算的？</h3><p><strong>位运算</strong>   效率比取模运算效率要高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><h4 id="12-5-1-为什么用-length-1去做与运算？"><a href="#12-5-1-为什么用-length-1去做与运算？" class="headerlink" title="12.5.1 为什么用 length - 1去做与运算？"></a>12.5.1 为什么用 length - 1去做与运算？</h4><ul><li>防止发生越界</li><li>低位全部是1，计算快</li></ul><h3 id="12-6-计算hashCode的时候，下面的一些抑或操作是做什么的？"><a href="#12-6-计算hashCode的时候，下面的一些抑或操作是做什么的？" class="headerlink" title="12.6 计算hashCode的时候，下面的一些抑或操作是做什么的？"></a>12.6 计算hashCode的时候，下面的一些抑或操作是做什么的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让hash变得更加散列，降低hash碰撞。 </p><p><strong><font color=green> 什么是hash扰动 ？ ？ ？</font></strong></p><h3 id="12-7-hashmap是如何扩容的？"><a href="#12-7-hashmap是如何扩容的？" class="headerlink" title="12.7 hashmap是如何扩容的？"></a>12.7 hashmap是如何扩容的？</h3><h4 id="12-7-1-什么时候触发扩容"><a href="#12-7-1-什么时候触发扩容" class="headerlink" title="12.7.1 什么时候触发扩容"></a>12.7.1 什么时候触发扩容</h4><p>size &gt; threshold = capital * load（加载因子），触发扩容。</p><p>13 &gt;= 12 = 16 * 0.75</p><h4 id="12-7-2-扩容是怎么进行的"><a href="#12-7-2-扩容是怎么进行的" class="headerlink" title="12.7.2 扩容是怎么进行的"></a>12.7.2 扩容是怎么进行的</h4><ul><li>数组的长度必须还得是2的指数幂，所以数组长度 * 2 </li><li>将原来的数据迁移到新的数组上面</li></ul><h4 id="12-7-3-hashmap1-7扩容机制"><a href="#12-7-3-hashmap1-7扩容机制" class="headerlink" title="12.7.3 hashmap1.7扩容机制"></a>12.7.3 hashmap1.7扩容机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;<span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">//第二行</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//第三行</span></span><br><span class="line">            newTable[i] = e;<span class="comment">//第四行</span></span><br><span class="line">            e = next;<span class="comment">//第五行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉了一些冗余的代码， 层次结构更加清晰了。</p><ul><li>第一行：记录oldhash表中e.next</li><li>第二行：rehash计算出数组的位置(hash表中桶的位置)</li><li>第三行：e要插入链表的头部， 所以要先将e.next指向new hash表中的第一个元素</li><li>第四行：将e放入到new hash表的头部</li><li>第五行： 转移e到下一个节点， 继续循环下去</li></ul><blockquote><p>头插法： 原来链表上的数据是 A - B - C ，新数组上的结点是 C - B - A</p></blockquote><p>单线程扩容时没有任何问题，但是多线程进行扩容的情况下，会发生<strong>死循环</strong>问题。</p><h5 id="12-7-3-1-多线程扩容的死锁问题"><a href="#12-7-3-1-多线程扩容的死锁问题" class="headerlink" title="12.7.3.1 多线程扩容的死锁问题"></a>12.7.3.1 多线程扩容的死锁问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; next = e.next;<span class="comment">//第一行，线程1执行到此被调度挂起</span></span><br><span class="line">      <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">//第二行</span></span><br><span class="line">      e.next = newTable[i];<span class="comment">//第三行</span></span><br><span class="line">      newTable[i] = e;<span class="comment">//第四行</span></span><br><span class="line">      e = next;<span class="comment">//第五行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-7-3-2-多线程扩容流程"><a href="#12-7-3-2-多线程扩容流程" class="headerlink" title="12.7.3.2  多线程扩容流程"></a>12.7.3.2  多线程扩容流程</h5><p><strong>流程图如下：</strong></p><img src="https://oscimg.oschina.net/oscnet/up-ff7bdfb24f595d69718aa3c10022dd4f177.png" style="zoom:50%;" /><p><strong>后面会形成环</strong>：</p><img src="https://oscimg.oschina.net/oscnet/up-a4c0b912329d188c0e95cf9f4b624717e19.png" style="zoom:50%;" /><p><strong>下次添加数据或者查询数据的时候，可能会发生死循环；</strong></p><h4 id="12-7-4-hashmap1-8扩容机制"><a href="#12-7-4-hashmap1-8扩容机制" class="headerlink" title="12.7.4 hashmap1.8扩容机制"></a>12.7.4 hashmap1.8扩容机制</h4><h5 id="12-7-4-1-什么时候链表可以转红黑树"><a href="#12-7-4-1-什么时候链表可以转红黑树" class="headerlink" title="12.7.4.1 什么时候链表可以转红黑树"></a>12.7.4.1 什么时候链表可以转红黑树</h5><ul><li>阈值=8 当链表长度为9的时候，链表可以转换成红黑树，但是还有下面这个条件的限制</li><li>容量大于等于 64，<strong>否则优先扩容</strong></li></ul><h5 id="12-7-4-2-为什么长度是8-链表转红黑树？"><a href="#12-7-4-2-为什么长度是8-链表转红黑树？" class="headerlink" title="12.7.4.2 为什么长度是8 链表转红黑树？"></a>12.7.4.2 为什么长度是8 链表转红黑树？</h5><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=8695e2cbdb8dd5b333b65f3cf53d1673&type=note">【泊松分布】</a></p><blockquote><p><strong>一句话总结：泊松分布是单位时间内独立事件发生次数的概率分布，指数分布是独立事件的时间间隔的概率分布。</strong></p><p>请注意是”独立事件”，泊松分布和指数分布的前提是，事件之间不能有关联，否则就不能运用上面的公式。</p></blockquote><p><strong>大多数情况下不会超过8的长度</strong></p><h5 id="12-7-4-3-扩容流程"><a href="#12-7-4-3-扩容流程" class="headerlink" title="12.7.4.3 扩容流程"></a>12.7.4.3 扩容流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>避免了rehash</strong></p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-f199c6b73df571a3922107499e3099cc5cd.png"></p><h3 id="12-8-加载因子为什么是0-75？"><a href="#12-8-加载因子为什么是0-75？" class="headerlink" title="12.8 加载因子为什么是0.75？"></a>12.8 加载因子为什么是0.75？</h3><ul><li>如果调整的比较小，空间利用率会下降</li><li>如果调整的比较大，哈希碰撞可能比较严重</li></ul><h3 id="12-9-线程安全的ConcurrentHashMap"><a href="#12-9-线程安全的ConcurrentHashMap" class="headerlink" title="12.9 线程安全的ConcurrentHashMap"></a>12.9 线程安全的ConcurrentHashMap</h3><h4 id="12-9-1-常用API"><a href="#12-9-1-常用API" class="headerlink" title="12.9.1 常用API"></a>12.9.1 常用API</h4><ul><li>Put  hash碰撞时同步</li><li>get 没有添加同步锁</li></ul><h4 id="12-9-2-JDK1-7中的concurrentHash"><a href="#12-9-2-JDK1-7中的concurrentHash" class="headerlink" title="12.9.2 JDK1.7中的concurrentHash"></a>12.9.2 JDK1.7中的concurrentHash</h4><h5 id="12-9-2-1-在JDK1-7中使用分段锁segment-继承-reentrantLock"><a href="#12-9-2-1-在JDK1-7中使用分段锁segment-继承-reentrantLock" class="headerlink" title="12.9.2.1 在JDK1.7中使用分段锁segment 继承 reentrantLock"></a>12.9.2.1 在JDK1.7中使用分段锁segment 继承 reentrantLock</h5><img src="https://oscimg.oschina.net/oscnet/up-c03ede9caa78c50bebf404c10c0508ccd3b.png" style="zoom:50%;" /><ul><li>根据key寻找segment并尝试获取锁</li><li>找到entry数组上的下标，然后插入数据</li><li>entry table 开始容量是2</li></ul><h5 id="12-9-2-2-扩容机制"><a href="#12-9-2-2-扩容机制" class="headerlink" title="12.9.2.2 扩容机制"></a>12.9.2.2 扩容机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="12-9-2-3-默认并发度"><a href="#12-9-2-3-默认并发度" class="headerlink" title="12.9.2.3 默认并发度"></a>12.9.2.3 默认并发度</h5><p><strong>16</strong> ， <font color=red>扩容是否可以增加并发度？</font></p><h4 id="12-9-3-在JDK1-8中使用cas-synchronized"><a href="#12-9-3-在JDK1-8中使用cas-synchronized" class="headerlink" title="12.9.3 在JDK1.8中使用cas + synchronized"></a>12.9.3 在JDK1.8中使用cas + synchronized</h4><h5 id="12-9-3-1-重要属性"><a href="#12-9-3-1-重要属性" class="headerlink" title="12.9.3.1 重要属性"></a>12.9.3.1 重要属性</h5><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:</p><ul><li><p>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh</p></li><li><p>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</p></li><li><p>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</p></li><li><p>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。</p></li><li><p>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</p></li><li><p>TREEBIN, 置为-2, 代表此元素后接红黑树。</p></li><li><p>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</p></li><li><p>sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:</p></li><li><ul><li><ul><li>0: table还没有被初始化</li><li>-1: table正在初始化</li><li>小于-1: 实际值为resizeStamp(n)&lt;</li><li>大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n</li></ul></li></ul></li><li><p>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</p></li><li><p>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</p></li></ul><p>​    ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。</p><h5 id="12-9-3-2-扩容的触发条件"><a href="#12-9-3-2-扩容的触发条件" class="headerlink" title="12.9.3.2 扩容的触发条件"></a>12.9.3.2 扩容的触发条件</h5><p>扩容检查主要发生在插入元素(putVal())的过程:</p><ul><li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li><li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li></ul><h5 id="12-9-3-3-put方法详解"><a href="#12-9-3-3-put方法详解" class="headerlink" title="12.9.3.3 put方法详解"></a>12.9.3.3 put方法详解</h5><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="1、初始化hash-table"><a href="#1、初始化hash-table" class="headerlink" title="1、初始化hash table"></a>1、初始化hash table</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tab = initTable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="comment">// 为什么这里初始化需要while循环</span></span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化的时候可能是多个线程同时在初始化，为了保证线程安全，这里使用了while + cas 来保证多线程安全。</p></blockquote><p><code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code> 相当于获取线程执行权限。只会有一个线程可以初始化，没有拿到执行权限的时候下一次循环的时候会判断</p><p><code>(tab = table) == null || tab.length == 0</code>. 不满足条件自然就不再初始化了。</p><h6 id="2、判断数组下标的位置是否是空的值"><a href="#2、判断数组下标的位置是否是空的值" class="headerlink" title="2、判断数组下标的位置是否是空的值"></a>2、判断数组下标的位置是否是空的值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) </span><br></pre></td></tr></table></figure><p>如果数组下标的位置是null，说明还没有元素，则使用cas来存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br></pre></td></tr></table></figure><h6 id="3、为什么需要cas呢？"><a href="#3、为什么需要cas呢？" class="headerlink" title="3、为什么需要cas呢？"></a>3、为什么需要cas呢？</h6><ul><li>保证线程安全</li></ul><h6 id="4、为什么put方法第5行需要循环？"><a href="#4、为什么put方法第5行需要循环？" class="headerlink" title="4、为什么put方法第5行需要循环？"></a>4、为什么put方法第5行需要循环？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Node&lt;K,V&gt;[] tab = table;;) </span><br></pre></td></tr></table></figure><p>第一个线程put一个数据和第二个线程put的数据如果发生了冲突，则第一次循环只有一个线程可以设置成功，另一个线程只能等到下一次循环。</p><h6 id="5、如果在不考虑扩容的情况下发生hash冲突，第二次插入的时候会怎样？"><a href="#5、如果在不考虑扩容的情况下发生hash冲突，第二次插入的时候会怎样？" class="headerlink" title="5、如果在不考虑扩容的情况下发生hash冲突，第二次插入的时候会怎样？"></a>5、如果在不考虑扩容的情况下发生hash冲突，第二次插入的时候会怎样？</h6><ul><li>对数组上的元素也就是链表的头结点的对象加锁 synchronized</li><li>构建链表</li><li><strong>尾部</strong>插入新元素</li><li>如果已经存在红黑树，则继续添加树的结点</li></ul><h6 id="6、往链表上添加数据如果不使用synchronized会怎样？"><a href="#6、往链表上添加数据如果不使用synchronized会怎样？" class="headerlink" title="6、往链表上添加数据如果不使用synchronized会怎样？"></a>6、往链表上添加数据如果不使用synchronized会怎样？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现添加的值被覆盖掉的情况：</p><ul><li>线程一执行 pred.next = new Node&lt;K,V&gt;  [1,a]</li><li>线程二执行 pred.next = new Node&lt;K,V&gt;  [2,b]</li></ul><p> 最后[1,a]丢失了。</p><h6 id="7、如何判断正在扩容"><a href="#7、如何判断正在扩容" class="headerlink" title="7、如何判断正在扩容"></a>7、如何判断正在扩容</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure><p>f 指的是链表的头结点。</p><h6 id="8、如果put的时候正在扩容会怎样"><a href="#8、如果put的时候正在扩容会怎样" class="headerlink" title="8、如果put的时候正在扩容会怎样"></a>8、如果put的时候正在扩容会怎样</h6><ul><li><p>当前线程会帮忙参与扩容。<code>helpTransfer(tab, f)</code></p></li><li><p>最少分配16个槽位迁移</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; <span class="comment">//table扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识符号</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;<span class="comment">//说明还在扩容</span></span><br><span class="line">                <span class="comment">//判断是否标志发生了变化||  扩容结束了</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                     <span class="comment">//达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</span></span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了如下事情:</p><ul><li><p>检查是否扩容完成</p></li><li><p>对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</p></li></ul><h6 id="9、扩容transfer"><a href="#9、扩容transfer" class="headerlink" title="9、扩容transfer"></a>9、<strong>扩容transfer</strong></h6><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">       <span class="comment">// subdivide range，每个线程最少迁移16个槽位，大的话，最多</span></span><br><span class="line">        stride = MIN_TRANSFER_STRIDE;</span><br><span class="line">    <span class="comment">// initiating  才开始初始化新的nextTab</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];  <span class="comment">//扩容2倍</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;<span class="comment">//更新的转移下标，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//是否能够向前推进到下一个周期</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123; <span class="comment">//取下一个周期</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个条件改变的是transferIndex的值，从16变成了1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     <span class="comment">//nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound; <span class="comment">//一块区间最小桶的下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">//能够处理的最大桶的下标</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123; <span class="comment">//每个迁移线程都能达到这里</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123; <span class="comment">//迁移完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">//扩大2n-0.5n = 1.50n, 更新新的容量阈值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示当前线程迁移完成了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">//注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对应位置为null， 则将ForwardingNode放在对应的地方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">//别的线程已经在处理了，再推进一个下标</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed，推动到下一个周期，仍然会检查i与bound是否结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//说明位置上有值了，</span></span><br><span class="line">            <span class="comment">//需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程向这个节点插入数据，此时迁移到这里了，会被阻塞住</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//判断i下标和f是否相同</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn; <span class="comment">//高位桶， 地位桶</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;<span class="comment">//n为2^n, 取余后只能是2^n</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">///找到最后一个不和fn相同的节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">//只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">//比如1，16，32,如果低位%16，那么肯定是0。</span></span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                 <span class="comment">//这样就把相同串的给串起来了</span></span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln); <span class="comment">//反着给串起来了</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">// 如果是红黑树</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//也是高低节点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//也是高低节点</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">//中序遍历红黑树</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123; <span class="comment">//0的放低位</span></span><br><span class="line">                                <span class="comment">//注意这里p.prev = loTail，每一个p都是下一个的prev</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p; <span class="comment">//把头记住</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;  <span class="comment">//上一次的p的next是这次的p</span></span><br><span class="line">                                loTail = p; <span class="comment">//把上次p给记住</span></span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123; <span class="comment">//高位</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p; <span class="comment">//把尾记住</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<span class="comment">// //判断是否需要转化为树</span></span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t; <span class="comment">//如果没有高低的话，则部分为两个树</span></span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有两个变量需要了解下:</p><ul><li>advance: 表示是否可以向下一个轮元素进行迁移。</li><li>finishing: table所有元素是否迁移完成。</li></ul><p>大致做了如下事情:</p><ul><li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。</li><li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。</li><li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。</li><li>从i -&gt; bound开始遍历table中每个元素, 这里是从大到小遍历的:</li></ul><ol><li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。</li><li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。</li><li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。</li></ol><ul><li>链表迁移原理如下: 遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面。</li></ul><p>​    迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。</p><p>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的节点存放在(n, 2n-1)的范围之内。</p><ul><li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。</li></ul><h6 id="10、如何确定table所有元素迁移完成"><a href="#10、如何确定table所有元素迁移完成" class="headerlink" title="10、如何确定table所有元素迁移完成"></a>10、如何确定table所有元素迁移完成</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前线程迁移完成了</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">     <span class="comment">//注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</span></span><br><span class="line">    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</p><p><strong>总结</strong></p><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p><h2 id="13-并发容器之CopyOnWriteArrayList"><a href="#13-并发容器之CopyOnWriteArrayList" class="headerlink" title="13. 并发容器之CopyOnWriteArrayList"></a>13. 并发容器之CopyOnWriteArrayList</h2><h3 id="13-1-什么是fail-fast机制"><a href="#13-1-什么是fail-fast机制" class="headerlink" title="13.1 什么是fail-fast机制"></a>13.1 什么是fail-fast机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;pool-1-thread-11&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at com.yg.edu.list.CopyOnWriteArrayListRunner$ReadTask.run(CopyOnWriteArrayListRunner.java:<span class="number">30</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><h3 id="13-2-CopyOnWriteArrayList设计思路"><a href="#13-2-CopyOnWriteArrayList设计思路" class="headerlink" title="13.2 CopyOnWriteArrayList设计思路"></a>13.2 CopyOnWriteArrayList设计思路</h3><p>猜想 ReentrantReadWriteLock 是否可以实现这个功能呢？</p><ul><li>读操作加读锁</li><li>写操作加写锁</li></ul><p>适用于读写都比价多的场景。</p><p>但是如果读多写少的场景下呢？有没有优化方案？</p><p><strong>核心思想：读写分离，空间换时间，避免为保证并发安全导致的激烈的锁竞争。</strong></p><p>划关键点：</p><p>1、CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率；</p><p>2、CopyOnWrite是最终一致性，在写的过程中，原有的读的数据是不会发生更新的，只有新的读才能读到最新数据；</p><p>3、如何使其他线程能够及时读到新的数据，需要使用volatile变量；</p><p>4、写的时候不能并发写，需要对写操作进行加锁；</p><h3 id="13-3-add方法源码"><a href="#13-3-add方法源码" class="headerlink" title="13.3 add方法源码"></a>13.3 add方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>final ReentrantLock lock = this.lock;  </code> 保证任意时刻只有一个线程进行add。</p><h3 id="13-4-使用场景"><a href="#13-4-使用场景" class="headerlink" title="13.4 使用场景"></a>13.4 使用场景</h3><ul><li>适合读多写少的情况。 思路就是空间换时间。</li><li>会造成一致性问题，只能保证最终一致性，可能会读到脏数据。</li></ul><h3 id="13-5-CopyOnWriteArraySet-底层"><a href="#13-5-CopyOnWriteArraySet-底层" class="headerlink" title="13.5 CopyOnWriteArraySet 底层"></a>13.5 CopyOnWriteArraySet 底层</h3><p>底层基于CopyOnWriteArrayList实现的</p><h3 id="13-6-ConcurrentSkipListMap"><a href="#13-6-ConcurrentSkipListMap" class="headerlink" title="13.6 ConcurrentSkipListMap"></a>13.6 ConcurrentSkipListMap</h3><p>跳表：</p><p><img src="https://oscimg.oschina.net/oscnet/up-0612b400df82bb1c43bf84edffab38e09f3.png"></p><ul><li>保证key的顺序</li><li>底层数据结构基于链表</li><li>时间复杂度O(logn)</li><li>空间换时间</li></ul><h2 id="14-Executor线程池原理解读"><a href="#14-Executor线程池原理解读" class="headerlink" title="14. Executor线程池原理解读"></a>14. Executor线程池原理解读</h2><h3 id="14-1-什么是线程？"><a href="#14-1-什么是线程？" class="headerlink" title="14.1 什么是线程？"></a>14.1 什么是线程？</h3><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型与ULT模型（这个在第一部分已经介绍过），<strong>JVM使用的KLT模型</strong>，<font color=red>Java线程与OS线程保持1:1的映射关系，也就是说有一个java线程也会在操作系统里有一个对应的线程。</font></p><p>进程是系统资源分配的基本单位。</p><h3 id="14-2-java线程中的状态"><a href="#14-2-java线程中的状态" class="headerlink" title="14.2 java线程中的状态"></a>14.2 java线程中的状态</h3><p>Java线程有多种生命状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW,新建</span><br><span class="line">RUNNABLE,运行</span><br><span class="line">BLOCKED,阻塞</span><br><span class="line">WAITING,等待</span><br><span class="line">TIMED_WAITING,超时等待</span><br><span class="line">TERMINATED，终结</span><br></pre></td></tr></table></figure><h3 id="14-3-为什么需要线程池？"><a href="#14-3-为什么需要线程池？" class="headerlink" title="14.3 为什么需要线程池？"></a>14.3 为什么需要线程池？</h3><p>创建线程和销毁线程需要CPU进行用户态和内核态的切换，因为上面提到过，java的线程模型是JLT模型。每创建一个java线程，在底层操作系统也需要创建一个系统级别的线程，有操作系统管理。</p><img src="https://oscimg.oschina.net/oscnet/up-2f02154dba45685e2fc0853b060925897be.png" style="zoom:50%;" /><p>“线程池”，顾名思义就是一个线程缓存，线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控</p><p><strong>线程池介绍</strong></p><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><p><strong>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</strong></p><p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。<strong>通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</strong></p><h3 id="14-4-什么时候使用线程池？"><a href="#14-4-什么时候使用线程池？" class="headerlink" title="14.4 什么时候使用线程池？"></a>14.4 什么时候使用线程池？</h3><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li></ul><h3 id="14-5-线程池优势"><a href="#14-5-线程池优势" class="headerlink" title="14.5 线程池优势"></a>14.5 线程池优势</h3><ul><li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="14-6-线程的生命周期"><a href="#14-6-线程的生命周期" class="headerlink" title="14.6 线程的生命周期"></a>14.6 线程的生命周期</h3><img src="https://oscimg.oschina.net/oscnet/up-14b67eef074413b1b085b17cd32d0c4cff9.png" style="zoom:50%;" /><blockquote><p>等待状态 超时等待状态 阻塞状态都会涉及到上下文切换！</p></blockquote><h3 id="14-7-什么是协程？"><a href="#14-7-什么是协程？" class="headerlink" title="14.7 什么是协程？"></a>14.7 什么是协程？</h3><p>协程    (纤程，用户级线程)，目的是为了追求最大力度的发挥硬件性能和提升软件的速度，协程基本原理是:在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来的栈信息并继续执行(整个过程线程不需要上下文切换)。</p><blockquote><p> Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包,如：quasar</p></blockquote><ul><li>只能在CPU的一个核上工作</li><li>把线程分成若干个 “单元”，也就是协程，协程之间切换不需要进行上下文切换</li><li>CPU大部分时间处于空闲，使用协程用来提高CPU利用率</li></ul><h3 id="14-8-Excutor框架"><a href="#14-8-Excutor框架" class="headerlink" title="14.8 Excutor框架"></a>14.8 Excutor框架</h3><h4 id="14-8-1-Excutor框架示意图"><a href="#14-8-1-Excutor框架示意图" class="headerlink" title="14.8.1 Excutor框架示意图"></a>14.8.1 <strong>Excutor框架示意图</strong></h4><p><img src="https://oscimg.oschina.net/oscnet/up-ed874d9d3ada0cd7e36191cf9a5ac3efc82.png"></p><blockquote><p>我们经常用到的是ThreadPoolExecutor</p></blockquote><h4 id="14-8-2-重要的API"><a href="#14-8-2-重要的API" class="headerlink" title="14.8.2 重要的API"></a>14.8.2 重要的API</h4><p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><p>1，<strong>execute</strong>（Runnable command）：履行Ruannable类型的任务,</p><p>2，<strong>submit</strong>（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象</p><p>3，<strong>shutdown</strong>（）：在完成已提交的任务后封闭办事，不再接管新任务,</p><p>4，<strong>shutdownNow</strong>（）：停止所有正在履行的任务并封闭办事。</p><p>5，<strong>isTerminated</strong>（）：测试是否所有任务都履行完毕了。</p><p>6，<strong>isShutdown</strong>（）：测试是否该ExecutorService已被关闭。</p><h4 id="14-8-3-重点属性"><a href="#14-8-3-重点属性" class="headerlink" title="14.8.3. 重点属性"></a>14.8.3. <strong>重点属性</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>ctl</strong> 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: </p><ul><li>线程池的运行状态 (runState) </li><li>线程池内有效线程的数量 (workerCount)</li></ul><p>这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p><p><strong>ctl相关方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; // 获取运行状态</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125; // 获取活动线程数</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; // 获取运行状态和活动线程数的值</span><br></pre></td></tr></table></figure><h4 id="14-8-4为什么阿里java规约中不建议使用Executors"><a href="#14-8-4为什么阿里java规约中不建议使用Executors" class="headerlink" title="14.8.4为什么阿里java规约中不建议使用Executors"></a>14.8.4为什么阿里java规约中不建议使用Executors</h4><ul><li><p>因为队列使用的是无界队列。任务可以无限存放，可能会造成内存泄漏。</p></li><li><p>而且任务阻塞时间比较久。</p></li></ul><h3 id="14-9-创建线程池"><a href="#14-9-创建线程池" class="headerlink" title="14.9 创建线程池"></a>14.9 创建线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters and default thread factory and rejected execution handler.</span></span><br><span class="line"><span class="comment">     * It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125; factory</span></span><br><span class="line"><span class="comment">     * methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-corePoolSize"><a href="#1-corePoolSize" class="headerlink" title="1. corePoolSize"></a>1. <strong>corePoolSize</strong></h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p><h4 id="2-maximumPoolSize"><a href="#2-maximumPoolSize" class="headerlink" title="2. maximumPoolSize"></a>2. <strong>maximumPoolSize</strong></h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</p><h4 id="3-keepAliveTime"><a href="#3-keepAliveTime" class="headerlink" title="3. keepAliveTime"></a>3. <strong>keepAliveTime</strong></h4><p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p><h4 id="4-unit"><a href="#4-unit" class="headerlink" title="4. unit"></a>4. <strong>unit</strong></h4><p>keepAliveTime的单位；</p><h4 id="5-workQueue"><a href="#5-workQueue" class="headerlink" title="5. workQueue"></a>5. <strong>workQueue</strong></h4><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p><ul><li>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li><li>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</li><li>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</li><li>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</li></ul><h4 id="6-threadFactory"><a href="#6-threadFactory" class="headerlink" title="6. threadFactory"></a>6. <strong>threadFactory</strong></h4><p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p><h4 id="7-handler"><a href="#7-handler" class="headerlink" title="7. handler"></a>7. <strong>handler</strong></h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li>1、AbortPolicy：直接抛出异常，默认策略；</li><li>2、CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>4、DiscardPolicy：直接丢弃任务；</li></ul><p>上面的4种策略都是ThreadPoolExecutor的内部类。</p><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h3 id="14-10-线程池执行流程"><a href="#14-10-线程池执行流程" class="headerlink" title="14.10 线程池执行流程"></a>14.10 线程池执行流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先创建核心线程并执行任务</li><li>把任务添加到阻塞队列</li><li>还有任务，创建非核心线程执行</li><li>如果还有任务进来，执行对应的拒绝策略</li></ul><p><strong>思考🤔</strong></p><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>如果核心线程还没有创建完，此时已经创建的核心线程的任务已经处理完了，此时，线程池新提交的任务由那个线程来处理呢？</p><p>是由已经创建的核心线程呢还是会创建新的核心线程呢？</p><p>答案是： <strong>会创建新的核心线程，知道核心线程数量达到最大核心线程数。</strong></p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p><strong><font color=red>如何区分核心线程还是非核心线程？</font></strong></p><p>其实并没有办法区分，线程销毁的时候会去判断当前线程数量是否比核心线程数大，如果大，则线程销毁，那这个线程就是非核心线程。如果不大，而且也允许核心线程存活的话，线程就不会销毁，留下来的也就是核心线程。</p><h3 id="14-11-线程池的生命状态？"><a href="#14-11-线程池的生命状态？" class="headerlink" title="14.11 线程池的生命状态？"></a>14.11 线程池的生命状态？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为111</span></span><br><span class="line">SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为000</span></span><br><span class="line">STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为001</span></span><br><span class="line">TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为010</span></span><br><span class="line">TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位为011</span></span><br></pre></td></tr></table></figure><h4 id="1、RUNNING"><a href="#1、RUNNING" class="headerlink" title="1、RUNNING"></a>1、RUNNING</h4><p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </p><p>(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p><h4 id="2、-SHUTDOWN"><a href="#2、-SHUTDOWN" class="headerlink" title="2、 SHUTDOWN"></a>2、 SHUTDOWN</h4><p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </p><p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><h4 id="3、STOP"><a href="#3、STOP" class="headerlink" title="3、STOP"></a>3、STOP</h4><p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </p><p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><h4 id="4、TIDYING"><a href="#4、TIDYING" class="headerlink" title="4、TIDYING"></a>4、TIDYING</h4><p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </p><p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p><h4 id="5、-TERMINATED"><a href="#5、-TERMINATED" class="headerlink" title="5、 TERMINATED"></a>5、 TERMINATED</h4><p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 </p><p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p><p>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功。</li></ul><img src="https://oscimg.oschina.net/oscnet/up-8dfc60e1eef3f170c19287d204a9e6caa4c.png" style="zoom:50%;" /><h3 id="14-12-线程池的拒绝策略有几种？"><a href="#14-12-线程池的拒绝策略有几种？" class="headerlink" title="14.12 线程池的拒绝策略有几种？"></a>14.12 线程池的拒绝策略有几种？</h3><h4 id="1-AbortPolicy-抛出异常"><a href="#1-AbortPolicy-抛出异常" class="headerlink" title="1. AbortPolicy 抛出异常"></a>1. AbortPolicy 抛出异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-CallerRunsPolicy：由当前线程执行"><a href="#2-CallerRunsPolicy：由当前线程执行" class="headerlink" title="2. CallerRunsPolicy：由当前线程执行"></a>2. CallerRunsPolicy：由当前线程执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Executes task r in the caller&#x27;s thread, unless the executor</span></span><br><span class="line"><span class="comment">         * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-DiscardOldestPolicy：抛弃队列中最老的任务"><a href="#3-DiscardOldestPolicy：抛弃队列中最老的任务" class="headerlink" title="3. DiscardOldestPolicy：抛弃队列中最老的任务"></a>3. DiscardOldestPolicy：抛弃队列中最老的任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">         * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">         * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">         * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-DiscardPolicy：-直接丢弃，什么都不做"><a href="#4-DiscardPolicy：-直接丢弃，什么都不做" class="headerlink" title="4. DiscardPolicy： 直接丢弃，什么都不做"></a>4. DiscardPolicy： 直接丢弃，什么都不做</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-13-非核心线程过期是如何判断的？"><a href="#14-13-非核心线程过期是如何判断的？" class="headerlink" title="14.13 非核心线程过期是如何判断的？"></a>14.13 非核心线程过期是如何判断的？</h3><p>阻塞队列实现，poll设置时间，然后响应中断异常。</p><h3 id="14-14-线程池参数如何配置？"><a href="#14-14-线程池参数如何配置？" class="headerlink" title="14.14 线程池参数如何配置？"></a>14.14 线程池参数如何配置？</h3><ul><li>CPU密集型 ： CPU核数 + 1</li><li>IO密集型 ： 2倍CPU核数</li></ul><h2 id="15-ScheduledThreadPoolExecutor"><a href="#15-ScheduledThreadPoolExecutor" class="headerlink" title="15. ScheduledThreadPoolExecutor"></a>15. ScheduledThreadPoolExecutor</h2><h4 id="15-1-创建定时线程池"><a href="#15-1-创建定时线程池" class="headerlink" title="15.1 创建定时线程池"></a>15.1 创建定时线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="15-2-如何周期性执行定时任务？"><a href="#15-2-如何周期性执行定时任务？" class="headerlink" title="15.2 如何周期性执行定时任务？"></a>15.2 如何周期性执行定时任务？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;send heart beat&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> starttime = System.currentTimeMillis(), nowtime = starttime;</span><br><span class="line">            <span class="keyword">while</span> ((nowtime - starttime) &lt; <span class="number">5000</span>) &#123;</span><br><span class="line">                nowtime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;task over....&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected error , stop working&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="15-3-定时任务的执行时间如果大于执行时间间隔怎么办？"><a href="#15-3-定时任务的执行时间如果大于执行时间间隔怎么办？" class="headerlink" title="15.3 定时任务的执行时间如果大于执行时间间隔怎么办？"></a>15.3 定时任务的执行时间如果大于执行时间间隔怎么办？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleWithFixedDelay</span><br></pre></td></tr></table></figure><p>上面第一种定时任务执行的方式下，在任务开始的时候开始算起，任务执行5s，但是任务执行间隔时间是2s，意味着任务还没有执行结束，下一次任务就在等待执行过了。最终会演变成，定时任务执行时间间隔变成5s。</p><p>解决上面的问题，就不应该在任务执行开始的时候就记时算起，而是在任务执行完成之后，2s后再开始执行新一轮任务。</p><p>如果只有一个任务，但是核心线程数配了2个会怎样？</p><p>只会有一个线程执行任务，因为只有一个任务，所以只创建了一个核心线程。</p><blockquote><p>线程创建是在提交任务的时候，所以，如果只是提交了1个任务，只会创建一个线程。</p></blockquote><h4 id="15-4-如果在执行过程中抛出异常会怎样？"><a href="#15-4-如果在执行过程中抛出异常会怎样？" class="headerlink" title="15.4 如果在执行过程中抛出异常会怎样？"></a>15.4 如果在执行过程中抛出异常会怎样？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;send heart beat&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> starttime = System.currentTimeMillis(), nowtime = starttime;</span><br><span class="line">    <span class="keyword">while</span> ((nowtime - starttime) &lt; <span class="number">5000</span>) &#123;</span><br><span class="line">        nowtime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;task over....&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected error , stop working&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>线程创建了但是任务不执行</p><h4 id="15-5-还有什么方式可以定时执行任务？"><a href="#15-5-还有什么方式可以定时执行任务？" class="headerlink" title="15.5 还有什么方式可以定时执行任务？"></a>15.5 还有什么方式可以定时执行任务？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;send heart beat&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected error , stop working&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">21</span>:<span class="number">11.915</span> [Timer-<span class="number">0</span>] INFO com.yg.edu.schedule.ScheduleThreadPoolRunner - send heart beat</span><br><span class="line">Exception in thread <span class="string">&quot;Timer-0&quot;</span> java.lang.RuntimeException: unexpected error , stop working</span><br><span class="line">at com.yg.edu.schedule.ScheduleThreadPoolRunner$<span class="number">1.</span>run(ScheduleThreadPoolRunner.java:<span class="number">95</span>)</span><br><span class="line">at java.util.TimerThread.mainLoop(Timer.java:<span class="number">555</span>)</span><br><span class="line">at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Timer already cancelled.</span><br><span class="line">at java.util.Timer.sched(Timer.java:<span class="number">397</span>)</span><br><span class="line">at java.util.Timer.scheduleAtFixedRate(Timer.java:<span class="number">328</span>)</span><br><span class="line">at com.yg.edu.schedule.ScheduleThreadPoolRunner.main(ScheduleThreadPoolRunner.java:<span class="number">105</span>)</span><br></pre></td></tr></table></figure><h4 id="15-6-Timer和Scheduled两种方式有什么区别？"><a href="#15-6-Timer和Scheduled两种方式有什么区别？" class="headerlink" title="15.6 Timer和Scheduled两种方式有什么区别？"></a>15.6 Timer和Scheduled两种方式有什么区别？</h4><p>Timer是单线程的，如果提交了多个任务，一旦一个任务抛出了异常，其他的任务也无法在执行</p><p>scheduledThreadPoolExecutor是多线程的，一个任务抛出了异常不影响其他的任务和将要来临的任务</p><h4 id="15-7-使用场景"><a href="#15-7-使用场景" class="headerlink" title="15.7 使用场景"></a>15.7 使用场景</h4><p>1、分布式锁 锁续命 定时判断 看门狗</p><p>2、心跳检测</p><p>3、其他</p><h4 id="15-8-定时任务是如何排序的？"><a href="#15-8-定时任务是如何排序的？" class="headerlink" title="15.8 定时任务是如何排序的？"></a>15.8 定时任务是如何排序的？</h4><p>堆结构</p><h2 id="16-Fock-Join框架"><a href="#16-Fock-Join框架" class="headerlink" title="16. Fock/Join框架"></a>16. Fock/Join框架</h2><h3 id="16-1-任务性质类型"><a href="#16-1-任务性质类型" class="headerlink" title="16.1 任务性质类型"></a>16.1 <strong>任务性质类型</strong></h3><h4 id="CPU密集型（CPU-bound）"><a href="#CPU密集型（CPU-bound）" class="headerlink" title="CPU密集型（CPU-bound）"></a><strong>CPU密集型（CPU-bound）</strong></h4><p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p><p>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p><p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p><p>线程数一般设置为：<code>线程数 = CPU核数+1 (现代CPU支持超线程)</code></p><h4 id="IO密集型（I-O-bound）"><a href="#IO密集型（I-O-bound）" class="headerlink" title="IO密集型（I/O bound）"></a><strong>IO密集型（I/O bound）</strong></h4><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。</p><p>I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p><p>线程数一般设置为：<code>线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 </code></p><h4 id="CPU密集型-vs-IO密集型"><a href="#CPU密集型-vs-IO密集型" class="headerlink" title="CPU密集型 vs IO密集型"></a><strong>CPU密集型 vs IO密集型</strong></h4><p>我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h3 id="16-2-什么是-Fork-Join-框架？"><a href="#16-2-什么是-Fork-Join-框架？" class="headerlink" title="16.2 什么是 Fork/Join 框架？"></a>16.2 <strong>什么是 Fork/Join 框架？</strong></h3><p>Fork/Join 框架是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…..＋10000，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。如下图所示：</p><img src="https://oscimg.oschina.net/oscnet/up-c970a71304111fa60b62f1f29613c9108f8.png" style="zoom:50%;" /><h3 id="16-3-Fork-Jion特性"><a href="#16-3-Fork-Jion特性" class="headerlink" title="16.3 Fork/Jion特性"></a>16.3 Fork/Jion特性</h3><ol><li>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。（见 Java Tip: When to use ForkJoinPool vs ExecutorService ）</li><li>ForkJoinPool <strong>主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数</strong>，例如 quick sort 等。</li><li>ForkJoinPool 最适合的是<strong>计算密集型</strong>的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</li></ol><h3 id="16-4-Fork-Join的实现"><a href="#16-4-Fork-Join的实现" class="headerlink" title="16.4 Fork/Join的实现"></a>16.4 Fork/Join的实现</h3><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p><p>我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通<strong>常会使用双端队列</strong>，**<font color=red >被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</font>**</p><h4 id="16-4-1-工作窃取算法的优点"><a href="#16-4-1-工作窃取算法的优点" class="headerlink" title="16.4.1 工作窃取算法的优点"></a>16.4.1 工作窃取算法的优点</h4><p>是充分利用线程进行并行计算，并减少了线程间的竞争，</p><h4 id="16-4-2-工作窃取算法的缺点"><a href="#16-4-2-工作窃取算法的缺点" class="headerlink" title="16.4.2 工作窃取算法的缺点"></a>16.4.2 工作窃取算法的缺点</h4><ul><li><p>在某些情况下还是存在竞争，比如双端队列里只有一个任务时。</p></li><li><p>消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></li></ul><h4 id="16-4-3-实现原理"><a href="#16-4-3-实现原理" class="headerlink" title="16.4.3 实现原理"></a>16.4.3 实现原理</h4><img src="https://oscimg.oschina.net/oscnet/up-b60c6d2ce35c06c2f20c0904e2b559b35ae.png" style="zoom:50%;" /><ol><li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li><li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li><li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li><li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li><li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li></ol><h3 id="16-5-Fork-Join框架执行流程"><a href="#16-5-Fork-Join框架执行流程" class="headerlink" title="16.5 Fork/Join框架执行流程"></a>16.5 <strong>Fork/Join框架执行流程</strong></h3><p>ForkJoinPool 中的任务执行分两种:</p><ul><li>直接通过 FJP 提交的外部任务(external/submissions task)，存放在 workQueues 的偶数槽位；</li><li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-1d1b8b1a381557e4f2f5be8016fb76cef90.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://note.youdao.com/ynoteshare/index.html?id=e59837f57323a12defbb62fa837b330d&type=note&_time=1641267390260">JMM讲解&amp;volatile</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=73fc01483ff8b40c47d6898ad17a66c8&type=note&_time=1641280508219">MESI协议</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=ee257490aa10fc87bb8c3823ed1e5421&type=note&_time=1641289972738">并发编程之synchronized详解</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=695b21d540f1a6c8c0dae11c4d696b1f&type=note&_time=1641371184468">抽象队列同步器AQS应用Lock详解【更多课程 zx-cc.net】</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=3224c156c25f8efcc118d5492d8fcffe&type=note&_time=1641782731057">Atomic类&amp;Unsafe类</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=28dacf9b84f676f10db7641c2cff742c&type=note&_time=1641787658813">并发容器之ConcurrentHashMap</a></li><li><a href="https://note.youdao.com/ynoteshare/index.html?id=251afb555eaeb23df333d276fded9f75&type=note&_time=1641890739630">定时任务线程池</a></li><li>[Fork/Join](<a href="https://note.youdao.com/ynoteshare/index.html?id=43491d79e1e5735d39b34b8f7a20c5c7&amp;type=note&amp;_time=1641968709155">https://note.youdao.com/ynoteshare/index.html?id=43491d79e1e5735d39b34b8f7a20c5c7&amp;type=note&amp;_time=1641968709155</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-volatile关键字&quot;&gt;&lt;a href=&quot;#2-volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;2. volatile关键字&quot;&gt;&lt;/a&gt;2. volatile关键字&lt;/h2&gt;&lt;h3 id=&quot;2-1-volatile的作用&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL为什么有时会选错索引</title>
    <link href="http://example.com/wiki/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/wiki/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</id>
    <published>2021-12-07T11:48:16.000Z</published>
    <updated>2021-12-07T11:49:06.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL为什么有时会选错索引"><a href="#MySQL为什么有时会选错索引" class="headerlink" title="MySQL为什么有时会选错索引"></a>MySQL为什么有时会选错索引</h1><p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你 写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确 定的。</p><p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索 引，而导致执行速度变得很慢?</p><p>我们一起来看一个例子吧。 我们先建一个简单的表，表里有a、b两个字段，并分别建上索引:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>然后，我们往表t中插入10万行记录，取值按整数递增，即:(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。</p><p>我是用存储过程来插入数据的，这里我贴出来方便你复现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line">create procedure idata()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    insert into t values(i, i, i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br></pre></td></tr></table></figure><p>接下来，我们分析一条SQL语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure><p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。 你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p><p><img src="https://oscimg.oschina.net/oscnet/up-45dfccea9790939067fb35e26f7155fce11.png"></p><p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索</p><p>引a。</p><p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做 如下操作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8a91fd7aff5e63d7798db49127b6d2fd6fd.png"></p><p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删</p><p>除后，又调用了 idata这个存储过程，插入了10万行数据。</p><p>这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志(slow log)来查看一下具体的执行情况。</p><p>为了说明优化器选择的结果是否正确，我增加了一个对照，即:使用force index(a)来让优化器强</p><p>制使用索引a(这部分内容，我还会在这篇文章的后半部分中提到)。 下面的三条SQL语句，就是这个实验过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set long_query_time=0;</span><br><span class="line">select * from t where a between 10000 and 20000; /*Q1*/</span><br><span class="line">select * from t force index(a) where a between 10000 and 20000;/*Q2*/</span><br></pre></td></tr></table></figure><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日 志中;</li><li> 第二句，Q1是session B原来的查询;</li><li> 第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>如图3所示是这三条SQL语句执行完成后的慢查询日志。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6d0b7f98193f539ed902b463d2660b305b6.png"></p><p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，</p><p>执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</p><p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引，是不是有点奇怪呢?今天，我们就从这个奇怪的结果说起吧。</p><h2 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h2><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，<strong>扫描行数是影响执行代价的因素之一</strong>。扫描的行数越少，意味着访问磁盘数据的次数越 少，消耗的CPU资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，<strong>优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</strong></p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出问题了。</p><h3 id="那么，问题就是-扫描行数是怎么判断的"><a href="#那么，问题就是-扫描行数是怎么判断的" class="headerlink" title="那么，问题就是:扫描行数是怎么判断的?"></a><font color=red>那么，问题就是:扫描行数是怎么判断的?</font></h3><p> MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。</p><p>而一个索引上不同的值的个数，我们称之为“基数”(cardinality)。也就是说，这个基数越 大，索引的区分度越好。</p><p>我们可以使用<code>show index</code>方法，看到一个索引的基数。</p><p>如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不 同，而且其实都不准确。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6cf5345e7c9034a3953e7f1b4227f4cc8cc.png"></p><h3 id="那么，MySQL是怎样得到索引的基数的呢"><a href="#那么，MySQL是怎样得到索引的基数的呢" class="headerlink" title="那么，MySQL是怎样得到索引的基数的呢?"></a><strong>那么，MySQL是怎样得到索引的基数的呢?</strong></h3><p>这里，我给你简单介绍一下MySQL采样统计的方法。 为什么要采样统计呢?  因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太</p><p>高了，所以只能选择“采样统计”。 采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1/M的 时候，会自动触发重新做一次索引统计。</p><p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择:</p><ul><li>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。 </li><li>设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li></ul><p>由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。 但，这还不是全部。</p><p>你可以从图4中看到，这次的索引统计值(cardinality列)虽然不够精确，但大体上还是差不多 的，选错索引一定还有别的原因。</p><p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要 扫描多少行。</p><p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5ef0aee057f2071d38388ec66b71d8f2b01.png"></p><p>rows这个字段表示的是预计扫描行数。</p><p>其中，Q1的结果还是符合预期的，rows的值是104620;但是Q2的rows值是37116，偏差就大了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢?</p><p>这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据， 这个代价优化器也要算进去的。</p><p>而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。 优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。 </p><blockquote><p><strong>使用普通索引需要把回表的代价算进去</strong></p></blockquote><p>在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。 所以冤有头债有主，MySQL选错索引，这件事儿</p><p>还得归咎到没能准确地判断出扫描行数。</p><p>既然是统计信息不对，那就修正。<code>analyze table t</code> 命令，可以用来重新统计索引信息。</p><p>我们来看 一下执行效果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-770cd142953256e165de08dd8f0e5c2fa3b.png"></p><p>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个 方法来处理。</p><p>其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优 化器可不止是看扫描行数。</p><p>依然是基于这个表t，我们看看另外一个语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1</span><br></pre></td></tr></table></figure><p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。 在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢? </p><p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6988e9b1a37bda5f715216d0131f2face47.png"></p><p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索</p><p>引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。 如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是</p><p>需要回到主键索引上取值再判断，所以需要扫描50001行。</p><p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底 是不是这么一回事儿。</p><p><img src="https://oscimg.oschina.net/oscnet/up-bbcf622b5cb93c997f77d3bd2c25cc9796a.png"></p><p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行</p><p>数是50198。 从这个结果中，你可以得到两个结论:</p><ul><li>扫描行数的估计值依然不准确;</li><li>这个例子里MySQL又选错了索引</li></ul><h2 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h2><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况: 原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢?</p><p>一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。MySQL会根据 词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需 要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估 其他索引的执行代价。</p><p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行 效果:</p><p><img src="https://oscimg.oschina.net/oscnet/up-2953174a3c3cf4fdc4d9c8f2a8975a904cd.png"></p><p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化</p><p>器的选择快了40多倍。<br> 也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。 不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p><blockquote><p>但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现 的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修 改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p></blockquote><p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢?</p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，我们可以考虑修改 语句，引导MySQL使用我们期望的索引。比如，在这个例子里，显然把“orderbyblimit1”改 成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p>我们来看看改之后的效果:</p><p><img src="https://oscimg.oschina.net/oscnet/up-697b792f8cd9e11b702ee9c5d2b8362f152.png"></p><p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序(b本身是索引，已经是有序</p><p>的了，如果选择索引b的话，不需要再做排序，只需要遍历)，所以即使扫描行数多，也判定为 代价更小。</p><p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫 描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p><p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条 件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才 可以这么做。</p><p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-bb1eee544d4ffe4a4dd3a74e15f4aa08538.png"></p><p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据<strong>数据特征诱导了一下优化器</strong>，也不具备通用性。</p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选 择，或删掉误用的索引。</strong></p><p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较 少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</p><p>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子， 最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是 就删掉了这个索引，优化器也就重新选择到了正确的索引。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前面我们在构造第一个例子的过程中，通过session A的配合， 让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001 变成37000多。</p><p>而如果没有session A的配合，只是单独执行delete from t 、call idata()、explain这三句话，会看 到rows字段其实还是10000左右。你可以自己验证一下这个结果。</p><p>这是为什么呢？</p><p>为什么经过这个操作序列，explain的结果就不对了?这 里，我来为你分析一下原因。</p><p>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来 的10万行。</p><p>但是，<strong>session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的</strong>。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数 据。</p><p>这样，索引a上的数据其实就有两份。</p><p>然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令 看到的扫描行数为什么还是100000左右?(潜台词，如果这个也翻倍，也许优化器还会认为选 字段a作为索引更合适)</p><p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是 show table status的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL为什么有时会选错索引&quot;&gt;&lt;a href=&quot;#MySQL为什么有时会选错索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL为什么有时会选错索引&quot;&gt;&lt;/a&gt;MySQL为什么有时会选错索引&lt;/h1&gt;&lt;p&gt;前面我们介绍过索引，你已经知道了在M</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>字符串字段如何创建索引</title>
    <link href="http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/</id>
    <published>2021-12-07T11:46:33.000Z</published>
    <updated>2021-12-07T11:47:11.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么给字符串字段添加索引"><a href="#怎么给字符串字段添加索引" class="headerlink" title="怎么给字符串字段添加索引"></a>怎么给字符串字段添加索引</h1><p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天 要讨论的问题。</p><p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> SUser(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">...</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语 句就只能做全表扫描。</p><p>同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，<strong>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</strong></p><p>比如，这两个在email字段上创建索引的语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串;而第二个语句创建的index2 索引里面，对于每个记录都是只取前6个字节。</p><p>那么，这两种不同的定义在数据结构和存储上有什么区别呢?如图2和3所示，就是这两个索引 的示意图。</p><p><img src="https://oscimg.oschina.net/oscnet/up-fa537bde10fbcdecaf1b58576ec108c66f9.png"></p><p>索引2 👇</p><p><img src="https://oscimg.oschina.net/oscnet/up-68ada8a9dc6378cf9e9b3d35b9aab0a0bef.png"></p><p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节(即:zhangs)，所以占用的空间会更小，这就是使用前缀索引的优势。</p><p>但，这同时带来的损失是，<strong>可能会增加额外的记录扫描次数</strong>。</p><p>接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>如果使用的是index1(即email整个字符串的索引结构)，执行顺序是这样的:</p><ul><li><p>从index1索引树找到满足索引值是’<a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#121;&#x7a;&#x40;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#121;&#x7a;&#x40;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#x6d;</a>’的这条记录，取得ID2的值;</p></li><li><p>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集;</p></li><li><p>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足 email=‘<a href="mailto:&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#109;">&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#109;</a>’的条件了，循环结束。</p></li></ul><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p></li><li><p>如果使用的是index2(即email(6)索引结构)，执行顺序是这样的:</p><ul><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1;</li><li>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#x79;&#122;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#111;&#x6d;">&#x7a;&#x68;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#x79;&#122;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#111;&#x6d;</a>’，这行记录丢 弃;</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取 整行然后判断，这次值对了，将这行记录加入结果集;</li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ul><p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p></li></ul><p><strong>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</strong></p><blockquote><p>但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7)，也就是说取 email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到 ID2，只扫描一行就结束了。</p></blockquote><p><font color=blue>也就是说使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查 询成本。</font></p><h2 id="如何定义前缀索引的长度呢"><a href="#如何定义前缀索引的长度呢" class="headerlink" title="如何定义前缀索引的长度呢"></a>如何定义前缀索引的长度呢</h2><p>于是，你就有个问题:当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢?</p><p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的 键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用 这个语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>))<span class="keyword">as</span> L4, <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>))<span class="keyword">as</span> L5, <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>))<span class="keyword">as</span> L6, <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>))<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以 选择前缀长度为6。</p><h2 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h2><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止 如此，我们再看一下另外一个场景。</p><p>你先来看看这个SQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>与前面例子中的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>相比，这个语句只要求返回id和email字段。</p><p>所以，如果使用index1(即email整个字符串的索引结构)的话，可以利用覆盖索引，从index1查 到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2(即email(6)索引结 构)的话，就不得不回到ID索引再去判断email字段的值。</p><p><strong>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息， 但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</strong></p><p><font color=red>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀 索引时需要考虑的一个因素。</font></p><h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢?</p><p>比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前</p><p>6位一般会是相同的。 假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。 按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的 效率也就会越低。</p><p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理 方法呢?这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p><p>答案是，有的。</p><h3 id="第一种方式是使用倒序存储"><a href="#第一种方式是使用倒序存储" class="headerlink" title="第一种方式是使用倒序存储"></a>第一种方式是使用倒序存储</h3><p>如果你存储身份证号的时候把它倒过来存，每次查询的时候，你 可以这么写:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区 分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p><h3 id="第二种方式是使用hash字段"><a href="#第二种方式是使用hash字段" class="headerlink" title="第二种方式是使用hash字段"></a>第二种方式是使用hash字段</h3><p>你可以在表上再创建一个整数字段，来保存身份证的校验码， 同时在这个字段上创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码 可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你 的查询语句where部分要判断id_card的值是否精确相同。</p><p>这样，<strong>索引的长度变成了4个字节</strong>，比原来小了很多。</p><p>接下来，我们再一起看看使用倒序存储和使用hash字段这两种方法的异同点。</p><h3 id="首先，它们的相同点是，"><a href="#首先，它们的相同点是，" class="headerlink" title="首先，它们的相同点是，"></a>首先，它们的相同点是，</h3><p>都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的 方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样 地，hash字段的方式也只能支持等值查询。</p><h3 id="它们的区别，"><a href="#它们的区别，" class="headerlink" title="它们的区别，"></a>它们的区别，</h3><p>主要体现在以下三个方面:</p><ol><li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字 段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如 果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li><li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash 字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的 话，reverse函数额外消耗的CPU资源会更小些。</li><li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽 然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储 方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的 方式有:</p><ol><li>直接创建完整索引，这样可能比较占用空间;</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引;</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题;</li><li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>好了，又到了最后的问题时间。</p><p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是:十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第 十位是入学年份、最后五位是顺序编号。</p><p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢?</p><p>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</p><p>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么给字符串字段添加索引&quot;&gt;&lt;a href=&quot;#怎么给字符串字段添加索引&quot; class=&quot;headerlink&quot; title=&quot;怎么给字符串字段添加索引&quot;&gt;&lt;/a&gt;怎么给字符串字段添加索引&lt;/h1&gt;&lt;p&gt;现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>innodb是如何处理脏页的</title>
    <link href="http://example.com/wiki/innodb%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%84%8F%E9%A1%B5%E7%9A%84/"/>
    <id>http://example.com/wiki/innodb%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%84%8F%E9%A1%B5%E7%9A%84/</id>
    <published>2021-12-07T11:45:11.000Z</published>
    <updated>2021-12-07T11:46:04.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的mysql为什么会抖一下"><a href="#我的mysql为什么会抖一下" class="headerlink" title="我的mysql为什么会抖一下"></a>我的mysql为什么会抖一下</h1><blockquote><p>innodb引擎是如何处理 <strong>脏页</strong> 的</p></blockquote><p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但 是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><h2 id="你的SQL语句为什么变“慢”了"><a href="#你的SQL语句为什么变“慢”了" class="headerlink" title="你的SQL语句为什么变“慢”了"></a>你的SQL语句为什么变“慢”了</h2><p>在前面《一条SQL更新语句是如何执行的?》中，介绍了WAL机制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志 叫作redo log(重做日志)，也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写 完redo log后，就返回给客户端，本次更新成功。</p><p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件(redo log)，掌柜的记忆就是内存。</p><p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 <strong>flush</strong>。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一 致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p><ul><li><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p></li><li><p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p></li></ul><p><strong>不论是脏页还是干净页，都在内存中</strong>。在这个例子里，内存对应的就是掌柜的记忆。</p><p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10 文，这次又要赊9文。</p><p><img src="https://oscimg.oschina.net/oscnet/up-81108822d1cb4643a5d86440190c0790bc6.png"></p><p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而</p><p><strong>MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页(flush)。</strong></p><h3 id="那么，什么情况会引发数据库的flush过程呢"><a href="#那么，什么情况会引发数据库的flush过程呢" class="headerlink" title="那么，什么情况会引发数据库的flush过程呢?"></a>那么，什么情况会引发数据库的flush过程呢?</h3><p>我们还是继续用咸亨酒店掌柜的这个例子，想一想:掌柜在什么情况下会把粉板上的赊账记录改</p><p>到账本上?</p><h4 id="第一种场景"><a href="#第一种场景" class="headerlink" title="第一种场景"></a>第一种场景</h4><p>粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活 儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确 的账目记录到账本中才行。</p><p> 这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把 checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意 图，这里我改成环形，便于大家理解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4e9f7569d6266f23dd6ea7df11fd9a1bc82.png"></p><p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中 👆，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志(浅绿色部分)，对应的所有脏页都flush到磁盘上。之后，图 中从write pos到CP’之间就是可以再写入的redo log的区域。</p><h4 id="第二种场景"><a href="#第二种场景" class="headerlink" title="第二种场景"></a>第二种场景</h4><p>这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出 账本把孔乙己这笔账先加进去。 </p><p>这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。 </p><p>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了? 这里其实是从性能考虑的。</p><p><strong>如果刷脏页一定会写盘， 就保证了每个数据页有两种状态:</strong></p><ul><li><p>一种是内存里存在，内存里就肯定是正确的结果，直接返回; </p></li><li><p>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。 这样的效率最高。</p></li></ul><h4 id="第三种场景"><a href="#第三种场景" class="headerlink" title="第三种场景"></a>第三种场景</h4><p>生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不 如更新账本。 </p><p>这种场景，对应的就是MySQL认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起 来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也 要见缝插针地找时间，只要有机会就刷一点“脏页”。</p><h4 id="第四种场景"><a href="#第四种场景" class="headerlink" title="第四种场景"></a>第四种场景</h4><p>年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都 记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。 </p><p>这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁 盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p><h4 id="接下来，你可以分析一下上面四种场景对性能的影响。"><a href="#接下来，你可以分析一下上面四种场景对性能的影响。" class="headerlink" title="接下来，你可以分析一下上面四种场景对性能的影响。"></a>接下来，你可以分析一下上面四种场景对性能的影响。</h4><p>其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库 本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前 两种场景下的性能问题。</p><p>第一种是“<strong>redo log写满了，要flush脏页</strong>”，这种情况是InnoDB要尽量避免的。因为出现这种情况 的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更 新数会跌为0。</p><p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。</p><p>InnoDB用缓冲池 (buffer pool)管理内存，缓冲池中的内存页有三种状态:</p><ul><li>第一种是，还没有使用的;</li><li>第二种是，使用了并且是干净页;</li><li>第三种是，使用了并且是脏页。</li></ul><p><strong>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</strong></p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。</p><p>这时候只能把最久不使用的数据页从内存中淘汰掉: </p><ul><li><p>如果要淘汰的是一个干净页，就直接释放出来复用;</p></li><li><p>但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。 所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的:</p><ul><li><p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长;</p></li><li><p>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。 </p></li></ul><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p></li></ul><h2 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h2><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p><p>首先，<strong>你要正确地告诉InnoDB所在主机的IO能力</strong>，这样InnoDB才能知道需要全力刷脏页的时 候，可以刷多快。</p><p>这就要用到 <code>innodb_io_capacity</code> 这个参数了，它会告诉InnoDB你的磁盘能力。这个值我<strong>建议你设置成磁盘的IOPS</strong>。</p><p>磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机 读写的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure><p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，<strong>说MySQL的写入速度很慢，TPS很低， 但是数据库主机的IO压力并不大</strong>。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p><p>他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个 系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了<strong>脏页累积</strong>，影响了查询和更新性能。</p><p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧? 毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按 照“全力”的百分比来刷脏页。</p><h3 id="根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因素呢"><a href="#根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因素呢" class="headerlink" title="根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因素呢?"></a>根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因素呢?</h3><p>这个问题可以这么想，如果刷太慢，会出现什么情况?  首先是内存脏页太多，其次是redo log写满。</p><p>所以，InnoDB的刷盘速度就是要参考这两个因素:一个是脏页比例，一个是redo log写盘速度。</p><p>InnoDB会根据这两个因素先单独算出两个数字。 </p><p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例(假设为M)，算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F1(M) &#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值， 我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为 F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p><p>然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力**乘以R%**来控制刷脏页的速度。</p><p>上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上 面我们通过脏页比例和redo log写入速度算出来的两个值。</p><p><img src="https://oscimg.oschina.net/oscnet/up-20c9667918f63b5caa0ca3397366d407a73.png"></p><p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。</p><p>所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p><p>要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且平时要多关注脏页比例，<strong>不要让它经常接近75%。</strong></p><p>其中，脏页比例是通过<code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>得到 的，具体的命令参考下面的代码:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们再看一个有趣的策略。</p><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>在InnoDB中，<code>innodb_flush_neighbors</code> 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</p><p>而如果使用的是SSD这类IOPS比较高的设备的话，<strong>我就建议你把innodb_flush_neighbors的值设置成0</strong>。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</p><p><strong>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我延续第2篇中介绍的WAL的概念，和你解释了这个机制后续需要的刷脏页操作和执行时机。利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。</p><p>但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。</p><p>但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的mysql为什么会抖一下&quot;&gt;&lt;a href=&quot;#我的mysql为什么会抖一下&quot; class=&quot;headerlink&quot; title=&quot;我的mysql为什么会抖一下&quot;&gt;&lt;/a&gt;我的mysql为什么会抖一下&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;innodb引擎是</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一条更新语句是如何执行的</title>
    <link href="http://example.com/wiki/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://example.com/wiki/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2021-12-06T10:47:01.000Z</published>
    <updated>2021-12-06T10:47:33.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条更新语句是如何执行的"><a href="#一条更新语句是如何执行的" class="headerlink" title="一条更新语句是如何执行的"></a>一条更新语句是如何执行的</h1><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还 记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后 到达存储引擎。</p><p>那么，一条更新语句的执行流程又是怎样的呢?</p><p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你 是不是心中也会不免会好奇，这是怎样做到的呢?</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个 整型字段c:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure><p>如果要将ID=2这一行的值加1，SQL语句就会这么写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看 这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p><img src="https://oscimg.oschina.net/oscnet/up-661c52fa2ca85182e119823265a003d152b.png" alt="MySQL的逻辑架构图"></p><p>你执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，<font color=blue>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会 把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</font></p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主 角:<strong>redo log(重做日志)和 binlog(归档日志)<strong>。如果接触MySQL，那这两个词肯定是绕不过 的，我后面的内容里也会不断地和你强调。</strong>不过话说回来，redo log和binlog在设计上有很多有 意思的地方，这些设计思路也可以用到你自己的程序里。</strong></p><h2 id="重要的日志模块-redo-log"><a href="#重要的日志模块-redo-log" class="headerlink" title="重要的日志模块:redo log"></a>重要的日志模块:redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记 录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会 有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法:</p><ul><li><p>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉;</p></li><li><p>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p></li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到 这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老 花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的 帮助，每次记账都得翻账本，效率是不是低得让人难以忍受?</p><p>同样，<font color=blue>在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到 对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。</font>为了解决这个问 题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的<code>WAL</code>技术，WAL的全称是<code>Write- Ahead Logging</code>，<font color=red>它的关键点就是先写日志，再写磁盘</font>，也就是先写粉板，等不忙的时候再写账本。</p><blockquote><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log(粉板)里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作 记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p></blockquote><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎 么办呢?这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把 这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环 写，如下面这个图所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-846e5f4de8648713e24cdd7a028b547f4a6.png"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。 checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文 件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos 追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或 写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板 上的数据明确赊账账目。</p><h2 id="重要的日志模块-binlog"><a href="#重要的日志模块-binlog" class="headerlink" title="重要的日志模块:binlog"></a>重要的日志模块:binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块:一块是Server层，它主要做的是MySQL功能 层面的事情;还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)。</p><p>我想你肯定会问，为什么会有两份日志呢?</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有 crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL 的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— — 也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><font color=red>redolog是InnoDB引擎特有的;</font> binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redolog是物理日志，记录的是“在某个数据页上做了什么修改”; binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li><li>redolog是循环写的，空间固定会用完;binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语 句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一 行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁盘读入内存，然 后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redolog里面，此时redolog处 于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redolog改成提交(commit)状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://oscimg.oschina.net/oscnet/up-67fa7fe81e054dbaaae134dea88c9d651f3.png"></p><p><strong><font color=blue>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤:prepare和commit，这就是”两阶段提交”。</font></strong></p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢?这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得 从文章开头的那个问题说起:怎样让数据库恢复到半个月内任意一秒的状态?</p><p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承 诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期 做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数 据，那你可以这么做:</p><ul><li><p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备 份恢复到临时库;</p></li><li><p>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</p></li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法 来进行解释。</p><blockquote><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p></blockquote><p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语 句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢?</p><ul><li><p>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异 常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份 日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以 后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日 志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同。</p></li></ul><p>可以看到，如果不使用“两阶段提交”，<font color=blue>那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</font></p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀?</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，<font color=blue>这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</font></p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p><ul><li><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证 MySQL异常重启之后数据不丢失。</p></li><li><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建 议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p></li></ul><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。<strong>两阶段提交是跨系统维持数据逻辑 一致性时常用的一个方案</strong>，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢?或者说，它影响了这个数据库系统的哪个指标?</p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>一天一备好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份， 而要恢复出一个到昨天晚上23点的备份。</p><p>一周一备最坏情况就要应用一周的binlog了。系统的对应指标就是RTO(恢复目标时间)。</p><p>当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来 的，就需要你根据业务重要性来评估了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条更新语句是如何执行的&quot;&gt;&lt;a href=&quot;#一条更新语句是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;一条更新语句是如何执行的&quot;&gt;&lt;/a&gt;一条更新语句是如何执行的&lt;/h1&gt;&lt;p&gt;前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离：为什么你改了我还看不见</title>
    <link href="http://example.com/wiki/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://example.com/wiki/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2021-12-06T10:45:45.000Z</published>
    <updated>2021-12-06T10:46:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务隔离：为什么你改了我还看不见"><a href="#事务隔离：为什么你改了我还看不见" class="headerlink" title="事务隔离：为什么你改了我还看不见"></a>事务隔离：为什么你改了我还看不见</h1><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么?这时就要用到“事 务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事 务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引 擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代 的重要原因之一。</p><p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给 出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>提到事务，你肯定会想到ACID(Atomicity、Consistency、Isolation、Durability，即原子性、一 致性、隔离性、持久性)，今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要 在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括:读未提交(read uncommitted)、 读提交(read committed)、可重复读(repeatable read)和串行化(serializable )。下面我逐 一为你解释:</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 </li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 </li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中 只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://oscimg.oschina.net/oscnet/up-4263a773c9c9bf065d77d3f59bdb13b004f.png"></p><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3 的返回值分别是什么。</p><ul><li><p>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被 A看到了。因此，V2、V3也都是2。 </p></li><li><p>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</p></li><li><p>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求: 事务在执行期间看到的数据前后必须是一致的。</p></li><li><p>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后， 事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</p></li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。<font color="red">在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</font><font color=blue>在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的</font>。这里需要注意的是，“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念;而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致， 你一定要记得将MySQL的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用<code>show variables</code>来查看当前的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。 我想你可能会问那什么时候需要“可重复读”的场景呢?我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时 候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务 更新的影响。</p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复 读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://oscimg.oschina.net/oscnet/up-823d70046a45479d602f2a8e62bc33ad0a2.png"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看 到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多 个版本，就是数据库的多版本并发控制(MVCC)。对于read-view A，要得到1，就必须将当前 值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的 事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢? 答案是，在不需要的时候才删除。 也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢?就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数 据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占 用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终 提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终 只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候 展开。</p><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并 不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种:</p><ul><li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是 rollback。</p></li><li><p>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</p></li></ul><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的 查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式 每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾 虑，我建议你使用<font color=red>commit work and chain</font>语法。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语 句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查 找持续时间超过60s的事务。</p><p><code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 </code> </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也 是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢?</p><p>这个问题，我们可以从应用开发端和数据库端来看。 首先，从应用开发端来看:</p><ol><li>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的 general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架 如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我 见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务 可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过SETMAX_EXECUTION_TIME命令， 来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。(为什么会意外?在后 续的文章中会提到这类案例)</li></ol><p>其次，从数据库端来看:</p><ol><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill;</li><li>Percona的pt-kill这个工具不错，推荐使用;</li><li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题;</li><li>如果使用的是MySQL5.6或者更新版本，把innodb_undo_tablespaces设置成2(或更大的 值)。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务隔离：为什么你改了我还看不见&quot;&gt;&lt;a href=&quot;#事务隔离：为什么你改了我还看不见&quot; class=&quot;headerlink&quot; title=&quot;事务隔离：为什么你改了我还看不见&quot;&gt;&lt;/a&gt;事务隔离：为什么你改了我还看不见&lt;/h1&gt;&lt;p&gt;提到事务，你肯定不陌生，和数</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>全局锁和表锁：给表加个字段怎么这么多阻碍</title>
    <link href="http://example.com/wiki/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/"/>
    <id>http://example.com/wiki/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</id>
    <published>2021-12-06T10:43:52.000Z</published>
    <updated>2021-12-06T10:45:28.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局锁和表锁：给表加个字段怎么这么多阻碍"><a href="#全局锁和表锁：给表加个字段怎么这么多阻碍" class="headerlink" title="全局锁和表锁：给表加个字段怎么这么多阻碍"></a>全局锁和表锁：给表加个字段怎么这么多阻碍</h1><p>今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资 源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介 绍。</p><p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock</code> (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞:数据更新语句(数据的增删改)、数据定义语句(包括 建表、修改表结构等)和更新类事务的提交语句。</p><p><strong><font color=blue>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。</font></strong></p><p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。 注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险:</p><ul><li><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆;</p></li><li><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p></li></ul><p>看来加全局锁不太好。但是细想一下，<font color=red>备份为什么要加锁呢? 我们来看一下不加锁会有什么问题。</font></p><p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p><p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉 他的余额，然后往已购课程里面加上一门课。</p><p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢?你可以看一下这个图:</p><p><img src="https://oscimg.oschina.net/oscnet/up-b686a902a661f2ba86e2820a32f1fd1b7c5.png"></p><p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了</p><p>一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。 作为用户可别觉得这样可真好啊，你可以试想一下:如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果?</p><p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致 的。</p><p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视 图的，对吧?</p><p>是的，就是在可重复读隔离级别下开启一个事务。</p><p>官方自带的逻辑备份工具是mysqldump。当<code>mysqldump</code>使用参数<code>–single-transaction</code>的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是 可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢?一致性读是好，但前提是引擎要支持这个隔离级别。比如，<font color=blue>对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是 只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</font></p><p>所以，<font color=blue>single-transaction方法只适用于所有的表使用事务引擎的库</font>。如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用 InnoDB替代MyISAM的原因之一。</p><p>你也许会问，既然要全库只读，为什么不使用 <code>set global readonly=true</code>的方式呢? 确实 readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因:</p><ul><li>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备 库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么 MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个 库长时间处于不可写状态，风险较高。</li></ul><p>业务的更新不只是增删改数据(DML)，还有可能是加字段等修改表结构的操作(DDL)。不论 是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍 的表级锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种:一种是表锁，一种是元数据锁(meta data lock，MDL)。</p><p>表锁的语法是 <code>lock tables ...read/write</code>。与FTWRL类似，可以用unlock tables主动释放锁， 也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写 外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读 写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操 作。连写t1都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持 行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h3 id="metadata-lock"><a href="#metadata-lock" class="headerlink" title="metadata lock"></a>metadata lock</h3><p>另一类表级的锁是<font color=blue>MDL(metadata lock)</font>。MDL不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个 表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果 跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL，**<font color=blue>当对一个表做增删改查操作的时候，加MDL读锁;当 要对表做结构变更操作的时候，加MDL写锁。</font>**</p><ul><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p></li><li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线 程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p></li></ul><p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。</p><p><strong>比如下面这个例子，我经常看到有人掉到这个坑里:给一个小表加个字段，导致整个库挂了。</strong></p><p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操 作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也 会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p><p>⚠️备注:这里的实验环境是MySQL 5.6。</p><p><img src="https://oscimg.oschina.net/oscnet/up-968696480927070a2a696f9d8f05bccda93.png"></p><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是 MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写 锁，因此只能被阻塞。</p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也 会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被 锁住，等于这个表现在完全不可读写了。</p><p><strong><font color=red>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session 再请求的话，这个库的线程很快就会爆满。</font></strong></p><p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释 放，而会等到整个事务提交后再释放。</p><hr><p>基于上面的分析，<font color=red>我们来讨论一个问题，如何安全地给小表加字段?</font></p><p><strong>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。</strong></p><p>在MySQL的information_schema 库的 innodb_trx表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务 在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频 繁，而你不得不加个字段，你该怎么做呢?</p><p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面 设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后 面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n 这个语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>备份一般都会在备库上执行，你在用–single-transaction方法做逻 辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从 备库上会看到什么现象呢?</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p><a href="https://blog.csdn.net/qq_26502245/article/details/111688120">https://blog.csdn.net/qq_26502245/article/details/111688120</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全局锁和表锁：给表加个字段怎么这么多阻碍&quot;&gt;&lt;a href=&quot;#全局锁和表锁：给表加个字段怎么这么多阻碍&quot; class=&quot;headerlink&quot; title=&quot;全局锁和表锁：给表加个字段怎么这么多阻碍&quot;&gt;&lt;/a&gt;全局锁和表锁：给表加个字段怎么这么多阻碍&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一条sql是如何执行的</title>
    <link href="http://example.com/wiki/%E4%B8%80%E6%9D%A1sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://example.com/wiki/%E4%B8%80%E6%9D%A1sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2021-12-06T10:35:29.000Z</published>
    <updated>2021-12-06T10:36:26.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条sql到底是怎么执行的？"><a href="#一条sql到底是怎么执行的？" class="headerlink" title="一条sql到底是怎么执行的？"></a>一条sql到底是怎么执行的？</h1><p>这个问题等同于： <strong>请将一下mysql的基础架构</strong></p><h2 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h2><p>我们经常说，看一个事儿千万不 要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程， 让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本 质，更为快速地定位并解决问题。</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功 能模块中的执行过程。</p><p><img src="https://oscimg.oschina.net/oscnet/up-661c52fa2ca85182e119823265a003d152b.png" alt="MySQL的逻辑架构图"></p><p>大体来说，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><p>Server层包括<strong>连接器</strong>、<strong>查询缓存</strong>、<strong>分析器</strong>、<strong>优化器</strong>、<strong>执行器</strong>等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了 默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不 过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用 <code>engine=memory</code>, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功 能也不同，在后面的文章中，我们会讨论到引擎的选择。</p><p>从图中不难看出，不同的存储引擎共用一个Server层 ，也就是从连接器到执行器的部分。你可 以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执 行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连 接、获取权限、维持和管理连接。连接命令一般是这么写的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行 中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器 就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序 结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面 的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。<strong>修改完成后，只有再新建的连接才会使用新的权限设置</strong>。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命 令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这 一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://oscimg.oschina.net/oscnet/up-2a647e124a6b81400ac56c8602d08803a29.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制 的，<strong>默认值是8小时。</strong></p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒: <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<font color=blue>所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</font></p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现 象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢?你可以考虑以下两种方案。</p><ul><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态。</p></li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步**:查询缓存。**</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过 的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是 查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客 户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存 中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结 果，这个效率会很高。</p><p><font color=blue>但是大多数情况下我会建议你不要使用查询缓存，为什么呢? 因为查询缓存往往弊大于利。</font></p><blockquote><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此 很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p></blockquote><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成 <code>DEMAND</code>，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定，像下面这个语句一样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><font color=red>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。</font></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，<font color=blue>MySQL需要知道你要做什么</font>，因此需要对SQL语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识 别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别 成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到<code>“You have an error in your SQL syntax”</code>的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4b5816275605cf38dcea5964ab23bfc1e16.png"></p><p><font color=red>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</font></p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是 否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否 等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些 疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，在后面的文章中单独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p><font color=blue>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶 段，开始执行语句。</font></p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用<strong>这个引擎</strong>提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的:</p><ul><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中;</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>至此，这个语句就执行完成了。 对于有索引的表，执行的逻辑也差不多。</p><p>第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。</p><p>这个值就是在执行器每次调用引擎获取数据行的时候累加的。<strong>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined并不是完全相同的</strong>。我们后面会专门有一篇文章来讲存储引擎的内部机制， 里面会有详细的说明。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那 肯定是会报“不存在这个列”的错误:     <code>“Unknown column ‘k’ in ‘where clause’”</code>。你觉得这个错误是 在我们上面提到的哪个阶段报出来的呢?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条sql到底是怎么执行的？&quot;&gt;&lt;a href=&quot;#一条sql到底是怎么执行的？&quot; class=&quot;headerlink&quot; title=&quot;一条sql到底是怎么执行的？&quot;&gt;&lt;/a&gt;一条sql到底是怎么执行的？&lt;/h1&gt;&lt;p&gt;这个问题等同于： &lt;strong&gt;请将一下m</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch使用规范</title>
    <link href="http://example.com/wiki/Elasticsearch%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/wiki/Elasticsearch%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</id>
    <published>2021-11-01T06:45:39.000Z</published>
    <updated>2021-11-01T06:46:32.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch使用规范"><a href="#Elasticsearch使用规范" class="headerlink" title="Elasticsearch使用规范"></a>Elasticsearch使用规范</h1><h2 id="查询规范建议"><a href="#查询规范建议" class="headerlink" title="查询规范建议"></a>查询规范建议</h2><ul><li><p><strong>定义好mappings和settings</strong>，不同的数据类型查询效率不一样，建议只需做精确查询以及范围查询的字段设置为keyword类型。对于要进行全文检索的字段设置合理的分词器。</p></li><li><p>对于只需要查询数据结果而不需要结果的相关度计算的情况，<strong>使用filter query能大幅提升你的查询效率</strong>。例如过滤某车牌和号码。</p></li><li><p><strong>避免一次性取出大量的数量</strong>：Elasticsearch被设计为一个搜索引擎，这使得它非常擅长获取与查询匹配的最优文档，但是不适合用来检索与特定查询匹配的所有文档。 Elasticsearch为了避免深分页，不允许使用分页（from&amp;size）查询10000条以后的数据，如果需要这样做，请确保使用Scroll API。 （Scroll API 后来不被推荐使用 可以使用search after）</p></li><li><p><strong>尽量细化查询条件</strong>，查询的条件越细，查询效率越高。</p></li><li><p><strong>选择合适的查询类型</strong>，比如term查询效率相对会高一些。</p></li><li><p><strong>优化路由</strong></p><p>  Elasticsearch写入文档时，文档会通过一个公式路由到一个索引中的一个分片上。默认公式如下：<br>  <code>shard_num = hash(_routing) % num_primary_shards</code><br>  _routing字段的取值，默认是_id字段，可以根据业务场景设置经常查询的字段作为路由字段。例如可以考虑将用户id、地区作为路由字段，查询时可以过滤不必要的分片，加快查询速度。</p></li><li><p>避免使用wildcard模糊匹配查询<br>  Elasticsearch默认支持通过*？正则表达式来做模糊匹配，数据量级别达到TB+甚至更高之后，模糊匹配查询通常会耗时比较长，甚至可能导致内存溢出，卡死乃至崩溃宕机的情况。所以数据量大的情况下，不要使用模糊匹配查询。</p></li><li><p>合理的配置使用index属性，analyzed和not_analyzed，根据业务需求来控制字段是否分词或不分词。只有groupby需求的字段，配置时就设置成not_analyzed,以提高查询或聚类的效率。</p></li><li><p>query_string或multi_match的查询字段越多，查询越慢。<br>  可以在mapping阶段，利用copy_to属性将多字段的值索引到一个新字段，multi_match时，用新的字段查询。</p></li><li><p><strong>日期字段的查询</strong><br>  尤其是用now的查询实际上是不存在缓存的，因此， 可以从业务的角度来考虑是否一定要用now,毕竟利用query cache是能够大大提高查询效率的。</p></li><li><p><strong>查询结果集的大小不能随意设置成大得离谱的值</strong><br>  如query.setSize不能设置成Integer.MAX_VALUE，<font color=red>因为ES内部需要建立一个数据结构来放指定大小的结果集数据。</font></p></li><li><p><strong>尽量避免使用script，万不得已需要使用的话，选择painless &amp; experssions引擎。</strong><br>  <font color=blue>一旦使用script查询，一定要注意控制返回，千万不要有死循环，因为ES没有脚本运行的超时控制，只要当前的脚本没执行完，该查询会一直阻塞。</font></p></li></ul><h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><ul><li><p><strong>分片(shard)容量</strong></p><ul><li>非日志型(搜索型、线上业务型)的shard容量在10~30GB（建议在10G）</li><li>日志型的shard容量在30~100GB（建议30G）</li><li>单个shard的文档个数不能超过21亿左右(Integer.MAX_VALUE - 128)<br>注：一个shard就是一个lucene分片，ES底层基于lucene实现。主分片个数一旦确定，就不可以更改。副本分片个数可以根据需要随时修改。</li></ul></li><li><p><strong>索引(index)数量</strong><br>大索引需要拆分：增强性能，风险分散。<br>反例：一个10T的索引，例如按date查询、name查询<br>正例：index_name拆成多个index_name_${date}<br>正例：index_name按hash拆分index_name_{1,2,3,…100..}<br>提示：索引和shard数并不是越多越好，对于批量读写都会有性能下降，所以要综合考虑性能和容量规划，同时配合压力测试，不存在真正的最优解。</p></li><li><p><strong>节点、分片、索引</strong><br>一个节点管理的shard数不要超过200个</p></li></ul><h2 id="配置使用规范"><a href="#配置使用规范" class="headerlink" title="配置使用规范"></a>配置使用规范</h2><ul><li><p><strong>shard个数（number_of_shards）</strong><br>  primery shard ：默认数量是1<br>  replica shard数量为1： 是每个primary shard 有多少个副本分片的意思<br>  primery shard = 1 ; replica shard = 2 ; 意味着一个索引，一共存在9个shard</p></li><li><p><strong>refresh频率（refresh_interval）</strong><br>  ES的定位是准实时搜索引擎，该值默认是1s，表示写入后1秒后可被搜索到，所以这里的值取决于业务对实时性的要求，注意这里并不是越小越好，刷新频率高也意味着对ES的开销也大，通常业务类型在1-5s，日志型在30s-120s，如果集中导入数据可将其设置为-1，ES会自动完成数据刷新（注意完成后更改回来，否则后续会出现搜索不到数据）</p></li><li><p><strong>使用别名（aliases）</strong>：不要过度依赖别名功能</p></li><li><p><strong>慢日志（slowlog）</strong></p></li><li><p><strong>设置合理的routing key(默认是id)</strong><br>  id不均衡：集群容量和访问不均衡，对于分布式存储是致命的</p></li><li><p><strong>关闭_all</strong><br>  ES6.0已经去掉，对容量（索引过大）和性能（性能下降）都有影响。    </p></li><li><p><strong>避免大宽表</strong><br>  ES默认最大1000，但建议不要超过100.    </p></li><li><p><strong>text类型的字段不要使用聚合查询。</strong><br>  <font color=red>text类型fileddata会加大对内存的占用，如果有需求使用，建议使用keyword</font></p></li><li><p><strong>聚合查询避免使用过多嵌套</strong><br>  <font color=red>聚合查询的中间结果和最终结果都会在内存中进行，嵌套过多，会导致内存耗尽</font></p></li><li><p><strong>修改index_buffer_size的设置</strong><br>  可以设置成百分数，也可设置成具体的大小，大小可根据集群的规模做不同的设置测试。<br>　　<code>indices.memory.index_buffer_size：10%（默认）</code><br>　　<code>indices.memory.min_index_buffer_size： 48mb（默认）</code><br>　　<code>indices.memory.max_index_buffer_size</code></p></li><li><p><strong>修改translog相关的设置</strong></p><ul><li>控制数据从内存到硬盘的操作频率，以减少硬盘IO。可将sync_interval的时间设置大一些。<br>　　      <code>index.translog.sync_interval：5s(默认)</code></li><li>控制tranlog数据块的大小，达到threshold大小时，才会flush到lucene索引文件。<br>  <code>index.translog.flush_threshold_size：512mb(默认)    </code></li></ul></li><li><p><strong>_id字段的使用</strong><br>  应尽可能避免自定义_id,以避免针对ID的版本管理；建议使用ES的默认ID生成策略或使用数字类型ID做为主键    </p></li><li><p><strong>Cache的设置及使用</strong></p><ul><li>QueryCache: ES查询的时候，使用filter查询会使用query cache,如果业务场景中的过滤查询比较多，建议将querycache设置大一些，以提高查询速度。<br><code>indices.queries.cache.size： 10%（默认）</code>，可设置成百分比，也可设置成具体值，如256mb。</li></ul><p>  当然也可以禁用查询缓存（默认是开启）, 通过<code>index.queries.cache.enabled：false</code>设置。</p><ul><li>FieldDataCache:在聚类或排序时，<code>field data cache</code>会使用频繁，因此，<strong>设置字段数据缓存的大小，在聚类或排序场景较多的情形下很有必要</strong><br>  可通过<code>indices.fielddata.cache.size：30%</code>或<code>具体值10GB</code>来设置。<strong>但是如果场景或数据变更比较频繁，设置cache并不是好的做法，因为缓存加载的开销也是特别大的。</strong></li><li><strong>ShardRequestCache</strong><br>查询请求发起后，每个分片会将结果返回给协调节点(Coordinating Node),由协调节点将结果整合。<br>如果有需求，可以设置开启;通过设置<strong>index.requests.cache.enable: true</strong>来开启。<br>不过，<code>shard request cache</code>只缓存<code>hits.total</code>, <code>aggregations</code>, <code>suggestions</code>类型的数据，并不会缓存hits的内容。也可以通过设置<code>indices.requests.cache.size: 1%（默认）</code>来控制缓存空间大小。    </li></ul></li></ul><h2 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h2><ul><li><p>text和keyword的用途必须分清：分词和关键词（确定字段是否需要分词）</p></li><li><p>确定字段是否需要独立存储</p></li><li><p>字段类型不支持修改，必须谨慎。</p></li><li><p>对不需要进行聚合/排序的字段禁用doc_values</p></li><li><p>不要在text做模糊搜索：</p></li></ul><h2 id="违规操作"><a href="#违规操作" class="headerlink" title="违规操作"></a>违规操作</h2><ul><li>原则：不要忽略设计，快就是慢，坏的索引设计后患无穷.</li><li>拒绝大聚合 ：ES计算都在JVM内存中完成。</li><li>拒绝模糊查询：es一大杀手</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;wildcard&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;title.keyword&quot;</span>:<span class="string">&quot;*张三*&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>拒绝深度分页<br>  ES获取数据时，每次默认最多获取10000条，获取更多需要分页，但存在深度分页问题，<font color=red>一定不要使用from/Size方式，建议使用scroll或者searchAfter方式。</font> scroll会把上一次查询结果缓存一定时间（通过配置scroll=1m实现)，所以在使用scroll时一定要保证search结果集不要太大。</p></li><li><p>基数查询<br>尽量不要用基数查询去查询去重后的数据量大小（kibana中界面上显示是Unique Count，Distinct Count等），即少用如下的查询：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;cardinality&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;userId&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>禁止查询 indexName-*</li><li>避免使用script、update_by_query、delete_by_query，对线上性能影响较大。</li></ul><h2 id="建议操作"><a href="#建议操作" class="headerlink" title="建议操作"></a>建议操作</h2><ul><li><strong>复用预索引数据方式来提高AGG性能</strong><br>  如通过terms aggregations替代range aggregations， 如要根据年龄来分组，分组目标是:少年（14岁以下） 青年（14-28） 中年（29-50） 老年（51以上）， <font color=red>可以在索引的时候设置一个age_group字段，预先将数据进行分类</font>。从而不用按age来做range aggregations,通过age_group字段就可以了。</li><li><strong>避免将不相关的数据放在同一个索引中，以避免稀疏，将这些文件放在不同的索引中往往更好。</strong></li></ul><h2 id="索引及字段命名规范"><a href="#索引及字段命名规范" class="headerlink" title="索引及字段命名规范"></a>索引及字段命名规范</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引受文件系统的限制。仅可能为小写字母，不能下划线开头。同时需遵守下列规则：</p><ul><li>不能包括 , /, *, ?, “, &lt;, &gt;, |, 空格, 逗号, #</li><li>7.0版本之前可以使用冒号:,但不建议使用并在7.0版本之后不再支持</li><li>不能以这些字符 -, _, + 开头</li><li>不能包括 . 或 …</li><li>长度不能超过 255 个字符</li></ul><p>以上这些命名限制是因为当Elasticsearch使用索引名称作为磁盘上的目录名称，这些名称必须符合不同操作系统的约定。<br>未来可能会放开这些限制，因为我们使用uuid关联索引放在磁盘上，而不使用索引名称</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><font color=red>7.0版本之后不再支持类型，默认为_doc</font></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>一个索引的shard数一旦确定不能改变</li><li>ES不支持事务ACID特性。</li><li>reindex：reindex可以实现索引的shard变更，但代价非常大：速度慢、对性能有影响，所以好的设计和规划更重要</li><li>field一旦创建不能更改mapping，如果需要修改，则必须重新创建索引</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.javajcw.com/72.html">Elasticsearch 使用规范</a></li><li><a href="https://blog.csdn.net/neweastsun/article/details/95868716">Elasticsearch索引及字段命名规范</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Elasticsearch使用规范&quot;&gt;&lt;a href=&quot;#Elasticsearch使用规范&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch使用规范&quot;&gt;&lt;/a&gt;Elasticsearch使用规范&lt;/h1&gt;&lt;h2 id=&quot;查询规范建</summary>
      
    
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及算法-树</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95-%E6%A0%91/</id>
    <published>2021-09-30T08:36:56.000Z</published>
    <updated>2021-09-30T08:36:56.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/draft/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/wiki/draft/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-09-27T14:11:31.478Z</published>
    <updated>2021-09-27T14:36:06.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式架构基石-远程通信协议"><a href="#分布式架构基石-远程通信协议" class="headerlink" title="分布式架构基石-远程通信协议"></a>分布式架构基石-远程通信协议</h1><h2 id="1、什么是通信"><a href="#1、什么是通信" class="headerlink" title="1、什么是通信"></a>1、什么是通信</h2><p>常见的通信有两种：</p><p>1、客户端与服务端之间的通信，通过http协议进行通信，或者服务器与服务器之间也会进行通信。</p><p>2、微服务架构中，节点之间的通信，通过RPC，实现类似于单体架构中的service方法的调用。</p><h2 id="2、Java中是如何进行通信呢"><a href="#2、Java中是如何进行通信呢" class="headerlink" title="2、Java中是如何进行通信呢"></a>2、Java中是如何进行通信呢</h2><p>通过socket套接字实现</p><blockquote><p>换行符 坑 导致提示Connection Reset (readline)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式架构基石-远程通信协议&quot;&gt;&lt;a href=&quot;#分布式架构基石-远程通信协议&quot; class=&quot;headerlink&quot; title=&quot;分布式架构基石-远程通信协议&quot;&gt;&lt;/a&gt;分布式架构基石-远程通信协议&lt;/h1&gt;&lt;h2 id=&quot;1、什么是通信&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="draft" scheme="http://example.com/categories/draft/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找（迭代&amp;递归）</title>
    <link href="http://example.com/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92%EF%BC%89/"/>
    <id>http://example.com/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92%EF%BC%89/</id>
    <published>2021-09-27T09:00:45.000Z</published>
    <updated>2021-09-27T09:59:51.333Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><p>输入: <code>nums = [-1,0,3,5,9,12], target = 9</code><br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><p>输入: <code>nums = [-1,0,3,5,9,12], target = 2</code><br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><p>提示：</p><blockquote><p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210927170614830.png" alt="image-20210927170614830"></p><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注意边界</span></span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">0</span>, nums.length - <span class="number">1</span>, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">          <span class="comment">// 注意mid取值的写法，避免越界异常</span></span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> find(left, mid - <span class="number">1</span>, target, nums);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> find(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查找第一个错误版本"><a href="#2-查找第一个错误版本" class="headerlink" title="2. 查找第一个错误版本"></a>2. 查找第一个错误版本</h2><p><a href="https://leetcode-cn.com/problems/first-bad-version/">leetcode278</a></p><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, bad = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">调用 isBadVersion(3) -&gt; false </span><br><span class="line">调用 isBadVersion(5) -&gt; true </span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure><h3 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-搜索插入位置"><a href="#3-搜索插入位置" class="headerlink" title="3. 搜索插入位置"></a>3. <a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></h2><p>Leetcode 35</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><h3 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot;&gt;https://leetcode-cn.com/problems/binary-search/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-二分查找&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    <category term="二分" scheme="http://example.com/categories/Leetcode/%E4%BA%8C%E5%88%86/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="二分" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>面试官真的问我「分布式事务」了</title>
    <link href="http://example.com/wiki/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9C%9F%E7%9A%84%E9%97%AE%E6%88%91%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%8D%E4%BA%86/"/>
    <id>http://example.com/wiki/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9C%9F%E7%9A%84%E9%97%AE%E6%88%91%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%8D%E4%BA%86/</id>
    <published>2021-09-18T09:07:46.000Z</published>
    <updated>2021-09-27T08:16:38.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。</p><p>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。<br>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。<br>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</p><p>熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。<br>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。<br>顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展</p><p>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。<br>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。<br>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。</p><p>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1FJ411A7mV?from=search&seid=11114763225649816490&spm_id_from=333.337.0.0">bilibili 分布式事务详解</a></li><li><a href="http://blog.itpub.net/69946034/viewspace-2671341/">微服务分布式事务4种解决方案实战</a></li><li><a href="https://juejin.cn/post/6844903647197806605">再有人问你分布式事务，把这篇扔给他</a></li><li><a href="https://juejin.cn/post/6844903573667446797#heading-5">https://juejin.cn/post/6844903573667446797#heading-5</a>  </li><li><a href="https://juejin.cn/post/7012425995634343966?utm_source=gold_browser_extension">https://juejin.cn/post/7012425995634343966?utm_source=gold_browser_extension</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h2&gt;&lt;p&gt;CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。&lt;</summary>
      
    
    
    
    <category term="分布式事务" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-高性能IO模型</title>
    <link href="http://example.com/wiki/Redis-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/wiki/Redis-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-16T03:54:08.000Z</published>
    <updated>2021-09-16T07:53:17.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/liang24/p/14178730.html">Redis基础篇（二）高性能IO模型</a></li><li><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></li><li><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/liang24/p/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基础算法分类和思想</title>
    <link href="http://example.com/wiki/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%9D%E6%83%B3/"/>
    <id>http://example.com/wiki/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%9D%E6%83%B3/</id>
    <published>2021-09-15T11:44:40.000Z</published>
    <updated>2021-09-16T02:46:09.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的算法解题思路以及模版"><a href="#常见的算法解题思路以及模版" class="headerlink" title="常见的算法解题思路以及模版"></a>常见的算法解题思路以及模版</h1><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>可以参照下面👇文章：<br><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a>  </p><p><strong>练习题库</strong><br>都是回溯算法的题目：👇<br><a href="https://leetcode-cn.com/tag/backtracking/problemset/">https://leetcode-cn.com/tag/backtracking/problemset/</a>  </p><h2 id="整理的比较不错的资源"><a href="#整理的比较不错的资源" class="headerlink" title="整理的比较不错的资源"></a><font color=blue>整理的比较不错的资源</font></h2><p><a href="https://labuladong.gitbook.io/algo/mu-lu-ye/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa">📖labuladong 的算法小抄</a>  </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/20210915202940.png" alt="20210915202940">  </p><p>整体来说还是相当不错的！  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见的算法解题思路以及模版&quot;&gt;&lt;a href=&quot;#常见的算法解题思路以及模版&quot; class=&quot;headerlink&quot; title=&quot;常见的算法解题思路以及模版&quot;&gt;&lt;/a&gt;常见的算法解题思路以及模版&lt;/h1&gt;&lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>理解ClassNotFoundException与NoClassDefFoundError的区别</title>
    <link href="http://example.com/wiki/%E7%90%86%E8%A7%A3ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/wiki/%E7%90%86%E8%A7%A3ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-09-15T07:43:20.000Z</published>
    <updated>2021-09-18T06:40:55.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h2><p>类加载时在指定路径下没有找到类文件</p><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>1、编译时存在某个类，但是运行时却找不到</p><blockquote><p>编译完成之后，手动删除一个类的class文件</p></blockquote><p>2、类根本就没有初始化成功，结果你还把它当做正常类使用，所以这事也不小，必须抛出ERROR告诉你不能再使用了</p><p><a href="https://cloud.tencent.com/developer/article/1356060">https://cloud.tencent.com/developer/article/1356060</a></p><p><a href="https://blog.csdn.net/u012129558/article/details/81540804">https://blog.csdn.net/u012129558/article/details/81540804</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ClassNotFoundException&quot;&gt;&lt;a href=&quot;#ClassNotFoundException&quot; class=&quot;headerlink&quot; title=&quot;ClassNotFoundException&quot;&gt;&lt;/a&gt;ClassNotFoundExcepti</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://example.com/wiki/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/wiki/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-09-15T03:21:41.000Z</published>
    <updated>2021-09-15T05:20:16.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis实现分布式锁的种种细节"><a href="#Redis实现分布式锁的种种细节" class="headerlink" title="Redis实现分布式锁的种种细节"></a>Redis实现分布式锁的种种细节</h1><p><strong>1、redis分布式锁直接使用 <code>setNx</code> 获取锁🔒，<code>del key</code> 释放锁</strong></p><p>会造成 「 <font color=blue><strong>死锁</strong></font> 」的问题，获取锁的线程没有释放锁，进程死掉了，其他进程永远无法获取锁</p><p><strong>2、给锁对应的key添加过期时间不就可以解决死锁的问题了吗？</strong></p><p><code>127.0.0.1:6379&gt; SETNX lock 1    // 加锁(integer) </code></p><p><code>127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期(integer) </code></p><p><font color=blue> <strong>上面两个命令有什么问题吗</strong>？</font></p><p>不是原子操作，可能 <code>expire</code>没有执行！使用如下复合命令 👇</p><p><code>127.0.0.1:6379&gt; SET lock 1 EX 10 NX</code></p><p><strong>3、这样还会存在一个问题，进程2释放的是进程1的锁</strong></p><p>进程1操作时间太久，还没有主动释放锁，锁就过期了，然后进程2获取锁，然后执行，进程2还没有执行完成，进程1执行完了，释放</p><p>锁，但是释放的是进程2的锁。「 <font color=blue><strong>释放他人锁</strong></font>」和 「 <font color=blue><strong>锁过期时间问题</strong></font>」</p><ol><li>加锁：<code>SET lock_key $unique_id EX $expire_time NX</code></li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 判断锁是自己的，才释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>4、锁过期时间不好评估怎么办？</strong></p><p><font color=blue><strong>假设一个方案：</strong></font></p><p><strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<font color=blue><strong>Redisson</strong></font>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><strong><font color=red>以上都是基于单机redis的角度思考的redis分布式锁的问题，主要有三点 👇</font></strong></p><p>1、死锁问题 （加过期时间解决）</p><p>2、释放他人锁 （添加线程标志）</p><p>3、锁过期时间问题 （守护线程自动续期）</p><p><strong><font color=red>如果是redis集群模式下会有哪些问题呢 👇</font></strong></p><p>在redis主从模式下，如果master节点突然宕机了，锁还没有同步到从节点是，是不是分布式锁就丢了？？？</p><p>Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。如何解决这个问题呢 ？ 「 **<font color=blue>RedLock</font>**」</p><p><strong>Redlock 的方案基于 2 个前提：</strong></p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/ybiN5Q89wI0CnLURGUz4vw">深度剖析：Redis 分布式锁到底安全吗？看完这篇文章彻底懂了！</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis实现分布式锁的种种细节&quot;&gt;&lt;a href=&quot;#Redis实现分布式锁的种种细节&quot; class=&quot;headerlink&quot; title=&quot;Redis实现分布式锁的种种细节&quot;&gt;&lt;/a&gt;Redis实现分布式锁的种种细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、redi</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap实现简易LRU</title>
    <link href="http://example.com/wiki/LinkedHashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93LRU/"/>
    <id>http://example.com/wiki/LinkedHashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93LRU/</id>
    <published>2021-09-15T02:07:58.000Z</published>
    <updated>2021-09-15T02:09:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目 #"></a>题目 <a href="https://hadyang.com/interview/docs/leetcode/LRUCache/#%E9%A2%98%E7%9B%AE">#</a></h2><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity , <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Integer integer = <span class="keyword">super</span>.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> integer == <span class="keyword">null</span> ? -<span class="number">1</span> : integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="keyword">this</span>.capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LruCache cache = <span class="keyword">new</span> LruCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get3 -&gt; &quot;</span> + cache.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get3 -&gt; &quot;</span> + cache.get(<span class="number">3</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get4 -&gt; &quot;</span> + cache.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目 #&quot;&gt;&lt;/a&gt;题目 &lt;a href=&quot;https://hadyang.com/interview/docs/leetcode/LRUCache/#%E9%A2%98%E7</summary>
      
    
    
    
    
    <category term="LRU" scheme="http://example.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Redis操作为什么是原子性的？</title>
    <link href="http://example.com/wiki/Redis%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/wiki/Redis%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F/</id>
    <published>2021-09-14T02:46:36.000Z</published>
    <updated>2021-09-14T03:19:40.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis原则性操作"><a href="#Redis原则性操作" class="headerlink" title="Redis原则性操作"></a>Redis原则性操作</h2><p>对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么</p><p>执行失败，这就是Redis的命令是原子性的原因。</p><blockquote><p>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</p></blockquote><h2 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><p>Discard:Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如何开启一个事务</span><br><span class="line">watch key1 key2 . . . （监听相关key）</span><br><span class="line">multi (开启事务)</span><br><span class="line">// 对监听key的一些操作</span><br><span class="line">exec（执行事务）</span><br><span class="line">discard（取消事务）</span><br></pre></td></tr></table></figure><p><strong>EXEC</strong> 命令负责触发并执行事务中的所有命令：如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</p><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</p><h3 id="如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？"><a href="#如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？" class="headerlink" title="如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？"></a><font color=blue><strong>如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？</strong></font></h3><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用 <code>redis-check-aof</code> 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h3 id="如果是集群下，watch命令有没有什么局限性？"><a href="#如果是集群下，watch命令有没有什么局限性？" class="headerlink" title="如果是集群下，watch命令有没有什么局限性？"></a><font color=blue>如果是集群下，watch命令有没有什么局限性？</font></h3><p>有没有想过为什么监听多个落在不同节点上的<code>key</code>，不同槽位的也不可以，会不被允许？在单节点下，<code>Redis</code>单线程执行，能够保证原子性，但在不同节点下，就是多进程多线程的问题，<code>Watch</code>自然就不能用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/lori/p/9300087.html">知其所以然~redis的原子性</a></li><li><a href="https://juejin.cn/post/6844904098987245576">Redis实现原子操作的两种方式与商品入库出库解决方案</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis原则性操作&quot;&gt;&lt;a href=&quot;#Redis原则性操作&quot; class=&quot;headerlink&quot; title=&quot;Redis原则性操作&quot;&gt;&lt;/a&gt;Redis原则性操作&lt;/h2&gt;&lt;p&gt;对Redis来说，执行get、set以及eval等API，都是一个一个的任务</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
