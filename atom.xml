<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-25T04:10:01.516Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-Key过期监听器</title>
    <link href="http://example.com/wiki/Redis-Key%E8%BF%87%E6%9C%9F%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://example.com/wiki/Redis-Key%E8%BF%87%E6%9C%9F%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2021-08-25T03:40:30.000Z</published>
    <updated>2021-08-25T04:10:01.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一个需求，我在某平台发布了一片文章，需要判断这片文章在发布之后，10min，30min，1h，3h，1d，3d时间点的点赞数量和关注数量，但是呢，平台没有提供信息统计的功能，那么只能我定期去查看。</p><p>那么如何实现这个功能或者需求呢？</p><p>当时首先想到的是定时任务轮训，这种方式其实比较简单，就是搂数据库，判断时间就完事了，同时记录这片文章定时任务执行了多少次，超过一定次数之后，设置标志位，那么下次就不需要筛选这些文章了。</p><p>但是这种方式的缺点很明显，首先定时任务执行的频率改如何设置呢，应该是最小时间10min。也就是每10min搂一次库，查出来的数据，再去执行业务逻辑。当数据量很大的时候，这个定时任务就会显得比较重了。</p><p>于是我想到了基于事件触发的方式去解决这个问题，比如延时队列，redis过期策略啊等等，应该有很多。</p><p>这里说到延时队列，为什么我没有用JDK自带的DelayQueue呢，毕竟这些数据都是放在内存中，还是解决不了内存的问题。</p><p>还有通过redis的sort set数据结果来做的方式，score存的是时间戳，这种方式其实要比直接搂数据库要好的多。</p><p>最后我选择使用redis过期监听策略来实现这个需求，各位大佬们有什么别的方案呢？</p><h2 id="redis过期监听"><a href="#redis过期监听" class="headerlink" title="redis过期监听"></a>redis过期监听</h2><h3 id="首先设置一下redis的通知事件"><a href="#首先设置一下redis的通知事件" class="headerlink" title="首先设置一下redis的通知事件"></a>首先设置一下redis的通知事件</h3><p>需要设置redis配置文件 <code>notify-keyspace-events Ex</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For instance <span class="keyword">if</span> keyspace events notification is enabled, and a client</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> performs a DEL operation on key <span class="string">&quot;foo&quot;</span> stored <span class="keyword">in</span> the Database 0, two</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  $     String commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l     List commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s     Set commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  h     Hash commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  z     Sorted <span class="built_in">set</span> commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  e     Evicted events (events generated when a key is evicted <span class="keyword">for</span> maxmemory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  t     Stream commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d     Module key <span class="built_in">type</span> events</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  m     Key-miss events (Note: It is not included <span class="keyword">in</span> the <span class="string">&#x27;A&#x27;</span> class)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  A     Alias <span class="keyword">for</span> g<span class="variable">$lshzxetd</span>, so that the <span class="string">&quot;AKE&quot;</span> string means all the events</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        (Except key-miss events <span class="built_in">which</span> are excluded from <span class="string">&#x27;A&#x27;</span> due to their</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         unique nature).</span></span><br></pre></td></tr></table></figure><p>或者使用命令 <code>CONFIG set notify-keyspace-events Ex</code></p><h3 id="Springboot-集成redis"><a href="#Springboot-集成redis" class="headerlink" title="Springboot 集成redis"></a>Springboot 集成redis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">RedisTemplate&lt;String, T&gt; <span class="title">getRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, T&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> GenericFastJsonRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate stringRedisTemplate = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        stringRedisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisScript&lt;Boolean&gt; <span class="title">hitMaxScript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Boolean&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;scripts/hitmax.lua&quot;</span>)));</span><br><span class="line">        redisScript.setResultType(Boolean.class);</span><br><span class="line">        <span class="keyword">return</span> redisScript;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        container.setTaskExecutor(executor());</span><br><span class="line">        Topic topic = <span class="keyword">new</span> PatternTopic(RedisKeyExpirationListener.LISTENER_PATTERN);</span><br><span class="line">        container.addMessageListener(<span class="keyword">new</span> RedisKeyExpirationListener(), topic);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;V-Thread&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义监听器重写onMessage方法"><a href="#自定义监听器重写onMessage方法" class="headerlink" title="自定义监听器重写onMessage方法"></a>自定义监听器重写onMessage方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LISTENER_PATTERN = <span class="string">&quot;__key*@*__:*&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;触发监听器。。。。。。&quot;</span>);</span><br><span class="line">        String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        String channel = <span class="keyword">new</span> String(message.getChannel());</span><br><span class="line">        System.out.println(<span class="string">&quot;onMessage &gt;&gt; &quot;</span>+String.format(<span class="string">&quot;channel: %s, body: %s, bytes: %s&quot;</span>,channel,body,<span class="keyword">new</span> String(pattern)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825120806260.png" alt="image-20210825120806260"></p><p><strong>项目控制台：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210825120841859.png" alt="image-20210825120841859"></p><p>⚠️ 监听key过期时间是不能获取key的value的，因为这个时间是key过期才触发的，所以我们把关键信息放到key上就行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有一个需求，我在某平台发布了一片文章，需要判断这片文章在发布之后，10min，30min，1h，3h，1d，3d时间点的点赞数量和关注数量，</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Web开发基础-Servlet</title>
    <link href="http://example.com/wiki/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-Servlet/"/>
    <id>http://example.com/wiki/Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-Servlet/</id>
    <published>2021-08-24T08:00:44.000Z</published>
    <updated>2021-08-24T10:00:32.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是servlet"><a href="#1、什么是servlet" class="headerlink" title="1、什么是servlet"></a>1、什么是servlet</h2><p><strong>什么是Serlvet？</strong></p><p>Servlet其实就是一个<strong>遵循Servlet开发的java类</strong>。Serlvet是<strong>由服务器调用的</strong>，<strong>运行在服务器端</strong>。</p><p>我们编写java程序想要在网上实现 聊天、发帖、这样一些的交互功能，<strong>普通的java技术是非常难完成的</strong>。sun公司就提供了Serlvet这种技术供我们使用。</p><h2 id="2、servlet生命周期"><a href="#2、servlet生命周期" class="headerlink" title="2、servlet生命周期"></a>2、servlet生命周期</h2><p><strong>Servlet生命周期可分为5个步骤</strong></p><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。 destroy()只有在Tomcat关闭的时候才会被调用。</strong></li></ul><h2 id="3、servlet调用流程"><a href="#3、servlet调用流程" class="headerlink" title="3、servlet调用流程"></a>3、servlet调用流程</h2><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210824161820602.png" alt="image-20210824161820602"></p><h2 id="4、Servlet是单例的"><a href="#4、Servlet是单例的" class="headerlink" title="4、Servlet是单例的"></a>4、Servlet是单例的</h2><h3 id="4-1-为什么Servlet是单例的"><a href="#4-1-为什么Servlet是单例的" class="headerlink" title="4.1 为什么Servlet是单例的"></a>4.1 为什么Servlet是单例的</h3><p><strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会<strong>驻留在内存中，为后续的请求做服务，直到服务器关闭</strong>。</p><h3 id="4-2-每次访问请求对象和响应对象都是新的"><a href="#4-2-每次访问请求对象和响应对象都是新的" class="headerlink" title="4.2 每次访问请求对象和响应对象都是新的"></a>4.2 每次访问请求对象和响应对象都是新的</h3><p>对于<strong>每次访问请求</strong>，Servlet引擎都会<strong>创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两<strong>个对象作为参数传递给它调用的Servlet的service()方法</strong>，<strong>service方法再根据请求方式分别调用doXXX方法</strong>。</p><h3 id="4-3-线程安全问题"><a href="#4-3-线程安全问题" class="headerlink" title="4.3 线程安全问题"></a>4.3 线程安全问题</h3><p>当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p><p>原则：</p><ol><li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li><li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</li></ol><h2 id="5、ServletConfig对象"><a href="#5、ServletConfig对象" class="headerlink" title="5、ServletConfig对象"></a>5、ServletConfig对象</h2><h3 id="5-1-ServletConfig对象有什么用？"><a href="#5-1-ServletConfig对象有什么用？" class="headerlink" title="5.1 ServletConfig对象有什么用？"></a>5.1 ServletConfig对象有什么用？</h3><blockquote><p>通过此对象可以读取web.xml中配置的初始化参数。</p></blockquote><p>现在问题来了，<strong>为什么我们要把参数信息放到web.xml文件中呢</strong>？我们可以直接在程序中都可以定义参数信息，<strong>搞到web.xml文件中又有什么好处呢</strong>？</p><p>好处就是：<strong>能够让你的程序更加灵活</strong>【更换需求，更改配置文件web.xml即可，程序代码不用改】</p><h3 id="5-2-获取web-xml文件配置的参数信息"><a href="#5-2-获取web-xml文件配置的参数信息" class="headerlink" title="5.2 获取web.xml文件配置的参数信息"></a>5.2 获取web.xml文件配置的参数信息</h3><p>为Demo1这个Servlet配置一个参数，参数名是name，值是zhongfucheng</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>zhongfucheng.web.Demo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>zhongfucheng<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Servlet中获取ServletConfig对象，通过ServletConfig对象获取在web.xml文件配置的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletConfig config = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">String name = config.getInitParameter(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="6、ServletContext对象"><a href="#6、ServletContext对象" class="headerlink" title="6、ServletContext对象"></a>6、ServletContext对象</h2><h3 id="6-1-什么是ServletContext对象？"><a href="#6-1-什么是ServletContext对象？" class="headerlink" title="6.1 什么是ServletContext对象？"></a>6.1 什么是ServletContext对象？</h3><p>当Tomcat启动的时候，就会创建一个ServletContext对象。它<strong>代表着当前web站点</strong></p><h3 id="6-2-ServletContext有什么用？"><a href="#6-2-ServletContext有什么用？" class="headerlink" title="6.2 ServletContext有什么用？"></a>6.2 ServletContext有什么用？</h3><ol><li>ServletContext既然代表着当前web站点，那么<strong>所有Servlet都共享着一个ServletContext对象</strong>，所以<strong>Servlet之间可以通过ServletContext实现通讯</strong>。</li><li>ServletConfig获取的是配置的是单个Servlet的参数信息，<strong>ServletContext可以获取的是配置整个web站点的参数信息</strong></li><li><strong>利用ServletContext读取web站点的资源文件</strong></li><li>实现Servlet的转发【用ServletContext转发不多，主要用request转发】</li></ol><h2 id="7、什么是会话技术"><a href="#7、什么是会话技术" class="headerlink" title="7、什么是会话技术"></a>7、什么是会话技术</h2><blockquote><p>基本概念: 指用户开一个浏览器，<strong>访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话</strong>.</p></blockquote><h3 id="7-1-什么是Cookie"><a href="#7-1-什么是Cookie" class="headerlink" title="7.1 什么是Cookie"></a>7.1 什么是Cookie</h3><blockquote><p>Cookie是由W3C组织提出，最早由netscape社区发展的一种机制</p></blockquote><ul><li>网页之间的<strong>交互是通过HTTP协议传输数据的，</strong>而Http协议是<strong>无状态的协议</strong>。无状态的协议是什么意思呢？<strong>一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接</strong>。</li><li>服务器无法确认用户的信息，于是乎，W3C就提出了：<strong>给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息</strong>。通行证就是Cookie</li></ul><h4 id="7-11-Cookie的流程"><a href="#7-11-Cookie的流程" class="headerlink" title="7.11 Cookie的流程"></a>7.11 Cookie的流程</h4><p>浏览器访问服务器，<strong>如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器</strong>。</p><h4 id="7-1-2-Cookie-API"><a href="#7-1-2-Cookie-API" class="headerlink" title="7.1.2 Cookie API"></a>7.1.2 Cookie API</h4><ul><li>Cookie类用于创建一个Cookie对象</li><li>response接口中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段</li><li>request接口中定义了一个getCookies方法，它用于获取客户端提交的Cookie</li></ul><p><strong>常用的Cookie方法：</strong></p><ul><li>public Cookie(String name,String value)</li><li>setValue与getValue方法</li><li>setMaxAge与getMaxAge方法</li><li>setPath与getPath方法</li><li>setDomain与getDomain方法</li><li>getName方法</li></ul><h4 id="7-1-3-cookie使用方式"><a href="#7-1-3-cookie使用方式" class="headerlink" title="7.1.3 cookie使用方式"></a>7.1.3 cookie使用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhongfucheng&quot;</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;我已经向浏览器发送了一个Cookie&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-1-4-Cookie不可跨域名性"><a href="#7-1-4-Cookie不可跨域名性" class="headerlink" title="7.1.4 Cookie不可跨域名性"></a>7.1.4 Cookie不可跨域名性</h4><ul><li>很多人在初学的时候可能有一个疑问：在访问Servlet的时候浏览器<strong>是不是把所有的Cookie都带过去给服务器</strong>，<strong>会不会修改了别的网站的Cookie</strong></li><li>答案是否定的。Cookie具有不可跨域名性。浏览器判断<strong>一个网站是否能操作另一个网站的Cookie的依据是域名</strong>。所以一般来说，<strong>当我访问baidu的时候，浏览器只会把baidu颁发的Cookie带过去，而不会带上google的Cookie。</strong></li></ul><h4 id="7-1-5-Cookie的有效期"><a href="#7-1-5-Cookie的有效期" class="headerlink" title="7.1.5 Cookie的有效期"></a>7.1.5 Cookie的有效期</h4><p><strong>Cookie的有效期是通过setMaxAge()来设置的</strong>。</p><ul><li>如果MaxAge为<strong>正数</strong>，<strong>浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆网站时该Cookie就有效</strong>【不论关闭了浏览器还是电脑】</li><li>如果MaxAge为<strong>负数</strong>，<strong>Cookie是临时性的，仅在本浏览器内有效</strong>，关闭浏览器Cookie就失效了，Cookie不会写到硬盘中。Cookie默认值就是-1。这也就为什么在我第一个例子中，如果我没设置Cookie的有效期，在硬盘中就找不到对应的文件。</li><li>如果MaxAge为<strong>0</strong>，则表示<strong>删除该Cookie</strong>。Cookie机制没有提供删除Cookie对应的方法，把MaxAge设置为0等同于删除Cookie</li></ul><h4 id="7-1-6-Cookie的域名"><a href="#7-1-6-Cookie的域名" class="headerlink" title="7.1.6 Cookie的域名"></a>7.1.6 Cookie的域名</h4><p>Cookie的<strong>domain属性决定运行访问Cookie的域名。domain的值规定为“.域名”</strong></p><p>Cookie的隐私安全机制决定Cookie是不可跨域名的。也就是说<a href="http://www.baidu.com和www.google.com之间的cookie是互不交接的.**即使是同一级域名,不同二级域名也不能交接**./">www.baidu.com和www.google.com之间的Cookie是互不交接的。**即使是同一级域名，不同二级域名也不能交接**。</a></p><h3 id="7-2-什么是Session"><a href="#7-2-什么是Session" class="headerlink" title="7.2 什么是Session"></a>7.2 什么是Session</h3><p>Session 是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是Session。</p><h4 id="7-2-1-为什么要使用Session技术？"><a href="#7-2-1-为什么要使用Session技术？" class="headerlink" title="7.2.1 为什么要使用Session技术？"></a>7.2.1 为什么要使用Session技术？</h4><p><strong>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，Cookie只能存储字符串。】。</strong></p><h4 id="7-2-2-Session-API"><a href="#7-2-2-Session-API" class="headerlink" title="7.2.2 Session API"></a>7.2.2 Session API</h4><ul><li>long getCreationTime();【获取Session被创建时间】</li><li><strong>String getId();【获取Session的id】</strong></li><li>long getLastAccessedTime();【返回Session最后活跃的时间】</li><li>ServletContext getServletContext();【获取ServletContext对象】</li><li><strong>void setMaxInactiveInterval(int var1);【设置Session超时时间】</strong></li><li><strong>int getMaxInactiveInterval();【获取Session超时时间】</strong></li><li><strong>Object getAttribute(String var1);【获取Session属性</strong>】</li><li>Enumeration getAttributeNames();【获取Session所有的属性名】</li><li><strong>void setAttribute(String var1, Object var2);【设置Session属性】</strong></li><li><strong>void removeAttribute(String var1);【移除Session属性】</strong></li><li><strong>void invalidate();【销毁该Session】</strong></li><li>boolean isNew();【该Session是否为新的】</li></ul><h4 id="7-2-3-session作为域对象"><a href="#7-2-3-session作为域对象" class="headerlink" title="7.2.3 session作为域对象"></a>7.2.3 session作为域对象</h4><p>Session有着request和ServletContext类似的方法。其实<strong>Session也是一个域对象</strong>。Session作为一种记录浏览器状态的机制，<strong>只要Session对象没有被销毁，Servlet之间就可以通过Session对象实现通讯</strong></p><p>一般来讲，当我们要存进的是<strong>用户级别的数据就用Session</strong>，那什么是用户级别呢？<strong>只要浏览器不关闭，希望数据还在，就使用Session来保存</strong>。</p><h4 id="7-2-4-session生命周期"><a href="#7-2-4-session生命周期" class="headerlink" title="7.2.4 session生命周期"></a>7.2.4 session生命周期</h4><p><strong>Session的生命周期和有效期</strong></p><ul><li><p>Session在用户<strong>第一次访问服务器Servlet，jsp等动态资源就会被自动创建，Session对象保存在内存里</strong>，这也就为什么上面的例子可以<strong>直接使用request对象获取得到Session对象</strong>。</p></li><li><p>如果访问HTML,IMAGE等静态资源Session不会被创建。</p></li><li><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，无论<strong>是否对Session进行读写，服务器都会认为Session活跃了一次</strong>。</p></li><li><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。<strong>为了防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除，这个时间也就是Session的超时时间</strong>。</p></li><li><p>Session的超时时间默认是30分钟，有三种方式可以对Session的超时时间进行修改</p><p>1、修改tomcat的web.xml</p><p>2、修改项目的web.xml</p><p>3、<code>httpSession.setMaxInactiveInterval(60);</code></p></li></ul><h3 id="7-3-Session和Cookie的区别"><a href="#7-3-Session和Cookie的区别" class="headerlink" title="7.3 Session和Cookie的区别"></a>7.3 Session和Cookie的区别</h3><ul><li><p><strong>从存储方式上比较</strong></p></li><li><ul><li>Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。</li><li>Session可以存储任何类型的数据，可以把Session看成是一个容器</li></ul></li><li><p><strong>从隐私安全上比较</strong></p></li><li><ul><li><strong>Cookie存储在浏览器中，对客户端是可见的</strong>。信息容易泄露出去。如果使用Cookie，最好将Cookie加密</li><li><strong>Session存储在服务器上，对客户端是透明的</strong>。不存在敏感信息泄露问题。</li></ul></li><li><p><strong>从有效期上比较</strong></p></li><li><ul><li>Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的</li><li><strong>Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。</strong></li></ul></li><li><p><strong>从对服务器的负担比较</strong></p></li><li><ul><li>Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。</li><li>Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。</li></ul></li><li><p><strong>从浏览器的支持上比较</strong></p></li><li><ul><li>如果浏览器禁用了Cookie，那么Cookie是无用的了！</li><li>如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。</li></ul></li><li><p><strong>从跨域名上比较</strong></p></li><li><ul><li>Cookie可以设置domain属性来实现跨域名</li><li>Session只在当前的域名内有效，不可跨域名</li></ul></li></ul><h2 id="8、forward和redirect的区别"><a href="#8、forward和redirect的区别" class="headerlink" title="8、forward和redirect的区别"></a>8、forward和redirect的区别</h2><h3 id="8-1-实际发生位置不同，地址栏不同"><a href="#8-1-实际发生位置不同，地址栏不同" class="headerlink" title="8.1 实际发生位置不同，地址栏不同"></a>8.1 <strong>实际发生位置不同，地址栏不同</strong></h3><p>1、转发是发生在服务器的<br>2、转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。<br>3、重定向是发生在浏览器的 - 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象</p><h3 id="8-2-用法不同"><a href="#8-2-用法不同" class="headerlink" title="8.2 用法不同"></a>8.2 用法不同</h3><p>很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： <strong>给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上</strong></p><p><code>request.getRequestDispatcher(&quot;/资源名 URI&quot;).forward(request,response)</code><br>转发时”/“代表的是本应用程序的根目录【zhongfucheng】<br><code>response.send(&quot;/web应用/资源名 URI&quot;); </code><br>重定向时”/“代表的是webapps目录  </p><h3 id="8-3-能够去往的URL的范围不一样"><a href="#8-3-能够去往的URL的范围不一样" class="headerlink" title="8.3 能够去往的URL的范围不一样"></a>8.3 能够去往的URL的范围不一样</h3><p>转发是服务器跳转只能去往当前web应用的资源<br>重定向是服务器跳转，可以去往任何的资源</p><h3 id="8-4-传递数据的类型不同"><a href="#8-4-传递数据的类型不同" class="headerlink" title="8.4 传递数据的类型不同"></a>8.4 传递数据的类型不同</h3><p>转发的request对象可以传递各种类型的数据，包括对象<br>重定向只能传递字符串</p><h3 id="8-5-跳转的时间不同"><a href="#8-5-跳转的时间不同" class="headerlink" title="8.5 跳转的时间不同"></a>8.5 跳转的时间不同</h3><p>转发时：执行到跳转语句时就会立刻跳转<br>重定向：整个页面执行完之后才执行跳转</p><p><strong>那么转发(forward)和重定向(redirect)使用哪一个？</strong></p><p>根据上面说明了转发和重定向的区别也可以很容易概括出来<strong>。转发是带着转发前的请求的参数的。重定向是新的请求</strong>。</p><h3 id="8-6-典型的应用场景："><a href="#8-6-典型的应用场景：" class="headerlink" title="8.6 典型的应用场景："></a>8.6 典型的应用场景：</h3><ol><li>转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变</li><li>重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了</li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484755&idx=7&sn=fb35232f3c15e2b4336498ac9f8804f1&chksm=ebd74452dca0cd44942721a159088a2f286d4e5c5f2bcdc7e264f0dccc8f9928d66858e475d4###rd">Servlet第六篇【Session介绍、API、生命周期、应用、与Cookie区别】(修订版)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是servlet&quot;&gt;&lt;a href=&quot;#1、什么是servlet&quot; class=&quot;headerlink&quot; title=&quot;1、什么是servlet&quot;&gt;&lt;/a&gt;1、什么是servlet&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是Serlvet？&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>服务发现的基本原理</title>
    <link href="http://example.com/wiki/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-24T06:30:25.000Z</published>
    <updated>2021-08-24T06:33:06.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6844903580999090183">https://juejin.cn/post/6844903580999090183</a></p><p><a href="https://blog.didispace.com/consul-service-discovery-exp/">使用Consul做服务发现的若干姿势</a></p><p><a href="https://laravelacademy.org/post/21214">注册中心篇（三）：Consul 服务发现的底层实现</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903580999090183&quot;&gt;https://j</summary>
      
    
    
    
    
    <category term="服务发现" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM-性能调优</title>
    <link href="http://example.com/wiki/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://example.com/wiki/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-08-23T02:13:43.000Z</published>
    <updated>2021-08-23T02:16:21.575Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p><a href="https://mikechen.cc/3321.html">JVM性能调优的6大步骤，及关键调优参数详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mikechen.cc/3321.html&quot;&gt;JVM性能调优的6大步骤，及关键调优参数详解&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Arthas-Java诊断神器</title>
    <link href="http://example.com/wiki/Arthas-Java%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/"/>
    <id>http://example.com/wiki/Arthas-Java%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/</id>
    <published>2021-08-20T08:28:32.000Z</published>
    <updated>2021-08-20T10:02:17.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Arthas-Java诊断神器"><a href="#Arthas-Java诊断神器" class="headerlink" title="Arthas-Java诊断神器"></a>Arthas-Java诊断神器</h2><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820172620815.png" alt="image-20210820172620815" style="zoom:50%;"/><p>官方文档地址 👉    <a href="https://arthas.aliyun.com/doc/index.html#">https://arthas.aliyun.com/doc/index.html#</a></p><h3 id="1-安装arthas"><a href="#1-安装arthas" class="headerlink" title="1. 安装arthas"></a>1. 安装arthas</h3><p><code>wget https://arthas.aliyun.com/arthas-boot.jar </code></p><p><code>java -jar arthas-boot.jar --target-ip 0.0.0.0</code></p><p>如果你的机器没有任何java进程在运行，会提示如下错误 👇</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820165717792.png" alt="image-20210820165717792"></p><p><strong>正常启动如下：</strong></p><p>⚠️ 由于我们仅仅启动了一个java进程，所有这里就只有一个。输入1回车即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820165953801.png" alt="image-20210820165953801"></p><p><strong>42423就是我们的java进程号</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820170112574.png" alt="image-20210820170112574"></p><h3 id="2-查看JVM信息"><a href="#2-查看JVM信息" class="headerlink" title="2. 查看JVM信息"></a>2. 查看JVM信息</h3><h4 id="2-1-sysprop"><a href="#2-1-sysprop" class="headerlink" title="2.1 sysprop"></a>2.1 sysprop</h4><p><code>sysprop</code> 可以打印所有的System Properties信息。</p><p>也可以指定单个key： <code>sysprop java.version</code></p><p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p><p>可以设置新的value： <code>sysprop testKey testValue</code></p><h4 id="2-2-sysenv"><a href="#2-2-sysenv" class="headerlink" title="2.2 sysenv"></a>2.2 sysenv</h4><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p><h4 id="2-3-jvm"><a href="#2-3-jvm" class="headerlink" title="2.3 jvm"></a>2.3 jvm</h4><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p><h4 id="2-4-dashboard"><a href="#2-4-dashboard" class="headerlink" title="2.4 dashboard"></a>2.4 dashboard</h4><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><p>输入 <code>Q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><h3 id="3-查看线程相关"><a href="#3-查看线程相关" class="headerlink" title="3. 查看线程相关"></a>3. 查看线程相关</h3><h4 id="3-1-查看线程列表"><a href="#3-1-查看线程列表" class="headerlink" title="3.1 查看线程列表"></a>3.1 查看线程列表</h4><p><code>thread</code> </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820163125277.png" alt="image-20210820163125277"></p><h4 id="3-2-查看线程栈信息"><a href="#3-2-查看线程栈信息" class="headerlink" title="3.2 查看线程栈信息"></a>3.2 <strong>查看线程栈信息</strong></h4><p><code>thread 18</code> </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820163518891.png" alt="image-20210820163518891"></p><h4 id="3-3-查看5秒内的CPU使用率top-n线程栈"><a href="#3-3-查看5秒内的CPU使用率top-n线程栈" class="headerlink" title="3.3 查看5秒内的CPU使用率top n线程栈"></a>3.3 查看5秒内的CPU使用率top n线程栈</h4><p><code>thread -n 3 -i 5000 </code></p><h4 id="3-4-查找线程是否有阻塞"><a href="#3-4-查找线程是否有阻塞" class="headerlink" title="3.4 查找线程是否有阻塞"></a>3.4 查找线程是否有阻塞</h4><p><code>thread -b</code></p><h3 id="4-sc-sm-查看已加载的类"><a href="#4-sc-sm-查看已加载的类" class="headerlink" title="4. sc/sm 查看已加载的类"></a>4. sc/sm 查看已加载的类</h3><p>下面介绍Arthas里查找已加载类的命令。</p><h3 id="4-1-sc-查找到所有JVM已经加载到的类"><a href="#4-1-sc-查找到所有JVM已经加载到的类" class="headerlink" title="4.1 sc 查找到所有JVM已经加载到的类"></a>4.1 sc 查找到<strong>所有JVM已经加载到的类</strong></h3><p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p><p><code>sc javax.servlet.Filter</code></p><p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p><p><code>sc -d javax.servlet.Filter</code></p><p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p><p><code>sc *StringUtils</code></p><h3 id="4-2-sm-查找类的具体函数"><a href="#4-2-sm-查找类的具体函数" class="headerlink" title="4.2 sm 查找类的具体函数"></a>4.2 sm 查找类的<strong>具体函数</strong></h3><p><code>sm java.math.RoundingMode</code></p><p>通过<code>-d</code>参数可以打印函数的具体属性：</p><p><code>sm -d java.math.RoundingMode</code></p><p>也可以查找特定的函数，比如查找构造函数：</p><p><code>sm java.math.RoundingMode &lt;init&gt;</code></p><h3 id="5-Jad反编译"><a href="#5-Jad反编译" class="headerlink" title="5. Jad反编译"></a>5. Jad反编译</h3><p>可以通过 <code>jad</code> 命令来反编译代码：</p><p><code>jad com.example.demo.arthas.user.UserController</code></p><p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p><p><code>jad --source-only com.example.demo.arthas.user.UserController</code></p><h3 id="6-Ognl动态代码"><a href="#6-Ognl动态代码" class="headerlink" title="6. Ognl动态代码"></a>6. Ognl动态代码</h3><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p><h4 id="6-1-调用static函数"><a href="#6-1-调用static函数" class="headerlink" title="6.1 调用static函数"></a>6.1 调用static函数</h4><p><code>ognl &#39;@java.lang.System@out.println(&quot;hello ognl&quot;)&#39;</code></p><p>可以检查<code>Terminal</code>里的进程输出，可以发现打印出了<code>hello ognl</code>。</p><h4 id="6-2-查找UserController的ClassLoader"><a href="#6-2-查找UserController的ClassLoader" class="headerlink" title="6.2 查找UserController的ClassLoader"></a>6.2 查找UserController的ClassLoader</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><p><code>$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</code></p><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter<span class="variable">$Slf4jLocationAwareLog</span>],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4 id="6-3-获取静态类的静态字段"><a href="#6-3-获取静态类的静态字段" class="headerlink" title="6.3 获取静态类的静态字段"></a>6.3 获取静态类的静态字段</h4><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><h4 id="6-4-执行多行表达式，赋值给临时变量，返回一个List"><a href="#6-4-执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="6.4 执行多行表达式，赋值给临时变量，返回一个List"></a>6.4 执行多行表达式，赋值给临时变量，返回一个List</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="6-5-更多"><a href="#6-5-更多" class="headerlink" title="6.5 更多"></a>6.5 更多</h4><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h3 id="7-Watch查看命令"><a href="#7-Watch查看命令" class="headerlink" title="7. Watch查看命令"></a>7. Watch查看命令</h3><h4 id="7-1-如何使用"><a href="#7-1-如何使用" class="headerlink" title="7.1 如何使用"></a>7.1 如何使用</h4><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, throwExp&#125;&#39;</code></p><p>执行完之后，会阻塞，此时如果有请求进来，发生一场的话，就会看到异常信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820171343673.png" alt="image-20210820171343673"></p><p>如果想把获取到的结果展开，可以用<code>-x</code>参数：</p><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, throwExp&#125;&#39; -x 2</code></p><h4 id="7-2-返回值表达式"><a href="#7-2-返回值表达式" class="headerlink" title="7.2 返回值表达式"></a>7.2 返回值表达式</h4><p>在上面的例子里，第三个参数是<code>返回值表达式</code>，它实际上是一个<code>ognl</code>表达式，它支持一些内置对象：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><p>你可以利用这些内置对象来组成不同的表达式。比如返回一个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * &#x27;&#123;params[0], target, returnObj&#125;&#x27;</span><br></pre></td></tr></table></figure><p>更多参考： <a href="https://arthas.aliyun.com/doc/advice-class.html">https://arthas.aliyun.com/doc/advice-class.html</a></p><h4 id="7-3-条件表达式"><a href="#7-3-条件表达式" class="headerlink" title="7.3 条件表达式"></a>7.3 条件表达式</h4><p><code>watch</code>命令支持在第4个参数里写条件表达式，比如：</p><p><code>watch com.example.demo.arthas.user.UserController * returnObj &#39;params[0] &gt; 100&#39;</code></p><p>当访问 <code>localhost:80/user/1</code>时，<code>watch</code>命令没有输出</p><p>当访问<code>localhost:80/user/101</code>时，<code>watch</code>会打印出结果。</p><h4 id="7-4-当异常时捕获"><a href="#7-4-当异常时捕获" class="headerlink" title="7.4 当异常时捕获"></a>7.4 当异常时捕获</h4><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><p><code>watch com.example.demo.arthas.user.UserController * &quot;&#123;params[0],throwExp&#125;&quot; -e</code></p><h4 id="7-5-按照耗时进行过滤"><a href="#7-5-按照耗时进行过滤" class="headerlink" title="7.5 按照耗时进行过滤"></a>7.5 按照耗时进行过滤</h4><p>watch命令支持按请求耗时进行过滤，比如：</p><p><code>watch com.example.demo.arthas.user.UserController * &#39;&#123;params, returnObj&#125;&#39; &#39;#cost&gt;200&#39;</code></p><h3 id="8-热更新代码"><a href="#8-热更新代码" class="headerlink" title="8. 热更新代码"></a>8. 热更新代码</h3><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost/user/0">http://localhost/user/0</a> ，会返回500异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//localhost/user/0</span></span><br><span class="line">&#123;<span class="string">&quot;timestamp&quot;</span>:<span class="number">1550223186170</span>,<span class="string">&quot;status&quot;</span>:<span class="number">500</span>,<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Internal Server Error&quot;</span>,<span class="string">&quot;exception&quot;</span>:<span class="string">&quot;java.lang.IllegalArgumentException&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;id &lt; 1&quot;</span>,<span class="string">&quot;path&quot;</span>:<span class="string">&quot;/user/0&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4 id="8-1-jad反编译UserController"><a href="#8-1-jad反编译UserController" class="headerlink" title="8.1 jad反编译UserController"></a>8.1 jad反编译UserController</h4><p><strong>在arthas中执行jad命令 👇</strong></p><p><code>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</code></p><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>在【 机器 】上然后用vim来编辑<code>/tmp/UserController.java</code>：</p><p><code>vim /tmp/UserController.java</code></p><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-sc查找加载UserController的ClassLoader"><a href="#8-2-sc查找加载UserController的ClassLoader" class="headerlink" title="8.2 sc查找加载UserController的ClassLoader"></a>8.2 sc查找加载UserController的ClassLoader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br><span class="line">$ sc -d *UserController | grep classLoaderHash</span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 <code>springbootLaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>记下classLoaderHash，后面需要使用它。在这里，它是 <code>1be6f5c3</code>。</p><h4 id="8-3-mc编译java文件"><a href="#8-3-mc编译java文件" class="headerlink" title="8.3 mc编译java文件"></a>8.3 mc编译java文件</h4><p>编译java文件，类似于javac。</p><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>或者<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br><span class="line">$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820172201737.png" alt="image-20210820172201737"></p><h4 id="8-4-redefine加载class文件"><a href="#8-4-redefine加载class文件" class="headerlink" title="8.4 redefine加载class文件"></a>8.4 redefine加载class文件</h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h4 id="8-5-热修改代码结果"><a href="#8-5-热修改代码结果" class="headerlink" title="8.5 热修改代码结果"></a>8.5 热修改代码结果</h4><p><code>redefine</code>成功之后，再次访问 <code>localhost:80/user/0</code> ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-Exit-Stop"><a href="#9-Exit-Stop" class="headerlink" title="9. Exit/Stop"></a>9. Exit/Stop</h3><h4 id="9-1-reset"><a href="#9-1-reset" class="headerlink" title="9.1 reset"></a>9.1 reset</h4><p>Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 <code>reset</code> 命令，可以清除掉这些增强代码。</p><h4 id="9-2-退出Arthas"><a href="#9-2-退出Arthas" class="headerlink" title="9.2 退出Arthas"></a>9.2 退出Arthas</h4><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p><p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p><h4 id="9-3-彻底退出Arthas"><a href="#9-3-彻底退出Arthas" class="headerlink" title="9.3 彻底退出Arthas"></a>9.3 彻底退出Arthas</h4><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p><p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p><h3 id="10-arthas-boot支持的参数"><a href="#10-arthas-boot支持的参数" class="headerlink" title="10. arthas-boot支持的参数"></a>10. arthas-boot支持的参数</h3><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p><h4 id="10-1-允许外部访问"><a href="#10-1-允许外部访问" class="headerlink" title="10.1 允许外部访问"></a>10.1 允许外部访问</h4><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p><p><code>java -jar arthas-boot.jar --target-ip</code></p><h4 id="10-2-列出所有的版本"><a href="#10-2-列出所有的版本" class="headerlink" title="10.2 列出所有的版本"></a>10.2 列出所有的版本</h4><p><code>java -jar arthas-boot.jar --versions</code></p><p>使用指定版本：</p><p><code>java -jar arthas-boot.jar --use-version 3.1.0</code></p><h4 id="10-3-只侦听Telnet端口，不侦听HTTP端口"><a href="#10-3-只侦听Telnet端口，不侦听HTTP端口" class="headerlink" title="10.3 只侦听Telnet端口，不侦听HTTP端口"></a>10.3 只侦听Telnet端口，不侦听HTTP端口</h4><p><code>java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</code></p><h4 id="10-4-打印运行的详情"><a href="#10-4-打印运行的详情" class="headerlink" title="10.4 打印运行的详情"></a>10.4 打印运行的详情</h4><p><code>java -jar arthas-boot.jar -v</code></p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820164916567.png" alt="image-20210820164916567"></p><h3 id="11-Web-Console"><a href="#11-Web-Console" class="headerlink" title="11. Web Console"></a>11. Web Console</h3><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210820173816512.png" alt="image-20210820173816512"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Arthas-Java诊断神器&quot;&gt;&lt;a href=&quot;#Arthas-Java诊断神器&quot; class=&quot;headerlink&quot; title=&quot;Arthas-Java诊断神器&quot;&gt;&lt;/a&gt;Arthas-Java诊断神器&lt;/h2&gt;&lt;img src=&quot;https://cdn</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-只出现一次的数字</title>
    <link href="http://example.com/wiki/LeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/wiki/LeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2021-08-19T13:12:54.000Z</published>
    <updated>2021-08-19T13:17:19.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4<br>相关标签<br>位运算</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>仅仅出现一个，很显然，这个数和前后都不一样，然后特殊判断一下头部和尾部就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">2</span>] != nums[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; nums[i - <span class="number">2</span>] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析二"><a href="#分析二" class="headerlink" title="分析二"></a>分析二</h2><p>使用异或运算，将所有值进行异或<br>异或运算，相异为真，相同为假，所以<code> a^a = 0 ;0^a = a</code><br>因为异或运算 满足交换律 <code>a^b^a = a^a^b = b </code>所以数组经过异或运算，单独的值就剩下了</p><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/?discussion=Mo9fKT">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/?discussion=Mo9fKT</a></p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reduce = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            reduce =  reduce ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;只出现一次的数字&quot;&gt;&lt;a href=&quot;#只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;只出现一次的数字&quot;&gt;&lt;/a&gt;只出现一次的数字&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/leetbook/read</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-存在重复元素</title>
    <link href="http://example.com/wiki/LeetCode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/wiki/LeetCode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-08-19T12:57:35.000Z</published>
    <updated>2021-08-19T13:04:26.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a></p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><p>示例 1:</p><p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p><p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p><p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>1、双重循环是很容易想到，但是会超出时间限制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、先排序，然后判断相邻两个元素是否相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;存在重复元素&quot;&gt;&lt;a href=&quot;#存在重复元素&quot; class=&quot;headerlink&quot; title=&quot;存在重复元素&quot;&gt;&lt;/a&gt;存在重复元素&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/leetbook/read/top-int</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-买卖股票的最佳时机II</title>
    <link href="http://example.com/wiki/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://example.com/wiki/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2021-08-19T12:35:49.000Z</published>
    <updated>2021-08-19T12:41:01.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a></p><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: <code>prices = [7,1,5,3,6,4]</code><br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:</p><p>输入: <code>prices = [1,2,3,4,5]</code><br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p><p>输入: <code>prices = [7,6,4,3,1]</code><br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>⏰提示：</p><p><code>1 &lt;= prices.length &lt;= 3 * 104</code><br><code>0 &lt;= prices[i] &lt;= 104</code></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>[7,1,5,3,6,4]</code><br><code>[1,2,3,4,5]</code></p><p>其实规律很简单，就比较当天和前一天的大小关系就好了，一次循环就下来了。</p><p>一开始想的比较复杂，用的指针滑动，比如1，2，3，4，5这种，一开始想的是 <code>5 - 1</code> ，其实 1 + 1 + 1 + 1就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [7,1,5,3,6,4]</span></span><br><span class="line">        <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                count += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;买卖股票的最佳时机II&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/l</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-删除排序数组中的重复项</title>
    <link href="http://example.com/wiki/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://example.com/wiki/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2021-08-19T11:28:03.000Z</published>
    <updated>2021-08-19T11:52:25.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a></p><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 </p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 3 * 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按升序排列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假如输入 <code>[0,0,1,1,1,2,2,3,3,4]</code></p><p>最终的结果应该是<code>[0,1,2,3,4,2,2,3,3,4]</code></p><p><strong>count</strong> 变量用来存储不重复数组的个数</p><p><strong>offset</strong> 作为当前游标记录判断之后不重复的数据的位置</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210819194952616.png" style="zoom:33%;" /><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[offset] = nums[i];</span><br><span class="line">            offset++;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除排序数组中的重复项&quot;&gt;&lt;/a&gt;删除排序数组中的重复项&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/l</summary>
      
    
    
    
    
    <category term="简单" scheme="http://example.com/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁🔒</title>
    <link href="http://example.com/wiki/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%F0%9F%94%92/"/>
    <id>http://example.com/wiki/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%F0%9F%94%92/</id>
    <published>2021-08-19T07:17:31.000Z</published>
    <updated>2021-08-19T07:32:53.269Z</updated>
    
    <content type="html"><![CDATA[<p>乐观锁和悲观锁</p><h3 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h3><blockquote><p><strong>表锁</strong>： 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</p></blockquote><p>表锁按照数据操作可以分成两种：</p><ul><li>表读锁（Table Read Lock）</li><li>表写锁（Table Write Lock</li></ul><p>读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁</p><p>读写阻塞：当前用户在读数据，其他的用户<strong>不能修改当前用户读的数据</strong>，会加锁！</p><p>写写阻塞：当前用户在修改数据，其他的用户<strong>不能修改当前用户正在修改的数据</strong>，会加锁！</p><blockquote><p><strong>行锁</strong>： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</p></blockquote><p>InnoDB实现了以下<strong>两种</strong>类型的行锁。</p><ul><li><p>共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>也叫做<strong>读锁</strong>：读锁是<strong>共享</strong>的，多个客户可以<strong>同时读取同一个</strong>资源，但<strong>不允许其他客户修改</strong>。</p></li><li><p>排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p></li><li><p>也叫做<strong>写锁</strong>：写锁是排他的，<strong>写锁会阻塞其他的写锁和读锁</strong>。</p></li></ul><p>另外，<strong>为了允许行锁和表锁共存，实现多粒度锁机制</strong>，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li><li>意向锁也是数据库隐式帮我们做了，<strong>不需要程序员操心</strong>！</li></ul><p>⚠️ <strong>InnoDB行锁和表锁都支持</strong>！<font color=red><strong>MyISAM只支持表锁</strong>！</font></p><h3 id="innoDB什么时候会使用到行锁？"><a href="#innoDB什么时候会使用到行锁？" class="headerlink" title="innoDB什么时候会使用到行锁？"></a>innoDB什么时候会使用到行锁？</h3><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN###rd">数据库两大神器【索引和锁】</a></p><p><a href="https://geekibli.github.io/wiki/mysql%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">基于数据表乐观锁实现分布式锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乐观锁和悲观锁&lt;/p&gt;
&lt;h3 id=&quot;表锁和行锁&quot;&gt;&lt;a href=&quot;#表锁和行锁&quot; class=&quot;headerlink&quot; title=&quot;表锁和行锁&quot;&gt;&lt;/a&gt;表锁和行锁&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;表锁&lt;/strong&gt;： 开销小，加锁快；不</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能调优</title>
    <link href="http://example.com/wiki/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://example.com/wiki/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-08-19T06:06:45.000Z</published>
    <updated>2021-08-19T08:25:08.529Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、使用【-覆盖索引-】避免回表锁造成的时间消耗"><a href="#1、使用【-覆盖索引-】避免回表锁造成的时间消耗" class="headerlink" title="1、使用【 覆盖索引 】避免回表锁造成的时间消耗"></a>1、使用【 覆盖索引 】避免回表锁造成的时间消耗</h5><p>1、查询语句的时候避免使用select * </p><p>2、创建索引添加适当的列避免回表</p><h5 id="2、使用【-联合索引-】区分度比较高的列放到前面"><a href="#2、使用【-联合索引-】区分度比较高的列放到前面" class="headerlink" title="2、使用【 联合索引 】区分度比较高的列放到前面"></a>2、使用【 联合索引 】区分度比较高的列放到前面</h5><p>注意联合索引的最左匹配原则</p><h5 id="3、对索引进行函数计算或者表达式计算会导致索引失效-🔒"><a href="#3、对索引进行函数计算或者表达式计算会导致索引失效-🔒" class="headerlink" title="3、对索引进行函数计算或者表达式计算会导致索引失效 🔒"></a>3、对索引进行函数计算或者表达式计算会导致索引失效 🔒</h5><h5 id="4、利用子查询优化超多分页场景"><a href="#4、利用子查询优化超多分页场景" class="headerlink" title="4、利用子查询优化超多分页场景"></a>4、利用子查询优化超多分页场景</h5><h5 id="5、explain命令查询执行计划-show-profile查询执行的性能消耗"><a href="#5、explain命令查询执行计划-show-profile查询执行的性能消耗" class="headerlink" title="5、explain命令查询执行计划 show profile查询执行的性能消耗"></a>5、explain命令查询执行计划 show profile查询执行的性能消耗</h5><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484461&idx=2&sn=5469534e2f370aba86c3a24a2ff52b70&chksm=ebd7452cdca0cc3ad456d695a78f48e72c245f85b4afb210fb7b62218e89785d964d72ec4891&token=620000779&lang=zh_CN&scene=21###wechat_redirect">面试前必须知道的MySQL命令【expalin】 -3y</a></p><h5 id="6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间"><a href="#6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间" class="headerlink" title="6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间"></a>6、在事务开始后，事务内尽可能只操作数据库，减少锁持有时间</h5><h5 id="7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch"><a href="#7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch" class="headerlink" title="7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch"></a>7、尽量避免字符串查询，如果允许的话可以使用Elasticsearch</h5><h5 id="8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据"><a href="#8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据" class="headerlink" title="8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据"></a>8、如果优化都做了还是查询的很慢，可以做一些聚合表，线上的业务直接查聚合之后的数据</h5><h5 id="9、读写瓶颈问题"><a href="#9、读写瓶颈问题" class="headerlink" title="9、读写瓶颈问题"></a>9、读写瓶颈问题</h5><p>9.1 如果是单库的情况下，可以考虑读写分离，提升读/写的性能</p><p>9.2 主从结构下还是存在瓶颈的话，可以考虑分库分表</p><p>注意 分库分表下的id尽量保证递增</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1、使用【-覆盖索引-】避免回表锁造成的时间消耗&quot;&gt;&lt;a href=&quot;#1、使用【-覆盖索引-】避免回表锁造成的时间消耗&quot; class=&quot;headerlink&quot; title=&quot;1、使用【 覆盖索引 】避免回表锁造成的时间消耗&quot;&gt;&lt;/a&gt;1、使用【 覆盖索引 】避免</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>kafka-基础知识</title>
    <link href="http://example.com/wiki/kafka-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/wiki/kafka-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-08-18T12:05:29.000Z</published>
    <updated>2021-08-18T12:14:58.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka是什么"><a href="#kafka是什么" class="headerlink" title="kafka是什么"></a>kafka是什么</h2><h2 id="kafka运行时架构"><a href="#kafka运行时架构" class="headerlink" title="kafka运行时架构"></a>kafka运行时架构</h2><h2 id="kafka为什么能承载高并发"><a href="#kafka为什么能承载高并发" class="headerlink" title="kafka为什么能承载高并发"></a>kafka为什么能承载高并发</h2><h2 id="kafka的确认机制是什么"><a href="#kafka的确认机制是什么" class="headerlink" title="kafka的确认机制是什么"></a>kafka的确认机制是什么</h2><h2 id="kafka如何保证消息准确"><a href="#kafka如何保证消息准确" class="headerlink" title="kafka如何保证消息准确"></a>kafka如何保证消息准确</h2><p>kafka会丢消息吗？</p><p>kafka会重复消费消息吗</p><p>幂等性</p><h2 id="消息顺序消费问题"><a href="#消息顺序消费问题" class="headerlink" title="消息顺序消费问题"></a>消息顺序消费问题</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247484387&idx=1&sn=5bb2ba58776e65f53b091a4bcdb73755&chksm=fdf0ebbcca8762aadc359066ecd70274fa23ee846f9ba9114017402dcbed415f25f97d3020a6&token=1131755397&lang=zh_CN&scene=21#wechat_redirect">kafka基础知识 - yyy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kafka是什么&quot;&gt;&lt;a href=&quot;#kafka是什么&quot; class=&quot;headerlink&quot; title=&quot;kafka是什么&quot;&gt;&lt;/a&gt;kafka是什么&lt;/h2&gt;&lt;h2 id=&quot;kafka运行时架构&quot;&gt;&lt;a href=&quot;#kafka运行时架构&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事务隔离</title>
    <link href="http://example.com/wiki/Spring-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://example.com/wiki/Spring-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2021-08-18T03:10:21.000Z</published>
    <updated>2021-08-18T03:11:08.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6854573219916021767">https://juejin.cn/post/6854573219916021767</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6854573219916021767&quot;&gt;https://j</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flink-物理分区函数</title>
    <link href="http://example.com/wiki/Flink-%E7%89%A9%E7%90%86%E5%88%86%E5%8C%BA%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/wiki/Flink-%E7%89%A9%E7%90%86%E5%88%86%E5%8C%BA%E5%87%BD%E6%95%B0/</id>
    <published>2021-08-12T08:38:31.000Z</published>
    <updated>2021-08-12T08:55:41.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flink提供的8种分区函数"><a href="#Flink提供的8种分区函数" class="headerlink" title="Flink提供的8种分区函数"></a>Flink提供的8种分区函数</h1><h2 id="GlobalPartitioner"><a href="#GlobalPartitioner" class="headerlink" title="GlobalPartitioner"></a>GlobalPartitioner</h2><p>该分区器会将所有的数据都发送到下游的某个算子实例(subtask id = 0)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  数据会被分发到下游算子的第一个实例中进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">global</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setMaxParallelism(<span class="number">8</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        dataStream.flatMap(<span class="keyword">new</span> RichFlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                collector.collect(s + <span class="string">&quot;_**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).setParallelism(<span class="number">2</span>).global().print(<span class="string">&quot;global : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ShufflePartitioner"><a href="#ShufflePartitioner" class="headerlink" title="ShufflePartitioner"></a>ShufflePartitioner</h2><p>随机选择一个下游算子实例进行发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据会被随机分发到下游算子的每一个实例中进行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        DataStream&lt;String&gt; broadcast = dataStream.shuffle();</span><br><span class="line">        broadcast.print(<span class="string">&quot;shuffle : &quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="BroadcastPartitioner"><a href="#BroadcastPartitioner" class="headerlink" title="BroadcastPartitioner"></a>BroadcastPartitioner</h2><p>发送到下游所有的算子实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广播分区会将上游数据输出到下游算子的每个实例中。适合于大数据集和小数据集做Jion的场景</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        DataStream&lt;String&gt; broadcast = dataStream.broadcast();</span><br><span class="line">        broadcast.print(<span class="string">&quot;broadcast : &quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RebalancePartitioner"><a href="#RebalancePartitioner" class="headerlink" title="RebalancePartitioner"></a>RebalancePartitioner</h2><p>通过循环的方式依次发送到下游的task</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setParallelism(<span class="number">4</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        dataStream.map(<span class="keyword">new</span> RichMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s + <span class="string">&quot;_**&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).setParallelism(<span class="number">1</span>).rebalance().print(<span class="string">&quot;rebalance : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RescalePartitioner"><a href="#RescalePartitioner" class="headerlink" title="RescalePartitioner"></a>RescalePartitioner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这种分区器会根据上下游算子的并行度，循环的方式输出到下游算子的每个实例。这里有点难以理解，假设上游并行度为 2，编号为 A 和 B。下游并行度为 4，编号为 1，2，3，4。那么 A 则把数据循环发送给 1 和 2，B 则把数据循环发送给 3 和 4。假设上游并行度为 4，编号为 A，B，C，D。下游并行度为 2，编号为 1，2。那么 A 和 B 则把数据发送给 1，C 和 D 则把数据发送给 2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rescale</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setParallelism(<span class="number">4</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        dataStream.map(<span class="keyword">new</span> RichMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s + <span class="string">&quot;_**&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).setParallelism(<span class="number">1</span>).rescale().print(<span class="string">&quot;rescale : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ForwardPartitioner"><a href="#ForwardPartitioner" class="headerlink" title="ForwardPartitioner"></a>ForwardPartitioner</h2><p>发送到下游对应的第一个task，保证上下游算子并行度一致，即上有算子与下游算子是1:1的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将记录输出到下游本地的算子实例。它要求上下游算子并行度一样。简单的说，ForwardPartitioner用来做数据的控制台打印。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setParallelism(<span class="number">1</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;qqq&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        DataStream&lt;String&gt; broadcast = dataStream.shuffle();</span><br><span class="line">        broadcast.print(<span class="string">&quot;shuffle : &quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>⚠️ 在上下游的算子没有指定分区器的情况下，如果上下游的算子并行度一致，则使用ForwardPartitioner，否则使用RebalancePartitioner，对于ForwardPartitioner，必须保证上下游算子并行度一致，否则会抛出异常。</p><h2 id="KeyByPartitioner"><a href="#KeyByPartitioner" class="headerlink" title="KeyByPartitioner"></a>KeyByPartitioner</h2><p>根据key的分组索引选择发送到相对应的下游subtask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keyBy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setMaxParallelism(<span class="number">8</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        dataStream.flatMap(<span class="keyword">new</span> RichFlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                collector.collect(s + <span class="string">&quot;_**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).keyBy(String::toString).print(<span class="string">&quot;keyBy : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CustomPartitionerWrapper"><a href="#CustomPartitionerWrapper" class="headerlink" title="CustomPartitionerWrapper"></a>CustomPartitionerWrapper</h2><p>通过Partitioner实例的partition方法(自定义的)将记录输出到下游。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">custom</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv().setMaxParallelism(<span class="number">8</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.fromElements(<span class="string">&quot;hhhh&quot;</span>, <span class="string">&quot;hhhss&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;sss&quot;</span>, <span class="string">&quot;www&quot;</span>);</span><br><span class="line">        dataStream.flatMap(<span class="keyword">new</span> RichFlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                collector.collect(s + <span class="string">&quot;_**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).partitionCustom(<span class="keyword">new</span> CustomPartitioner(),String::toString)</span><br><span class="line">        .print(<span class="string">&quot;custom :&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// key: 根据key的值来分区</span></span><br><span class="line">        <span class="comment">// numPartitions: 下游算子并行度</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.length() % numPartitions;<span class="comment">//在此处定义分区策略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_36039236/article/details/112576091?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&spm=1001.2101.3001.4242">Flink的八种分区策略源码解读</a></p><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/dev/datastream/operators/overview/#custom-partitioning">Apache Flink 中文文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flink提供的8种分区函数&quot;&gt;&lt;a href=&quot;#Flink提供的8种分区函数&quot; class=&quot;headerlink&quot; title=&quot;Flink提供的8种分区函数&quot;&gt;&lt;/a&gt;Flink提供的8种分区函数&lt;/h1&gt;&lt;h2 id=&quot;GlobalPartitioner</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink-UDF函数类</title>
    <link href="http://example.com/wiki/Flink-UDF%E5%87%BD%E6%95%B0%E7%B1%BB/"/>
    <id>http://example.com/wiki/Flink-UDF%E5%87%BD%E6%95%B0%E7%B1%BB/</id>
    <published>2021-08-12T06:36:09.000Z</published>
    <updated>2021-08-12T07:18:26.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h2><p>比如说我们常用的MapFunction，FilterFunction，ProcessFunction等，每一步操作都基本上都对应一个Function。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 首先按照空格分词</span></span><br><span class="line">      String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="comment">// 遍历所有的word 包装成二元组输出</span></span><br><span class="line">      <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 简单滚动聚合函数，比如sum，max是不需要Function。</p><p><strong>好处：</strong></p><p>1、通用型强，可复用</p><p>2、可抽象方法，代码简洁</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>不需要单独定义Function，直接在Stream的操作中直接实现，效果和上面👆的完全一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; dataStream = unionStream.map(<span class="keyword">new</span> MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SensorReading <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(strings[<span class="number">0</span>], <span class="keyword">new</span> Double(strings[<span class="number">1</span>]), <span class="keyword">new</span> Double(strings[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="富函数"><a href="#富函数" class="headerlink" title="富函数"></a>富函数</h2><p>‘‘富函数’’是DataStream API 提供的一个函数类的接口，所有Flink函数类都有其Rich版本，它与常规函数的不同在于，可以获取运行环境的上下文，并包含一些声明周期方法，所以可以实现更加复杂的功能。</p><p><code>RichMapFunction</code>，<code>RichFlatMapFunction</code>等等</p><p>Rich Function有一个生命周期的概念，典型的生命周期方法有 👇</p><p><code>open()</code> 方法是rich function的初始化方法，当一个算子比如map被调用之前被调用。</p><p><code>close()</code>方法是生命周期中最后一个被调用的方法，做一些清理工作。</p><blockquote><p>如果有多个分区的话，每个分区的open方法和close方法都会执行一次</p></blockquote><p><code>getRuntimeContext()</code>获取运行时上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RichFunctionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStreamSource&lt;String&gt; dataSource = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = dataSource.map(<span class="keyword">new</span> MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SensorReading <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(strings[<span class="number">0</span>], <span class="keyword">new</span> Long(strings[<span class="number">1</span>]), <span class="keyword">new</span> Double(strings[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; stream = dataStream.map(<span class="keyword">new</span> MyMapFunction());</span><br><span class="line">        stream.print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 富函数是抽象类，这里要用继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapFunction</span> <span class="keyword">extends</span> <span class="title">RichMapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;invoke open&quot;</span>);</span><br><span class="line">            <span class="comment">// 一般定义状态，或者链接数据库操作</span></span><br><span class="line">            <span class="keyword">super</span>.open(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            RuntimeContext runtimeContext = <span class="keyword">this</span>.getRuntimeContext();</span><br><span class="line">            System.err.println(<span class="string">&quot;runtimeContext.getTaskName() : &quot;</span> + runtimeContext.getTaskName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(sensorReading.getSersorId(), runtimeContext.getIndexOfThisSubtask());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">            System.err.println(<span class="string">&quot;invoke close method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数类&quot;&gt;&lt;a href=&quot;#函数类&quot; class=&quot;headerlink&quot; title=&quot;函数类&quot;&gt;&lt;/a&gt;函数类&lt;/h2&gt;&lt;p&gt;比如说我们常用的MapFunction，FilterFunction，ProcessFunction等，每一步操作都基本上都对应一个</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink-到底支持多少种数据类型</title>
    <link href="http://example.com/wiki/Flink-%E5%88%B0%E5%BA%95%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/wiki/Flink-%E5%88%B0%E5%BA%95%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-08-11T11:50:41.000Z</published>
    <updated>2021-08-12T06:35:36.160Z</updated>
    
    <content type="html"><![CDATA[<p>Flink支持所有的Java和Scala基础数据类型以及其包装类型</p><p>支持Tuple元组类型，Flink在Java API中定义了很多Tuple的实现类，从Tuple0 ~ Tuple25类型</p><p>Scala样例类 case class，对应Java中的POJO类对象(必须提供无参构造方法 get/set)</p><p>其他，比如 Arrays , Lists, Maps, Enums等都是支持的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flink支持所有的Java和Scala基础数据类型以及其包装类型&lt;/p&gt;
&lt;p&gt;支持Tuple元组类型，Flink在Java API中定义了很多Tuple的实现类，从Tuple0 ~ Tuple25类型&lt;/p&gt;
&lt;p&gt;Scala样例类 case class，对应Java中</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink-如何读取数据源（集合｜文件｜自定义｜Kafka等）</title>
    <link href="http://example.com/wiki/Flink-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88%E9%9B%86%E5%90%88%EF%BD%9C%E6%96%87%E4%BB%B6%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BD%9CKafka%E7%AD%89%EF%BC%89/"/>
    <id>http://example.com/wiki/Flink-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88%E9%9B%86%E5%90%88%EF%BD%9C%E6%96%87%E4%BB%B6%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BD%9CKafka%E7%AD%89%EF%BC%89/</id>
    <published>2021-08-11T11:50:11.000Z</published>
    <updated>2021-08-11T12:08:35.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>这里是以txt文件为例，实现WordCount，其他文件类型同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建执行环境</span></span><br><span class="line">        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 2、读取文件数据</span></span><br><span class="line">        String inputPath = <span class="string">&quot;/Users/gaolei/Documents/DemoProjects/flink-start/src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">        DataSource&lt;String&gt; dataSource = env.readTextFile(inputPath);</span><br><span class="line">        <span class="comment">// 对数据集进行处理 按照空格分词展开 转换成（word，1）二元组</span></span><br><span class="line">        AggregateOperator&lt;Tuple2&lt;String, Integer&gt;&gt; result = dataSource.flatMap(<span class="keyword">new</span> MyFlatMapper())</span><br><span class="line">                <span class="comment">// 按照第一个位置 -&gt; word 分组</span></span><br><span class="line">                .groupBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        result.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 首先按照空格分词</span></span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历所有的word 包装成二元组输出</span></span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现自定义数据源"><a href="#实现自定义数据源" class="headerlink" title="实现自定义数据源"></a>实现自定义数据源</h2><p>需要自己写一个类，实现SourceFunction接口的run方法和cancle方法，注意⚠️，SourceFunction<SensorReading>的泛型类型必须要写上，不然会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        DataStreamSource dataStreamSource = env.addSource(<span class="keyword">new</span> MySourceFunction());</span><br><span class="line">        dataStreamSource.print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的source</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySourceFunction</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 定义标识位 控制数据产生</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 定义各个随机数生成器</span></span><br><span class="line">            HashMap&lt;String, Double&gt; sensorMap = <span class="keyword">new</span> HashMap&lt;String, Double&gt;(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sensorMap.put(<span class="string">&quot;sensor_&quot;</span> + (i + <span class="number">1</span>), <span class="number">60</span> + <span class="keyword">new</span> Random().nextGaussian() * <span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String sensor : sensorMap.keySet()) &#123;</span><br><span class="line">                    <span class="keyword">double</span> newtemp = sensorMap.get(sensor) + <span class="keyword">new</span> Random().nextGaussian();</span><br><span class="line">                    sensorMap.put(sensor, newtemp);</span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> SensorReading(sensor, System.currentTimeMillis(), newtemp));</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;读取文件&quot;&gt;&lt;a href=&quot;#读取文件&quot; class=&quot;headerlink&quot; title=&quot;读取文件&quot;&gt;&lt;/a&gt;读取文件&lt;/h2&gt;&lt;p&gt;这里是以txt文件为例，实现WordCount，其他文件类型同理。&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink-你所知道的算子都在这</title>
    <link href="http://example.com/wiki/Flink-%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%97%E5%AD%90%E9%83%BD%E5%9C%A8%E8%BF%99/"/>
    <id>http://example.com/wiki/Flink-%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%97%E5%AD%90%E9%83%BD%E5%9C%A8%E8%BF%99/</id>
    <published>2021-08-11T11:49:20.000Z</published>
    <updated>2021-08-11T12:04:38.123Z</updated>
    
    <content type="html"><![CDATA[<p>好了，看到这的话，Apache Flink基础概念啥的都应该了解差不多了吧，我们几天就See一下，平时用到的StreamApi中各式各样的算子都有什么，然后，我们搞点Demo试一下。</p><p>📒 我也是边学边实现一些Demo,这样呢可以方便自己理解，形成体系以后也应该能帮到别人快速学习吧。</p><p>这就是地址了👉 <a href="https://github.com/geekibli/flink-study">https://github.com/geekibli/flink-study</a>  欢迎star！</p><p><strong>下面的Demo都是可以直接运行的</strong>  如果是通过socket获取数据的话，确认现开启端口啊，我用的Mac系统，可以使用以下命令 <code>nc -lk 9999</code></p><h2 id="提供一个全局获取环境的方法"><a href="#提供一个全局获取环境的方法" class="headerlink" title="提供一个全局获取环境的方法"></a>提供一个全局获取环境的方法</h2><p>我们一个静态方法getEnv(), 不然每次还要new，挺麻烦的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title">getEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJO类"><a href="#POJO类" class="headerlink" title="POJO类"></a>POJO类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String sersorId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> newtemp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = getEnv();</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = Lists.newArrayList();</span><br><span class="line">    nums.add(<span class="number">1</span>);</span><br><span class="line">    nums.add(<span class="number">2</span>);</span><br><span class="line">    nums.add(<span class="number">3</span>);</span><br><span class="line">    DataStreamSource&lt;Integer&gt; source = env.fromCollection(nums);</span><br><span class="line">    SingleOutputStreamOperator&lt;Integer&gt; map = source.map(<span class="keyword">new</span> MapFunction&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">map</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> integer * integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    map.print();</span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keyByTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; source = env.fromElements(</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(<span class="string">&quot;age&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(<span class="string">&quot;name&quot;</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(<span class="string">&quot;name&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(<span class="string">&quot;name&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        source.map(</span><br><span class="line">                <span class="keyword">new</span> MapFunction&lt;Tuple2&lt;String, Integer&gt;, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Integer f1 = stringIntegerTuple2.f1;</span><br><span class="line">                        stringIntegerTuple2.setField(f1 + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> stringIntegerTuple2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(<span class="number">1</span>)</span><br><span class="line">                .print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        env.fromElements(</span><br><span class="line">                Tuple2.of(<span class="number">2L</span>, <span class="number">3L</span>),</span><br><span class="line">                Tuple2.of(<span class="number">1L</span>, <span class="number">5L</span>),</span><br><span class="line">                Tuple2.of(<span class="number">1L</span>, <span class="number">5L</span>),</span><br><span class="line">                Tuple2.of(<span class="number">1L</span>, <span class="number">7L</span>),</span><br><span class="line">                Tuple2.of(<span class="number">2L</span>, <span class="number">4L</span>),</span><br><span class="line">                Tuple2.of(<span class="number">1L</span>, <span class="number">5L</span>))</span><br><span class="line">                .keyBy(<span class="number">1</span>)</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;Long, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;Long, Long&gt; longLongTuple2, Tuple2&lt;Long, Long&gt; t1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;Long, Long&gt;(t1.f0, longLongTuple2.f1 + t1.f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .print();</span><br><span class="line">        env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个栗子🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        DataStreamSource&lt;String&gt; dataSource = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = dataSource.map(<span class="keyword">new</span> MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SensorReading <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(strings[<span class="number">0</span>], <span class="keyword">new</span> Long(strings[<span class="number">1</span>]), <span class="keyword">new</span> Double(strings[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; sersorId = dataStream.keyBy(<span class="string">&quot;sersorId&quot;</span>)</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;SensorReading&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading sensorReading, SensorReading t1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        String id = t1.getSersorId();</span><br><span class="line">                        Double time = t1.getTimestamp();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(id, time, Math.max(sensorReading.getNewtemp(), t1.getNewtemp()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        sersorId.print();</span><br><span class="line">        env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="split-select"><a href="#split-select" class="headerlink" title="split|select"></a>split|select</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = getEnv();</span><br><span class="line">        DataStreamSource&lt;String&gt; dataSource = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = dataSource.map(<span class="keyword">new</span> MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SensorReading <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(strings[<span class="number">0</span>], <span class="keyword">new</span> Double(strings[<span class="number">1</span>]), <span class="keyword">new</span> Double(strings[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SplitStream&lt;SensorReading&gt; split = dataStream.split(<span class="keyword">new</span> OutputSelector&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(SensorReading value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (value.getNewtemp() &gt; <span class="number">30</span>) ? Collections.singleton(<span class="string">&quot;high&quot;</span>) : Collections.singleton(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; low = split.select(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; high = split.select(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; all = split.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connect</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Double&gt;&gt; highStream = high.map(<span class="keyword">new</span> MapFunction&lt;SensorReading, Tuple2&lt;String, Double&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Double&gt; <span class="title">map</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(sensorReading.getSersorId(), sensorReading.getNewtemp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链接之后的stream</span></span><br><span class="line">        ConnectedStreams&lt;Tuple2&lt;String, Double&gt;, SensorReading&gt; connect = highStream.connect(low);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Object&gt; resultStream = connect.map(<span class="keyword">new</span> CoMapFunction&lt;Tuple2&lt;String, Double&gt;, SensorReading, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">map1</span><span class="params">(Tuple2&lt;String, Double&gt; stringDoubleTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(stringDoubleTuple2.f0, stringDoubleTuple2.f0, <span class="string">&quot;high temp warning&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">map2</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(sensorReading.getSersorId(), <span class="string">&quot;normal temp&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="connect-coMap"><a href="#connect-coMap" class="headerlink" title="connect | coMap"></a>connect | coMap</h2><p>如上split方法下面我们是有操作connect的api的</p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unionTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 必须是数据类型相同</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;String&gt; firstStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; secondStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; unionStream = firstStream.union(secondStream);</span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = unionStream.map(<span class="keyword">new</span> MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SensorReading <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(strings[<span class="number">0</span>], <span class="keyword">new</span> Double(strings[<span class="number">1</span>]), <span class="keyword">new</span> Double(strings[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dataStream.print();</span><br><span class="line">        env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// TODO 不断学习 不断补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好了，看到这的话，Apache Flink基础概念啥的都应该了解差不多了吧，我们几天就See一下，平时用到的StreamApi中各式各样的算子都有什么，然后，我们搞点Demo试一下。&lt;/p&gt;
&lt;p&gt;📒 我也是边学边实现一些Demo,这样呢可以方便自己理解，形成体系以后也应</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink-核心之Windows窗口</title>
    <link href="http://example.com/wiki/Flink-%E6%A0%B8%E5%BF%83%E4%B9%8BWindows%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/wiki/Flink-%E6%A0%B8%E5%BF%83%E4%B9%8BWindows%E7%AA%97%E5%8F%A3/</id>
    <published>2021-08-10T08:55:40.000Z</published>
    <updated>2021-08-10T11:40:39.547Z</updated>
    
    <content type="html"><![CDATA[<p>什么是窗口</p><p>窗口分配器有几种</p><p>窗口如何实现增量计算和全量计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是窗口&lt;/p&gt;
&lt;p&gt;窗口分配器有几种&lt;/p&gt;
&lt;p&gt;窗口如何实现增量计算和全量计算&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Apache Flink" scheme="http://example.com/tags/Apache-Flink/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-门面模式</title>
    <link href="http://example.com/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-07T12:27:47.000Z</published>
    <updated>2021-08-07T12:36:22.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h1><p>门面模式又叫做外观模式，提供统一的一个接口，用来访问子系统中的一群接口；<br>门面模式定义了一个高层接口，让子系统更容易使用；门面模式属于结构型模式；  </p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-937cef58fcd4540a37854b0eeb31cda5c06.png">  </p><h3 id="Facade-门面类"><a href="#Facade-门面类" class="headerlink" title="Facade 门面类"></a>Facade 门面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承各个子系统功能，进行封装，一定程度上不遵循单一职责原则</span></span><br><span class="line">    SubSystemA subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">    SubSystemB subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">    SubSystemC subSystemC = <span class="keyword">new</span> SubSystemC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subSystemA.doA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subSystemB.doB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subSystemC.doC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子系统A"><a href="#子系统A" class="headerlink" title="子系统A"></a>子系统A</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子系统B"><a href="#子系统B" class="headerlink" title="子系统B"></a>子系统B</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子系统C"><a href="#子系统C" class="headerlink" title="子系统C"></a>子系统C</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doC</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上Facade类集成了三个子系统的类，在自己定义的方法中，并不是Facade自己实现的逻辑，而是<br>调用了对应子系统的方法，这种实现方式叫做门面模式；是不是很简单；  </p><p>看到这是不是有点似曾相识呢，没错，我们天天都在写的Controller,Service,Dao不就是门面模式吗，<br>没错，只不过把这种方式形成方法论，也就有了所谓的门面模式！  </p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>一些商业博客会有一个功能，就是发表文章或者评论点赞会获得一些积分啊，虚拟币啊,然后会有积分商城，在里面可以免费的兑换商品，其实很难凑的够积分，不够费劲的… 好了，结合伪代码来体验门面模式👇👇👇：  </p><p><strong>下面是一些演示所需要的类：</strong>  </p><h3 id="关系图如下"><a href="#关系图如下" class="headerlink" title="关系图如下"></a>关系图如下</h3><p><img src="https://oscimg.oschina.net/oscnet/up-e117a07cbd9489e5a037d1e64961c1062c7.png">  </p><h3 id="PaymentService-支付服务"><a href="#PaymentService-支付服务" class="headerlink" title="PaymentService 支付服务"></a>PaymentService 支付服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(GiftInfo giftInfo)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减&quot;</span> + giftInfo.getName() + <span class="string">&quot;积分成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QualityService-库存服务"><a href="#QualityService-库存服务" class="headerlink" title="QualityService 库存服务"></a>QualityService 库存服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualityService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(GiftInfo giftInfo)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验&quot;</span> + giftInfo.getName() + <span class="string">&quot;积分通过，库存充足！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ShipService-物流服务"><a href="#ShipService-物流服务" class="headerlink" title="ShipService 物流服务"></a>ShipService 物流服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShipService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doShip</span><span class="params">(GiftInfo giftInfo)</span></span>&#123;</span><br><span class="line">        System.out.println(giftInfo.getName() + <span class="string">&quot;生成物流订单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-非门面模式写法"><a href="#客户端-非门面模式写法" class="headerlink" title="客户端 非门面模式写法"></a>客户端 非门面模式写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    QualityService qualityService = <span class="keyword">new</span> QualityService();</span><br><span class="line">    PaymentService paymentService = <span class="keyword">new</span> PaymentService();</span><br><span class="line">    ShipService shipService = <span class="keyword">new</span> ShipService();</span><br><span class="line"></span><br><span class="line">    GiftInfo giftInfo = <span class="keyword">new</span> GiftInfo(<span class="string">&quot; 《Java编程思想》 &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qualityService.isAvailable(giftInfo))&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Quality not enough!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!paymentService.pay(giftInfo))&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Pay error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String shipNo = shipService.doShip(giftInfo);</span><br><span class="line">    System.err.println(<span class="string">&quot;Order shipNo:&quot;</span> + shipNo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法会将库存，支付和物流等服务都暴露给调用方，是很不安全的，而且造成客户端依赖严重，代码臃肿；  </p><h3 id="门面模式写法"><a href="#门面模式写法" class="headerlink" title="门面模式写法"></a>门面模式写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       FacadeService facadeService = <span class="keyword">new</span> FacadeService();</span><br><span class="line">       GiftInfo giftInfo = <span class="keyword">new</span> GiftInfo(<span class="string">&quot; 《Java编程思想》 &quot;</span>);</span><br><span class="line">       String shipNo = facadeService.doOrder(giftInfo);</span><br><span class="line">       System.err.println(<span class="string">&quot;Order shipNo:&quot;</span> + shipNo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面这种就是门面模式的写法👆 ， 相信大家应该很熟悉吧，这样的话，暴露给客户端就一个订单服务就可以了！</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>子系统越来越复杂，增加门面模式提供简单的接口，给用户使用；</strong></li><li><strong>构建多层的系统接口，利用门面对象作为每层的入口，简化层之间的调用</strong></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><code>Spring JdbcUtils</code><br><code>Mybatis configuration</code><br><code>Tomcat requestFacade responseFacade </code></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>简化了调用过程，无需深入了解子系统，以防止给子系统带来风险</strong></li></ul><p>根据上面礼品兑换的逻辑，用户根本不care你底层的兑换逻辑，什么库存啊，支付状态啊，生成订单逻辑等等，对于用户来说，我只需要一步下单即可；  </p><ul><li><strong>减少系统依赖，松耦合</strong></li></ul><p>这一点也是相对客户端来说，客户端只关心的的订单服务就好了，其他的库存，供应链等都不关系；</p><ul><li><strong>更好的划分访问层次，提高了安全性</strong></li></ul><p>合理的划分层次，减少底层系统的暴露，仅仅暴露一些必要的状态和接口，这一点大家应该都知道的，像service层调用Dao层，而不能在service层直接访问数据库；</p><ul><li><strong>遵循迪米特法则</strong></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><strong>当子系统的功能需要扩展或者修改的时候，上层封装可能要面临修改的风险，这样增加了后期的维护成本，也不遵循开闭原则</strong></li><li><strong>可能会违背单一职责原则</strong></li></ul><h2 id="门面模式和代理模式的区别"><a href="#门面模式和代理模式的区别" class="headerlink" title="门面模式和代理模式的区别"></a>门面模式和代理模式的区别</h2><p>简单来说，门面模式就是一种代理模式，是属于静态代理的模式；但是和静态代理又有一些区别，门面模式的侧重点在于对底层的封装，而静态代理则终于对代理对象的增强，除了调用受委托对象的方法之外，可以扩展额外的功能；<br>很多时候会把门面模式注入成单例，比如一些全局的Util,还有我们常见的一些Controller等等；  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;门面模式&quot;&gt;&lt;a href=&quot;#门面模式&quot; class=&quot;headerlink&quot; title=&quot;门面模式&quot;&gt;&lt;/a&gt;门面模式&lt;/h1&gt;&lt;p&gt;门面模式又叫做外观模式，提供统一的一个接口，用来访问子系统中的一群接口；&lt;br&gt;门面模式定义了一个高层接口，让子系统更容易使</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
