<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-06T10:47:33.600Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一条更新语句是如何执行的</title>
    <link href="http://example.com/wiki/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://example.com/wiki/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2021-12-06T10:47:01.000Z</published>
    <updated>2021-12-06T10:47:33.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条更新语句是如何执行的"><a href="#一条更新语句是如何执行的" class="headerlink" title="一条更新语句是如何执行的"></a>一条更新语句是如何执行的</h1><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还 记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后 到达存储引擎。</p><p>那么，一条更新语句的执行流程又是怎样的呢?</p><p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你 是不是心中也会不免会好奇，这是怎样做到的呢?</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个 整型字段c:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure><p>如果要将ID=2这一行的值加1，SQL语句就会这么写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看 这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p><img src="https://oscimg.oschina.net/oscnet/up-661c52fa2ca85182e119823265a003d152b.png" alt="MySQL的逻辑架构图"></p><p>你执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，<font color=blue>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会 把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</font></p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主 角:<strong>redo log(重做日志)和 binlog(归档日志)<strong>。如果接触MySQL，那这两个词肯定是绕不过 的，我后面的内容里也会不断地和你强调。</strong>不过话说回来，redo log和binlog在设计上有很多有 意思的地方，这些设计思路也可以用到你自己的程序里。</strong></p><h2 id="重要的日志模块-redo-log"><a href="#重要的日志模块-redo-log" class="headerlink" title="重要的日志模块:redo log"></a>重要的日志模块:redo log</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记 录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会 有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法:</p><ul><li><p>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉;</p></li><li><p>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p></li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到 这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老 花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的 帮助，每次记账都得翻账本，效率是不是低得让人难以忍受?</p><p>同样，<font color=blue>在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到 对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。</font>为了解决这个问 题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的<code>WAL</code>技术，WAL的全称是<code>Write- Ahead Logging</code>，<font color=red>它的关键点就是先写日志，再写磁盘</font>，也就是先写粉板，等不忙的时候再写账本。</p><blockquote><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log(粉板)里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作 记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p></blockquote><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎 么办呢?这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把 这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环 写，如下面这个图所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-846e5f4de8648713e24cdd7a028b547f4a6.png"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。 checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文 件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos 追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或 写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板 上的数据明确赊账账目。</p><h2 id="重要的日志模块-binlog"><a href="#重要的日志模块-binlog" class="headerlink" title="重要的日志模块:binlog"></a>重要的日志模块:binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块:一块是Server层，它主要做的是MySQL功能 层面的事情;还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)。</p><p>我想你肯定会问，为什么会有两份日志呢?</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有 crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL 的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— — 也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><font color=red>redolog是InnoDB引擎特有的;</font> binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redolog是物理日志，记录的是“在某个数据页上做了什么修改”; binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li><li>redolog是循环写的，空间固定会用完;binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语 句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一 行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁盘读入内存，然 后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redolog里面，此时redolog处 于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redolog改成提交(commit)状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://oscimg.oschina.net/oscnet/up-67fa7fe81e054dbaaae134dea88c9d651f3.png"></p><p><strong><font color=blue>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤:prepare和commit，这就是”两阶段提交”。</font></strong></p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢?这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得 从文章开头的那个问题说起:怎样让数据库恢复到半个月内任意一秒的状态?</p><p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承 诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期 做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数 据，那你可以这么做:</p><ul><li><p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备 份恢复到临时库;</p></li><li><p>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</p></li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法 来进行解释。</p><blockquote><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p></blockquote><p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语 句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢?</p><ul><li><p>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异 常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份 日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以 后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日 志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同。</p></li></ul><p>可以看到，如果不使用“两阶段提交”，<font color=blue>那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</font></p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀?</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，<font color=blue>这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</font></p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p><ul><li><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证 MySQL异常重启之后数据不丢失。</p></li><li><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建 议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p></li></ul><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。<strong>两阶段提交是跨系统维持数据逻辑 一致性时常用的一个方案</strong>，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢?或者说，它影响了这个数据库系统的哪个指标?</p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>一天一备好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份， 而要恢复出一个到昨天晚上23点的备份。</p><p>一周一备最坏情况就要应用一周的binlog了。系统的对应指标就是RTO(恢复目标时间)。</p><p>当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来 的，就需要你根据业务重要性来评估了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条更新语句是如何执行的&quot;&gt;&lt;a href=&quot;#一条更新语句是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;一条更新语句是如何执行的&quot;&gt;&lt;/a&gt;一条更新语句是如何执行的&lt;/h1&gt;&lt;p&gt;前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离：为什么你改了我还看不见</title>
    <link href="http://example.com/wiki/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://example.com/wiki/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2021-12-06T10:45:45.000Z</published>
    <updated>2021-12-06T10:46:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务隔离：为什么你改了我还看不见"><a href="#事务隔离：为什么你改了我还看不见" class="headerlink" title="事务隔离：为什么你改了我还看不见"></a>事务隔离：为什么你改了我还看不见</h1><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么?这时就要用到“事 务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事 务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引 擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代 的重要原因之一。</p><p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给 出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>提到事务，你肯定会想到ACID(Atomicity、Consistency、Isolation、Durability，即原子性、一 致性、隔离性、持久性)，今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要 在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括:读未提交(read uncommitted)、 读提交(read committed)、可重复读(repeatable read)和串行化(serializable )。下面我逐 一为你解释:</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 </li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 </li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中 只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://oscimg.oschina.net/oscnet/up-4263a773c9c9bf065d77d3f59bdb13b004f.png"></p><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3 的返回值分别是什么。</p><ul><li><p>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被 A看到了。因此，V2、V3也都是2。 </p></li><li><p>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</p></li><li><p>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求: 事务在执行期间看到的数据前后必须是一致的。</p></li><li><p>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后， 事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</p></li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。<font color="red">在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</font><font color=blue>在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的</font>。这里需要注意的是，“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念;而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致， 你一定要记得将MySQL的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用<code>show variables</code>来查看当前的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。 我想你可能会问那什么时候需要“可重复读”的场景呢?我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时 候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务 更新的影响。</p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复 读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://oscimg.oschina.net/oscnet/up-823d70046a45479d602f2a8e62bc33ad0a2.png"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看 到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多 个版本，就是数据库的多版本并发控制(MVCC)。对于read-view A，要得到1，就必须将当前 值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的 事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢? 答案是，在不需要的时候才删除。 也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢?就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数 据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占 用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终 提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终 只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候 展开。</p><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并 不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种:</p><ul><li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是 rollback。</p></li><li><p>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</p></li></ul><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的 查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式 每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾 虑，我建议你使用<font color=red>commit work and chain</font>语法。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语 句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查 找持续时间超过60s的事务。</p><p><code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 </code> </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也 是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢?</p><p>这个问题，我们可以从应用开发端和数据库端来看。 首先，从应用开发端来看:</p><ol><li>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的 general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架 如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我 见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务 可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过SETMAX_EXECUTION_TIME命令， 来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。(为什么会意外?在后 续的文章中会提到这类案例)</li></ol><p>其次，从数据库端来看:</p><ol><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill;</li><li>Percona的pt-kill这个工具不错，推荐使用;</li><li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题;</li><li>如果使用的是MySQL5.6或者更新版本，把innodb_undo_tablespaces设置成2(或更大的 值)。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务隔离：为什么你改了我还看不见&quot;&gt;&lt;a href=&quot;#事务隔离：为什么你改了我还看不见&quot; class=&quot;headerlink&quot; title=&quot;事务隔离：为什么你改了我还看不见&quot;&gt;&lt;/a&gt;事务隔离：为什么你改了我还看不见&lt;/h1&gt;&lt;p&gt;提到事务，你肯定不陌生，和数</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>全局锁和表锁：给表加个字段怎么这么多阻碍</title>
    <link href="http://example.com/wiki/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/"/>
    <id>http://example.com/wiki/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</id>
    <published>2021-12-06T10:43:52.000Z</published>
    <updated>2021-12-06T10:45:28.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局锁和表锁：给表加个字段怎么这么多阻碍"><a href="#全局锁和表锁：给表加个字段怎么这么多阻碍" class="headerlink" title="全局锁和表锁：给表加个字段怎么这么多阻碍"></a>全局锁和表锁：给表加个字段怎么这么多阻碍</h1><p>今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资 源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介 绍。</p><p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock</code> (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞:数据更新语句(数据的增删改)、数据定义语句(包括 建表、修改表结构等)和更新类事务的提交语句。</p><p><strong><font color=blue>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。</font></strong></p><p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。 注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险:</p><ul><li><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆;</p></li><li><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p></li></ul><p>看来加全局锁不太好。但是细想一下，<font color=red>备份为什么要加锁呢? 我们来看一下不加锁会有什么问题。</font></p><p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p><p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉 他的余额，然后往已购课程里面加上一门课。</p><p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢?你可以看一下这个图:</p><p><img src="https://oscimg.oschina.net/oscnet/up-b686a902a661f2ba86e2820a32f1fd1b7c5.png"></p><p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了</p><p>一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。 作为用户可别觉得这样可真好啊，你可以试想一下:如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果?</p><p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致 的。</p><p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视 图的，对吧?</p><p>是的，就是在可重复读隔离级别下开启一个事务。</p><p>官方自带的逻辑备份工具是mysqldump。当<code>mysqldump</code>使用参数<code>–single-transaction</code>的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是 可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢?一致性读是好，但前提是引擎要支持这个隔离级别。比如，<font color=blue>对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是 只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</font></p><p>所以，<font color=blue>single-transaction方法只适用于所有的表使用事务引擎的库</font>。如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用 InnoDB替代MyISAM的原因之一。</p><p>你也许会问，既然要全库只读，为什么不使用 <code>set global readonly=true</code>的方式呢? 确实 readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因:</p><ul><li>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备 库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么 MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个 库长时间处于不可写状态，风险较高。</li></ul><p>业务的更新不只是增删改数据(DML)，还有可能是加字段等修改表结构的操作(DDL)。不论 是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍 的表级锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种:一种是表锁，一种是元数据锁(meta data lock，MDL)。</p><p>表锁的语法是 <code>lock tables ...read/write</code>。与FTWRL类似，可以用unlock tables主动释放锁， 也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写 外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读 写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操 作。连写t1都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持 行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h3 id="metadata-lock"><a href="#metadata-lock" class="headerlink" title="metadata lock"></a>metadata lock</h3><p>另一类表级的锁是<font color=blue>MDL(metadata lock)</font>。MDL不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个 表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果 跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL，**<font color=blue>当对一个表做增删改查操作的时候，加MDL读锁;当 要对表做结构变更操作的时候，加MDL写锁。</font>**</p><ul><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p></li><li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线 程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p></li></ul><p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。</p><p><strong>比如下面这个例子，我经常看到有人掉到这个坑里:给一个小表加个字段，导致整个库挂了。</strong></p><p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操 作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也 会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p><p>⚠️备注:这里的实验环境是MySQL 5.6。</p><p><img src="https://oscimg.oschina.net/oscnet/up-968696480927070a2a696f9d8f05bccda93.png"></p><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是 MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写 锁，因此只能被阻塞。</p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也 会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被 锁住，等于这个表现在完全不可读写了。</p><p><strong><font color=red>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session 再请求的话，这个库的线程很快就会爆满。</font></strong></p><p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释 放，而会等到整个事务提交后再释放。</p><hr><p>基于上面的分析，<font color=red>我们来讨论一个问题，如何安全地给小表加字段?</font></p><p><strong>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。</strong></p><p>在MySQL的information_schema 库的 innodb_trx表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务 在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频 繁，而你不得不加个字段，你该怎么做呢?</p><p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面 设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后 面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n 这个语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>备份一般都会在备库上执行，你在用–single-transaction方法做逻 辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从 备库上会看到什么现象呢?</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p><a href="https://blog.csdn.net/qq_26502245/article/details/111688120">https://blog.csdn.net/qq_26502245/article/details/111688120</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全局锁和表锁：给表加个字段怎么这么多阻碍&quot;&gt;&lt;a href=&quot;#全局锁和表锁：给表加个字段怎么这么多阻碍&quot; class=&quot;headerlink&quot; title=&quot;全局锁和表锁：给表加个字段怎么这么多阻碍&quot;&gt;&lt;/a&gt;全局锁和表锁：给表加个字段怎么这么多阻碍&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一条sql是如何执行的</title>
    <link href="http://example.com/wiki/%E4%B8%80%E6%9D%A1sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://example.com/wiki/%E4%B8%80%E6%9D%A1sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2021-12-06T10:35:29.000Z</published>
    <updated>2021-12-06T10:36:26.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条sql到底是怎么执行的？"><a href="#一条sql到底是怎么执行的？" class="headerlink" title="一条sql到底是怎么执行的？"></a>一条sql到底是怎么执行的？</h1><p>这个问题等同于： <strong>请将一下mysql的基础架构</strong></p><h2 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h2><p>我们经常说，看一个事儿千万不 要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程， 让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本 质，更为快速地定位并解决问题。</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功 能模块中的执行过程。</p><p><img src="https://oscimg.oschina.net/oscnet/up-661c52fa2ca85182e119823265a003d152b.png" alt="MySQL的逻辑架构图"></p><p>大体来说，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><p>Server层包括<strong>连接器</strong>、<strong>查询缓存</strong>、<strong>分析器</strong>、<strong>优化器</strong>、<strong>执行器</strong>等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了 默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不 过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用 <code>engine=memory</code>, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功 能也不同，在后面的文章中，我们会讨论到引擎的选择。</p><p>从图中不难看出，不同的存储引擎共用一个Server层 ，也就是从连接器到执行器的部分。你可 以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执 行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连 接、获取权限、维持和管理连接。连接命令一般是这么写的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行 中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器 就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序 结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面 的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。<strong>修改完成后，只有再新建的连接才会使用新的权限设置</strong>。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命 令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这 一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://oscimg.oschina.net/oscnet/up-2a647e124a6b81400ac56c8602d08803a29.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制 的，<strong>默认值是8小时。</strong></p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒: <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，<font color=blue>所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</font></p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现 象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢?你可以考虑以下两种方案。</p><ul><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态。</p></li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步**:查询缓存。**</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过 的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是 查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客 户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存 中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结 果，这个效率会很高。</p><p><font color=blue>但是大多数情况下我会建议你不要使用查询缓存，为什么呢? 因为查询缓存往往弊大于利。</font></p><blockquote><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此 很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p></blockquote><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成 <code>DEMAND</code>，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定，像下面这个语句一样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><font color=red>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。</font></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，<font color=blue>MySQL需要知道你要做什么</font>，因此需要对SQL语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识 别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别 成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到<code>“You have an error in your SQL syntax”</code>的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4b5816275605cf38dcea5964ab23bfc1e16.png"></p><p><font color=red>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</font></p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是 否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否 等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些 疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，在后面的文章中单独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p><font color=blue>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶 段，开始执行语句。</font></p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用<strong>这个引擎</strong>提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的:</p><ul><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中;</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>至此，这个语句就执行完成了。 对于有索引的表，执行的逻辑也差不多。</p><p>第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。</p><p>这个值就是在执行器每次调用引擎获取数据行的时候累加的。<strong>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined并不是完全相同的</strong>。我们后面会专门有一篇文章来讲存储引擎的内部机制， 里面会有详细的说明。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那 肯定是会报“不存在这个列”的错误:     <code>“Unknown column ‘k’ in ‘where clause’”</code>。你觉得这个错误是 在我们上面提到的哪个阶段报出来的呢?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条sql到底是怎么执行的？&quot;&gt;&lt;a href=&quot;#一条sql到底是怎么执行的？&quot; class=&quot;headerlink&quot; title=&quot;一条sql到底是怎么执行的？&quot;&gt;&lt;/a&gt;一条sql到底是怎么执行的？&lt;/h1&gt;&lt;p&gt;这个问题等同于： &lt;strong&gt;请将一下m</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch使用规范</title>
    <link href="http://example.com/wiki/Elasticsearch%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/wiki/Elasticsearch%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</id>
    <published>2021-11-01T06:45:39.000Z</published>
    <updated>2021-11-01T06:46:32.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch使用规范"><a href="#Elasticsearch使用规范" class="headerlink" title="Elasticsearch使用规范"></a>Elasticsearch使用规范</h1><h2 id="查询规范建议"><a href="#查询规范建议" class="headerlink" title="查询规范建议"></a>查询规范建议</h2><ul><li><p><strong>定义好mappings和settings</strong>，不同的数据类型查询效率不一样，建议只需做精确查询以及范围查询的字段设置为keyword类型。对于要进行全文检索的字段设置合理的分词器。</p></li><li><p>对于只需要查询数据结果而不需要结果的相关度计算的情况，<strong>使用filter query能大幅提升你的查询效率</strong>。例如过滤某车牌和号码。</p></li><li><p><strong>避免一次性取出大量的数量</strong>：Elasticsearch被设计为一个搜索引擎，这使得它非常擅长获取与查询匹配的最优文档，但是不适合用来检索与特定查询匹配的所有文档。 Elasticsearch为了避免深分页，不允许使用分页（from&amp;size）查询10000条以后的数据，如果需要这样做，请确保使用Scroll API。 （Scroll API 后来不被推荐使用 可以使用search after）</p></li><li><p><strong>尽量细化查询条件</strong>，查询的条件越细，查询效率越高。</p></li><li><p><strong>选择合适的查询类型</strong>，比如term查询效率相对会高一些。</p></li><li><p><strong>优化路由</strong></p><p>  Elasticsearch写入文档时，文档会通过一个公式路由到一个索引中的一个分片上。默认公式如下：<br>  <code>shard_num = hash(_routing) % num_primary_shards</code><br>  _routing字段的取值，默认是_id字段，可以根据业务场景设置经常查询的字段作为路由字段。例如可以考虑将用户id、地区作为路由字段，查询时可以过滤不必要的分片，加快查询速度。</p></li><li><p>避免使用wildcard模糊匹配查询<br>  Elasticsearch默认支持通过*？正则表达式来做模糊匹配，数据量级别达到TB+甚至更高之后，模糊匹配查询通常会耗时比较长，甚至可能导致内存溢出，卡死乃至崩溃宕机的情况。所以数据量大的情况下，不要使用模糊匹配查询。</p></li><li><p>合理的配置使用index属性，analyzed和not_analyzed，根据业务需求来控制字段是否分词或不分词。只有groupby需求的字段，配置时就设置成not_analyzed,以提高查询或聚类的效率。</p></li><li><p>query_string或multi_match的查询字段越多，查询越慢。<br>  可以在mapping阶段，利用copy_to属性将多字段的值索引到一个新字段，multi_match时，用新的字段查询。</p></li><li><p><strong>日期字段的查询</strong><br>  尤其是用now的查询实际上是不存在缓存的，因此， 可以从业务的角度来考虑是否一定要用now,毕竟利用query cache是能够大大提高查询效率的。</p></li><li><p><strong>查询结果集的大小不能随意设置成大得离谱的值</strong><br>  如query.setSize不能设置成Integer.MAX_VALUE，<font color=red>因为ES内部需要建立一个数据结构来放指定大小的结果集数据。</font></p></li><li><p><strong>尽量避免使用script，万不得已需要使用的话，选择painless &amp; experssions引擎。</strong><br>  <font color=blue>一旦使用script查询，一定要注意控制返回，千万不要有死循环，因为ES没有脚本运行的超时控制，只要当前的脚本没执行完，该查询会一直阻塞。</font></p></li></ul><h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><ul><li><p><strong>分片(shard)容量</strong></p><ul><li>非日志型(搜索型、线上业务型)的shard容量在10~30GB（建议在10G）</li><li>日志型的shard容量在30~100GB（建议30G）</li><li>单个shard的文档个数不能超过21亿左右(Integer.MAX_VALUE - 128)<br>注：一个shard就是一个lucene分片，ES底层基于lucene实现。主分片个数一旦确定，就不可以更改。副本分片个数可以根据需要随时修改。</li></ul></li><li><p><strong>索引(index)数量</strong><br>大索引需要拆分：增强性能，风险分散。<br>反例：一个10T的索引，例如按date查询、name查询<br>正例：index_name拆成多个index_name_${date}<br>正例：index_name按hash拆分index_name_{1,2,3,…100..}<br>提示：索引和shard数并不是越多越好，对于批量读写都会有性能下降，所以要综合考虑性能和容量规划，同时配合压力测试，不存在真正的最优解。</p></li><li><p><strong>节点、分片、索引</strong><br>一个节点管理的shard数不要超过200个</p></li></ul><h2 id="配置使用规范"><a href="#配置使用规范" class="headerlink" title="配置使用规范"></a>配置使用规范</h2><ul><li><p><strong>shard个数（number_of_shards）</strong><br>  primery shard ：默认数量是1<br>  replica shard数量为1： 是每个primary shard 有多少个副本分片的意思<br>  primery shard = 1 ; replica shard = 2 ; 意味着一个索引，一共存在9个shard</p></li><li><p><strong>refresh频率（refresh_interval）</strong><br>  ES的定位是准实时搜索引擎，该值默认是1s，表示写入后1秒后可被搜索到，所以这里的值取决于业务对实时性的要求，注意这里并不是越小越好，刷新频率高也意味着对ES的开销也大，通常业务类型在1-5s，日志型在30s-120s，如果集中导入数据可将其设置为-1，ES会自动完成数据刷新（注意完成后更改回来，否则后续会出现搜索不到数据）</p></li><li><p><strong>使用别名（aliases）</strong>：不要过度依赖别名功能</p></li><li><p><strong>慢日志（slowlog）</strong></p></li><li><p><strong>设置合理的routing key(默认是id)</strong><br>  id不均衡：集群容量和访问不均衡，对于分布式存储是致命的</p></li><li><p><strong>关闭_all</strong><br>  ES6.0已经去掉，对容量（索引过大）和性能（性能下降）都有影响。    </p></li><li><p><strong>避免大宽表</strong><br>  ES默认最大1000，但建议不要超过100.    </p></li><li><p><strong>text类型的字段不要使用聚合查询。</strong><br>  <font color=red>text类型fileddata会加大对内存的占用，如果有需求使用，建议使用keyword</font></p></li><li><p><strong>聚合查询避免使用过多嵌套</strong><br>  <font color=red>聚合查询的中间结果和最终结果都会在内存中进行，嵌套过多，会导致内存耗尽</font></p></li><li><p><strong>修改index_buffer_size的设置</strong><br>  可以设置成百分数，也可设置成具体的大小，大小可根据集群的规模做不同的设置测试。<br>　　<code>indices.memory.index_buffer_size：10%（默认）</code><br>　　<code>indices.memory.min_index_buffer_size： 48mb（默认）</code><br>　　<code>indices.memory.max_index_buffer_size</code></p></li><li><p><strong>修改translog相关的设置</strong></p><ul><li>控制数据从内存到硬盘的操作频率，以减少硬盘IO。可将sync_interval的时间设置大一些。<br>　　      <code>index.translog.sync_interval：5s(默认)</code></li><li>控制tranlog数据块的大小，达到threshold大小时，才会flush到lucene索引文件。<br>  <code>index.translog.flush_threshold_size：512mb(默认)    </code></li></ul></li><li><p><strong>_id字段的使用</strong><br>  应尽可能避免自定义_id,以避免针对ID的版本管理；建议使用ES的默认ID生成策略或使用数字类型ID做为主键    </p></li><li><p><strong>Cache的设置及使用</strong></p><ul><li>QueryCache: ES查询的时候，使用filter查询会使用query cache,如果业务场景中的过滤查询比较多，建议将querycache设置大一些，以提高查询速度。<br><code>indices.queries.cache.size： 10%（默认）</code>，可设置成百分比，也可设置成具体值，如256mb。</li></ul><p>  当然也可以禁用查询缓存（默认是开启）, 通过<code>index.queries.cache.enabled：false</code>设置。</p><ul><li>FieldDataCache:在聚类或排序时，<code>field data cache</code>会使用频繁，因此，<strong>设置字段数据缓存的大小，在聚类或排序场景较多的情形下很有必要</strong><br>  可通过<code>indices.fielddata.cache.size：30%</code>或<code>具体值10GB</code>来设置。<strong>但是如果场景或数据变更比较频繁，设置cache并不是好的做法，因为缓存加载的开销也是特别大的。</strong></li><li><strong>ShardRequestCache</strong><br>查询请求发起后，每个分片会将结果返回给协调节点(Coordinating Node),由协调节点将结果整合。<br>如果有需求，可以设置开启;通过设置<strong>index.requests.cache.enable: true</strong>来开启。<br>不过，<code>shard request cache</code>只缓存<code>hits.total</code>, <code>aggregations</code>, <code>suggestions</code>类型的数据，并不会缓存hits的内容。也可以通过设置<code>indices.requests.cache.size: 1%（默认）</code>来控制缓存空间大小。    </li></ul></li></ul><h2 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h2><ul><li><p>text和keyword的用途必须分清：分词和关键词（确定字段是否需要分词）</p></li><li><p>确定字段是否需要独立存储</p></li><li><p>字段类型不支持修改，必须谨慎。</p></li><li><p>对不需要进行聚合/排序的字段禁用doc_values</p></li><li><p>不要在text做模糊搜索：</p></li></ul><h2 id="违规操作"><a href="#违规操作" class="headerlink" title="违规操作"></a>违规操作</h2><ul><li>原则：不要忽略设计，快就是慢，坏的索引设计后患无穷.</li><li>拒绝大聚合 ：ES计算都在JVM内存中完成。</li><li>拒绝模糊查询：es一大杀手</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;wildcard&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;title.keyword&quot;</span>:<span class="string">&quot;*张三*&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>拒绝深度分页<br>  ES获取数据时，每次默认最多获取10000条，获取更多需要分页，但存在深度分页问题，<font color=red>一定不要使用from/Size方式，建议使用scroll或者searchAfter方式。</font> scroll会把上一次查询结果缓存一定时间（通过配置scroll=1m实现)，所以在使用scroll时一定要保证search结果集不要太大。</p></li><li><p>基数查询<br>尽量不要用基数查询去查询去重后的数据量大小（kibana中界面上显示是Unique Count，Distinct Count等），即少用如下的查询：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;cardinality&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;userId&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>禁止查询 indexName-*</li><li>避免使用script、update_by_query、delete_by_query，对线上性能影响较大。</li></ul><h2 id="建议操作"><a href="#建议操作" class="headerlink" title="建议操作"></a>建议操作</h2><ul><li><strong>复用预索引数据方式来提高AGG性能</strong><br>  如通过terms aggregations替代range aggregations， 如要根据年龄来分组，分组目标是:少年（14岁以下） 青年（14-28） 中年（29-50） 老年（51以上）， <font color=red>可以在索引的时候设置一个age_group字段，预先将数据进行分类</font>。从而不用按age来做range aggregations,通过age_group字段就可以了。</li><li><strong>避免将不相关的数据放在同一个索引中，以避免稀疏，将这些文件放在不同的索引中往往更好。</strong></li></ul><h2 id="索引及字段命名规范"><a href="#索引及字段命名规范" class="headerlink" title="索引及字段命名规范"></a>索引及字段命名规范</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引受文件系统的限制。仅可能为小写字母，不能下划线开头。同时需遵守下列规则：</p><ul><li>不能包括 , /, *, ?, “, &lt;, &gt;, |, 空格, 逗号, #</li><li>7.0版本之前可以使用冒号:,但不建议使用并在7.0版本之后不再支持</li><li>不能以这些字符 -, _, + 开头</li><li>不能包括 . 或 …</li><li>长度不能超过 255 个字符</li></ul><p>以上这些命名限制是因为当Elasticsearch使用索引名称作为磁盘上的目录名称，这些名称必须符合不同操作系统的约定。<br>未来可能会放开这些限制，因为我们使用uuid关联索引放在磁盘上，而不使用索引名称</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><font color=red>7.0版本之后不再支持类型，默认为_doc</font></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>一个索引的shard数一旦确定不能改变</li><li>ES不支持事务ACID特性。</li><li>reindex：reindex可以实现索引的shard变更，但代价非常大：速度慢、对性能有影响，所以好的设计和规划更重要</li><li>field一旦创建不能更改mapping，如果需要修改，则必须重新创建索引</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.javajcw.com/72.html">Elasticsearch 使用规范</a></li><li><a href="https://blog.csdn.net/neweastsun/article/details/95868716">Elasticsearch索引及字段命名规范</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Elasticsearch使用规范&quot;&gt;&lt;a href=&quot;#Elasticsearch使用规范&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch使用规范&quot;&gt;&lt;/a&gt;Elasticsearch使用规范&lt;/h1&gt;&lt;h2 id=&quot;查询规范建</summary>
      
    
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及算法-树</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95-%E6%A0%91/</id>
    <published>2021-09-30T08:36:56.000Z</published>
    <updated>2021-09-30T08:36:56.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/draft/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/wiki/draft/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-09-27T14:11:31.478Z</published>
    <updated>2021-09-27T14:36:06.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式架构基石-远程通信协议"><a href="#分布式架构基石-远程通信协议" class="headerlink" title="分布式架构基石-远程通信协议"></a>分布式架构基石-远程通信协议</h1><h2 id="1、什么是通信"><a href="#1、什么是通信" class="headerlink" title="1、什么是通信"></a>1、什么是通信</h2><p>常见的通信有两种：</p><p>1、客户端与服务端之间的通信，通过http协议进行通信，或者服务器与服务器之间也会进行通信。</p><p>2、微服务架构中，节点之间的通信，通过RPC，实现类似于单体架构中的service方法的调用。</p><h2 id="2、Java中是如何进行通信呢"><a href="#2、Java中是如何进行通信呢" class="headerlink" title="2、Java中是如何进行通信呢"></a>2、Java中是如何进行通信呢</h2><p>通过socket套接字实现</p><blockquote><p>换行符 坑 导致提示Connection Reset (readline)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式架构基石-远程通信协议&quot;&gt;&lt;a href=&quot;#分布式架构基石-远程通信协议&quot; class=&quot;headerlink&quot; title=&quot;分布式架构基石-远程通信协议&quot;&gt;&lt;/a&gt;分布式架构基石-远程通信协议&lt;/h1&gt;&lt;h2 id=&quot;1、什么是通信&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="draft" scheme="http://example.com/categories/draft/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找（迭代&amp;递归）</title>
    <link href="http://example.com/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92%EF%BC%89/"/>
    <id>http://example.com/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92%EF%BC%89/</id>
    <published>2021-09-27T09:00:45.000Z</published>
    <updated>2021-09-27T09:59:51.333Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><p>输入: <code>nums = [-1,0,3,5,9,12], target = 9</code><br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><p>输入: <code>nums = [-1,0,3,5,9,12], target = 2</code><br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><p>提示：</p><blockquote><p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210927170614830.png" alt="image-20210927170614830"></p><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注意边界</span></span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">0</span>, nums.length - <span class="number">1</span>, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">          <span class="comment">// 注意mid取值的写法，避免越界异常</span></span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> find(left, mid - <span class="number">1</span>, target, nums);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> find(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查找第一个错误版本"><a href="#2-查找第一个错误版本" class="headerlink" title="2. 查找第一个错误版本"></a>2. 查找第一个错误版本</h2><p><a href="https://leetcode-cn.com/problems/first-bad-version/">leetcode278</a></p><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, bad = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">调用 isBadVersion(3) -&gt; false </span><br><span class="line">调用 isBadVersion(5) -&gt; true </span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure><h3 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-搜索插入位置"><a href="#3-搜索插入位置" class="headerlink" title="3. 搜索插入位置"></a>3. <a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></h2><p>Leetcode 35</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><h3 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot;&gt;https://leetcode-cn.com/problems/binary-search/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-二分查找&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    <category term="二分" scheme="http://example.com/categories/Leetcode/%E4%BA%8C%E5%88%86/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
    <category term="二分" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>面试官真的问我「分布式事务」了</title>
    <link href="http://example.com/wiki/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9C%9F%E7%9A%84%E9%97%AE%E6%88%91%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%8D%E4%BA%86/"/>
    <id>http://example.com/wiki/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9C%9F%E7%9A%84%E9%97%AE%E6%88%91%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%8D%E4%BA%86/</id>
    <published>2021-09-18T09:07:46.000Z</published>
    <updated>2021-09-27T08:16:38.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。</p><p>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。<br>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。<br>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</p><p>熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。<br>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。<br>顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展</p><p>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。<br>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。<br>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。</p><p>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1FJ411A7mV?from=search&seid=11114763225649816490&spm_id_from=333.337.0.0">bilibili 分布式事务详解</a></li><li><a href="http://blog.itpub.net/69946034/viewspace-2671341/">微服务分布式事务4种解决方案实战</a></li><li><a href="https://juejin.cn/post/6844903647197806605">再有人问你分布式事务，把这篇扔给他</a></li><li><a href="https://juejin.cn/post/6844903573667446797#heading-5">https://juejin.cn/post/6844903573667446797#heading-5</a>  </li><li><a href="https://juejin.cn/post/7012425995634343966?utm_source=gold_browser_extension">https://juejin.cn/post/7012425995634343966?utm_source=gold_browser_extension</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h2&gt;&lt;p&gt;CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。&lt;</summary>
      
    
    
    
    <category term="分布式事务" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-高性能IO模型</title>
    <link href="http://example.com/wiki/Redis-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/wiki/Redis-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-16T03:54:08.000Z</published>
    <updated>2021-09-16T07:53:17.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/liang24/p/14178730.html">Redis基础篇（二）高性能IO模型</a></li><li><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></li><li><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/liang24/p/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基础算法分类和思想</title>
    <link href="http://example.com/wiki/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%9D%E6%83%B3/"/>
    <id>http://example.com/wiki/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%9D%E6%83%B3/</id>
    <published>2021-09-15T11:44:40.000Z</published>
    <updated>2021-09-16T02:46:09.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的算法解题思路以及模版"><a href="#常见的算法解题思路以及模版" class="headerlink" title="常见的算法解题思路以及模版"></a>常见的算法解题思路以及模版</h1><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>可以参照下面👇文章：<br><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a>  </p><p><strong>练习题库</strong><br>都是回溯算法的题目：👇<br><a href="https://leetcode-cn.com/tag/backtracking/problemset/">https://leetcode-cn.com/tag/backtracking/problemset/</a>  </p><h2 id="整理的比较不错的资源"><a href="#整理的比较不错的资源" class="headerlink" title="整理的比较不错的资源"></a><font color=blue>整理的比较不错的资源</font></h2><p><a href="https://labuladong.gitbook.io/algo/mu-lu-ye/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa">📖labuladong 的算法小抄</a>  </p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/20210915202940.png" alt="20210915202940">  </p><p>整体来说还是相当不错的！  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见的算法解题思路以及模版&quot;&gt;&lt;a href=&quot;#常见的算法解题思路以及模版&quot; class=&quot;headerlink&quot; title=&quot;常见的算法解题思路以及模版&quot;&gt;&lt;/a&gt;常见的算法解题思路以及模版&lt;/h1&gt;&lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>理解ClassNotFoundException与NoClassDefFoundError的区别</title>
    <link href="http://example.com/wiki/%E7%90%86%E8%A7%A3ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/wiki/%E7%90%86%E8%A7%A3ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-09-15T07:43:20.000Z</published>
    <updated>2021-09-18T06:40:55.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h2><p>类加载时在指定路径下没有找到类文件</p><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>1、编译时存在某个类，但是运行时却找不到</p><blockquote><p>编译完成之后，手动删除一个类的class文件</p></blockquote><p>2、类根本就没有初始化成功，结果你还把它当做正常类使用，所以这事也不小，必须抛出ERROR告诉你不能再使用了</p><p><a href="https://cloud.tencent.com/developer/article/1356060">https://cloud.tencent.com/developer/article/1356060</a></p><p><a href="https://blog.csdn.net/u012129558/article/details/81540804">https://blog.csdn.net/u012129558/article/details/81540804</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ClassNotFoundException&quot;&gt;&lt;a href=&quot;#ClassNotFoundException&quot; class=&quot;headerlink&quot; title=&quot;ClassNotFoundException&quot;&gt;&lt;/a&gt;ClassNotFoundExcepti</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://example.com/wiki/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/wiki/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-09-15T03:21:41.000Z</published>
    <updated>2021-09-15T05:20:16.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis实现分布式锁的种种细节"><a href="#Redis实现分布式锁的种种细节" class="headerlink" title="Redis实现分布式锁的种种细节"></a>Redis实现分布式锁的种种细节</h1><p><strong>1、redis分布式锁直接使用 <code>setNx</code> 获取锁🔒，<code>del key</code> 释放锁</strong></p><p>会造成 「 <font color=blue><strong>死锁</strong></font> 」的问题，获取锁的线程没有释放锁，进程死掉了，其他进程永远无法获取锁</p><p><strong>2、给锁对应的key添加过期时间不就可以解决死锁的问题了吗？</strong></p><p><code>127.0.0.1:6379&gt; SETNX lock 1    // 加锁(integer) </code></p><p><code>127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期(integer) </code></p><p><font color=blue> <strong>上面两个命令有什么问题吗</strong>？</font></p><p>不是原子操作，可能 <code>expire</code>没有执行！使用如下复合命令 👇</p><p><code>127.0.0.1:6379&gt; SET lock 1 EX 10 NX</code></p><p><strong>3、这样还会存在一个问题，进程2释放的是进程1的锁</strong></p><p>进程1操作时间太久，还没有主动释放锁，锁就过期了，然后进程2获取锁，然后执行，进程2还没有执行完成，进程1执行完了，释放</p><p>锁，但是释放的是进程2的锁。「 <font color=blue><strong>释放他人锁</strong></font>」和 「 <font color=blue><strong>锁过期时间问题</strong></font>」</p><ol><li>加锁：<code>SET lock_key $unique_id EX $expire_time NX</code></li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 判断锁是自己的，才释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>4、锁过期时间不好评估怎么办？</strong></p><p><font color=blue><strong>假设一个方案：</strong></font></p><p><strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<font color=blue><strong>Redisson</strong></font>。</p><p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p><strong><font color=red>以上都是基于单机redis的角度思考的redis分布式锁的问题，主要有三点 👇</font></strong></p><p>1、死锁问题 （加过期时间解决）</p><p>2、释放他人锁 （添加线程标志）</p><p>3、锁过期时间问题 （守护线程自动续期）</p><p><strong><font color=red>如果是redis集群模式下会有哪些问题呢 👇</font></strong></p><p>在redis主从模式下，如果master节点突然宕机了，锁还没有同步到从节点是，是不是分布式锁就丢了？？？</p><p>Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。如何解决这个问题呢 ？ 「 **<font color=blue>RedLock</font>**」</p><p><strong>Redlock 的方案基于 2 个前提：</strong></p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/ybiN5Q89wI0CnLURGUz4vw">深度剖析：Redis 分布式锁到底安全吗？看完这篇文章彻底懂了！</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis实现分布式锁的种种细节&quot;&gt;&lt;a href=&quot;#Redis实现分布式锁的种种细节&quot; class=&quot;headerlink&quot; title=&quot;Redis实现分布式锁的种种细节&quot;&gt;&lt;/a&gt;Redis实现分布式锁的种种细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、redi</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap实现简易LRU</title>
    <link href="http://example.com/wiki/LinkedHashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93LRU/"/>
    <id>http://example.com/wiki/LinkedHashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93LRU/</id>
    <published>2021-09-15T02:07:58.000Z</published>
    <updated>2021-09-15T02:09:16.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目 #"></a>题目 <a href="https://hadyang.com/interview/docs/leetcode/LRUCache/#%E9%A2%98%E7%9B%AE">#</a></h2><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity , <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Integer integer = <span class="keyword">super</span>.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> integer == <span class="keyword">null</span> ? -<span class="number">1</span> : integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="keyword">this</span>.capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LruCache cache = <span class="keyword">new</span> LruCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get3 -&gt; &quot;</span> + cache.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;get1 -&gt; &quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get2 -&gt; &quot;</span> + cache.get(<span class="number">2</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get3 -&gt; &quot;</span> + cache.get(<span class="number">3</span>));</span><br><span class="line">        System.err.println(<span class="string">&quot;get4 -&gt; &quot;</span> + cache.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目 #&quot;&gt;&lt;/a&gt;题目 &lt;a href=&quot;https://hadyang.com/interview/docs/leetcode/LRUCache/#%E9%A2%98%E7</summary>
      
    
    
    
    
    <category term="LRU" scheme="http://example.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Redis操作为什么是原子性的？</title>
    <link href="http://example.com/wiki/Redis%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/wiki/Redis%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F/</id>
    <published>2021-09-14T02:46:36.000Z</published>
    <updated>2021-09-14T03:19:40.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis原则性操作"><a href="#Redis原则性操作" class="headerlink" title="Redis原则性操作"></a>Redis原则性操作</h2><p>对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么</p><p>执行失败，这就是Redis的命令是原子性的原因。</p><blockquote><p>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</p></blockquote><h2 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><p>Discard:Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如何开启一个事务</span><br><span class="line">watch key1 key2 . . . （监听相关key）</span><br><span class="line">multi (开启事务)</span><br><span class="line">// 对监听key的一些操作</span><br><span class="line">exec（执行事务）</span><br><span class="line">discard（取消事务）</span><br></pre></td></tr></table></figure><p><strong>EXEC</strong> 命令负责触发并执行事务中的所有命令：如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</p><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</p><h3 id="如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？"><a href="#如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？" class="headerlink" title="如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？"></a><font color=blue><strong>如果redis备份采用的是AOF的方式，事务执行一半被终止，会怎样？</strong></font></h3><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用 <code>redis-check-aof</code> 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h3 id="如果是集群下，watch命令有没有什么局限性？"><a href="#如果是集群下，watch命令有没有什么局限性？" class="headerlink" title="如果是集群下，watch命令有没有什么局限性？"></a><font color=blue>如果是集群下，watch命令有没有什么局限性？</font></h3><p>有没有想过为什么监听多个落在不同节点上的<code>key</code>，不同槽位的也不可以，会不被允许？在单节点下，<code>Redis</code>单线程执行，能够保证原子性，但在不同节点下，就是多进程多线程的问题，<code>Watch</code>自然就不能用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/lori/p/9300087.html">知其所以然~redis的原子性</a></li><li><a href="https://juejin.cn/post/6844904098987245576">Redis实现原子操作的两种方式与商品入库出库解决方案</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis原则性操作&quot;&gt;&lt;a href=&quot;#Redis原则性操作&quot; class=&quot;headerlink&quot; title=&quot;Redis原则性操作&quot;&gt;&lt;/a&gt;Redis原则性操作&lt;/h2&gt;&lt;p&gt;对Redis来说，执行get、set以及eval等API，都是一个一个的任务</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>大厂是如何进行【负载均衡】的</title>
    <link href="http://example.com/wiki/%E5%A4%A7%E5%8E%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E3%80%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%91%E7%9A%84/"/>
    <id>http://example.com/wiki/%E5%A4%A7%E5%8E%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E3%80%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%91%E7%9A%84/</id>
    <published>2021-09-13T12:46:14.000Z</published>
    <updated>2021-09-14T02:40:02.776Z</updated>
    
    <content type="html"><![CDATA[<p>轮训算法 随机算法</p><p>平滑加权轮询算法</p><p>一致性哈希算法</p><p>最小活跃数算法</p><h2 id="权重随机"><a href="#权重随机" class="headerlink" title="权重随机"></a>权重随机</h2><p>1、存到一个list中，权重高的存多份，权重低的，存少份，具体按照权重去比</p><p>2、把权重展示在坐标轴上，然后按照随机产生的数，在坐标轴上的分布来判断</p><p>curl -XPUT -u elastic ‘<a href="http://localhost:9200/_xpack/security/user/kibana/_password&#39;">http://localhost:9200/_xpack/security/user/kibana/_password&#39;</a>  -H ‘Content-Type: application/json’ -d ‘{  “password” : “redeem_123456” }’</p><p>curl -u my_admin -XPUT ‘<a href="http://localhost:9200/_xpack/security/user/elastic/_password?pretty&#39;">http://localhost:9200/_xpack/security/user/elastic/_password?pretty&#39;</a> -H ‘Content-Type: application/json’ -d’ {  “password” : “new_password” } ‘ </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1vz4y1679x?p=45">2021年阿里巴巴JAVA面试100道</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;轮训算法 随机算法&lt;/p&gt;
&lt;p&gt;平滑加权轮询算法&lt;/p&gt;
&lt;p&gt;一致性哈希算法&lt;/p&gt;
&lt;p&gt;最小活跃数算法&lt;/p&gt;
&lt;h2 id=&quot;权重随机&quot;&gt;&lt;a href=&quot;#权重随机&quot; class=&quot;headerlink&quot; title=&quot;权重随机&quot;&gt;&lt;/a&gt;权重随机&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>来自TCP协议的灵魂拷问</title>
    <link href="http://example.com/wiki/%E6%9D%A5%E8%87%AATCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE/"/>
    <id>http://example.com/wiki/%E6%9D%A5%E8%87%AATCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE/</id>
    <published>2021-09-10T12:05:58.000Z</published>
    <updated>2021-09-11T10:56:56.612Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-TCP-是用来解决什么问题？"><a href="#1-TCP-是用来解决什么问题？" class="headerlink" title="1. TCP 是用来解决什么问题？"></a>1. TCP 是用来解决什么问题？</h4><h4 id="2-为什么要-TCP，IP-层实现控制不行么？"><a href="#2-为什么要-TCP，IP-层实现控制不行么？" class="headerlink" title="2. 为什么要 TCP，IP 层实现控制不行么？"></a>2. 为什么要 TCP，IP 层实现控制不行么？</h4><p>之所以要<strong>提取出一个 TCP 层来实现控制是因为 IP 层涉及到的设备更多</strong>，一条数据在网络上传输需要经过很多设备，而设备之间需要靠 IP 来寻址。</p><p>假设 IP 层实现了控制，那是不是涉及到的设备都需要关心很多事情？整体传输的效率是不是大打折扣了？</p><h4 id="3-连接到底是什么？"><a href="#3-连接到底是什么？" class="headerlink" title="3. 连接到底是什么？"></a>3. 连接到底是什么？</h4><p>我们已经知道了为什么需要独立出 TCP 这一层，并且这一层主要是用来干嘛的，接下来就来看看它到底是怎么干的。</p><p>我们都知道 TCP 是面向连接的，那这个连接到底是个什么东西？真的是拉了一条线让端与端之间连起来了？</p><p><strong>所谓的连接其实只是双方都维护了一个状态，通过每一次通信来维护状态的变更</strong>，使得看起来好像有一条线关联了对方。</p><h4 id="4-TCP报文头是什么样的"><a href="#4-TCP报文头是什么样的" class="headerlink" title="4. TCP报文头是什么样的"></a>4. TCP报文头是什么样的</h4><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910200950214.png" alt="image-20210910200950214" style="zoom:50%;" /><p>首先可以看到 TCP 包只有端口，没有 IP。</p><p><font color=blue> <strong>Seq 就是 Sequence Number 即序号，它是用来解决乱序问题的</strong></font></p><p><font color=green><strong>ACK 就是 Acknowledgement Numer 即确认号，它是用来解决丢包情况的，告诉发送方这个包我收到啦</strong></font></p><p>标志位就是 TCP flags 用来标记这个包是什么类型的，用来控制 TPC 的状态。</p><p>窗口就是滑动窗口，Sliding Window，用来流控。</p><h4 id="5-三次握手流程是怎么样的"><a href="#5-三次握手流程是怎么样的" class="headerlink" title="5. 三次握手流程是怎么样的"></a>5. 三次握手流程是怎么样的</h4><p><font color=prey><strong>为什么要握手？</strong></font></p><p><strong>其实主要就是为了初始化Seq Numer</strong>，SYN 的全称是 Synchronize Sequence Numbers，这个序号是用来保证之后传输数据的顺序性。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910201233569.png" alt="image-20210910201233569" style="zoom:50%;" /><h4 id="6-第一次握手seq是怎么取值的"><a href="#6-第一次握手seq是怎么取值的" class="headerlink" title="6. 第一次握手seq是怎么取值的"></a>6. 第一次握手seq是怎么取值的</h4><p>不知道大家有没有想过 ISN 的值要设成什么？代码写死从零开始？</p><p>想象一下如果写死一个值，比如 0 ，那么假设已经建立好连接了，client 也发了很多包比如已经第 20 个包了，然后网络断了之后 client 重新，端口号还是之前那个，然后序列号又从 0 开始，此时服务端返回第 20 个包的ack，客户端是不是傻了？</p><p>所以 RFC793 中认为 ISN 要和一个假的时钟绑定在一起<strong>ISN 每四微秒加一，当超过 2 的 32 次方之后又从 0 开始，要四个半小时左右发生 ISN 回绕</strong>。</p><p>所以 ISN 变成一个递增值，真实的实现还需要加一些随机值在里面，防止被不法份子猜到 ISN。</p><h4 id="7-SYN-超时了怎么处理？"><a href="#7-SYN-超时了怎么处理？" class="headerlink" title="7. SYN 超时了怎么处理？"></a>7. SYN 超时了怎么处理？</h4><p>也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？</p><p>我脑海中一想到的就是重试，但是不能连续快速重试多次，你想一下，假设 client 掉线了，你总得给它点时间恢复吧，所以呢需要<strong>慢慢重试，阶梯性重试</strong>。</p><p>在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。</p><h4 id="8-SYN泛洪攻击是什么？"><a href="#8-SYN泛洪攻击是什么？" class="headerlink" title="8. SYN泛洪攻击是什么？"></a>8. SYN泛洪攻击是什么？</h4><p>你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。</p><p>使得 server 的 SYN 队列耗尽，无法处理正常的建连请求。</p><p><font color=red><strong>所以怎么办？如何解决SYN攻击呢？</strong></font></p><p>可以开启 tcp_syncookies，那就用不到 SYN 队列了。</p><p>SYN 队列满了之后 TCP 根据自己的 ip、端口、然后对方的 ip、端口，对方 SYN 的序号，时间戳等一波操作生成一个特殊的序号（即 cookie）发回去，如果对方是正常的 client 会把这个序号发回来，然后 server 根据这个序号建连。</p><p>或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。</p><h4 id="9-什么是四次挥手？"><a href="#9-什么是四次挥手？" class="headerlink" title="9. 什么是四次挥手？"></a>9. 什么是四次挥手？</h4><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910202311830.png" alt="image-20210910202311830" style="zoom:50%;" /><p><font color=red><strong>那么所有的断开链接都是上面锁描述的那样吗？</strong></font></p><p>可以看到👇双方都主动发起断开请求所以各自都是主动发起方，状态会从 FIN_WAIT_1 都进入到 CLOSING 这个过度状态然后再到 TIME_WAIT。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910202609442.png" alt="image-20210910202609442" style="zoom:50%;" /><h4 id="10-挥手一定需要四次吗？"><a href="#10-挥手一定需要四次吗？" class="headerlink" title="10. 挥手一定需要四次吗？"></a>10. 挥手一定需要四次吗？</h4><p>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack ，然后继续发送数据。</p><p>等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。</p><p><font color=blue><strong>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？</strong></font></p><h4 id="11-为什么要有-TIME-WAIT"><a href="#11-为什么要有-TIME-WAIT" class="headerlink" title="11. 为什么要有 TIME_WAIT?"></a>11. 为什么要有 TIME_WAIT?</h4><p>断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入 CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。</p><p>MSL 是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux 实际实现是 30s，那么 2MSL 是一分钟。</p><p><font color=red><strong>那么为什么要等 2MSL 呢？</strong></font></p><ul><li>就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。</li><li>假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</li></ul><h4 id="12-等待-2MSL-会产生什么问题？"><a href="#12-等待-2MSL-会产生什么问题？" class="headerlink" title="12. 等待 2MSL 会产生什么问题？"></a>12. 等待 2MSL 会产生什么问题？</h4><p>如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL 才会释放资源。</p><p>如果是客户端主动关闭大量的连接，那么在 2MSL 里面那些端口都是被占用的，端口只有 65535 个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？</p><p><strong>对于服务端来说就是资源得不到立即释放，对于客户端来说，就是端口不能立即释放来发起新的链接。</strong></p><h4 id="13-超时重传机制是为了解决什么问题？"><a href="#13-超时重传机制是为了解决什么问题？" class="headerlink" title="13. 超时重传机制是为了解决什么问题？"></a>13. 超时重传机制是为了解决什么问题？</h4><p>前面我们提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。</p><p>TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5 那说明前面四个包你都收到了，就是这么回事儿。</p><p>不过这里要注意，SeqNum 和 ACK 都是<strong>以字节数为单位的</strong>，也就是说假设你收到了1、2、4 但是 3 没有收到你不能 ACK 5，如果你回了 5 那么发送方就以为你5之前的都收到了。</p><p>所以<strong>只能回复确认最大连续收到包</strong>，也就是 3。</p><h4 id="14-为什么还需要快速重传机制？"><a href="#14-为什么还需要快速重传机制？" class="headerlink" title="14. 为什么还需要快速重传机制？"></a>14. 为什么还需要快速重传机制？</h4><p>超时重传是按时间来驱动的，如果是网络状况真的不好的情况，超时重传没问题，但是如果网络状况好的时候，只是恰巧丢包了，那等这么长时间就没必要。</p><p>于是又引入了数据驱动的重传叫快速重传，什么意思呢？就是发送方如果连续三次收到对方相同的确认号，那么马上重传数据。</p><p>因为连续收到三次相同 ACK 证明当前网络状况是 ok 的，那么确认是丢包了，于是立马重发，没必要等这么久。</p><p><font color=blue>就是发送方收到接收方连续的ACK报文之后，马上重传报文。</font></p><h4 id="14-SACK-的引入是为了解决什么问题？"><a href="#14-SACK-的引入是为了解决什么问题？" class="headerlink" title="14. SACK 的引入是为了解决什么问题？"></a>14. SACK 的引入是为了解决什么问题？</h4><p><font color=blue>SACK 即 Selective Acknowledgment，它的引入就是为了解决发送方不知道该重传哪些数据的问题。</font></p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910204103120.png" alt="image-20210910204103120" style="zoom: 50%;" /><p>SACK 就是接收方会回传它已经接受到的数据，这样发送方就知道哪一些数据对方已经收到了，所以就可以选择性的发送丢失的数据。</p><p>如图，通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 我收到了，6000-7000的数据我收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999 的那一波数据应该是丢了，于是重传。</p><p>而且如果数据是多段不连续的， SACK 也可以发送，比如 SACK 0-500,1000-1500，2000-2500。就表明这几段已经收到了。</p><h4 id="15-滑动窗口是什么"><a href="#15-滑动窗口是什么" class="headerlink" title="15. 滑动窗口是什么"></a>15. 滑动窗口是什么</h4><p>我们已经知道了 TCP 有序号，并且还有重传，但是这还不够，因为我们不是愣头青，还需要根据情况来控制一下发送速率，因为网络是复杂多变的，有时候就会阻塞住，而有时候又很通畅。</p><p>所以发送方需要知道接收方的情况，好控制一下发送的速率，不至于蒙着头一个劲儿的发然后接受方都接受不过来。</p><p><font color=blue>因此 TCP 就有个叫滑动窗口的东西来做流量控制，也就是接收方告诉发送方我还能接受多少数据，然后发送方就可以根据这个信息来进行数据的发送。</font></p><p>以下是<strong>发送方维护的窗口</strong>，就是黑色圈起来的。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910204451140.png" alt="image-20210910204451140" style="zoom:50%;" /><p>图中的 #1 是已收到 ACK 的数据，#2 是已经发出去但是还没收到 ACK 的数据，#3 就是在窗口内可以发送但是还没发送的数据。#4 就是还不能发送的数据。</p><h4 id="16-如果接收方回复的窗口一直是-0-怎么办？"><a href="#16-如果接收方回复的窗口一直是-0-怎么办？" class="headerlink" title="16. 如果接收方回复的窗口一直是 0 怎么办？"></a>16. 如果接收方回复的窗口一直是 0 怎么办？</h4><p>上文已经说了发送方式根据接收方回应的 window 来控制能发多少数据，如果接收方一直回应 0，那发送方就杵着？</p><p>你想一下，发送方发的数据都得到 ACK 了，但是呢回应的窗口都是 0 ，这发送方此时不敢发了啊，那也不能一直等着啊，这 Window 啥时候不变 0 啊？</p><p><font color=blue>于是 TCP 有一个 Zero Window Probe 技术，发送方得知窗口是 0 之后，会去探测探测这个接收方到底行不行，也就是发送 ZWP 包给接收方。</font></p><h4 id="17-已经有滑动窗口了为什么还要拥塞控制？"><a href="#17-已经有滑动窗口了为什么还要拥塞控制？" class="headerlink" title="17. 已经有滑动窗口了为什么还要拥塞控制？"></a>17. 已经有滑动窗口了为什么还要拥塞控制？</h4><p>前面我们提到了重传，如果不管网络整体的情况，肯定就是对方没给 ACK ，那我就无脑重传。</p><p>如果此时网络状况很差，所有的连接都这样无脑重传，是不是网络情况就更差了，更加拥堵了？</p><h4 id="18-拥塞控制怎么搞？"><a href="#18-拥塞控制怎么搞？" class="headerlink" title="18. 拥塞控制怎么搞？"></a>18. 拥塞控制怎么搞？</h4><p>主要有以下几个步骤来搞：</p><p>1、慢启动，探探路。</p><p>2、拥塞避免，感觉差不多了减速看看 </p><p>3、拥塞发生快速重传/恢复</p><h4 id="19-什么是-TCP-半连接队列和全连接队列？"><a href="#19-什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="19. 什么是 TCP 半连接队列和全连接队列？"></a>19. 什么是 TCP 半连接队列和全连接队列？</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accepet 队列；</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210911125838391.png" alt="image-20210911125838391" style="zoom: 33%;" /><h4 id="20-如何查看全链接队列"><a href="#20-如何查看全链接队列" class="headerlink" title="20. 如何查看全链接队列"></a>20. 如何查看全链接队列</h4><p><code>ss -lnt | grep port</code></p><p><strong>查看全链接队列溢出情况：</strong></p><p><code>netstat -s | </code></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/LUtk6u_zv0w8g8GIGWEuCw">万字长文 | 23 个问题 TCP 疑难杂症全解析</a></li><li><a href="https://mp.weixin.qq.com/s/tRXlq1hErqKQLMMLcxoXvg">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-TCP-是用来解决什么问题？&quot;&gt;&lt;a href=&quot;#1-TCP-是用来解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;1. TCP 是用来解决什么问题？&quot;&gt;&lt;/a&gt;1. TCP 是用来解决什么问题？&lt;/h4&gt;&lt;h4 id=&quot;2-为什么要-</summary>
      
    
    
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>详解网络IO</title>
    <link href="http://example.com/wiki/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://example.com/wiki/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9CIO/</id>
    <published>2021-09-10T06:43:37.000Z</published>
    <updated>2021-09-16T07:34:11.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习思路可以是网络IO的演变过程，从【阻塞io】到【非阻塞io】然后到【多路复用】，后续还有【异步io】</p><h2 id="1-阻塞io"><a href="#1-阻塞io" class="headerlink" title="1. 阻塞io"></a>1. 阻塞io</h2><p>应用程序进行 recvfrom 系统调用时将阻塞在此调用，直到该套接字上有数据并且复制到用户空间缓冲区。该模式一般配合多线程使用，</p><p>应用进程每接收一个连接，为此连接创建一个线程来处理该连接上的读写以及业务处理。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910160418632.png" alt="image-20210910160418632" style="zoom:50%;" /><p><strong>缺点</strong>：如果套接字上没有数据，进程将一直阻塞。这时其他套接字上有数据也不能进行及时处理。</p><p>如果是多线程方式，除非连接关闭否则线程会一直存在，而线程的创建、维护和销毁非常消耗资源，所以能建立的连接数量非常有限。</p><h2 id="2-非阻塞io"><a href="#2-非阻塞io" class="headerlink" title="2. 非阻塞io"></a>2. 非阻塞io</h2><p>应用进程调用recefrom函数之后，不等待内核数据准备完成，而是不断轮训（注意这里是用户进程不断轮训，会有用户态到内核态的切换，性能损耗比较严重）</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910160610025.png" alt="image-20210910160610025" style="zoom:50%;" /><p><strong>优点</strong>：代码编写相对简单，进程不会阻塞，可以在同一线程中处理所有连接。</p><p><strong>缺点</strong>：需要频繁的轮询，比较耗CPU，在并发量很大的时候将花费大量时间在没有任何数据的连接上轮询。所以该模型只在专门提供某种功能的系统中才会出现。</p><h2 id="3-io复用"><a href="#3-io复用" class="headerlink" title="3. io复用"></a>3. io复用</h2><p>应用进程阻塞于 <strong>select/poll/epoll</strong> 等系统函数等待某个连接变成可读（有数据过来），再调用 recvfrom 从连接上读取数据。虽然此模式也会阻塞在 select/poll/epoll 上，但与阻塞IO 模型不同它阻塞在等待多个连接上有读（写）事件的发生，明显提高了效率且增加了单线程/单进程中并行处理多连接的可能。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910160743784.png" alt="image-20210910160743784" style="zoom:50%;" /><p><strong>优点</strong>：统一管理连接，不一定采用多线程的方式，同时也不需要轮询。只需要阻塞于 select 即可，可以同时管理多个连接。</p><p><strong>缺点</strong>：当 select/poll/epoll 管理的连接数过少时，这种模型将退化成阻塞 IO 模型。并且还多了一次系统调用：一次 select/poll/epoll 一次 recvfrom。</p><h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h3><p>1、句柄上限- 默认打开的FD有限制,1024个。</p><p>2、重复初始化-每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，内核进行遍历。</p><p>3、逐个排查所有FD状态效率不高。</p><h3 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h3><p>poll和select相比在本质上变化不大，只是poll没有了select方式的最大文件描述符数量的限制。</p><p>缺点：逐个排查所有FD状态效率不高。</p><h3 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h3><p><font color=blue>没有fd个数限制，用户态拷贝到内核态只需要一次，使用事件通知机制来触发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的I/O操作。</font></p><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：</p><p><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即</p><p>处理该事件`。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序必须立即处</p><p>理该事件`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p><strong>缺点</strong>：</p><ul><li>跨平台，Linux 支持最好。</li><li>底层实现复杂。</li><li>同步。</li></ul><h3 id="3-4-select-poll-epoll之间的区别"><a href="#3-4-select-poll-epoll之间的区别" class="headerlink" title="3.4 select/poll/epoll之间的区别"></a>3.4 select/poll/epoll之间的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910161725824.png" alt="image-20210910161725824"></p><h2 id="4-信号驱动io"><a href="#4-信号驱动io" class="headerlink" title="4. 信号驱动io"></a>4. 信号驱动io</h2><p>应用进程创建 SIGIO 信号处理程序，此程序可处理连接上数据的读写和业务处理。并向操作系统安装此信号，进程可以往下执行。当内核数据准备好会向应用进程发送信号，触发信号处理程序的执</p><p>行。再在信号处理程序中进行 recvfrom 和业务处理。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910161310686.png" alt="image-20210910161310686" style="zoom:50%;" /><p><strong>优点：</strong>非阻塞</p><p><strong>缺点：</strong>在前一个通知信号没被处理的情况下，后一个信号来了也不能被处理。所以在信号量大</p><p>的时候会导致后面的信号不能被及时感知。</p><h2 id="5-异步io"><a href="#5-异步io" class="headerlink" title="5. 异步io"></a>5. 异步io</h2><p>应用进程通过 aio_read 告知内核启动某个操作，在整个操作完成之后内核再通知应用进程，包括把</p><p>数据从内核空间拷贝到用户空间。</p><p><font color=blue><strong>信号驱动 IO 是内核通知我们何时可以启动一个 IO 操作，而异步 IO 模型是由内核通知我们 IO 操作何时完成</strong></font>。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210910161126217.png" alt="image-20210910161126217" style="zoom:50%;" /><p><strong><font color=green>注：前 4 种模型都是带有阻塞部分的，有的阻塞在等待数据准备好，有的阻塞在从内核空间拷贝数据到用户空间(信号量io)。而这种模型应用进程从调用 aio_read 到数据被拷贝到用户空间，不用任何阻塞，所以该种模式叫异步 IO 模型。</font></strong></p><p><strong>优点</strong>：没有任何阻塞，充分利用系统内核将 IO 操作与计算逻辑并行。</p><p><strong>缺点</strong>：编程复杂、操作系统支持不好。目前只有 windows 下的 iocp 实现了真正的 AIO。linux </p><p>下在 2.6 版本中才引入，目前并不完善，所以 Linux 下一般采用多路复用模型。</p><h2 id="6-Reactor-和-Proactor"><a href="#6-Reactor-和-Proactor" class="headerlink" title="6. Reactor 和 Proactor"></a>6. Reactor 和 Proactor</h2><p>Reactor 是<font color=blue><strong>非阻塞同步网络模式，感知的是就绪可读写事件</strong></font>。在每次  感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读  取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，  读取完数据后应用进程才能处理数据。</p><p>Proactor 是<font color=blue><strong>异步网络模式， 感知的是已完成的读写事件</strong></font>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，<font color=green><strong>这里的读写工作全程由操作系统来做，并不需</strong></font>要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据**</font>，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p><p>因此，<font color=blue><strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong></font>，而 <font color=green> **Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</font>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/20210910173232.png">  </p><p>可参见 <a href="https://mp.weixin.qq.com/s/px6-YnPEUCEqYIp_YHhDzg">https://mp.weixin.qq.com/s/px6-YnPEUCEqYIp_YHhDzg</a>    </p><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/x-AZQO5uiuu5svIvScotzA">「网络IO套路」当时就靠它追到女友</a></li><li><a href="https://juejin.cn/post/6844904200141438984">彻底理解 IO多路复用</a></li><li><a href="https://juejin.cn/post/6844903678227267597">看完这个，Java IO从此不在难</a></li><li><a href="https://juejin.cn/post/6844904048198451214">从操作系统层面理解Linux下的网络IO模型</a></li><li><a href="https://juejin.cn/post/6844903728718462990#heading-8">五种IO模型介绍和对比</a></li><li><a href="https://juejin.cn/post/6844903812738596878#heading-3">服务器网络编程之 IO 模型</a></li><li><a href="https://www.processon.com/view/5f1e369ee0b34d54dacc18b9?fromnew=1">网络编程与高效IO</a></li><li><a href="https://juejin.cn/post/6979761228251922469">高性能网络IO模式Reactor</a></li><li><a href="https://juejin.cn/post/6844903488170786824#heading-15">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247489558&idx=1&sn=7a96604032d28b8843ca89cb8c129154&scene=21#wechat_redirect">这次答应我，一举拿下 I/O 多路复用！</a></li><li><a href="https://mp.weixin.qq.com/s/px6-YnPEUCEqYIp_YHhDzg">原来 8 张图，就能学废 Reactor 和 Proactor</a></li><li><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></li><li><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习思路可以是网络IO的演变过程，从【阻塞io】到【非阻塞io】然后到【多路复用】，后续还有【异步io】&lt;/p&gt;
&lt;h2 id=&quot;1-阻塞i</summary>
      
    
    
    
    
    <category term="网络IO" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9CIO/"/>
    
    <category term="epoll" scheme="http://example.com/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>Netty基础</title>
    <link href="http://example.com/wiki/Netty%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/wiki/Netty%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-09T06:56:22.000Z</published>
    <updated>2021-09-18T03:54:25.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1、什么是粘包和拆包，Netty如何解决这个问题<br><a href="https://www.cnblogs.com/rickiyang/p/12904552.html">https://www.cnblogs.com/rickiyang/p/12904552.html</a>  </p><p>这部分可能设计到的技术点 【TCP窗口滑动】【IO模型】【零拷贝】【socket缓冲区】【Nagle 算法】【MSS和MTU】</p><p>2、Netty中的空轮训bug是什么，如何解决这个问题？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.processon.com/view/60384ce3e401fd0290002128?fromnew=1"><strong>Netty（Reactor线程模型/零拷贝/空轮询）Netty（Reactor线程模型/零拷贝/空轮询）</strong></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;p&gt;1、什么是粘包和拆包，Netty如何解决这个问题&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/r</summary>
      
    
    
    
    
    <category term="NIO" scheme="http://example.com/tags/NIO/"/>
    
    <category term="Netty" scheme="http://example.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝技术</title>
    <link href="http://example.com/wiki/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/wiki/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</id>
    <published>2021-09-09T06:12:33.000Z</published>
    <updated>2021-09-09T07:45:08.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>什么是零拷贝技术？</p><p>为什么需要零拷贝？</p><p>零拷贝有哪些应用场景？</p><p>什么叫做用户态到内核态切换？为什么需要两种状态的切换？</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="传统的数据拷贝技术"><a href="#传统的数据拷贝技术" class="headerlink" title="传统的数据拷贝技术"></a>传统的数据拷贝技术</h3><p>没有DMA的数据拷贝流程如下 👇</p><p>用户发起read的系统调用，应用进程从用户态进入到内核态，CPU发送IO请求到磁盘，磁盘准备好数据之后发送中断信号。</p><p>之后CPU响应中断，讲磁盘缓冲区数据拷贝到内核缓冲区，数据拷贝完成之后，在把内核缓冲区的数据拷贝到应用进程的缓冲区中。</p><p>这个过程中CPU是一直占用的，不能进行其他的操作。最后，应用进程在从内核态切换到用户态。一共进行和4次数据拷贝和2次用户态/内核态的切换。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210909150331477.png" alt="image-20210909150331477" style="zoom:50%;" /><p>为了提高CPU 的执行效率，于是又了DMA技术。</p><p>什么是 DMA 技术？简单理解就是，<font color=blue>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</font>。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210909151257401.png" alt="image-20210909151257401" style="zoom:50%;" /><p>1、用户进程调用read系统指令，进程从用户态切换到内核态，CPU发起IO请求，把读取磁盘数据的任务交给DMA</p><p>2、DMA发送IO请求到磁盘，磁盘准备好数据之后，发送中断信号，由DMA响应中断请求</p><p>3、DMA读取磁盘缓冲区的数据到内核缓冲区，数据读取完成之后，通知CPU进行处理</p><p>4、CPU把内核缓冲区的数据拷贝到应用缓冲期中，最后，进程从内核态切换到用户态。</p><h3 id="为什么系统调用的时候需要-「用户态」和-「内核态」的切换"><a href="#为什么系统调用的时候需要-「用户态」和-「内核态」的切换" class="headerlink" title="为什么系统调用的时候需要 「用户态」和 「内核态」的切换"></a>为什么系统调用的时候需要 「用户态」和 「内核态」的切换</h3><p>这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>这么设计是为了操作系统的安全考虑。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行</p><h2 id="零拷贝的实现方式"><a href="#零拷贝的实现方式" class="headerlink" title="零拷贝的实现方式"></a>零拷贝的实现方式</h2><p>零拷贝有两种实现方式，mmap 和 sendFile 两种。</p><p>它们是如何减少「上下文切换」和「数据拷贝」的次数？</p><h3 id="mmap实现零拷贝"><a href="#mmap实现零拷贝" class="headerlink" title="mmap实现零拷贝"></a>mmap实现零拷贝</h3><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210909152900745.png" alt="image-20210909152900745" style="zoom:50%;" /><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，<font color='blue'>操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据</font></li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h3 id="sendfile实现零拷贝"><a href="#sendfile实现零拷贝" class="headerlink" title="sendfile实现零拷贝"></a>sendfile实现零拷贝</h3><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</span></span><br></pre></td></tr></table></figure><p>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210909153709043.png" alt="image-20210909153709043" style="zoom:50%;" /><p>但是这还不是真正的零拷贝技术。因为CPU还有执行一次内核缓冲区到Socket缓冲区的拷贝。</p><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><p>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</p><p>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到<font color=blue>网卡的缓冲区</font>里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</p><img src="https://cdn.jsdelivr.net/gh/zabernism/image@main/gao/image-20210909154030275.png" alt="image-20210909154030275" style="zoom:50%;" /><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ">傻瓜三歪让我教他「零拷贝」</a></li><li><a href="https://www.processon.com/view/5f559cdc5653bb53ea93bb58?fromnew=1"><strong>文件传输，零拷贝文件传输，零拷贝</strong></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;思考问题&quot;&gt;&lt;a href=&quot;#思考问题&quot; class=&quot;headerlink&quot; title=&quot;思考问题&quot;&gt;&lt;/a&gt;思考问题&lt;/h2&gt;&lt;p&gt;什么是零拷贝技术？&lt;/p&gt;
&lt;p&gt;为什么需要零拷贝？&lt;/p&gt;
&lt;p&gt;零拷贝有哪些应用场景？&lt;/p&gt;
&lt;p&gt;什么叫做用户态到内</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="IO" scheme="http://example.com/tags/IO/"/>
    
  </entry>
  
</feed>
