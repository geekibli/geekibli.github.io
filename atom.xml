<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekIBLi</title>
  
  <subtitle>For Coder</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-08T03:29:28.552Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>gaolei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elasticsearch-overview</title>
    <link href="http://example.com/wiki/elasticsearch-overview/"/>
    <id>http://example.com/wiki/elasticsearch-overview/</id>
    <published>2021-07-08T03:17:58.000Z</published>
    <updated>2021-07-08T03:29:28.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li> <a href="https://doc.codingdict.com/elasticsearch/">https://www.codingdict.com/</a></li><li> <a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></li><li> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indexing-buffer.html">https://www.elastic.co/guide/en/</a></li><li> <a href="https://elastic.blog.csdn.net/">铭毅天下</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt; &lt;a href=&quot;https://doc.codingdict.com/elasticsearch/&quot;&gt;htt</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>关于 Elasticsearch 内存占用及分配</title>
    <link href="http://example.com/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/"/>
    <id>http://example.com/wiki/%E5%85%B3%E4%BA%8E-Elasticsearch-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%8A%E5%88%86%E9%85%8D/</id>
    <published>2021-07-08T02:39:16.000Z</published>
    <updated>2021-07-08T03:28:02.241Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 和 Lucene 对内存使用情况： </p><img src='https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/es-cache.png' width=500 height=550><p>Elasticsearch 限制的内存大小是 JAVA 堆空间的大小，不包括Lucene 缓存倒排索引数据空间。</p><p>Lucene 中的 倒排索引 segments 存储在文件中，为提高访问速度，都会把它加载到内存中，从而提高 Lucene 性能。所以建议至少留系统一半内存给Lucene。<br><code>Node Query Cache</code> (负责缓存f ilter 查询结果)，每个节点有一个，被所有 shard 共享，filter query查询结果要么是 yes 要么是no，不涉及 scores 的计算。<br>集群中每个节点都要配置，默认为：indices.queries.cache.size:10%</p><p><code>Indexing Buffer</code> 索引缓冲区，用于存储新索引的文档，当其被填满时，缓冲区中的文档被写入磁盘中的 <code>segments</code> 中。节点上所有 <code>shard</code> 共享。<br>缓冲区默认大小： indices.memory.index_buffer_size: 10%<br>如果缓冲区大小设置了百分百则 indices.memory.min_index_buffer_size 用于这是最小值，默认为 48mb。indices.memory.max_index_buffer_size 用于最大大小，无默认值。</p><p><code>segments</code><br>segments会长期占用内存，其初衷就是利用OS的cache提升性能。只有在Merge之后，才会释放掉标记为Delete的segments，释放部分内存。</p><p><code>Shard Request Cache</code> 用于缓存请求结果，但之缓存request size为0的。比如说 hits.total, aggregations 和 suggestions.<br>默认最大为indices.requests.cache.size:1%</p><p><code>Field Data Cache</code> 字段缓存重要用于对字段进行排序、聚合是使用。因为构建字段数据缓存代价昂贵，所以建议有足够的内训来存储。<br><code>Fielddata</code> 是 「 延迟 」 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中，也就不会使用大量的内存，所以可以考虑分配较小的heap给Elasticsearch。因为heap越小意味着Elasticsearch的GC会比较快，并且预留给Lucene的内存也会比较大。。<br>如果没有足够的内存保存fielddata时，Elastisearch会不断地从磁盘加载数据到内存，并剔除掉旧的内存数据。剔除操作会造成严重的磁盘I/O，并且引发大量的GC，会严重影响Elastisearch的性能。</p><p>默认情况下Fielddata会不断占用内存，直到它触发了fielddata circuit breaker。<br>fielddata circuit breaker会根据查询条件评估这次查询会使用多少内存，从而计算加载这部分内存之后，Field Data Cache所占用的内存是否会超过indices.breaker.fielddata.limit。如果超过这个值，就会触发fielddata circuit breaker，abort这次查询并且抛出异常，防止OOM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indices.breaker.fielddata.limit:60% (默认heap的60%)  (es7之后改成70%)</span><br></pre></td></tr></table></figure><p>如果设置了indices.fielddata.cache.size，当达到size时，cache会剔除旧的fielddata。</p><blockquote><p>indices.breaker.fielddata.limit 必须大于 indices.fielddata.cache.size，否则只会触发fielddata circuit breaker，而不会剔除旧的fielddata。</p></blockquote><h2 id="配置Elasticsearch堆内存"><a href="#配置Elasticsearch堆内存" class="headerlink" title="配置Elasticsearch堆内存"></a>配置Elasticsearch堆内存</h2><p>Elasticsearch默认安装后设置的内存是 <code>1GB</code>，这是远远不够用于生产环境的。<br>有两种方式修改Elasticsearch的堆内存：</p><blockquote><ol><li>设置环境变量：<code>export ES_HEAP_SIZE=10g</code> 在es启动时会读取该变量；</li><li>启动时作为参数传递给es： <code>./bin/elasticsearch -Xmx10g -Xms10g</code></li></ol></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>给es分配内存时要注意，至少要分配一半儿内存留给 Lucene。<br>分配给 es 的内存最好不要超过 32G ，因为如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。如果大于32G 每个指针占用 8字节，并且会占用更多的内存带宽，降低了cpu性能。</p><p>还有一点， 要关闭 <code>swap</code> 内存交换空间，禁用swapping。频繁的swapping 对服务器来说是致命的。<br>总结：给es JVM栈的内存最好不要超过32G，留给Lucene的内存越大越好，Lucene把所有的segment都缓存起来，会加快全文检索。</p><h2 id="关闭交换区"><a href="#关闭交换区" class="headerlink" title="关闭交换区"></a>关闭交换区</h2><p>这应该显而易见了，但仍然需要明确的写出来：把内存换成硬盘将毁掉服务器的性能，想象一下：涉及内存的操作是需要快速执行的。如果介质从内存变为了硬盘，一个10微秒的操作变成需要10毫秒。而且这种延迟发生在所有本该只花费10微秒的操作上，就不难理解为什么交换区对于性能来说是噩梦。</p><p>最好的选择是禁用掉操作系统的交换区。可以用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><p>来禁用，你可能还需要编辑 <code>/etc/fstab</code> 文件。细节可以参考你的操作系统文档。</p><p>如果实际环境不允许禁用掉 <code>swap</code>，你可以尝试降低 <code>swappiness</code>。此值控制操作系统使用交换区的积极性。这可以防止在正常情况下使用交换区，但仍允许操作系统在紧急情况下将内存里的东西放到交换区。</p><p>对于大多数Linux系统来说，这可以用 <code>sysctl</code> 值来配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 将此值配置为1会比0好，在kernal内核的某些版本中，0可能会引起OOM异常。</span></span><br></pre></td></tr></table></figure><p>最后，如果两种方法都不可用，你应该在ElasticSearch的配置中启用 <code>mlockall.file</code>。这允许JVM锁定其使用的内存，而避免被放入操作系统交换区。</p><p>在elasticsearch.yml中，做如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.mlockall: true</span><br></pre></td></tr></table></figure><h2 id="查看node节点数据"><a href="#查看node节点数据" class="headerlink" title="查看node节点数据"></a>查看node节点数据</h2><p><code>GET /_cat/nodes?v&amp;h=id,ip,port,v,master,name,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p><p><code>GET /_cat/nodes?v&amp;h=id,heap.current,heap.percent,heap.max,ram.current,ram.percent,ram.max,fielddata.memory_size</code></p><p><code>GET /_cat/nodes?v&amp;h=id,fielddata.evictions,query_cache.memory_size,query_cache.evictions, request_cache.memory_size,request_cache.evictions,request_cache.hit_count,request_cache.miss_count</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch 和 Lucene 对内存使用情况： &lt;/p&gt;
&lt;img src=&#39;https://nereuschen.github.io/2015/09/16/ElasticSearch%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="配置运维" scheme="http://example.com/categories/Elasticsearch/%E9%85%8D%E7%BD%AE%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>cross-fields跨字段查询</title>
    <link href="http://example.com/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/wiki/cross-fields%E8%B7%A8%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-07-07T06:41:42.000Z</published>
    <updated>2021-07-07T06:43:59.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_cross_fields_queries.html#_cross_fields_queries">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » cross-fields 跨字段查询</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/el</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="For search" scheme="http://example.com/categories/Elasticsearch/For-search/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>copy_to参数</title>
    <link href="http://example.com/wiki/copy-to%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/wiki/copy-to%E5%8F%82%E6%95%B0/</id>
    <published>2021-07-07T06:34:42.000Z</published>
    <updated>2021-07-07T06:44:17.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/custom-all.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 自定义 _all 字段</a></li><li><a href="https://doc.codingdict.com/elasticsearch/319/">Docs » Mapping parameters（映射参数） » Mapping(映射) » copy_to（合并参数）</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/el</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="For search" scheme="http://example.com/categories/Elasticsearch/For-search/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>字符串排序与多字段</title>
    <link href="http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/"/>
    <id>http://example.com/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%9A%E5%AD%97%E6%AE%B5/</id>
    <published>2021-07-07T03:05:31.000Z</published>
    <updated>2021-07-07T03:05:31.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>推荐系统-Overview</title>
    <link href="http://example.com/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/"/>
    <id>http://example.com/wiki/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Overview/</id>
    <published>2021-07-07T02:08:05.000Z</published>
    <updated>2021-07-07T09:47:43.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客资料"><a href="#博客资料" class="headerlink" title="博客资料"></a>博客资料</h2><ul><li><a href="https://blog.csdn.net/qq_40027052/article/details/78733365">深度解析京东个性化推荐系统演进史</a>  </li><li><a href="https://www.cnblogs.com/liuning8023/p/5522619.html">用 Mahout 和 Elasticsearch 实现推荐系统</a></li><li><a href="https://tech.meituan.com/2015/01/22/mt-recommend-practice.html">美团推荐算法实践</a></li><li><a href="https://blog.csdn.net/love284969214/article/details/82932064">58同城推荐系统设计与实现</a></li><li><a href="http://www.360doc.com/content/16/0307/22/31263000_540328712.shtml">微博推荐系统的架构演进之路</a></li><li><a href="https://blog.csdn.net/tzs_1041218129/article/details/103331908">Flink 在小红书推荐系统中的应用</a></li><li><a href="https://www.slidestalk.com/YunQi/XiaoHongShu_BigData_Platform_Evolution">小红书大数据在推荐系统中的应用</a></li><li><a href="https://www.slidestalk.com/u223/rs_in_kuaikan">快看漫画个性化推荐探索与实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/45123018">数据仓库系列篇——唯品会大数据架构</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;博客资料&quot;&gt;&lt;a href=&quot;#博客资料&quot; class=&quot;headerlink&quot; title=&quot;博客资料&quot;&gt;&lt;/a&gt;博客资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40027052/article/detai</summary>
      
    
    
    
    <category term="推荐系统" scheme="http://example.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Overview" scheme="http://example.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/Overview/"/>
    
    
    <category term="推荐" scheme="http://example.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>flink 提交任务</title>
    <link href="http://example.com/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/wiki/flink-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-07-06T15:57:04.000Z</published>
    <updated>2021-07-07T14:25:24.237Z</updated>
    
    <content type="html"><![CDATA[<p>下面演示如何通过admin页面提交任务 👇</p><h2 id="准备task-jar"><a href="#准备task-jar" class="headerlink" title="准备task jar"></a>准备task jar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamContextEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于数据流进行转换计算</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String,Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>mvn install -DskipTest</code> 可以得到相应的jar</p><h2 id="admin提交jar"><a href="#admin提交jar" class="headerlink" title="admin提交jar"></a>admin提交jar</h2><img src='https://oscimg.oschina.net/oscnet/up-6f96aa46a523c9cd32f12177775b6d6fab9.png' width=900 height=450> <p>提交完jar包之后，需要设置相关参数，这个根据自己的实际情况来设置，下面是参考样例： </p><ul><li>Enter Class : com.ibli.flink.StreamWordCount<br>也就是程序入口，我们这是写了一个main方法，如果是程序的话，可以写对应bootstrap的启动类</li><li>Program Arguments : –host localhost –port 7777 </li></ul><p>点击 <code>submit</code>  之后查看提交的任务状态</p><h2 id="查看任务"><a href="#查看任务" class="headerlink" title="查看任务"></a>查看任务</h2><img src='https://oscimg.oschina.net/oscnet/up-f11b32799d87f90c6e78732db82f191be3b.png' width=900 height=450>  <p>可以看到是有两个任务，并且都是在执行状态；<br>点击一个任务，还可以查看任务详情信息，和一些其他的信息，非常全面；</p><img src="https://oscimg.oschina.net/oscnet/up-9678050d3906aae9ccead23d02927d46851.png" width=900 height=450><h2 id="查看运行时任务列表"><a href="#查看运行时任务列表" class="headerlink" title="查看运行时任务列表"></a>查看运行时任务列表</h2><img src='https://oscimg.oschina.net/oscnet/up-da8bf04ac90ae3c16095a6ebf25175b4452.png' width=900 height=350><h2 id="查看任务管理列表"><a href="#查看任务管理列表" class="headerlink" title="查看任务管理列表"></a>查看任务管理列表</h2><img src="https://oscimg.oschina.net/oscnet/up-a85746f93dc171f3d320a17c07294682bb3.png" width=900 height=450><p>点击任务可以跳转到详情页面 👇 下面是执行日志 </p><img src= 'https://oscimg.oschina.net/oscnet/up-a11c7ccc522c77d100d57a9c2a08ec9183b.png' width=900 height=500><p>我们还可以看到任务执行的标准输出结果✅</p><img src="https://oscimg.oschina.net/oscnet/up-3d990a6318fab3a11e7336fdcd271851fda.png" width=900 height=400><h2 id="任务源数据"><a href="#任务源数据" class="headerlink" title="任务源数据"></a>任务源数据</h2><p>通过nc 输入数据，由程序读取7777端口输入流并解析数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gaolei:geekibli gaolei$ nc -lk 7777</span><br><span class="line">hello java</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure><h2 id="取消任务如下"><a href="#取消任务如下" class="headerlink" title="取消任务如下"></a>取消任务如下</h2><img src='https://oscimg.oschina.net/oscnet/up-05199d86b957e0adec4e4d91390a0aebbec.png' width=900 height=400> <p>再次查看已完成任务列表 如下：</p><img src='https://oscimg.oschina.net/oscnet/up-78c97d4c4aec1641a22165735764c54b969.png' width=900 height=400>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面演示如何通过admin页面提交任务 👇&lt;/p&gt;
&lt;h2 id=&quot;准备task-jar&quot;&gt;&lt;a href=&quot;#准备task-jar&quot; class=&quot;headerlink&quot; title=&quot;准备task jar&quot;&gt;&lt;/a&gt;准备task jar&lt;/h2&gt;&lt;figure cla</summary>
      
    
    
    
    <category term="Apache Flink" scheme="http://example.com/categories/Apache-Flink/"/>
    
    
    <category term="flink" scheme="http://example.com/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>apache-flink-overview</title>
    <link href="http://example.com/wiki/apache-flink-overview/"/>
    <id>http://example.com/wiki/apache-flink-overview/</id>
    <published>2021-07-06T15:39:54.000Z</published>
    <updated>2021-07-06T16:20:24.847Z</updated>
    
    <content type="html"><![CDATA[<img src="https://flink.apache.org/img/flink-header-logo.svg" width=300 height=300><h2 id="学习初衷"><a href="#学习初衷" class="headerlink" title="学习初衷"></a>学习初衷</h2><p>推荐系统数据需要实时处理，使用Apache Flink实时计算用户数据，分析用户行为，达到实时业务数据分析和实现业务相关推荐；</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><a href="https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ashiamd.github.io</a></li><li><a href="https://www.bilibili.com/video/BV1qy4y1q728?p=11&spm_id_from=pageDriver">尚硅谷2021最新Java版Flink 武老师清华硕士，原IBM-CDL负责人</a></li><li><a href="https://flink.apache.org/">Apache Flink® — Stateful Computations over Data Streams</a></li><li><a href="https://flink.apache.org/zh/">Apache Flink® - 数据流上的有状态计算</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://flink.apache.org/img/flink-header-logo.svg&quot; width=300 height=300&gt;

&lt;h2 id=&quot;学习初衷&quot;&gt;&lt;a href=&quot;#学习初衷&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Apache Flink" scheme="http://example.com/categories/Apache-Flink/"/>
    
    
    <category term="flink" scheme="http://example.com/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>most_fields类型</title>
    <link href="http://example.com/wiki/most-fields%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/wiki/most-fields%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-07-06T12:54:23.000Z</published>
    <updated>2021-07-06T13:12:34.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多字段映射"><a href="#多字段映射" class="headerlink" title="多字段映射"></a>多字段映射</h2><p>首先要做的事情就是对我们的字段索引两次：一次使用词干模式以及一次非词干模式。为了做到这点，采用 <code>multifields</code> 来实现，已经在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-fields.html">multifields</a> 有所介绍：</p><p><code>DELETE /my_index</code>  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123; <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span> &#125;, </span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123; </span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;std&quot;</span>:   &#123; </span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>title 字段使用 english 英语分析器来提取词干。</li><li>title.std 字段使用 standard 标准分析器，所以没有词干提取。</li></ul><p>接着索引一些文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>这里用一个简单 match 查询 title 标题字段是否包含 jumping rabbits （跳跃的兔子）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;jumping rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有了 <code>english</code> 分析器，这个查询是在查找以 jump 和 rabbit 这两个被提取词的文档。两个文档的 title 字段都同时包括这两个词，所以两个文档得到的评分也相同：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.42039964</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是查询 <code>title.std</code> 字段，那么只有文档 2 是匹配的。尽管如此，如果同时查询两个字段，然后使用 <code>bool</code> 查询将评分结果 合并 ，那么两个文档都是匹配的（ <code>title</code> 字段的作用），而且文档 2 的相关度评分更高（ <code>title.std</code> 字段的作用）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:   <span class="string">&quot;most_fields&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;title.std&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望将所有匹配字段的评分合并起来，所以使用 <code>most_fields</code> 类型。这让 <code>multi_match</code> 查询用 <code>bool</code> 查询将两个字段语句包在里面，而不是使用 <code>dis_max</code> (最佳字段) 查询。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.8226396</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Jumping jack rabbits&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.10741998</span>, </span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My rabbit jumps&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档 2 现在的评分要比文档 1 高。</p><p>用广度匹配字段 <code>title</code> 包括尽可能多的文档——以提升召回率——同时又使用字段 <code>title.std</code> 作为 信号 将相关度更高的文档置于结果顶部。</p><p>每个字段对于最终评分的贡献可以通过自定义值 <code>boost</code> 来控制。比如，使 <code>title</code> 字段更为重要，这样同时也降低了其他信号字段的作用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>:       <span class="string">&quot;jumping rabbits&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:        <span class="string">&quot;most_fields&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>:      [ <span class="string">&quot;title^10&quot;</span>, <span class="string">&quot;title.std&quot;</span> ] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>title 字段的 boost 的值为 10 使它比 title.std 更重要。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/most-fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 多数字段</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多字段映射&quot;&gt;&lt;a href=&quot;#多字段映射&quot; class=&quot;headerlink&quot; title=&quot;多字段映射&quot;&gt;&lt;/a&gt;多字段映射&lt;/h2&gt;&lt;p&gt;首先要做的事情就是对我们的字段索引两次：一次使用词干模式以及一次非词干模式。为了做到这点，采用 &lt;code&gt;mult</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>multi_match 查询</title>
    <link href="http://example.com/wiki/multi-match-%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/wiki/multi-match-%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-07-06T12:37:26.000Z</published>
    <updated>2021-07-06T12:47:47.596Z</updated>
    
    <content type="html"><![CDATA[<p>multi_match 查询为能在多个字段上反复执行相同查询提供了一种便捷方式。</p><p>📒 📒 📒</p><blockquote><p>multi_match 多匹配查询的类型有多种，其中的三种恰巧与 了解我们的数据 中介绍的三个场景对应，即：<code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）。</p></blockquote><p>默认情况下，查询的类型是 <code>best_fields</code> ，这表示它会为每个字段生成一个 <code>match</code> 查询，然后将它们组合到 <code>dis_max</code> 查询的内部，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;queries&quot;</span>:  [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;tie_breaker&quot;</span>: <span class="number">0.3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个查询用 multi_match 重写成更简洁的形式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:                <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:                 <span class="string">&quot;best_fields&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>:               [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;body&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;tie_breaker&quot;</span>:          <span class="number">0.3</span>,</span><br><span class="line">        <span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;30%&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ ⚠️ ⚠️</p><ul><li>best_fields 类型是默认值，可以不指定。</li><li>如 minimum_should_match 或 operator 这样的参数会被传递到生成的 match 查询中。</li></ul><h2 id="查询字段名称的模糊匹配"><a href="#查询字段名称的模糊匹配" class="headerlink" title="查询字段名称的模糊匹配"></a>查询字段名称的模糊匹配</h2><p>字段名称可以用 <code>模糊匹配</code> 的方式给出：任何与模糊模式正则匹配的字段都会被包括在搜索条件中，例如可以使用以下方式同时匹配 <code>book_title</code> 、 <code>chapter_title</code> 和 <code>section_title</code> （书名、章名、节名）这三个字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: <span class="string">&quot;*_title&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提升单个字段的权重"><a href="#提升单个字段的权重" class="headerlink" title="提升单个字段的权重"></a>提升单个字段的权重</h2><p>可以使用 ^ 字符语法为单个字段提升权重，在字段名称的末尾添加 ^boost ，其中 boost 是一个浮点数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:  <span class="string">&quot;Quick brown fox&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>: [ <span class="string">&quot;*_title&quot;</span>, <span class="string">&quot;chapter_title^2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chapter_title 这个字段的 boost 值为 2 ，而其他两个字段 book_title 和 section_title 字段的默认 boost 值为 1 。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-match-query.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » multi_match 查询</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-multi-match-query.html">Elasticsearch Guide [7.x] » Query DSL » Full text queries » Multi-match query</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;multi_match 查询为能在多个字段上反复执行相同查询提供了一种便捷方式。&lt;/p&gt;
&lt;p&gt;📒 📒 📒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;multi_match 多匹配查询的类型有多种，其中的三种恰巧与 了解我们的数据 中介绍的三个场景对应，即：&lt;code&gt;</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>dis_max查询</title>
    <link href="http://example.com/wiki/dis-max%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/wiki/dis-max%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-07-06T12:09:23.000Z</published>
    <updated>2021-07-06T15:33:19.291Z</updated>
    
    <content type="html"><![CDATA[<p>假设有个网站允许用户搜索博客的内容，以下面两篇博客内容文档为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Quick brown rabbits&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown rabbits are commonly seen.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Keeping pets healthy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;My quick brown fox eats rabbits on a regular basis.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户输入词组 <code>Brown fox</code> 然后点击搜索按钮。事先，我们并不知道用户的搜索项是会在 title 还是在 body 字段中被找到，但是，用户很有可能是想搜索相关的词组。用肉眼判断，文档 2 的匹配度更高，因为它同时包括要查找的两个词：</p><p>现在运行以下 bool 查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现查询的结果是文档 1 的评分更高：</p><img src="https://oscimg.oschina.net/oscnet/up-fa805607436bd64629e31ea8ea574c330cf.png" width=920 height=450>  <p>为了理解导致这样的原因，需要回想一下 bool 是如何计算评分的：</p><p>它会执行 should 语句中的两个查询。<br>加和两个查询的评分。<br>乘以匹配语句的总数。<br>除以所有语句总数（这里为：2）。</p><p>文档 1 的两个字段都包含 <code>brown</code> 这个词，所以两个 <code>match</code> 语句都能成功匹配并且有一个评分。文档 2 的 body 字段同时包含 <code>brown</code> 和 <code>fox</code> 这两个词，但 title 字段没有包含任何词。这样， body 查询结果中的高分，加上 title 查询中的 0 分，然后乘以二分之一，就得到比文档 1 更低的整体评分。</p><p>在本例中， title 和 body 字段是相互竞争的关系，所以就需要找到单个 最佳匹配 的字段。</p><p>如果不是简单将每个字段的评分结果加在一起，而是将 <code>最佳匹配</code> 字段的评分作为查询的整体评分，结果会怎样？这样返回的结果可能是： 同时 包含 <code>brown</code> 和 <code>fox</code> 的单个字段比反复出现相同词语的多个不同字段有更高的相关度。</p><h2 id="dis-max-查询"><a href="#dis-max-查询" class="headerlink" title="dis_max 查询"></a>dis_max 查询</h2><p>不使用 <code>bool</code> 查询，可以使用 <code>dis_max</code> 即分离 最大化查询 <code>（Disjunction Max Query）</code> 。分离（Disjunction）的意思是 或（or） ，这与可以把结合（conjunction）理解成 与（and） 相对应。分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回 ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>:  <span class="string">&quot;Brown fox&quot;</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到我们想要的结果为：<br><img src="https://oscimg.oschina.net/oscnet/up-f4e15cd66644b0031abe4757efdcfdd2886.png" width=900 height=450>  </p><h2 id="Top-level-parameters-for-dis-maxedit"><a href="#Top-level-parameters-for-dis-maxedit" class="headerlink" title="Top-level parameters for dis_maxedit"></a>Top-level parameters for dis_maxedit</h2><ul><li><code>queries</code><br>(Required, array of query objects) Contains one or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, Elasticsearch uses the highest relevance score.</li><li><code>tie_breaker</code><br>(Optional, float) Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses. Defaults to 0.0.</li></ul><p>You can use the tie_breaker value to assign higher relevance scores to documents that contain the same term in multiple fields than documents that contain this term in only the best of those multiple fields, without confusing this with the better case of two different terms in the multiple fields.</p><p>If a document matches multiple clauses, the dis_max query calculates the relevance score for the document as follows:</p><p>Take the relevance score from a matching clause with the highest score.<br>Multiply the score from any other matching clauses by the tie_breaker value.<br>Add the highest score to the multiplied scores.<br>If the tie_breaker value is greater than 0.0, all matching clauses count, but the clause with the highest score counts most.</p><p><code>dis_max</code>，只是取分数最高的那个query的分数而已，完全不考虑其他query的分数，这种一刀切的做法，可能导致在有其他query的影响下，score不准确的情况，这时为了使用结果更准确，最好还是要考虑到其他query的影响;<br>使用 <code>tie_breaker</code> 将其他query的分数也考虑进去, <code>tie_breaker</code> 参数的意义，将其他query的分数乘以<code>tie_breaker</code>，然后综合考虑后与最高分数的那个query的分数综合在一起进行计算，这样做除了取最高分以外，还会考虑其他的query的分数。<code>tie_breaker</code>的值，设置在在0~1之间，是个小数就行，没有固定的值</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_best_fields.html">Elasticsearch: 权威指南 » 深入搜索 » 多字段搜索 » 最佳字段</a></li><li><a href="https://learnku.com/docs/elasticsearch73/7.3">Elasticsearch中文文档</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-dis-max-query.html">Elasticsearch Guide [7.x] » Query DSL » Compound queries » Disjunction max query</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设有个网站允许用户搜索博客的内容，以下面两篇博客内容文档为例：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch被破坏的相似度</title>
    <link href="http://example.com/wiki/elasticsearch%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <id>http://example.com/wiki/elasticsearch%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/</id>
    <published>2021-07-06T11:50:11.000Z</published>
    <updated>2021-07-06T11:53:48.013Z</updated>
    
    <content type="html"><![CDATA[<p>在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。</p><p>用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤：用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。</p><p>为了理解为什么会这样，可以设想，我们在两个主分片上创建了索引和总共 10 个文档，其中 6 个文档有单词 foo 。可能是分片 1 有其中 3 个 foo 文档，而分片 2 有其中另外 3 个文档，换句话说，所有文档是均匀分布存储的。</p><p>在 什么是相关度？中，我们描述了 Elasticsearch 默认使用的相似度算法，这个算法叫做 词频/逆向文档频率 或 TF/IDF 。词频是计算某个词在当前被查询文档里某个字段中出现的频率，出现的频率越高，文档越相关。 逆向文档频率 将 某个词在索引内所有文档出现的百分数 考虑在内，出现的频率越高，它的权重就越低。</p><p>但是由于性能原因， Elasticsearch 不会计算索引内所有文档的 IDF 。相反，每个分片会根据 该分片 内的所有文档计算一个本地 IDF 。</p><p>因为文档是均匀分布存储的，两个分片的 IDF 是相同的。相反，设想如果有 5 个 foo 文档存于分片 1 ，而第 6 个文档存于分片 2 ，在这种场景下， foo 在一个分片里非常普通（所以不那么重要），但是在另一个分片里非常出现很少（所以会显得更重要）。这些 IDF 之间的差异会导致不正确的结果。</p><p>在实际应用中，这并不是一个问题，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。</p><p>为了测试，我们可以通过两种方式解决这个问题。第一种是只在主分片上创建索引，正如 match 查询 里介绍的那样，如果只有一个分片，那么本地的 IDF 就是 全局的 IDF。</p><p>第二个方式就是在搜索请求后添加 ?search_type=dfs_query_then_fetch ， dfs 是指 分布式频率搜索（Distributed Frequency Search） ， 它告诉 Elasticsearch ，先分别获得每个分片本地的 IDF ，然后根据结果再计算整个索引的全局 IDF 。</p><p>不要在生产环境上使用 dfs_query_then_fetch 。完全没有必要。只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上 DFS 这步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html">Elasticsearch: 权威指南 » 基础入门 » 排序与相关性 » 什么是相关性?</a></li><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-is-broken.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 被破坏的相关度！</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在讨论更复杂的 多字段搜索 之前，让我们先快速解释一下为什么只在主分片上 创建测试索引 。&lt;/p&gt;
&lt;p&gt;用户会时不时的抱怨无法按相关度排序并提供简短的重现步骤：用户索引了一些文档，运行一个简单的查询，然后发现明显低相关度的结果出现在高相关度结果之上。&lt;/p&gt;
&lt;p&gt;为了理</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>canal同步es后部分字段为null</title>
    <link href="http://example.com/wiki/canal%E5%90%8C%E6%AD%A5es%E5%90%8E%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BAnull/"/>
    <id>http://example.com/wiki/canal%E5%90%8C%E6%AD%A5es%E5%90%8E%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BAnull/</id>
    <published>2021-07-06T08:11:15.000Z</published>
    <updated>2021-07-06T08:27:31.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><img src="https://oscimg.oschina.net/oscnet/up-54f2fa4a9dfb35acb02b77c5c6bc8c84c0f.png" width=800 height=400><p>配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataSourceKey: defaultDS        # 源数据源的key, 对应上面配置的srcDataSources中的值</span><br><span class="line">destination: example            # cannal的instance或者MQ的topic</span><br><span class="line">groupId: g1 # 对应MQ模式下的groupId, 只会同步对应groupId的数据</span><br><span class="line">esMapping:</span><br><span class="line">  _index: rd_member_fans_info           # es 的索引名称</span><br><span class="line">  _type: _doc                   # es 的doc名称</span><br><span class="line">  _id: _id                      # es 的_id, 如果不配置该项必须配置下面的pk项_id则会由es自动分配</span><br><span class="line">#  pk: id                       # 如果不需要_id, 则需要指定一个属性为主键属性</span><br><span class="line">#  # sql映射</span><br><span class="line">  sql: &#x27;SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.create_time,t.update_time,t.`status` FROM rd_member_fans_info t&#x27;</span><br><span class="line">#  objFields:</span><br><span class="line">#    _labels: array:;           # 数组或者对象属性, array:; 代表以;字段里面是以;分隔的</span><br><span class="line">#    _obj: object               # json对象</span><br><span class="line">  etlCondition: &quot;where t.update_time&gt;=&#123;&#125;&quot; # etl 的条件参数</span><br><span class="line">  commitBatch: 3000 # 提交批大小</span><br></pre></td></tr></table></figure><p>⚠️ ⚠️<br>sql执行是没有问题的！</p><img src="https://oscimg.oschina.net/oscnet/up-24a77ccd81ae7be4c6d4434f3d1d28edea0.png" width=800 height=400><p>canal-adapter 获取binlog数据也没有问题，显示日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-07-06 15:39:24.588 [pool-1-thread-1] DEBUG c.a.o.canal.client.adapter.es.core.service.ESSyncService - DML: &#123;&quot;data&quot;:[&#123;&quot;id&quot;:3,&quot;redtom_id&quot;:1,&quot;fans_redtom_id&quot;:1,&quot;fans_username&quot;:&quot;1&quot;,&quot;fans_introduce&quot;:&quot;1&quot;,&quot;fans_avatar&quot;:&quot;1&quot;,&quot;is_each_following&quot;:1,&quot;follow_channel&quot;:1,&quot;create_time&quot;:1625556851000,&quot;update_time&quot;:1625556851000,&quot;status&quot;:2&#125;],&quot;database&quot;:&quot;redtom_dev&quot;,&quot;destination&quot;:&quot;example&quot;,&quot;es&quot;:1625557164000,&quot;groupId&quot;:&quot;g1&quot;,&quot;isDdl&quot;:false,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;table&quot;:&quot;rd_member_fans_info&quot;,&quot;ts&quot;:1625557164587,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br></pre></td></tr></table></figure><p>然后看一下我创建索引的mapping<br><img src="https://oscimg.oschina.net/oscnet/up-8eac2e46423574ae04cd8694d2ac7389530.png" width=800 height=400>  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>调整sql如下： </p><p><code>SELECT t.id as _id , t.redtom_id ,t.fans_redtom_id,t.fans_username,t.fans_introduce,t.fans_avatar,t.is_each_following,t.follow_channel,t.</code>status<code> as is_deleted , t.create_time,t.update_time FROM rd_member_fans_info t</code></p><p>调整了那些东西呢？     <code>status</code> 的顺序提前而已！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行一下命令：<br><code>curl http://127.0.0.1:8081/etl/es7/rd_member_fans_info.yml -X POST</code></p><p>canal-adapter 日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-07-06 16:21:33.519 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member_fans_info</span><br><span class="line">2021-07-06 16:21:33.527 [http-nio-8081-exec-1] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - 数据全量导入完成, 一共导入 3 条数据, 耗时: 7</span><br></pre></td></tr></table></figure><p>查看es数据：</p><img src="https://oscimg.oschina.net/oscnet/up-69c4ac09e2b8fcd27a5b990e378664d6568.png" width=800 height=400>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-54f2fa4a9dfb35acb02b77c5c6</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="问题记录" scheme="http://example.com/categories/Elasticsearch/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch-analyzer</title>
    <link href="http://example.com/wiki/elasticsearch-analyzer/"/>
    <id>http://example.com/wiki/elasticsearch-analyzer/</id>
    <published>2021-07-06T07:02:01.000Z</published>
    <updated>2021-07-06T11:46:55.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试常见分析器"><a href="#测试常见分析器" class="headerlink" title="测试常见分析器"></a>测试常见分析器</h2><p><code>GET /_analyze</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GET /_analyze</code>  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat #Cats&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>GET /_analyze</code>   </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GET /_analyze</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Oredr it now from Amazon  #fun #girlpower #fatscooter #Fat Cats&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认分析器"><a href="#默认分析器" class="headerlink" title="默认分析器"></a>默认分析器</h2><p>虽然我们可以在字段层级指定分析器，但是如果该层级没有指定任何的分析器，那么我们如何能确定这个字段使用的是哪个分析器呢？  </p><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：</p><ul><li>字段映射里定义的 analyzer ，否则</li><li>索引设置中名为 default 的分析器，默认为</li><li>standard 标准分析器</li></ul><p>在搜索时，顺序有些许不同：</p><ul><li>查询自己定义的 analyzer ，否则</li><li>字段映射里定义的 analyzer ，否则</li><li>索引设置中名为 default 的分析器，默认为</li><li>standard 标准分析器</li></ul><p>有时，在索引时和搜索时使用不同的分析器是合理的。我们可能要想为同义词建索引（例如，所有 quick 出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。</p><p>为了区分，Elasticsearch 也支持一个可选的 <code>search_analyzer</code> 映射，它仅会应用于搜索时（ <code>analyzer</code> 还用于索引时）。还有一个等价的 <code>default_search</code> 映射，用以指定索引层的默认配置。</p><p>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：</p><p>查询自己定义的 <code>analyzer</code> ，否则<br>字段映射里定义的 <code>search_analyzer</code> ，否则<br>字段映射里定义的 <code>analyzer</code> ，否则<br>索引设置中名为 <code>default_search</code> 的分析器，默认为<br>索引设置中名为 <code>default</code> 的分析器，默认为<code>standard</code> 标准分析器</p><h2 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h2><p>多数情况下，会提前知道文档会包括哪些字段。最简单的途径就是在创建索引或者增加类型映射时，为每个全文字段设置分析器。这种方式尽管有点麻烦，但是它让我们可以清楚的看到每个字段每个分析器是如何设置的。</p><p>通常，多数字符串字段都是 <code>not_analyzed</code> 精确值字段，比如标签（tag）或枚举（enum），而且更多的全文字段会使用默认的 <code>standard</code> 分析器或 <code>english</code> 或其他某种语言的分析器。这样只需要为少数一两个字段指定自定义分析：或许标题 title 字段需要以支持 输入即查找（find-as-you-type） 的方式进行索引。</p><p>可以在索引级别设置中，为绝大部分的字段设置你想指定的 <code>default</code> 默认分析器。然后在字段级别设置中，对某一两个字段配置需要指定的分析器。</p><p>📒 📒 📒<br>对于和时间相关的日志数据，通常的做法是每天自行创建索引，由于这种方式不是从头创建的索引，仍然可以用 索引模板（Index Template） 为新建的索引指定配置和映射。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_controlling_analysis.html">Elasticsearch: 权威指南 » 深入搜索 » 全文搜索 » 控制分析</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试常见分析器&quot;&gt;&lt;a href=&quot;#测试常见分析器&quot; class=&quot;headerlink&quot; title=&quot;测试常见分析器&quot;&gt;&lt;/a&gt;测试常见分析器&lt;/h2&gt;&lt;p&gt;&lt;code&gt;GET /_analyze&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="analyzer" scheme="http://example.com/categories/Elasticsearch/analyzer/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Parameter index out of range (1 &gt; number of parameters, which is 0).</title>
    <link href="http://example.com/wiki/Parameter-index-out-of-range-1-number-of-parameters-which-is-0/"/>
    <id>http://example.com/wiki/Parameter-index-out-of-range-1-number-of-parameters-which-is-0/</id>
    <published>2021-07-06T05:03:16.000Z</published>
    <updated>2021-07-06T05:07:16.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2021-07-06 12:39:31.179 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:39:31.186 [http-nio-8081-exec-2] ERROR com.alibaba.otter.canal.client.adapter.support.Util - sqlRs has error, sql: SELECT COUNT(1) FROM ( select t.redtom_id as id, t.username, t.nickname, t.avatar, t.status, t.mobile, t.mobile_region_no, t.email, t.gender, t.password,t.salt,t.birthday,t.introduce,t.country,t.region,t.level,t.is_vip,t.follows    ,t.fans,t.likes_num, t.collects_num, t.instagram_account, t.youtube_account, t.facebook_account, t.twitter_account,t.create_ip, t.create_time,t.update_time from rd_member r where t.create_time&gt;=&#x27;&#123;0&#125;&#x27;) _CNT</span><br><span class="line">2021-07-06 12:39:31.188 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">java.lang.RuntimeException: java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0).</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:65) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:62) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) [client-adapter.es7x-1.1.5-SNAPSHOT-jar-with-dependencies.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) [client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br></pre></td></tr></table></figure><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我执行的操作如下：👇<br><code>curl http://127.0.0.1:8081/etl/es7/customer.yml -X POST -d &quot;params=2019-08-31 00:00:00&quot;</code></p><p>但是我的 es7/rd_member.yml的配置文件如下：</p><p><code>etlCondition:&quot;where a.c_time&gt;=&#39;&#123;0&#125;&#39;&quot; # etl 的条件参数</code></p><p>应该改成：<br><code>etlCondition:&quot;where a.c_time&gt;=&#123;&#125;&quot; # etl 的条件参数</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题记录&quot;&gt;&lt;a href=&quot;#问题记录&quot; class=&quot;headerlink&quot; title=&quot;问题记录&quot;&gt;&lt;/a&gt;问题记录&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="问题记录" scheme="http://example.com/categories/Elasticsearch/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>field name is null or empty</title>
    <link href="http://example.com/wiki/field-name-is-null-or-empty/"/>
    <id>http://example.com/wiki/field-name-is-null-or-empty/</id>
    <published>2021-07-06T04:53:44.000Z</published>
    <updated>2021-07-06T08:28:33.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="canal-adapter-报错信息"><a href="#canal-adapter-报错信息" class="headerlink" title="canal adapter 报错信息"></a>canal adapter 报错信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring FrameworkServlet &#x27;dispatcherServlet&#x27;</span><br><span class="line">2021-07-06 12:46:31.959 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization started</span><br><span class="line">2021-07-06 12:46:31.968 [http-nio-8081-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - FrameworkServlet &#x27;dispatcherServlet&#x27;: initialization completed in 9 ms</span><br><span class="line">2021-07-06 12:46:31.995 [http-nio-8081-exec-2] INFO  c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - start etl to import data to index: rd_member</span><br><span class="line">2021-07-06 12:46:32.027 [http-nio-8081-exec-2] ERROR c.a.otter.canal.client.adapter.es7x.etl.ESEtlService - field name is null or empty</span><br><span class="line">java.lang.IllegalArgumentException: field name is null or empty</span><br><span class="line">at org.elasticsearch.index.query.BaseTermQueryBuilder.&lt;init&gt;(BaseTermQueryBuilder.java:113) ~[na:na]</span><br><span class="line">at org.elasticsearch.index.query.TermQueryBuilder.&lt;init&gt;(TermQueryBuilder.java:75) ~[na:na]</span><br><span class="line">at org.elasticsearch.index.query.QueryBuilders.termQuery(QueryBuilders.java:202) ~[na:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.lambda$executeSqlImport$1(ESEtlService.java:141) ~[na:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.support.Util.sqlRS(Util.java:60) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.executeSqlImport(ESEtlService.java:64) ~[na:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.support.AbstractEtlService.importData(AbstractEtlService.java:105) ~[client-adapter.common-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.etl.ESEtlService.importData(ESEtlService.java:56) ~[na:na]</span><br><span class="line">at com.alibaba.otter.canal.client.adapter.es7x.ES7xAdapter.etl(ES7xAdapter.java:79) ~[na:na]</span><br><span class="line">at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:100) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at com.alibaba.otter.canal.adapter.launcher.rest.CommonRest.etl(CommonRest.java:123) ~[client-adapter.launcher-1.1.5-SNAPSHOT.jar:na]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_292]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_292]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_292]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_292]</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke</span><br></pre></td></tr></table></figure><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>操作是向数据库中插入一条数据，通过canal-adapter同步到elasticsearch中，接口发生以上错误！<br>现象是canal-adapter检测到和mysql的数据变化，但是同步到es的时候发生了错误；<br>猜想大概是某个为空导致存到es的时候发生异常；</p><p>然后查看es7下的mapping配置：</p><img src="https://oscimg.oschina.net/oscnet/up-93dc9d1f9074d9d44946f2d5c3780dd7e13.png" width=400 height=300><p>发现我的sql查id的时候写错了，别名应该写成_id,对应elasticsearch的_id</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;canal-adapter-报错信息&quot;&gt;&lt;a href=&quot;#canal-adapter-报错信息&quot; class=&quot;headerlink&quot; title=&quot;canal adapter 报错信息&quot;&gt;&lt;/a&gt;canal adapter 报错信息&lt;/h2&gt;&lt;figure c</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="问题记录" scheme="http://example.com/categories/Elasticsearch/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch映射</title>
    <link href="http://example.com/wiki/elasticsearch%E6%98%A0%E5%B0%84/"/>
    <id>http://example.com/wiki/elasticsearch%E6%98%A0%E5%B0%84/</id>
    <published>2021-07-05T14:54:05.000Z</published>
    <updated>2021-07-06T11:56:41.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Elasticsearch 支持如下简单域类型：</p><ul><li>字符串: string （es7之后编程text）</li><li>整数 : byte, short, integer, long</li><li>浮点数: float, double</li><li>布尔型: boolean</li><li>日期: date</li></ul><h2 id="查看索引的mapping"><a href="#查看索引的mapping" class="headerlink" title="查看索引的mapping"></a>查看索引的mapping</h2><p><code>GET /gb/_mapping/tweet</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;gb&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;date&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;strict_date_optional_time||epoch_millis&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h2><p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p><ul><li>全文字符串域和精确值字符串域的区别</li><li>使用特定语言分析器</li><li>优化域以适应部分匹配</li><li>指定自定义数据格式</li><li>还有更多</li></ul><p>域最重要的属性是 <code>type</code> 。对于不是 string 的域，你一般只需要设置 type ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认， <code>string</code> (text) 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p><p>string 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index 属性控制怎样索引字符串。它可以是下面三个值：</p><h4 id="analyzed"><a href="#analyzed" class="headerlink" title="analyzed"></a>analyzed</h4><p>首先分析字符串，然后索引它。换句话说，以全文索引这个域。</p><h4 id="not-analyzed"><a href="#not-analyzed" class="headerlink" title="not_analyzed"></a>not_analyzed</h4><p>  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</p><h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>不索引这个域。这个域不会被搜索到。 (比如一些隐私信息)</p><p>string 域 index 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 not_analyzed ：</p><p>⚠️ ⚠️<br>其他简单类型（例如 long ， double ， date 等）也接受 index 参数，但有意义的值只有 no 和 not_analyzed ， 因为它们永远不会被分析。  </p><h3 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h3><p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如 <code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:     <span class="string">&quot;string&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h2><p>当你首次创建一个索引的时候，可以指定类型的映射。你也可以使用 /_mapping 为新类型（或者为存在的类型更新映射）增加映射。<br>⚠️ ⚠️<br>尽管你可以 增加 一个存在的映射，你不能 修改 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p><p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。</p><p>为了描述指定映射的两种方式，我们先删除 gd 索引：<br><code>DELETE /gb</code><br>然后创建一个新索引，指定 tweet 域使用 english 分析器：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;tweet&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> :   <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍后，我们决定在 tweet 映射增加一个新的名为 tag 的 not_analyzed 的文本域，使用 _mapping ：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;tag&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>:    <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中</p><h2 id="测试映射"><a href="#测试映射" class="headerlink" title="测试映射"></a>测试映射</h2><p>你可以使用 analyze API 测试字符串域的映射。比较下面两个请求的输出：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tweet&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tag&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tweet 域产生两个词条 black 和 cat ， tag 域产生单独的词条 Black-cats 。换句话说，我们的映射正常工作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/mapping-intro.html">Elasticsearch权威指南</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Elasticsearch 支持如下简单域类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串: string （es7之后编程text）&lt;/li&gt;
&lt;li&gt;整数 : </summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="mapping" scheme="http://example.com/categories/Elasticsearch/mapping/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>分析与分析器</title>
    <link href="http://example.com/wiki/%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>http://example.com/wiki/%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%86%E6%9E%90%E5%99%A8/</id>
    <published>2021-07-05T14:43:44.000Z</published>
    <updated>2021-07-06T11:40:41.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>包含下面的过程：</p><p>首先，将一块文本分成适合于倒排索引的独立的 <code>词条</code> ，之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall<br>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：</p><h3 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a>字符过滤器</h3><p>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</p><h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p><h3 id="Token-过滤器"><a href="#Token-过滤器" class="headerlink" title="Token 过滤器"></a>Token 过滤器</h3><p>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。<br>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p><h2 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h2><p>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<br><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p><h3 id="标准分析器"><a href="#标准分析器" class="headerlink" title="标准分析器"></a>标准分析器</h3><p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</code></p><h3 id="简单分析器"><a href="#简单分析器" class="headerlink" title="简单分析器"></a>简单分析器</h3><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生<br><code>set, the, shape, to, semi, transparent, by, calling, set, trans</code></p><h3 id="空格分析器"><a href="#空格分析器" class="headerlink" title="空格分析器"></a>空格分析器</h3><p>空格分析器在空格的地方划分文本。它会产生<br><code>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</code></p><h3 id="语言分析器"><a href="#语言分析器" class="headerlink" title="语言分析器"></a>语言分析器</h3><p>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p><h3 id="英语-分词器会产生下面的词条："><a href="#英语-分词器会产生下面的词条：" class="headerlink" title="英语 分词器会产生下面的词条："></a>英语 分词器会产生下面的词条：</h3><p><code>set, shape, semi, transpar, call, set_tran, 5</code><br>注意看 <code>transparent、</code> <code>calling</code> 和 <code>set_trans</code> 已经变为词根格式。</p><h2 id="什么时候使用分析器"><a href="#什么时候使用分析器" class="headerlink" title="什么时候使用分析器"></a>什么时候使用分析器</h2><p>当我们 <code>索引</code> 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p><p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p><p>当你查询一个 <code>全文</code> 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。<br>当你查询一个 <code>精确值</code> 域时，不会分析查询字符串，而是搜索你指定的精确值。</p><h2 id="测试分析器"><a href="#测试分析器" class="headerlink" title="测试分析器"></a>测试分析器</h2><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 <code>analyze API</code> 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Text to analyze&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中每个元素代表一个单独的词条：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;text&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;to&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;token&quot;</span>:        <span class="string">&quot;analyze&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;start_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">&quot;end_offset&quot;</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;</span>:         <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;position&quot;</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>token</code> 是实际存储到索引中的词条。 <code>position</code> 指明词条在原始文本中出现的位置。 <code>start_offset</code> 和 <code>end_offset</code> 指明字符在原始字符串中的位置。</p><p>每个分析器的 <code>type</code> 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于​keep_types token 过滤器​。</p><p>analyze API 是一个有用的工具，它有助于我们理解Elasticsearch索引内部发生了什么，随着深入，我们会进一步讨论它。</p><h2 id="指定分析器"><a href="#指定分析器" class="headerlink" title="指定分析器"></a>指定分析器</h2><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文 <code>字符串</code> 域，使用 <code>标准</code> 分析器对它进行分析。</p><p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域—​不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。</p><p>要做到这一点，我们必须手动指定这些域的映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;包含下面的过程：&lt;/p&gt;
&lt;p&gt;首先，将一块文本分成适合于倒排索引的独立的 &lt;code&gt;词条&lt;/code&gt; ，之后，将这些词条统一化为标准格</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="analyzer" scheme="http://example.com/categories/Elasticsearch/analyzer/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>倒排索引</title>
    <link href="http://example.com/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</id>
    <published>2021-07-05T14:17:00.000Z</published>
    <updated>2021-07-05T14:30:57.743Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。  </p><p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：  </p><p>The quick brown fox jumped over the lazy dog<br>Quick brown foxes leap over lazy dogs in summer<br>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p><img src="https://oscimg.oschina.net/oscnet/up-ea663f731dfb8db97706ffd2d34a2297576.png" width=230 height=300>  <p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：  </p><img src="https://oscimg.oschina.net/oscnet/up-6b1b6fb36d1467bfab8d222ace66f4f3dc7.png" width=230 height=160>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。  <p>但是，我们目前的倒排索引有一些问题：</p><p><code>Quick</code> 和 <code>quick</code> 以独立的词条出现，然而用户可能认为它们是相同的词。<br><code>fox</code> 和 <code>foxes</code> 非常相似, 就像 <code>dog</code> 和 <code>dogs</code> ；他们有相同的词根。<br><code>jumped</code> 和 <code>leap</code>, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。<br>使用前面的索引搜索 <code>+Quick</code> <code>+fox</code> 不会得到任何匹配文档。（记住，+ 前缀表明这个词必须存在。）只有同时出现 <code>Quick</code> 和 <code>fox</code> 的文档才满足这个查询条件，但是第一个文档包含 <code>quick fox</code> ，第二个文档包含 <code>Quick foxes</code> 。</p><p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p><p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p><p><code>Quick</code> 可以小写化为 <code>quick</code> 。<br><code>foxes</code> 可以 词干提取 –变为词根的格式– 为 <code>fox</code> 。类似的， <code>dogs</code> 可以为提取为 <code>dog</code> 。<br><code>jumped</code> 和 <code>leap</code> 是同义词，可以索引为相同的单词 <code>jump</code> 。<br>现在索引看上去像这样：<br><img src="https://oscimg.oschina.net/oscnet/up-5ee716c408738e8394f2d9809f8be8354ba.png" width=230 height=270><br>这还远远不够。我们搜索 <code>+Quick</code> <code>+fox</code> 仍然 会失败，因为在我们的索引中，已经没有 <code>Quick</code> 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 <code>+quick</code> <code>+fox</code> ，这样两个文档都会匹配！</p><p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。  &lt;/p&gt;
&lt;p&gt;例如，假设我们有两个文档，每个文档的 content 域包含如下内容：  &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch分页查询</title>
    <link href="http://example.com/wiki/elasticsearch%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/wiki/elasticsearch%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-07-05T14:08:23.000Z</published>
    <updated>2021-07-06T11:30:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：</p><p><code>size</code><br>显示应该返回的结果数量，默认是 10<br><code>from</code><br>显示应该跳过的初始结果数量，默认是 0<br>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p><p><code>GET /_search?size=5</code><br><code>GET /_search?size=5&amp;from=5</code><br><code>GET /_search?size=5&amp;from=10</code>  </p><p>⚠️ ⚠️ ⚠️<br>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。  </p><p>在分布式系统中深度分页</p><blockquote><p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p></blockquote><p>现在假设我们请求第 1000 页—​结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p><p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/pagination.html">elasticsearch权威指南</a>  </li><li><a href="https://blog.csdn.net/laoyang360/article/details/116472697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162549431316780269873046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162549431316780269873046&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-116472697.pc_v2_rank_blog_default&utm_term=%E5%88%86%E9%A1%B5&spm=1018.2226.3001.4450">干货 | 全方位深度解读 Elasticsearch 分页查询</a>  </li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/paginate-search-results.html">Paginate search results</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和 SQL 使用 LIMIT 关键字返回单个 page 结果的方法相同，Elasticsearch 接受 from 和 size 参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt;&lt;br&gt;显示应该返回的结果数量，默认是 10&lt;br&gt;&lt;code&gt;from&lt;/code&gt;&lt;</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="基本搜索" scheme="http://example.com/categories/Elasticsearch/%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
